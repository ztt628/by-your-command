/*[c][size=1] STARTBYCA /**/
var myUsername = "";
var usernameRE = /href="\/collection\/user\/(.*?)">Collection/.exec(document.body.innerHTML);
if(usernameRE){
	myUsername = usernameRE[1];
}
var BYCversion = [2,6,2]; 
/*jshint -W018*/ /*jshint -W086*/ /*jshint -W014*/ /*jshint -W117*/ /* TODO: deal with bouncing options (just change context, don't remove and add) */ /*TODO: Major Victory CO */ 
/*var module = "";var alertify = "";*/
/*var alert = "";var confirm = "";var prompt = ""; var document = "";*/
/* TODO: Admiral "Lee" Banner, President/Admiral/CAG "Billy" banners*/ /* TODO: Dictator Starbuck, Kat, Anders, Gaeta, Tory */
var d = {
	"characters": ["Adama", "Apollo", "Baltar", "Boomer", "Chief", "Helo", "Roslin", "Starbuck", "Tigh", "Zarek", 
				   "Cain", "Dee", "Ellen", "Kat", "Cavil", "Leoben", "Six", 
				   "Anders", "Cally", "Gaeta", "Tory", 
				   "Cottle", "Hoshi", "Hot Dog", "Romo", "D'Anna", "Simon", "Doral", "Athena", "Gaius", "Karl", "Lee", "Tom", 
				   "Elosha", "Kelly", "Racetrack", "Seelix", "Shaw", "Billy", "Crashdown"
	],
	"startingLocations": ["Admiral's Quarters", "Sector 5", "Research Lab", "Armory", "Hangar Deck", "Stranded on Caprica", "President's Office",
		"Hangar Deck", "Command", "Administration", "Command", "Communications", "Admiral's Quarters", "Hangar Deck", "Cylon Fleet", "Human Fleet",
		"Caprica", "Armory", "Hangar Deck", "FTL Control", "Press Room", "Research Lab", "Communications", "Hangar Deck", "Administration",
		"Human Fleet", "Cylon Fleet", "Caprica", "Hangar Deck", "Admiral's Quarters", "Admiral's Quarters", "Admiral's Quarters", "Weapons Control",
		"President's Office", "Command", "Hangar Deck", "Hangar Deck", "Weapons Control", "President's Office", "Armory"
	],
	"banners": [544211, 544204, 544202, 544206, 544210, 544207, 544209, 544208, 544203, 544205, 
	    544871, 544872, 544875, 544873, 544870, 544874, 544876,
		878727, 878729, 878731, 878733, 
		900674, 900680, 900681, 3007562, 900676, 900687, 900677, 666181, 2045919, 6279784, 1887176, 6089733, 
		900678, 900683, 900685, 1419731, 900686, 1418384, 900675
	],
	"cylonBanners": [551658, 551665, 551652, 551655, 551664, 551660, 551661, 551657, 551654, 551656, 551659, 551666, 551662, 551668, 551663, 551653, 551667,
		878728, 878730, 878732, 878734, 1273565, 1273573, 1273574, 5336752, 1273567, 1273580, 1273569, 1696684, 
		2045920, 551660, 1976333, 551656, 1273571, 1273576, 1273578, 1419728, 1273579, 1418402, 1273566
	],
	"presidentBanners": [1302932, 1263108, 1263109, 1263110, 1263113, 1263117, 1248698, 1270646, 1263120, 1263122, 1263111, 1263114, 1263115, 1263118, 0, 0, 0, 
	    1263107, 1263112, 1263116, 1263121, 1324090, 1324111, 1324140, 3007402, 0, 0, 0, 0, 
		2045917, 1263117, 1887177, 6089731, 1324102, 1324190, 1324202, 1324208, 1324214, 1324148, 1324091
	],
	"admiralBanners": [1263070, 1263072, 1263073, 1263074, 1263077, 1263081, 1263083, 1270645, 1263085, 1263087, 1263075, 1263078, 1263079, 1263082, 0, 0, 0, 
	    1263071, 1263076, 1263080, 1263086, 1324087, 2630364, 1324137, 3007563, 0, 0, 0, 0, 
		2045916, 1263081, 1263072, 6089734, 1324099, 1324187, 1324199, 1324205, 1324211, 1324143, 1324094
	],
	"cagBanners": [1263088, 1263090, 1263091, 1263092, 1263095, 1263099, 1263101, 1263102, 1263103, 1263105, 1263093, 1263096, 1263097, 1263100, 0, 0, 0,
		1263089, 1263094, 1263098, 1263104, 1324089, 1324110, 1324139, 5336743, 0, 0, 0, 0, 
		2045921, 1263099, 2244280, 1263105, 1324101, 1324189, 1324201, 1324207, 1324213, 1324146, 1324096
	],
	"dictatorBanners": [741584, 1382131, 2027272, 1615788, 1695765, 1688278, 1463754, 1000286, 1412378, 1445933, 1685904, 803955, 1541494, 1054001, 0, 0, 0,
		1850112, 1688320, 1310440, 1483123, 1324086, 1324107, 1324136, 3007568, 0, 0, 0, 0, 
		2027276, 1688278, 1382131, 6089732, 1324098, 1320703, 1324198, 1324204, 1324210, 1324142, 1324093
	],
	"skillSets": [
		[0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0],
		[1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
		[1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
		[0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1],
		[0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	],
	"skillDraws": [
		[0, 0, 2, 0, 1, 0, 3, 0, 0, 2, 0, 0, 2, 0, 0, 1, 0, 0, 1, 0, 3, 1, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 2, 3, 0, 0, 1, 0, 3, 0],
		[3, 0, 1, 0, 2, 2, 2, 0, 2, 2, 2, 1, 2, 1, 0, 0, 1, 2, 1, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 3, 1, 0, 2, 1, 0],
		[2, 1, 0, 2, 0, 2, 0, 2, 3, 1, 2, 3, 0, 2, 1, 0, 0, 2, 1, 2, 1, 2, 2, 1, 2, 0, 0, 0, 0, 0, 2, 1, 1, 0, 1, 2, 1, 2, 0, 3],
		[0, 2, 0, 2, 0, 1, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 2, 0, 0, 0, 1, 1, 0, 0, 1],
		[0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	],
	"presidentSuccession": [12, 9, 2, 25, 14, 13, 1, 31, 27, 4, 20, 21, 8, 32, 99, 99, 99, 30, 16, 11, 6, 18, 22, 29, 5, 99, 99, 99, 99, 15, 23, 3, 10, 7, 28, 30.5, 17, 20.5, 6.5, 30.75
	],
	"admiralSuccession": [2, 10, 27, 15, 20, 6, 30, 13, 3, 24, 1, 11, 25, 14, 99, 99, 99, 18, 21, 7, 29, 22, 8, 16, 28, 99, 99, 99, 99, 26, 12, 23, 9, 31, 5, 14.5, 19, 4, 30.5, 17.5
	],
	"cagSuccession": [13, 1, 27, 5, 21, 10, 31, 2, 15, 24, 14, 18, 25, 3, 99, 99, 99, 8, 22, 17, 28, 23, 19, 6, 29, 99, 99, 99, 99, 26, 4, 9, 20, 30, 11, 4.5, 8.5, 16, 32, 7.5
	],
	"allyNames": ["Chief", "Doral", "Kelly", "Crashdown", "Dee", "Billy", "Hot Dog", "Cavil", "Cally", "Six", "D'Anna", "Seelix", "Cottle", "Ellen",
		"Gaeta", "Baltar", "Cain", "Starbuck", "Helo", "Shaw", "Roslin", "Apollo", "Leoben", "Kat", "Hoshi", "Racetrack", "Elosha", "Romo", "Anders",
		"Tigh", "Boomer", "Simon", "Zarek", "Tory", "Adama"
	],
	"allyLocations": ["Hangar Deck", "Administration", "Command", "Armory", "Communications", "Administration", "Weapons Control", "Research Lab",
		"Hangar Deck", "Brig", "Press Room", "Armory", "Sickbay", "Admiral's Quarters", "FTL Control", "Research Lab", "Command", "Hangar Deck",
		"Weapons Control", "Weapons Control", "President's Office", "Hangar Deck", "Communications", "Hangar Deck", "Communications", "Weapons Control",
		"President's Office", "Brig", "Armory", "Command", "Armory", "Sickbay", "Administration", "Press Room", "Admiral's Quarters"
	],
	"destinationNames": ["Asteroid Field", "Asteroid Field", "Barren Planet", "Barren Planet", "Barren Planet", "Barren Planet", "Cylon Ambush",
		"Cylon Refinery", "Deep Space", "Deep Space", "Deep Space", "Desolate Moon", "Icy Moon", "Icy Moon", "Ragnar Anchorage", "Remote Planet",
		"Remote Planet", "Remote Planet", "Tylium Planet", "Tylium Planet", "Tylium Planet", "Tylium Planet", "A Civilian Convoy", "Binary Star",
		"Gas Cloud", "Mining Asteroid", "Misjump", "Algae Planet", "Cylon Raiders", "Derelict Basestar", "Dying Star", "Gas Giant",
		"Lion's Head Nebula", "Radioactive Cloud", "Legendary Discovery", "Digging up the Past", "The Search for Home"
	],
	"crisisNames": ["A Traitor Accused", "Admiral Grilled", "Ambush", "Analyze Enemy Fighter", "Besieged", "Boarding Parties", "Bomb Threat",
		"Build Cylon Detector", "Colonial Day", "Crash Landing", "Crippled Raider", "Cylon Accusation", "Cylon Screenings", "Cylon Swarm",
		"Cylon Tracking Device", "Cylon Virus", "Declare Martial Law", "Detector Sabotage", "Elections Loom", "Food Shortage", "Food Shortage",
		"Food Shortage", "Food Shortage", "Forced Water Mining", "Fulfiller of Prophecy", "Guilt by Collusion", "Hangar Accident", "Heavy Assault",
		"Informing the Public", "Jammed Assault", "Jump Computer Failure", "Keep Tabs on Visitor", "Legendary Discovery", "Loss of a Friend",
		"Low Supplies", "Mandatory Testing", "Missing G4 Explosives", "Network Computers", "Prison Labor", "Prisoner Revolt", "Raiding Party",
		"Requested Resignation", "Rescue Caprica Survivors", "Rescue Mission (B/*)", "Rescue Mission (R/*)", "Rescue the Fleet", "Resistance",
		"Riots (B/*)", "Riots (L/-)", "Scouting for Fuel", "Scouting for Water", "Security Breach", "Send Survey Team", "Sleep Deprivation",
		"Surrounded", "Tactical Strike", "Terrorist Bomber", "Terrorist Investigations", "The Olympic Carrier", "Thirty-Three", "Unexpected Reunion",
		"Unidentified Ship", "Water Sabotaged", "Water Shortage (B/-)", "Water Shortage (B/*)", "Water Shortage (B/*)", "Water Shortage (B/*)",
		"Water Shortage (R/*)", "Weapon Malfunction", "Witch Hunt", "A Verdict of Guilty", "An Offer of Peace", "Assassination Plot",
		"Civilian Ship Nuked", "Code Blue", "Defending a Prisoner", "Dogfight", "Food Hoarding in the Fleet", "Medical Breakthrough",
		"Pressure the Supply Ships", "Reunite the Fleet", "Review Galactica's Log", "Sabotage Investigated", "Scar", "Standoff with Pegasus",
		"Suspicious Election Results", "The Black Market", "The Guardians", "Training Snafu", "Unsettling Stories", "Airlock Leak",
		"Ambushed by the Press", "Appoint Head of Security", "Centurion Assault", "Consult the Prisoner", "Controversial Manuscript", "Cylon Genocide",
		"Detente", "Divisive Behavior", "Familiar Face", "Guilty Conscience", "Haunted by the Past", "Hera Rescued", "Hidden Explosives",
		"Hidden Identity", "In the Ring", "Interrogation", "Joe's Bar", "Labor Dispute", "Medal of Distinction", "Mysterious Guide",
		"Mysterious Message", "Power Failure", "Raiders Inbound", "Raptor Malfunction", "Return to Duty", "Review Camera Footage", "Set a Trap",
		"Strange Beacon", "Temple of the Five", "The Circle", "The Passage", "Threat of a Super Nova", "Tracked by Radiation", "Training a Rookie",
		"Truth and Reconciliation", "Unexplained Deaths", "Unfair Bias", "Unwelcome Faces", "Widespread Starvation", "A Desperate Pact",
		"Abandon Galactica", "An Ambitious Operation", "Blindsided", "Consult the Hybrid", "Dangerous Plots", "Dishonest Tactics", "Domestic Dispute",
		"Earth in Ruins", "Enemy of my Enemy", "Event Horizon", "Galactica Falling Apart", "Give In To Despair", "Hornet's Nest", "Hybrid in Panic",
		"Incitement to Mutiny", "Insubordinate Crew", "Lockdown", "One Last Cocktail", "Question Procedure", "Quorum in Uproar", "Rallying Support",
		"Reactor Critical", "Rebuild Trust", "Religious Turmoil", "Reprisal", "Requisition for Demetrius", "Secret Meetings", "Starvation in Dogsville",
		"Trial by Fire", "Bomb on Colonial One", "Cylon Intruders", "Fleet Mobilization", "Inbound Nukes", "Massive Assault",
		"'Demand Peace' Manifesto", "Footage Transmitted", "Lured into a Trap", "Psychological Warfare", "The Farm", "Fighting Blind",
		"Fire All Missiles", "Human Prisoner", "A Cylon Ally", "Arrests at Night", "Attack on the Power Plant", "Betrayed From Within",
		"Brutal Treatment", "Centurion Ambush", "Contact Informant", "Contact Raptor", "Decode Cylon Maps", "Demanded Surrender",
		"Dissent Among Cylons", "Establish Sanitation", "Execution List", "Held for Questioning", "Hiding Underground", "Intra-Atmos Entry",
		"Keeping Hera Hidden", "Labor Union Strike", "Marine Reinforcements", "Meet Liaison Officer", "NCP Graduation", "NCP Recruitment",
		"Organize the Pilots", "Playing with Emotions", "Prepare for a Fight", "Prepare the Civilians", "Recover Launch Keys", "Rescue Detainees",
		"Resistance Bombing", "Second Thoughts", "Attack on the Colony", "Cylon Civil War", "Destroy the Hub", "Digging up the Past",
		"Needs of the People", "Rescue Hera", "The Red Stripes", "The Search for Home"
	],
	"quorumNames": ["Accept Prophecy", "Arrest Order", "Arrest Order", "Assign Arbitrator", "Assign Mission Specialist", "Assign Vice President",
		"Authorization of Brutal Force", "Authorization of Brutal Force", "Encourage Mutiny", "Food Rationing", "Food Rationing",
		"Inspirational Speech", "Inspirational Speech", "Inspirational Speech", "Inspirational Speech", "Presidential Pardon", "Release Cylon Mugshots",
		"Assign Chief of Staff", "Civilian Self Defense", "Consult the Oracle", "Enact Production Quotas", "Eulogy", "Execute Prisoner", "Probation",
		"Resources for Galactica", "Unsavory Connections", "Establish Dogsville", "Presidential Order", "Resignation"
	],
	"mutinyNames": ["Armed Resistance", "Assume Command", "Bait and Switch", "Betrayal of Trust", "Blackmail", "Clipped Wings", "Controversial Speech",
		"Feed the People", "Impeachment", "Make a Deal", "Necessary Risk", "Panic", "Peaceful Resistance", "Ruined Reputation", "Scavenging for Parts",
		"Selfish Act", "Send a Message", "Set the Agenda", "The Strong Survive", "Unauthorized Usage", "Violent Protest", "Weapons Armed"
	],
	"currentPlayerChooses": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
		0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
		1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0,
		1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"presidentChooses": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,
		0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"admiralChooses": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"cagChooses": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"CAC": [0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
		0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"positives": [
		[1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
			0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0,
			1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0,
			0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1
		],
		[1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0,
			0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
			0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1,
			1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1,
			0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1
		],
		[0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0,
			0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
			0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1,
			0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1
		],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
			0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0
		],
		[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
			0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
			0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1
		]
	],
	"difficulty": [8, 9, 0, 7, 0, 0, 13, 0, 10, 6, 10, 10, 9, 0, 10, 13, 0, 8, 8, 0, 0, 0, 0, 17, 6, 9, 10, 0, 7, 0, 7, 12, 14, 9, 7, 13, 7, 11, 10, 11, 0,
		0, 0, 0, 0, 0, 12, 0, 0, 12, 9, 6, 15, 0, 0, 0, 9, 12, 11, 0, 8, 10, 13, 0, 0, 0, 0, 0, 11, 10, 0, 12, 0, 0, 13, 11, 0, 0, 12, 0, 10, 14, 9, 0,
		22, 0, 13, 0, 8, 9, 6, 0, 0, 9, 13, 0, 21, 0, 10, 12, 7, 12, 10, 0, 12, 12, 0, 12, 0, 0, 11, 9, 14, 0, 12, 0, 0, 10, 13, 9, 0, 14, 10, 0, 0, 0,
		8, 12, 0, 0, 15, 0, 0, 0, 10, 0, 0, 9, 9, 13, 0, 8, 14, 0, 12, 13, 12, 0, 7, 0, 8, 8, 7, 9, 7, 0, 0, 9, 0, 0, 15, 18, 24, 15, 0, 0, 17, 0, 0,
		15, 0, 22, 18, 0, 10, 0, 9, 9, 7, 9, 7, 8, 0, 12, 0, 0, 10, 9, 15, 0, 13, 0, 10, 0, 8, 9, 7, 8, 9, 10, 9, 12, 9, 14, 21, 14, 14, 18, 20, 16, 25
	],
	"partial": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 9, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 9,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
		0, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 12, 0, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 9, 0,
		10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"consequence": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"jumpIcon": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1,
		1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0,
		1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1,
		1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0
	],
	"activation": ["R", "R", "B", "R", "R", "H", "R", "H", "B", "H", "R", "R", "R", "B", "R", "L", "B", "H", "H", "R", "R", "R", "R", "R", "B", "R", "H",
		"R", "R", "R", "L", "R", "L", "H", "R", "H", "R", "R", "R", "H", "R", "B", "R", "B", "R", "R", "H", "B", "L", "R", "R", "L", "R", "B", "B", "R",
		"H", "H", "H", "R", "R", "L", "R", "B", "B", "B", "B", "R", "L", "H", "B", "L", "B", "R", "H", "H", "R", "R", "H", "R", "R", "R", "H", "R", "L",
		"R", "R", "B", "B", "R", "H", "R", "L", "L", "B", "R", "R", "L", "H", "R", "H", "H", "R", "R", "L", "H", "B", "R", "B", "B", "R", "R", "H", "H",
		"R", "R", "B", "R", "R", "L", "R", "R", "H", "B", "L", "B", "R", "R", "R", "R", "R", "B", "R", "R", "H", "B", "R", "R", "R", "R", "R", "R", "H",
		"R", "H", "H", "R", "H", "B", "B", "L", "R", "L", "R", "R", "R", "B", "R", "R", "R", "", "", "", "", "", "", "", "", "", "", "", "", "", "R/O",
		"L", "L", "R", "B/O", "R", "R/O", "R", "H/O", "B/O", "L", "R", "H/O", "H/O", "R/O", "H", "R/O", "R/O", "R", "R", "H", "R", "B", "L", "R/O", "R",
		"B", "H/O", "B/O", "B/O", "", "", "", "", "", "", "", ""
	],
	"loyaltyNames": ["You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon",
		"You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon", "You Are NOT A Cylon",
		"[col" + "or=red]You are a Cylon - Can Send a Character to Sickbay[/col" + "or]", "[col" +
		"or=red]You are a Cylon - Can Send a Character to the Brig[/col" + "or]", "[col" + "or=red]You are a Cylon - Can Reduce Morale by 1[/col" +
		"or]", "[col" + "or=red]You are a Cylon - Can Damage Galactica[/col" + "or]", "You Are A Sympathizer", "You Are NOT A Cylon (P)",
		"You Are A Sympathetic Cylon", "[col" + "or=red]You are a Cylon - Can Make Players Draw Treachery[/col" + "or]", "You Are NOT A Cylon (X)",
		"You Are NOT A Cylon (X)", "You Are NOT A Cylon (X)", "You Are NOT A Cylon (X)", "You Are NOT A Cylon (X)", "[col" +
		"or=green]Personal Goal - Stand and Fight: 10 or More Raiders (else -1 Population)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Sacrifice: 6 Vipers Damaged or Destroyed (else -1 Fuel)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Devastation: Admiral has no Remaining Nuke Tokens (else -1 Morale)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Use Caution: The Fleet has made a 1-Distance Jump (else -1 Population)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Acquire Power: 2 or More Title Cards at the Same Time (else -1 Food)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Political Intrigue: The President is in the Brig (else -1 Food)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Selfish: Discard Skill Cards Equal to 20 Strength (else -1 Fuel)[/col" + "or]", "[col" +
		"or=green]Personal Goal - Self-Destruction: In the Brig or Sickbay (else -1 Morale)[/col" + "or]", "[col" +
		"or=darkgreen]Final Five - Whoever Examines this Card is Executed[/col" + "or]", "[col" +
		"or=darkgreen]Final Five - If this Card is Examined, Cylon Ships are Activated[/col" + "or]", "[col" +
		"or=darkgreen]Final Five - If this Card is Examined, Galactica is Damaged Twice[/col" + "or]", "[col" +
		"or=darkgreen]Final Five - If this Card is Examined, You are Executed[/col" + "or]", "[col" +
		"or=darkgreen]Final Five - Whoever Examines this Card is Sent to the \"Brig\"[/col" + "or]", "[col" +
		"or=red]You are a Cylon - Can Place a Centurion Token on the Boarding Party Track[/col" + "or]", "[col" +
		"or=red]You are a Cylon - Can Decrease the Jump Preparation Track by 2[/col" + "or]", "You Are NOT A Cylon (D)", "You Are the Mutineer",
		"[col" + "or=blue]Human Agenda: Convert the Infidels[/col" + "or]", "[col" + "or=blue]Human Agenda: Join the Colonials[/col" + "or]", "[col" +
		"or=blue]Human Agenda: Guide them to Destiny[/col" + "or]", "[col" + "or=blue]Human Agenda: Prove their Worth[/col" + "or]", "[col" +
		"or=brown]Cylon Agenda: The Illusion of Hope[/col" + "or]", "[col" + "or=brown]Cylon Agenda: Salvage Their Equipment[/col" + "or]", "[col" +
		"or=brown]Cylon Agenda: Show Their True Nature[/col" + "or]", "[col" + "or=brown]Cylon Agenda: Siege Warfare[/col" + "or]", "[col" +
		"or=brown]Cylon Agenda: Reduce Them To Ruins[/col" + "or]", "[col" + "or=brown]Cylon Agenda: Genocide[/col" + "or]", "[col" +
		"or=blue]Human Agenda: Grant Mercy[/col" + "or]", "[col" + "or=blue]Human Agenda: Mutual Annihilation[/col" + "or]", "[col" +
		"or=blue]Human Allegiance: End the Chase[/col" + "or]", "[col" + "or=blue]Human Allegiance: Make an Ally[/col" + "or]", "[col" +
		"or=blue]Human Allegiance: Remove the Threat[/col" + "or]", "[col" + "or=blue]Human Allegiance: Improve Efficiency[/col" + "or]", "[col" +
		"or=blue]Human Allegiance: Learn to Cherish[/col" + "or]", "[col" + "or=blue]Human Allegiance: Pressure their Leaders[/col" + "or]", "[col" +
		"or=blue]Human Allegiance: Keep them Docile[/col" + "or]", "[col" + "or=brown]Cylon Allegiance: A Justified Response[/col" + "or]", "[col" +
		"or=brown]Cylon Allegiance: No Unnecessary Force[/col" + "or]", "[col" + "or=brown]Cylon Allegiance: Savor Their Demise[/col" + "or]", "[col" +
		"or=brown]Cylon Allegiance: Fight With Honor[/col" + "or]", "[col" + "or=brown]Cylon Allegiance: Subjects for Study[/col" + "or]", "[col" +
		"or=brown]Cylon Allegiance: A False Sense of Security[/col" + "or]", "[col" + "or=brown]Cylon Allegiance: Harvest Their Resources[/col" + "or]", "[col"+
		"or=green]Infiltration (P)[/color]", "[col"+
		"or=green]Infiltration (D)[/color]"
	]
};
var z = {};
var ts = document.getElementsByTagName("textarea");
var t = ts[ts.length-1];
var me = -1;
var myPlayer = "";
var myCharacter = -1;
var meBoxed = -1;
var bl = "";
var mobile = false;

function inv() {
	/* DEDAFF */
	return colorText("#F7F7F8", "|");
} /***** ALERTIFY ****/
var lb = String.fromCharCode(60);
var TRANSITION_FALLBACK_DURATION = 500;
var hideElement = function(el) {
	if(!el) {
		return;
	}
	let removeThis = function() {
		if(el && el.parentNode) {
			el.parentNode.removeChild(el);
		}
	};
	el.classList.remove("show");
	el.classList.add("hide");
	el.addEventListener("transitionend", removeThis); /* alertify: Fallback for no transitions. */
	setTimeout(removeThis, TRANSITION_FALLBACK_DURATION);
};

function Alertify() {
	/**	 * Alertify private object	 * @type {Object}	 */ /* _alertify is a struct, with functions... */
	let _alertify = {
		parent: document.body,
		version: "1.0.11",
		defaultOkLabel: "Ok",
		okLabel: "Ok",
		defaultCancelLabel: "Cancel",
		cancelLabel: "Cancel",
		defaultMaxLogItems: 2,
		maxLogItems: 2,
		promptValue: "",
		promptPlaceholder: "",
		closeLogOnClick: false,
		closeLogOnClickDefault: false,
		delay: 5000,
		defaultDelay: 5000,
		logContainerClass: "alertify-logs",
		logContainerDefaultClass: "alertify-logs",
		dialogs: {
			buttons: {
				holder: lb + "nav>{" + "{buttons}}" + lb + "/nav>",
				ok: lb + "button class='ok' tabindex='1'>{" + "{ok}}" + lb + "/button>",
				cancel: lb + "button class='cancel' tabindex='2'>{" + "{cancel}}" + lb + "/button>",
				choice: lb + "button class='choice' id='choice{" + "{num}}'>{" + "{choice}}" + lb + "/button>"
			},
			input: lb + "input type='text'>",
			message: lb + "p class='msg'>{" + "{message}}" + lb + "/p>",
			log: lb + "div class='{" + "{class}}'>{" + "{message}}" + lb + "/div>"
		},
		defaultDialogs: {
			buttons: {
				holder: lb + "nav>{" + "{buttons}}" + lb + "/nav>",
				ok: lb + "button class='ok' tabindex='1'>{" + "{ok}}" + lb + "/button>",
				cancel: lb + "button class='cancel' tabindex='2'>{" + "{cancel}}" + lb + "/button>"
			},
			input: lb + "input type='text'>",
			message: lb + "p class='msg'>{" + "{message}}" + lb + "/p>",
			log: lb + "div class='{" + "{class}}'>{" + "{message}}" + lb + "/div>"
		},
		/**		 * Build the proper message box		 *		 * @param  {Object} item    Current object in the queue		 *		 * @return {String}         An HTML string of the message box		 */
		build: function(item) {
			/* promptButton uses onOkay to carry illegal with us... */
			let btnTxt = this.dialogs.buttons.ok;
			let html = lb + "div class='dialog'>" + lb + "div>";
			if(item.type === "promptButton" && typeof item.message === "string") {
				let illegal = item.onOkay;
				let split = item.message.split("\n");
				let foundAnyChoices = false;
				for(let j = 0; !(j >= split.length); j++) {
					let re = /^([ABC]|\d+): (.*)$/.exec(split[j]);
					if(re === null) {
						html += this.dialogs.message.replace("{" + "{message}}", split[j]);
					} else {
						foundAnyChoices = true;
						let n = parseInt(re[1]);
						if(isNaN(n) || !illegal(n)) {
							/* valid options or a number, gets id choiceA, choiceB, choiceC, choice0, choice1, etc... */
							html += this.dialogs.buttons.holder.replace("{" + "{buttons}}", this.dialogs.buttons.choice.replace("{" + "{choice}}", re[
								2]).replace("{" + "{num}}", re[1]));
						} else {
							html += this.dialogs.message.replace("{" + "{message}}", split[j]);
						}
					}
				}
				if(!foundAnyChoices) {
					for(let n = 0; !(n > 30); n++) {
						if(!illegal(n)) {
							html += this.dialogs.buttons.holder.replace("{" + "{buttons}}", this.dialogs.buttons.choice.replace("{" + "{choice}}", n)
								.replace("{" + "{num}}", n));
						}
					}
				}
				html += this.dialogs.buttons.holder.replace("{" + "{buttons}}", this.dialogs.buttons.cancel.replace("{" + "{cancel}}", this
					.cancelLabel));
				html += lb + "/div>" + lb + "/div>";
				return html;
			}
			if(typeof item.message === "string") {
				item.message = item.message.replace(/\n/g, lb + "br>");
			}
			html += this.dialogs.message.replace("{" + "{message}}", item.message);
			if(item.type === "confirm" || item.type === "prompt") {
				btnTxt = this.dialogs.buttons.cancel + this.dialogs.buttons.ok;
			}
			if(item.type === "prompt") {
				html += this.dialogs.input;
			}
			html = (html + this.dialogs.buttons.holder + lb + "/div>" + lb + "/div>").replace("{" + "{buttons}}", btnTxt).replace("{" + "{ok}}", this
				.okLabel).replace("{" + "{cancel}}", this.cancelLabel);
			return html;
		},
		/**		 * Create a dialog box		 *		 * @param  {String}   message      The message passed from the callee		 * @param  {String}   type         Type of dialog to create		 * @param  {Function} onOkay       [Optional] Callback function when clicked okay.		 * @param  {Function} onCancel     [Optional] Callback function when cancelled.		 *		 * @return {Object}		 */
		dialog: function(message, type, onOkay, onCancel) {
			return this.setup({
				type: type,
				message: message,
				onOkay: onOkay,
				onCancel: onCancel
			});
		},
		/**		 * Initiate all the required pieces for the dialog box		 *		 * @return {undefined}		 */ setup: function(item) {
			let el = document.createElement("div");
			el.className = "alertify hide";
			el.innerHTML = this.build(item);
			let illegal = item.onOkay;
			item.onOkay = null;
			let btnOK = el.querySelector(".ok");
			let btnCancel = el.querySelector(".cancel");
			let input = el.querySelector("input");
			let label = el.querySelector("label");
			let choiceA = el.querySelector("#choiceA");
			let choiceB = el.querySelector("#choiceB");
			let choiceC = el.querySelector("#choiceC");
			let choices = [];
			if(choiceA) {
				choices.push(choiceA);
			}
			if(choiceB) {
				choices.push(choiceB);
			}
			if(choiceC) {
				choices.push(choiceC);
			}
			for(let j = 0; !(j > 20); j++) {
				let choiceN = el.querySelector("#choice" + j);
				if(choiceN) {
					choices.push(choiceN);
				}
			} /*document.getElementById("body").parentNode.insertBefore(el,document.getElementById("body")); */ /* alertify: Set default value/placeholder of input */
			if(input) {
				if(typeof this.promptPlaceholder === "string") {
					/* alertify: Set the label, if available, for MDL, etc. */
					if(label) {
						label.textContent = this.promptPlaceholder;
					} else {
						input.placeholder = this.promptPlaceholder;
					}
				}
				if(typeof this.promptValue === "string") {
					input.value = this.promptValue;
				}
			} /* is there any reject? gotta have cleanup... */
			function setupHandlers(resolve) {
				if("function" !== typeof resolve) {
					/* alertify: promises are not available so resolve is a no-op */
					resolve = function() {};
				}
				for(let j = 0; !(j >= choices.length); j++) {
					choices[j].addEventListener("click", (ev) => {
						resolve({
							buttonClicked: choices[j].id,
							event: ev
						});
						hideElement(el);
					});
				}
				if(btnOK) {
					if(!input) {
						btnOK.addEventListener("keyup", function(ev) {
							if(ev.which === 27) {
								if(btnCancel) {
									btnCancel.click();
								} else {
									btnOK.click();
								}
							}
						});
					}
					btnOK.addEventListener("click", function(ev) {
						if(input) {
							resolve({
								buttonClicked: "ok",
								inputValue: input.value,
								event: ev
							});
						} else {
							resolve({
								buttonClicked: "ok",
								event: ev
							});
						}
						hideElement(el);
					});
				}
				if(btnCancel) {
					btnCancel.addEventListener("click", function(ev) {
						if(item.onCancel && "function" === typeof item.onCancel) {
							item.onCancel(ev);
						}
						if(input) {
							resolve({
								buttonClicked: "cancel",
								inputValue: input.value,
								event: ev
							});
						} else {
							resolve({
								buttonClicked: "cancel",
								event: ev
							});
						}
						hideElement(el);
					});
				}
				if(input) {
					input.addEventListener("keyup", function(ev) {
						if(ev.which === 13) {
							btnOK.click();
						} else if(ev.which === 27) {
							btnCancel.click();
						}
					});
				}
			}
			let promise;
			if(typeof Promise === "function") {
				promise = new Promise(setupHandlers);
			} else {
				setupHandlers();
			}
			this.parent.appendChild(el);
			setTimeout(function() {
				el.classList.remove("hide");
				if(input && item.type && item.type === "prompt") {
					input.select(); /* I don't think this works on iOS */
					input.focus();
				} else {
					if(btnOK) {
						btnOK.focus();
					}
				}
			}, 100);
			return promise;
		},
		okBtn: function(label) {
			this.okLabel = label;
			return this;
		},
		setDelay: function(time) {
			time = time || 0;
			this.delay = isNaN(time) ? this.defaultDelay : parseInt(time, 10);
			return this;
		},
		cancelBtn: function(str) {
			this.cancelLabel = str;
			return this;
		},
		/*setMaxLogItems: function(num) {			this.maxLogItems = parseInt(num || this.defaultMaxLogItems);		},*/ /* TODO: play around with this, though then we may need to be careful with calls to reset. */
		theme: function(themeStr) {
			switch (themeStr.toLowerCase()) {
				case "bootstrap":
					this.dialogs.buttons.ok = lb + "button class='ok btn btn-primary' tabindex='1'>{" + "{ok}}" + lb + "/button>";
					this.dialogs.buttons.cancel = lb + "button class='cancel btn btn-default' tabindex='2'>{" + "{cancel}}" + lb + "/button>";
					this.dialogs.input = lb + "input type='text' class='form-control'>";
					break;
				case "purecss":
					this.dialogs.buttons.ok = lb + "button class='ok pure-button' tabindex='1'>{" + "{ok}}" + lb + "/button>";
					this.dialogs.buttons.cancel = lb + "button class='cancel pure-button' tabindex='2'>{" + "{cancel}}" + lb + "/button>";
					break;
				case "mdl":
				case "material-design-light":
					this.dialogs.buttons.ok = lb + "button class='ok mdl-button mdl-js-button mdl-js-ripple-effect'  tabindex='1'>{" + "{ok}}" + lb +
						"/button>";
					this.dialogs.buttons.cancel = lb + "button class='cancel mdl-button mdl-js-button mdl-js-ripple-effect' tabindex='2'>{" +
						"{cancel}}" + lb + "/button>";
					this.dialogs.input = lb + "div class='mdl-textfield mdl-js-textfield'>" + lb + "input class='mdl-textfield__input'>" + lb +
						"label class='md-textfield__label'>" + lb + "/label>" + lb + "/div>";
					break;
				case "angular-material":
					this.dialogs.buttons.ok = lb + "button class='ok md-primary md-button' tabindex='1'>{" + "{ok}}" + lb + "/button>";
					this.dialogs.buttons.cancel = lb + "button class='cancel md-button' tabindex='2'>{" + "{cancel}}" + lb + "/button>";
					this.dialogs.input = lb + "div layout='column'>" + lb + "md-input-container md-no-float>" + lb + "input type='text'>" + lb +
						"/md-input-container>" + lb + "/div>";
					break;
				case "default":
				default:
					this.dialogs.buttons.ok = this.defaultDialogs.buttons.ok;
					this.dialogs.buttons.cancel = this.defaultDialogs.buttons.cancel;
					this.dialogs.input = this.defaultDialogs.input;
					break;
			}
		},
		reset: function() {
			this.parent = document.body;
			this.theme("default");
			this.okBtn(this.defaultOkLabel);
			this.cancelBtn(this.defaultCancelLabel); /*this.setMaxLogItems();*/
			this.promptValue = "";
			this.promptPlaceholder = "";
			this.delay = this
			.defaultDelay; /*this.setCloseLogOnClick(this.closeLogOnClickDefault);			this.setLogPosition("bottom left");			this.logTemplateMethod = null;*/
		},
		injectCSS: function() {
			if(!document.querySelector("#alertifyCSS")) {
				let head = document.getElementsByTagName("head")[0];
				let css = document.createElement("style");
				css.type = "text/css";
				css.id = "alertifyCSS";
				css.innerHTML =
					".alertify-logs > * {  padding: 12px 24px;  color: #fff;  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.2);  border-radius: 1px; }  .alertify-logs > *, .alertify-logs > *.default {    background: rgba(0, 0, 0, 0.8); }  .alertify-logs > *.error {    background: rgba(244, 67, 54, 0.8); }  .alertify-logs > *.success {    background: rgba(76, 175, 80, 0.9); } .alertify2 {position: fixed;  background-color: rgba(0, 0, 0, 0.3);  left: 0;  right: 0;  top: 0;  bottom: 0;  width: 100%;  height: 100%;  z-index: 99998;  box-sizing: border-box;  transition: all 0.33s cubic-bezier(0.25, 0.8, 0.25, 1);} .alertify {  position: fixed;  background-color: rgba(0, 0, 0, 0);  left: 0;  right: 0;  top: 0;  bottom: 0;  width: 100%;  height: 100%;  z-index: 99999; }  .alertify.hide {    opacity: 0;    pointer-events: none; }  .alertify, .alertify.show {    box-sizing: border-box;    transition: all 0.33s cubic-bezier(0.25, 0.8, 0.25, 1); }  .alertify, .alertify * {    box-sizing: border-box; }  .alertify .dialog {    padding: 12px; }  .alertify .dialog, .alertify .alert {    width: 100%;	transform: translateY(-50%);    margin: 0 auto;    position: relative;    top: 50%;    transform: translateY(-50%); }    .alertify .dialog > *, .alertify .alert > * {      width: 400px;      max-width: 95%;      margin: 0 auto;      text-align: center;      padding: 12px;      background: #fff;      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.14), 0 4px 5px 0 rgba(0, 0, 0, 0.098), 0 1px 10px 0 rgba(0, 0, 0, 0.084); }    .alertify .dialog .msg, .alertify .alert .msg {      padding: 12px;      margin-bottom: 12px;      margin: 0;      text-align: left; }    .alertify .dialog input:not(.form-control), .alertify .alert input:not(.form-control) {      margin-bottom: 15px;      width: 100%;      font-size: 100%;      padding: 12px; }      .alertify .dialog input:not(.form-control):focus, .alertify .alert input:not(.form-control):focus {        outline-offset: -2px; }    .alertify .dialog nav, .alertify .alert nav {      text-align: right; }      .alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button), .alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button) {        background: transparent;        box-sizing: border-box;        color: rgba(0, 0, 0, 0.87);        position: relative;        outline: 0;        border: 0;        display: inline-block;        -ms-flex-align: center;            -ms-grid-row-align: center;            align-items: center;        padding: 0 6px;        margin: 6px 8px;        line-height: 36px;        min-height: 36px;        white-space: nowrap;        min-width: 88px;        text-align: center;      font-size: 14px;        text-decoration: none;        cursor: pointer;        border: 1px solid transparent;        border-radius: 2px; }        .alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):hover, .alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):active, .alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):hover, .alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):active {          background-color: rgba(0, 0, 0, 0.05); }        .alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):focus, .alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):focus {          border: 1px solid rgba(0, 0, 0, 0.1); }      .alertify .dialog nav button.btn, .alertify .alert nav button.btn {        margin: 6px 4px; }.alertify-logs {  position: fixed;  z-index: 99999; }  .alertify-logs.bottom, .alertify-logs:not(.top) {    bottom: 16px; }  .alertify-logs.left, .alertify-logs:not(.right) {    left: 16px; }    .alertify-logs.left > *, .alertify-logs:not(.right) > * {      float: left;      transform: translate3d(0, 0, 0);      height: auto; }      .alertify-logs.left > *.show, .alertify-logs:not(.right) > *.show {        left: 0; }      .alertify-logs.left > *, .alertify-logs.left > *.hide, .alertify-logs:not(.right) > *, .alertify-logs:not(.right) > *.hide {        left: -110%; }  .alertify-logs.right {    right: 16px; }    .alertify-logs.right > * {      float: right;      transform: translate3d(0, 0, 0); }      .alertify-logs.right > *.show {        right: 0;        opacity: 1; }      .alertify-logs.right > *, .alertify-logs.right > *.hide {        right: -110%;        opacity: 0; }  .alertify-logs.top {    top: 0; }  .alertify-logs > * {    box-sizing: border-box;    transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);    position: relative;    clear: both;    backface-visibility: hidden;    perspective: 1000; }    .alertify-logs > * {      max-height: 0;      margin: 0;      padding: 0;      overflow: hidden;      opacity: 0;      pointer-events: none; }    .alertify-logs > *.show {      margin-top: 12px;      opacity: 1;      max-height: 1000px;      padding: 12px;      pointer-events: auto; }";
				head.insertBefore(css, head.firstChild);
			}
		},
		removeCSS: function() {
			let css = document.querySelector("#alertifyCSS");
			if(css && css.parentNode) {
				css.parentNode.removeChild(css);
			}
		}
	};
	_alertify.injectCSS();
	return {
		_$$alertify: _alertify,
		parent: function(elem) {
			_alertify.parent = elem;
		},
		reset: function() {
			_alertify.reset();
			return this;
		},
		alert: function(message, onOkay, onCancel) {
			return _alertify.dialog(message, "alert", onOkay, onCancel) || this;
		},
		confirm: function(message, onOkay, onCancel) {
			return _alertify.dialog(message, "confirm", onOkay, onCancel) || this;
		},
		prompt: function(message, onOkay, onCancel) {
			return _alertify.dialog(message, "prompt", onOkay, onCancel) || this;
		},
		promptButton: function(message, illegal, onCancel) {
			return _alertify.dialog(message, "promptButton", illegal, onCancel) || this;
		},
		log: function(message, click) {
			_alertify.log(message, "default", click);
			return this;
		},
		theme: function(themeStr) {
			_alertify.theme(themeStr);
			return this;
		},
		success: function(message, click) {
			_alertify.log(message, "success", click);
			return this;
		},
		error: function(message, click) {
			_alertify.log(message, "error", click);
			return this;
		},
		cancelBtn: function(label) {
			_alertify.cancelBtn(label);
			return this;
		},
		okBtn: function(label) {
			_alertify.okBtn(label);
			return this;
		},
		delay: function(time) {
			_alertify.setDelay(time);
			return this;
		},
		placeholder: function(str) {
			_alertify.promptPlaceholder = str;
			return this;
		},
		defaultValue: function(str) {
			_alertify.promptValue = str;
			return this;
		},
		maxLogItems: function(num) {
			_alertify.setMaxLogItems(num);
			return this;
		},
		closeLogOnClick: function(bool) {
			_alertify.setCloseLogOnClick(!!bool);
			return this;
		},
		logPosition: function(str) {
			_alertify.setLogPosition(str || "");
			return this;
		},
		setLogTemplate: function(templateMethod) {
			_alertify.logTemplateMethod = templateMethod;
			return this;
		},
		clearLogs: function() {
			_alertify.setupLogContainer().innerHTML = "";
			return this;
		},
		version: _alertify.version
	};
} /* alertify: AMD, window, and NPM support */
if("undefined" !== typeof module && !!module && !!module.exports) {
	/* alertify: Preserve backwards compatibility */
	module.exports = function() {
		return new Alertify();
	};
	let obj = new Alertify();
	for(let key in obj) {
		module.exports[key] = obj[key];
	}
} else if(typeof define === "function" && define.amd) {
	define(function() {
		return new Alertify();
	});
} else {
	window.alertify = new Alertify();
} /**** END ALERTIFY ****/
var alertifyBackground = document.createElement("div");
alertifyBackground.className = "alertify2 hide";
document.body.appendChild(alertifyBackground);
setTimeout(function() {
	alertifyBackground.classList.remove("hide");
}, 100);
var alertQueue = [];
var queuedPrompt = [];

function alertQueueShift(arg) {
	if(arg) {
		arg.event.preventDefault();
	}
	alertQueue.shift();
	if(alertQueue.length > 0) {
		if(me >= 0 && z.numPlayers > me && z.promptStyle[me] === 0) {
			alert(alertQueue[0]);
			alertQueueShift();
		} else {
			alertify.cancelBtn("CANCEL").okBtn("OK");
			alertify.alert(alertQueue[0]).then(alertQueueShift);
		}
	} else if(queuedPrompt.length > 0) {
		let promptType = queuedPrompt[0];
		switch (promptType) {
			case "promptNum": {
				let promptText = queuedPrompt[1];
				let illegal = queuedPrompt[2];
				let cancel = queuedPrompt[3];
				let user = queuedPrompt[4];
				let newCancel = queuedPrompt[5];
				queuedPrompt = [];
				promptNum(promptText, illegal, cancel, user, newCancel);
				break;
			}
			case "confirm": {
				let confirmText = queuedPrompt[1];
				let cancel = queuedPrompt[2];
				let user = queuedPrompt[3];
				let newOK = queuedPrompt[4];
				let newCancel = queuedPrompt[5];
				queuedPrompt = [];
				confirmify(confirmText, cancel, user, newOK, newCancel);
				break;
			}
			case "promptString": {
				let promptText = queuedPrompt[1];
				let cancel = queuedPrompt[2];
				let user = queuedPrompt[3];
				let defaultText = queuedPrompt[4];
				queuedPrompt = [];
				promptString(promptText, cancel, user, defaultText);
				break;
			}
			case "mainMenu": {
				queuedPrompt = [];
				mainMenu();
			}
		}
	}
}

function addAlert(alertText) {
	if(me >= 0 && z.numPlayers > me && z.promptStyle[me] !== 0) {
		let colorRE = new RegExp('\\[col' + 'or=([^\\]]+)\\]([^[]*)\\[/col' + 'or\\]', "g");
		let boldRE = new RegExp('\\[b' + '\\]([^[]*)\\[/' + 'b\\]', "g");
		let strikethroughRE = new RegExp('\\[-' + '\\]([^[]*)\\[/' + '-\\]', "g");
		alertText = alertText.replace(colorRE, lb + 'span style="color:$1;">$2' + lb + '/span>');
		alertText = alertText.replace(boldRE, lb + 'b>$1' + lb + '/b>');
		alertText = alertText.replace(strikethroughRE, lb + 'strike>$1' + lb + '/strike>');
	}
	alertQueue.push(alertText);
	if(alertQueue.length === 1) {
		if(me >= 0 && z.numPlayers > me && z.promptStyle[me] === 0) {
			alert(alertText);
			alertQueueShift();
		} else {
			alertify.cancelBtn("CANCEL").okBtn("OK");
			alertify.alert(alertText).then(alertQueueShift);
		}
	}
}

function confirmify(confirmText, cancel, user, newOK, newCancel) {
	if(queuedPrompt.length > 0) {
		alert("Error! Cannot queue multiple prompts");
	} else if(alertQueue.length > 0) {
		queuedPrompt = ["confirm", confirmText, cancel, user, newOK, newCancel];
	} else if(me >= 0 && z.numPlayers > me && z.promptStyle[me] === 0) {
		let ok = confirm(confirmText);
		if(ok) {
			user();
		} else {
			cancel();
		}
	} else {
		let colorRE = new RegExp('\\[col' + 'or=([^\\]]+)\\]([^[]*)\\[/col' + 'or\\]', "g");
		let boldRE = new RegExp('\\[b' + '\\]([^[]*)\\[/' + 'b\\]', "g");
		let strikethroughRE = new RegExp('\\[-' + '\\]([^[]*)\\[/' + '-\\]', "g");
		confirmText = confirmText.replace(colorRE, lb + 'span style="color:$1;">$2' + lb + '/span>');
		confirmText = confirmText.replace(boldRE, lb + 'b>$1' + lb + '/b>');
		confirmText = confirmText.replace(strikethroughRE, lb + 'strike>$1' + lb + '/strike>');
		if(!newOK) {
			newOK = "OK";
		}
		if(!newCancel) {
			newCancel = "CANCEL";
		}
		alertify.okBtn(newOK).cancelBtn(newCancel).confirm(confirmText).then(function(arg) {
			arg.event.preventDefault();
			if(arg.buttonClicked == "cancel") {
				cancel();
			} else {
				user();
			}
		});
	}
}

function tooManyOptions(illegal) {
	let legalCount = 0;
	for(let j = 0; !(j > 20); j++) {
		if(!illegal(j)) {
			legalCount++;
		}
	}
	return legalCount > 13;
} /* TODO: var waiting, var quit */
function promptNum(promptText, illegal, cancel, user, newCancel) {
	if(queuedPrompt.length > 0) {
		alert("Error! Cannot queue multiple prompts");
	} else if(alertQueue.length > 0) {
		queuedPrompt = ["promptNum", promptText, illegal, cancel, user, newCancel];
	} else if(me >= 0 && z.numPlayers > me && z.promptStyle[me] === 0) {
		let prompted = prompt(promptText);
		if(prompted === null) {
			cancel();
		} else {
			let n = parseInt(prompted);
			if(isNaN(n) || illegal(n)) {
				promptNum(promptText, illegal, cancel, user);
			} else {
				user(n);
			}
		}
	} else {
		let colorRE = new RegExp('\\[col' + 'or=([^\\]]+)\\]([^[]*)\\[/col' + 'or\\]', "g");
		let boldRE = new RegExp('\\[b' + '\\]([^[]*)\\[/' + 'b\\]', "g");
		let strikethroughRE = new RegExp('\\[-' + '\\]([^[]*)\\[/' + '-\\]', "g");
		promptText = promptText.replace(colorRE, lb + 'span style="color:$1;">$2' + lb + '/span>');
		promptText = promptText.replace(boldRE, lb + 'b>$1' + lb + '/b>');
		promptText = promptText.replace(strikethroughRE, lb + 'strike>$1' + lb + '/strike>');
		if(!newCancel) {
			newCancel = "CANCEL";
		}
		alertify.cancelBtn(newCancel).okBtn("OK");
		if(0 > me || me >= z.numPlayers || (!mobile && z.promptStyle[me] === 1) || z.promptStyle[me] === 3 || tooManyOptions(illegal)) {
			alertify.prompt(promptText).then((arg) => {
				arg.event.preventDefault();
				let n = parseInt(arg.inputValue);
				if(arg.buttonClicked === "cancel" || arg.inputValue === null) {
					if(newCancel !== undefined && !isNaN(n) && !illegal(n)) {
						confirmify('Are you sure you want to quit?  Whatever option you had typed in the dialog box when you pressed "' + newCancel +
							'" will not be processed.', mainMenu, cancel, "Yes, Quit", "No, Go Back");
					} else {
						cancel();
					}
				} else {
					if(isNaN(n) || illegal(n)) {
						promptNum(promptText, illegal, cancel, user, newCancel);
					} else {
						user(n);
					}
				}
			});
		} else {
			alertify.promptButton(promptText, illegal).then((arg) => {
				arg.event.preventDefault();
				if(arg.buttonClicked === "cancel") {
					cancel();
				} else {
					user(parseInt(/^choice(\d+)$/.exec(arg.buttonClicked)[1]));
				}
			});
		}
	}
} /* empty strings now count as cancel */
function promptString(promptText, cancel, user, defaultText) {
	if(queuedPrompt.length > 0) {
		alert("Error! Cannot queue multiple prompts");
	} else if(alertQueue.length > 0) {
		queuedPrompt = ["promptString", promptText, cancel, user, defaultText];
	} else if(me >= 0 && z.numPlayers > me && z.promptStyle[me] === 0) {
		let prompted = prompt(promptText);
		if(prompted === null || prompted === "") {
			cancel();
		} else {
			user(prompted);
		}
	} else {
		let colorRE = new RegExp('\\[col' + 'or=([^\\]]+)\\]([^[]*)\\[/col' + 'or\\]', "g");
		let boldRE = new RegExp('\\[b' + '\\]([^[]*)\\[/' + 'b\\]', "g");
		let strikethroughRE = new RegExp('\\[-' + '\\]([^[]*)\\[/' + '-\\]', "g");
		promptText = promptText.replace(colorRE, lb + 'span style="color:$1;">$2' + lb + '/span>');
		promptText = promptText.replace(boldRE, lb + 'b>$1' + lb + '/b>');
		promptText = promptText.replace(strikethroughRE, lb + 'strike>$1' + lb + '/strike>');
		if(!defaultText) {
			defaultText = "";
		}
		alertify.cancelBtn("CANCEL").okBtn("OK");
		alertify.defaultValue(defaultText).prompt(promptText).then((arg) => {
			arg.event.preventDefault();
			if(arg.buttonClicked == "cancel" || arg.inputValue === null || arg.inputValue === "") {
				alertify.defaultValue("");
				cancel();
			} else {
				alertify.defaultValue("");
				user(arg.inputValue);
			}
		});
	}
}

function error(str) {
	alert(str);
} /* TODO: better in-mod notification that you're in DE range. */

const aLCG = 1664525;
const cLCG = 1013904223;
const mLCG = 0x100000000;

function updateSeed(){
	z.seed = (aLCG * z.seed + cLCG) % mLCG;
}

function shuffle(array) {
	for(let i = array.length; i > 0; i--) {
		let rando = Math.floor((z.seed * i)/ mLCG);
		updateSeed();
		let removed = array.splice(rando, 1)[0];
		array.push(removed);
	}
	return array;
}

function colorText(color, text) {
	return "[col" + bl + "or=" + color + "]" + text + "[/col" + bl + "or]";
}

function size(text, pt) {
	return "[siz" + bl + "e=" + pt + "]" + text + "[/s" + bl + "ize]";
}

function bold(text) {
	return "[b" + bl + "]" + text + "[/" + bl + "b]";
}

function spoiler(text) {
	return "[o" + bl + "]" + text + "[/" + bl + "o]";
}

function invisible(str) {
	/* F4F4FF */
	return "[color=" + bl + "#FFFFFF]" + str + "[/" + bl + "color]";
}

function code(text) {
	return "[c"+bl+"]"+text+"[/"+bl+"c]";
}

function strikethrough(text) {
	return "[-" + bl + "]" + text + "[/" + bl + "-]";
}

function italics(text) {
	return "[i" + bl + "]" + text + "[/" + bl + "i]";
}

function floatleft(text) {
	return "[float" + bl + "left]" + text + "[/float" + bl + "left]";
}

function floatright(text) {
	return "[float" + bl + "right]" + text + "[/float" + bl + "right]";
}

function center(text) {
	return "[cent" + bl + "er]" + text + "[/cent" + bl + "er]";
}

function clear() {
	return "[cle" + bl + "ar]";
}

function colorIDName(colorID) {
	switch (colorID) {
		case 0:
			return colorText("orange", "Politics");
		case 1:
			return colorText("green", "Leadership");
		case 2:
			return colorText("purple", "Tactics");
		case 3:
			return colorText("red", "Piloting");
		case 4:
			return colorText("blue", "Engineering");
		case 5:
			return colorText("brown", "Treachery");
		default:
			return "Invalid Color ID";
	}
}

function plainAlert(text) {
	addAlert(text);
	t.value += text.replace(/President(?![a-zA-Z'])/g, colorText("orange", "President")).replace(/Admiral(?![a-zA-Z'])/g, colorText("green", "Admiral"))
		.replace(/CAG/g, colorText("red", "CAG")).replace(/Politics/g, colorText("orange", "Politics")).replace(/Leadership/g, colorText("green", "Leadership"))
		.replace(/Tactics/g, colorText("purple", "Tactics")).replace(/Piloting/g, colorText("red", "Piloting")).replace(/Engineering/g, colorText("blue",
			"Engineering")).replace(/Treachery/g, colorText("brown", "Treachery")) + "\r\n";
}

function boldAlert(text) {
	addAlert(text);
	t.value += bold(text.replace(/President(?![a-zA-Z'])/g, colorText("orange", "President")).replace(/Admiral(?![a-zA-Z'])/g, colorText("green", "Admiral"))
		.replace(/CAG/g, colorText("red", "CAG")).replace(/Politics/g, colorText("orange", "Politics")).replace(/Leadership/g, colorText("green",
			"Leadership")).replace(/Tactics/g, colorText("purple", "Tactics")).replace(/Piloting/g, colorText("red", "Piloting")).replace(/Engineering/g,
			colorText("blue", "Engineering")).replace(/Treachery/g, colorText("brown", "Treachery"))) + "\r\n";
}

function clearSpoilers() {
	let ore = new RegExp('\\[o\\][\\s\\S]*\\[/o\\]', "g");
	t.value = t.value.replace(ore, "").replace(ore, ""); /* TODO: check this */
}

function clearQuotes() {
	let qre0 = new RegExp('\\[q="(?!BYC)((?!(\\[q[\\]=]|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	let qre1 = new RegExp('\\[q="(?!BYC)(((?!(\\[q[\\]=]|\\[/q\\]))[\\s\\S])*\\[q[\\]=]((?!(\\[q=|\\[/q\\]))[\\s\\S])*\\[/q\\]((?!(\\[q[\\]=]|\\[/q\\]))[\\s\\S])*)*\\[/q\\]',
		"g");
	t.value = t.value.replace(qre0, "").replace(qre1, "").replace(qre0, "").replace(qre1, "");
}

function colorIDAlert(colorID) {
	switch (colorID) {
		case 0:
			return "Politics";
		case 1:
			return "Leadership";
		case 2:
			return "Tactics";
		case 3:
			return "Piloting";
		case 4:
			return "Engineering";
		case 5:
			return "Treachery";
		default:
			return "Invalid Color ID";
	}
}

function colorIDcolor(colorID) {
	switch (colorID) {
		case 0:
			return "orange";
		case 1:
			return "green";
		case 2:
			return "purple";
		case 3:
			return "red";
		case 4:
			return "blue";
		case 5:
			return "brown";
		default:
			return "black";
	}
}

function cardColorID(id) {
	return Math.floor(id / 35);
}

function cardColor(id) {
	return colorIDcolor(cardColorID(id));
}

function cardValue(id) {
	let mod = id % 35;
	if(Math.floor(id / 35) === 5) {
		if(z.daybreak) {
			if(mod >= 23) {
				return 5;
			} else if(mod >= 20) {
				return 4;
			} else if(mod >= 12) {
				return 3;
			} else {
				return 0;
			}
		} else if(z.pegasus) {
			if(mod >= 20) {
				return 3;
			} else if(mod >= 12) {
				return 2;
			} else {
				return 1;
			}
		}
	}
	switch (mod) {
		case 34:
		case 25:
		case 20:
			return 5;
		case 33:
		case 24:
			return 4;
		case 32:
		case 23:
			return 3;
		case 31:
		case 30:
		case 28:
		case 27:
		case 26:
			return 0;
		case 29:
			return 6;
		case 22:
			return 2;
		case 21:
			return 1;
		default:
			if(mod >= 18) {
				return 4;
			} else if(mod >= 14) {
				return 3;
			} else if(mod >= 8) {
				return 2;
			} else if(mod >= 0) {
				return 1;
			} else {
				return -1;
			}
	}
}

function cardName(id) {
	let mod = id % 35;
	switch (Math.floor(id / 35)) {
		case 5:
			if(z.daybreak) {
				if(mod >= 23) {
					return "Exploit Weakness";
				} else if(mod >= 20) {
					return "Violent Outbursts";
				} else if(mod >= 16) {
					return "A Better Machine";
				} else if(mod >= 12) {
					return "Personal Vices";
				} else if(mod >= 6) {
					return "Dradis Contact";
				} else {
					return "Bait";
				}
			} else if(z.pegasus) {
				if(mod >= 24) {
					return "Human Weakness";
				} else if(mod >= 20) {
					return "Sabotage";
				} else if(mod >= 17) {
					return "God's Plan";
				} else if(mod >= 12) {
					return "Special Destiny";
				} else if(mod >= 8) {
					return "By Your Command";
				} else {
					return "Broadcast Location";
				}
			}
			case 0:
				if(mod === 34) {
					return "Negotiation";
				} else if(mod >= 32) {
					return "Popular Influence";
				} else if(mod >= 30) {
					return "Force Their Hand";
				} else if(mod === 29) {
					return "Political Prowess";
				} else if(mod >= 26) {
					return "Red Tape";
				} else if(mod >= 23) {
					return "Preventative Policy";
				} else if(mod >= 21) {
					return "Support the People";
				} else if(mod >= 14) {
					return "Investigative Committee";
				} else {
					return "Consolidate Power";
				}
				case 1:
					if(mod === 34) {
						return "Change of Plans";
					} else if(mod >= 32) {
						return "Restore Order";
					} else if(mod >= 30) {
						return "All Hands on Deck";
					} else if(mod === 29) {
						return "State of Emergency";
					} else if(mod >= 26) {
						return "Iron Will";
					} else if(mod >= 23) {
						return "At Any Cost";
					} else if(mod >= 21) {
						return "Major Victory";
					} else if(mod >= 14) {
						return "Declare Emergency";
					} else {
						return "Executive Order";
					}
					case 2:
						if(mod === 34) {
							return "A Second Chance";
						} else if(mod >= 32) {
							return "Unorthodox Plan";
						} else if(mod >= 30) {
							return "Quick Thinking";
						} else if(mod === 29) {
							return "Scout for Fuel";
						} else if(mod >= 26) {
							return "Trust Instincts";
						} else if(mod >= 23) {
							return "Critical Situation";
						} else if(mod >= 21) {
							return "Guts and Initiative";
						} else if(mod >= 14) {
							return "Strategic Planning";
						} else {
							return "Launch Scout";
						}
						case 3:
							if(mod === 34) {
								return "Launch Reserves";
							} else if(mod >= 32) {
								return "Combat Veteran";
							} else if(mod >= 30) {
								return "Dogfight";
							} else if(mod === 29) {
								return "Best of the Best";
							} else if(mod >= 26) {
								return "Protect the Fleet";
							} else if(mod >= 23) {
								return "Run Interference";
							} else if(mod >= 21) {
								return "Full Throttle";
							} else if(mod >= 14) {
								return "Maximum Firepower";
							} else {
								return "Evasive Maneuvers";
							}
							case 4:
								if(mod === 34) {
									return "Test the Limits";
								} else if(mod >= 32) {
									return "Raptor Specialist";
								} else if(mod >= 30) {
									return "Install Upgrades";
								} else if(mod === 29) {
									return "Build Nuke";
								} else if(mod >= 26) {
									return "Establish Network";
								} else if(mod >= 23) {
									return "Calculations";
								} else if(mod >= 21) {
									return "Jury Rigged";
								} else if(mod >= 14) {
									return "Scientific Research";
								} else {
									return "Repair";
								}
								default:
									return "No such card.";
	}
}

function cardText(id) {
	return colorText(cardColor(id), cardValue(id) + " - " + cardName(id));
}

function reshuffleSkillCardDeck(colorID) {
	if(z.skillCardDecks[colorID].length === 0) {
		z.skillCardDecks[colorID] = z.skillCardDiscards[colorID];
		shuffle(z.skillCardDecks[colorID]);
		t.value += colorIDName(colorID) + " deck empty; reshuffling.\r\n";
		z.skillCardDiscards[colorID] = [];
	}
}

function drawFromDeck(colorID) {
	let card = z.skillCardDecks[colorID].pop();
	reshuffleSkillCardDeck(colorID); /* will return undefined if empty */
	return card;
}

function buildDestiny() {
	t.value += "Destiny rebuilt.\r\n";
	if(z.destiny.length !== 0) {
		addAlert("Cannot rebuild Destiny; Destiny not empty.");
		return 0;
	}
	for(let colorID = 0; !(colorID >= z.skillCardDecks.length); colorID++) {
		for(let i = 2; i > 0; i--) {
			let card = drawFromDeck(colorID);
			if(card !== undefined) {
				z.destiny.push(card);
			} else {
				t.value += "Note: there are no cards in the " + colorIDName(colorID) + " deck or its discards; Destiny now has fewer cards than usual.\r\n";
			}
		}
	}
	shuffle(z.destiny);
}

function onGalactica(location) {
	return (location === "Brig" || location === "Sickbay" || location === "FTL Control" || location === "Weapons Control" || location === "Communications" ||
		location === "Research Lab" || location === "Command" || location === "Admiral's Quarters" || location === "Hangar Deck" || location === "Armory");
}

function isOnGalactica(player) {
	return onGalactica(z.playerLocations[player]);
}

function onNewCaprica(playerLocation) {
	return (playerLocation === "Detention" || playerLocation === "Medical Center" || playerLocation === "Resistance HQ" || playerLocation ===
		"Occupation Authority" || playerLocation === "Breeder's Canyon" || playerLocation === "Shipyard");
}

function onPegasus(l) {
	return (l === "Pegasus CIC" || l === "Airlock" || l === "Main Batteries" || l === "Engine Room");
}

function onCylonLocations(l) {
	return (l === "Resurrection Ship" || l === "Hub Destroyed" || l === "Human Fleet" || l === "Cylon Fleet" || l === "Caprica" || l === "Basestar Bridge");
}

function onColonialOne(l) {
	return (l === "Administration" || l === "President's Office" || l === "Press Room" || l === "Quorum Chamber");
}

function onDemetrius(l) {
	return (l === "Tactical Plot" || l === "Captain's Cabin" || l === "Bridge");
}

function onRebelBasestar(l) {
	return (l === "Datastream" || l === "Raider Bay" || l === "Hybrid Tank");
}

function inSpace(loc) {
	return loc === "Sector 1" || loc === "Sector 2" || loc === "Sector 3" || loc === "Sector 4" || loc === "Sector 5" || loc === "Sector 6";
}

function isInSpace(player) {
	return inSpace(z.playerLocations[player]);
}

function canAttackRaider(manned) {
	if(manned) {
		let sector = parseInt(z.playerLocations[me].slice(7));
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] === sector) {
				return true;
			}
		}
		return false;
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
			for(let k = 0; !(k >= z.raiders.length); k++) {
				if(z.raiders[k] === z.vipersII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
			for(let k = 0; !(k >= z.raiders.length); k++) {
				if(z.raiders[k] === z.vipersVII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
			for(let k = 0; !(k >= z.raiders.length); k++) {
				if(z.raiders[k] === z.assaultRaptors[j]) {
					return true;
				}
			}
		}
	}
	return false;
}

function canAttackHeavy(manned) {
	if(manned) {
		let sector = parseInt(z.playerLocations[me].slice(7));
		for(let j = 0; !(j >= z.heavies.length); j++) {
			if(z.heavies[j] === sector) {
				return true;
			}
		}
		return false;
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
			for(let k = 0; !(k >= z.heavies.length); k++) {
				if(z.heavies[k] === z.vipersII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
			for(let k = 0; !(k >= z.heavies.length); k++) {
				if(z.heavies[k] === z.vipersVII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
			for(let k = 0; !(k >= z.heavies.length); k++) {
				if(z.heavies[k] === z.assaultRaptors[j]) {
					return true;
				}
			}
		}
	}
	return false;
}

function canAttackScar(manned) {
	if(!z.scarCAC) {
		return false;
	}
	if(manned) {
		let sector = parseInt(z.playerLocations[me].slice(7));
		return z.scar === sector;
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
			if(z.vipersII[j] === z.scar) {
				return true;
			}
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
			if(z.assaultRaptors[j] === z.scar) {
				return true;
			}
		}
	}
	return false;
}

function canAttackBasestar(manned) {
	if(manned) {
		let sector = parseInt(z.playerLocations[me].slice(7));
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(z.basestars[j][0] === sector) {
				return true;
			}
		}
		return false;
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
			for(let k = 0; !(k >= z.basestars.length); k++) {
				if(z.basestars[k][0] === z.vipersII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
			for(let k = 0; !(k >= z.basestars.length); k++) {
				if(z.basestars[k][0] === z.vipersVII[j]) {
					return true;
				}
			}
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
			for(let k = 0; !(k >= z.basestars.length); k++) {
				if(z.basestars[k][0] === z.assaultRaptors[j]) {
					return true;
				}
			}
		}
	}
	return false;
}

function canEscort(manned) {
	if(manned) {
		let sector = parseInt(z.playerLocations[me].slice(7));
		return z.spaceCivilians[sector - 1].length > 0;
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
			if(z.spaceCivilians[z.vipersII[j] - 1].length > 0) {
				return true;
			}
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
			if(z.spaceCivilians[z.vipersVII[j] - 1].length > 0) {
				return true;
			}
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
			if(z.spaceCivilians[z.assaultRaptors[j] - 1].length > 0) {
				return true;
			}
		}
	}
	return false;
}

function isOnNewCaprica(player) {
	return onNewCaprica(z.playerLocations[player]);
}

function ship(l) {
	if(onGalactica(l)) {
		return "Galactica";
	}
	if(onPegasus(l)) {
		return "Pegasus";
	}
	if(onDemetrius(l)) {
		return "Demetrius";
	}
	if(onRebelBasestar(l)) {
		return "Rebel Basestar";
	}
	if(onColonialOne(l)) {
		return "Colonial One";
	}
	if(onNewCaprica(l)) {
		return "New Caprica";
	}
	if(inSpace(l)) {
		return "Space";
	}
	if(onCylonLocations(l)) {
		return "Cylon Locations";
	}
	return "NONE";
}

function decreaseFood() {
	if(z.food === 0) {
		t.value += "Food is already at 0, and cannot decrease further.\r\n";
		addAlert("Food is already at 0.");
	} else if(z.preventative === "Food") {
		t.value += "Food loss is prevented by " + colorText("orange", "Preventative Policy") + ".\r\n";
		addAlert("Food loss prevented by Preventative Policy.");
		z.preventative = null;
	} else {
		z.food--;
		t.value += bold("Food drops to ");
		addAlert("Food drops to " + z.food + ".");
		if(z.food > 4) {
			t.value += bold(z.food + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.food) + ".") + "\r\n";
		}
		if(z.vBrutality && !z.unconventionalTactics && characterPresent("Zarek") && z.players[z.turn] === "Zarek" && z.currentCrisis !== null && !z
			.capricaCrisis && !z.aggressiveTacticsSkip && z.population > 0) {
			plainAlert("Zarek may be able to use Unconventional Tactics to replace this with a loss of 1 Population.");
			if(hasContext(me, "Unconventional Tactics", "Morale")) {
				addOption(getPlayerNum("Zarek"), "Unconventional Tactics", "Both", false);
			} else {
				addOption(getPlayerNum("Zarek"), "Unconventional Tactics", "Food", false);
			}
		}
	}
}

function increaseFood() {
	if(z.food === 15) {
		t.value += "Food is already at 15, and cannot increase further.\r\n";
		addAlert("Cannot increase Food beyond 15.");
	} else {
		z.food++;
		t.value += bold("Food increases to ");
		addAlert("Food increases to " + z.food + ".");
		if(z.food > 4) {
			t.value += bold(z.food + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.food) + ".") + "\r\n";
		}
	}
}

function hasVariableDraw(player) {
	if(z.revealedCylons[player] === 1 || isCylonLeader(z.players[player]) || player === z.theSympatheticCylon) {
		return true;
	}
	if(z.playerLocations[player] === "Sickbay" || z.playerLocations[player] === "Medical Center") {
		return true;
	}
	if(z.players[player] === "Karl" && !isOnGalactica(player) && !z.vBrutality && !noDrawback(player)) {
		return true;
	}
	if(z.players[player] === "Adama" && z.vBrutality && versionAtLeast([2, 0, 1])) {
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(isOnNewCaprica(player)) {
				if(z.playerLocations[j] === "Detention") {
					return true;
				}
			} else if(z.playerLocations[j] === "Brig") {
				return true;
			}
		}
	}
	switch (z.players[player]) {
		case "Apollo":
		case "Starbuck":
		case "Cain":
		case "Anders":
		case "Gaeta":
		case "Lee":
		case "Racetrack":
		case "Seelix":
			return true;
	}
	if(versionAtLeast([2,1,13]) && z.players[player] === "Shaw"){
		return true;
	}
	return false;
}

function decreaseFuel() {
	if(z.fuel === 0) {
		t.value += "Fuel is already at 0, and cannot decrease further.\r\n";
		addAlert("Fuel is already at 0.");
	} else if(z.preventative === "Fuel") {
		t.value += "Fuel loss is prevented by " + colorText("orange", "Preventative Policy") + ".\r\n";
		addAlert("Fuel loss prevented by Preventative Policy.");
		z.preventative = null;
	} else {
		z.fuel--;
		t.value += bold("Fuel drops to ");
		addAlert("Fuel drops to " + z.fuel + ".");
		if(z.fuel > 4) {
			t.value += bold(z.fuel + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.fuel) + ".") + "\r\n";
		}
	}
}

function increaseFuel() {
	if(z.fuel === 15) {
		t.value += "Fuel is already at 15, and cannot increase further.\r\n";
		addAlert("Cannot increase Fuel beyond 15.");
	} else {
		z.fuel++;
		t.value += bold("Fuel increases to ");
		addAlert("Fuel increases to " + z.fuel + ".");
		if(z.fuel > 4) {
			t.value += bold(z.fuel + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.fuel) + ".") + "\r\n";
		}
	}
}

function decreaseMorale() {
	let midExecution = arguments.length > 0;
	if(z.morale === 0) {
		t.value += "Morale is already at 0, and cannot decrease further.\r\n";
		addAlert("Morale is already at 0.");
		return true;
	} else if(z.preventative === "Morale") {
		t.value += "Morale loss is prevented by " + colorText("orange", "Preventative Policy") + ".\r\n";
		addAlert("Morale loss prevented by Preventative Policy.");
		z.preventative = null;
		return true;
	} else {
		z.morale--;
		t.value += bold("Morale drops to ");
		addAlert("Morale drops to " + z.morale + ".");
		if(z.morale > 5) {
			t.value += bold(z.morale + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.morale) + ".") + "\r\n";
		}
		if(2 >= z.morale && characterPresent("Dee") && !noDrawback(getPlayerNum("Dee"))) {
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.players[j] === "Dee" && z.revealedCylons[j] === 0) {
					t.value += bold("Dee is Emotionally Fragile.") + "\r\n";
					if(midExecution) {
						addAlert("Dee is Emotionally Fragile!  Execute Dee once the current execution resolves.");
						t.value += "Once this execution resolves, execute Dee.\r\n";
						optionForAll("Execute a player", "Dee", false);
					} else if(z.vBrutality && characterPresent("Zarek") && z.players[z.turn] === "Zarek" && z.currentCrisis !== null && !z.capricaCrisis && !z
						.aggressiveTacticsSkip && z.population > 0) {
						plainAlert("If Zarek does not use his Unconventional Tactics ability here, execute Dee from her Emotionally Fragile drawback.");
						optionForAll("Execute a player", "Dee", false);
					} else {
						executePlayer(j);
					}
					return false;
				}
			}
		}
		if(z.vBrutality && characterPresent("Zarek") && !z.unconventionalTactics && z.players[z.turn] === "Zarek" && z.currentCrisis !== null && !z
			.capricaCrisis && !z.aggressiveTacticsSkip && z.population > 0) {
			plainAlert("Zarek may be able to use Unconventional Tactics to replace this with a loss of 1 Population.");
			if(hasContext(me, "Unconventional Tactics", "Food")) {
				addOption(getPlayerNum("Zarek"), "Unconventional Tactics", "Both", false);
			} else {
				addOption(getPlayerNum("Zarek"), "Unconventional Tactics", "Morale", false);
			}
		}
		return true;
	}
}

function increaseMorale() {
	if(z.morale === 15) {
		t.value += "Morale is already at 15, and cannot increase further.\r\n";
		addAlert("Morale cannot increase beyond 15.");
	} else {
		z.morale++;
		t.value += bold("Morale increases to ");
		addAlert("Morale increases to " + z.morale + ".");
		if(z.morale > 5) {
			t.value += bold(z.morale + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.morale) + ".") + "\r\n";
		}
	}
} /* TODO: think about multiple contexts (should be rare) */
function addOption(player, opt, con, man) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt) {
			z.context[player][j] = con;
			z.mandatory[player][j] = man;
			return false;
		}
	}
	z.crisisOptions[player].push(opt);
	z.context[player].push(con);
	z.mandatory[player].push(man);
}

function removeOption(player, opt) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt) {
			z.crisisOptions[player].splice(j, 1);
			z.context[player].splice(j, 1);
			z.mandatory[player].splice(j, 1);
			j--;
		}
	}
}

function hasOption(player, opt) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt) {
			return true;
		}
	}
	return false;
}

function hasContext(player, opt, con) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt && z.context[player][j] === con) {
			return true;
		}
	}
	return false;
}

function getContext(player, opt) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt) {
			return z.context[player][j];
		}
	}
	return undefined;
}

function isMandatory(player, opt) {
	for(let j = 0; !(j >= z.crisisOptions[player].length); j++) {
		if(z.crisisOptions[player][j] === opt) {
			return z.mandatory[player][j];
		}
	}
	return false;
}

function anyMandatory() {
	let mandatories = [];
	for(let j = 0; !(j >= z.numPlayers); j++) {
		for(let k = 0; !(k >= z.crisisOptions[j].length); k++) {
			if(z.mandatory[j][k]) {
				mandatories.push([j, z.crisisOptions[j][k]]);
			}
		}
	}
	return mandatories;
}

function mementoAvailable() {
	if(!characterPresent("Hot Dog")) {
		return false;
	}
	return hasOption(getPlayerNum("Hot Dog"), "Memento (OPT)");
}

function decreasePopulation() {
	if(z.population === 0) {
		t.value += "Population is already at 0, and cannot decrease further.\r\n";
		addAlert("Population is already at 0.");
		return true;
	} else if(z.preventative === "Population") {
		t.value += "Population loss is prevented by " + colorText("orange", "Preventative Policy") + ".\r\n";
		addAlert("Population loss prevented by Preventative Policy.");
		z.preventative = null;
		return true;
	} else {
		z.population--;
		t.value += bold("Population drops to ");
		addAlert("Population drops to " + z.population + ".");
		if(z.population > 6) {
			t.value += bold(z.population + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.population) + ".") + "\r\n";
		}
		if(characterPresent("Hot Dog") && !mementoAvailable() && !z.mementoUsed && !z.endGame) {
			boldAlert("Hot Dog's Memento ability triggers.");
			addOption(getPlayerNum("Hot Dog"), "Memento (OPT)", false);
			return false;
		}
		return true;
	}
}

function increasePopulation() {
	if(z.population === 15) {
		t.value += "Population is already at 15, and cannot increase further.\r\n";
		addAlert("Cannot increase Population above 15.");
	} else {
		z.population++;
		t.value += bold("Population increases to ");
		addAlert("Population increases to " + z.population + ".");
		if(z.population > 6) {
			t.value += bold(z.population + ".") + "\r\n";
		} else {
			t.value += bold(colorText("red", z.population) + ".") + "\r\n";
		}
	}
}

function isGalacticaDestroyed() {
	let damagedCount = 0;
	for(let i = 0; !(i >= z.damagedLocations.length); i++) {
		let loc = z.damagedLocations[i ];
		if(loc === "FTL Control" || loc === "Weapons Control" || loc === "Command" || loc === "Admiral's Quarters" || loc === "Hangar Deck" || loc ===
			"Armory") {
			damagedCount++;
		}
	}
	return damagedCount === 6;
}

function isPegasusDestroyed() {
	let damagedCount = 0;
	for(let i = 0; !(i >= z.damagedLocations.length); i++) {
		let loc = z.damagedLocations[i ];
		if(loc === "Pegasus CIC" || loc === "Airlock" || loc === "Main Batteries" || loc === "Engine Room") {
			damagedCount++;
		}
	}
	return damagedCount === 4 && !z.pegasusDestroyed;
}

function anyUndamagedBasestars() {
	for(let j = 0; !(j >= z.basestars.length); j++) {
		if(z.basestars[j][0] > 0 && z.basestars[j].length === 1) {
			return true;
		}
	}
	return false;
}

function primeJumpIcon() {
	if(z.currentCrisis !== null) {
		z.toDoRaiders = false;
		z.toDoHeavies = false;
		z.toDoLaunchRaiders = false;
		z.toDoBasestars = false;
		if(!z.aggressiveTacticsSkip && (z.establishSanitation || (z.vBrutality && !versionAtLeast([2, 0, 1]) && z.players[z.turn] === "Cain" && !z
				.capricaCrisis && z.revealedCylons[z.turn] === 0 && anyUndamagedBasestars()))) {
			addAlert("The Prepare for Jump step of this turn is skipped.");
			t.value += "Skipping the Prepare for Jump step of this turn.\r\n";
			z.establishSanitation = false;
			if(!z.capricaCrisis && characterPresent("Boomer") && z.players[z.turn] === "Boomer"){
				plainAlert("Boomer may now do her Recon.");
			}
		} else if((z.aggressiveTacticsSkip || d.jumpIcon[z.currentCrisis] === 1 || (!isSuperCrisis(z.currentCrisis) && z.engineRoom && !z.vBrutalityPlus)) && (!z.executedCurrentPlayer || z.capricaCrisis)) {
			if(!z.capricaCrisis || z.pegasus || z.exodus || z.daybreak) {
				z.toDoJumpIcon = true;
				if(z.engineRoom && !isSuperCrisis(z.currentCrisis)) {
					addAlert("Remember that the Engine Room gives this Crisis a Jump Prep icon.");
					z.engineRoom = false;
				}
			}
			if(z.jumpTrack === 4 && !z.galacticaAway && z.toDoJumpIcon && !z.capricaCrisis && z.turn === z.theMutineer && !z.aggressiveTacticsSkip) {
				plainAlert("Mutineer " + z.players[z.turn] +
					" must draw a Mutiny during their Prepare for Jump step.  They may choose to do so before or after the Fleet jumps.");
				addOption(z.turn, "Draw a Mutiny card", undefined, true);
			}
			if(z.galacticaReturned && z.toDoJumpIcon && !z.capricaCrisis && z.turn === z.theMutineer && !z.aggressiveTacticsSkip) {
				addAlert("The Mutineer draws a Mutiny card.");
				t.value += bold("The Mutineer automatically draws a Mutiny card.") + "\r\n";
				dealMutiny(z.theMutineer, false);
			}
			if(z.galacticaReturned && d.jumpIcon[z.currentCrisis] === 0 && z.toDoJumpIcon) {
				addAlert("Prepare for Jump Icons have no effect once Galactica has returned.");
				z.toDoJumpIcon = false;
				if(characterPresent("Boomer") && z.players[z.turn] === "Boomer" && !z.capricaCrisis){
					plainAlert("Boomer may now do her Recon.");
				}
			}
			if(z.galacticaReturned && z.toDoJumpIcon && z.preparedCivilians.length === 0) {
				addAlert("There are no Civilians to evacuate.");
				z.toDoJumpIcon = false;
				if(characterPresent("Boomer") && z.players[z.turn] === "Boomer" && !z.capricaCrisis){
					plainAlert("Boomer may now do her Recon.");
				}
			}
		} else if(d.CAC[z.currentCrisis] !== 1 && z.players[z.turn] === "Boomer" && !z.capricaCrisis && characterPresent("Boomer") && !z.executedCurrentPlayer){
			plainAlert("Boomer may now do her Recon.");
		}
		if(d.CAC[z.currentCrisis] === 1) {
			z.toDoCACSetup = true;
		}
	}
}

function unbuiltARs() {
	let c = 0;
	for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
		if(z.assaultRaptors[j] === -3) {
			c++;
		}
	}
	return c;
}

function revealAssistLoyalty() {
	let revealed = z.assistLoyalty.pop();
	boldAlert(z.assist + " reveals " + d.loyaltyNames[revealed] + ".");
	if(revealed === 11 || revealed === 12 || revealed === 13 || revealed === 14 || revealed === 18 || revealed === 37 || revealed === 38) {
		if(revealed === 11) {
			if(ship(z.playerLocations[me]) === "Galactica") {
				addAlert("You are moved to Sickbay and must discard 5 skill cards.");
				movePlayer(me, "Sickbay");
				addOption(me, "Discard a Skill Card", 5, true);
			} else {
				plainAlert(z.players[me] + " is not on Galactica; no effect.");
			}
		} else if(revealed === 12) {
			if(ship(z.playerLocations[me]) === "Galactica") {
				addAlert("You are moved to the Brig!");
				movePlayer(me, "Brig");
			} else {
				plainAlert(z.players[me] + " is not on Galactica; no effect.");
			}
		} else if(revealed === 13) {
			decreaseMorale();
		} else if(revealed === 14) {
			damageGalactica();
			damageGalactica();
		} else if(revealed === 18) {
			discardRandomSkillCard(me);
			addAlert("You must draw 1 Treachery card.");
			addOption(me, "Draw 1 Treachery", undefined, true);
		} else if(revealed === 37) {
			boardGalactica();
		} else if(revealed === 38) {
			decreaseJump();
			decreaseJump();
		}
		if(z.personalGoals) {
			z.loyaltyHands[me] = z.assistLoyalty;
		}
		boldAlert(z.assist + " is no longer in play.");
		z.graveyard.push(z.assist);
		z.assistLoyalty = undefined;
		z.assist = undefined;
		z.assistMiracle = undefined;
	}
	if(revealed >= 24 && 31 >= revealed && 7 > z.distance) {
		plainAlert("The Loyalty deck gets another Loyalty card, then " + z.assist + " draws a new Loyalty card and reveals another one.");
		if(z.notCylonDeck.length > 0){
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			shuffle(z.loyaltyDeck);
		}
		if(z.loyaltyDeck.length > 0){
			z.assistLoyalty.push(z.loyaltyDeck.pop());
			shuffle(z.assistLoyalty);
		}
		if(z.assistLoyalty.length > 0){
			revealAssistLoyalty();
		}
	} else {
		plainAlert("No effect.");
	}
}

function primeCylonActivation() {
	/* RULES: OF activation during negotiation */
	let act = d.activation[z.currentCrisis];
	if(z.negotiation) {
		plainAlert("Negotiation prevents Cylon Ship activations this turn.");
		if(act === "R/O" || act === "H/O" || act === "B/O") {
			z.toDoOFs = true;
			addAlert("You must still activate Occupation Forces, however.");
			t.value += "It does not prevent the Occupation Force activation, however.\r\n";
			return undefined;
		}
		primeJumpIcon();
	} else if(d.CAC[z.currentCrisis] === 1 || (!z.capricaCrisis && !z.executedCurrentPlayer)) {
		switch (act) {
			case "R":
				z.toDoRaiders = !z.galacticaAway;
				addAlert("Cylon Ship Activation is: Raiders");
				break;
			case "H":
				z.toDoHeavies = !z.galacticaAway;
				if(z.assist !== undefined) {
					/* TODO: have this happen when they actually activate? */
					revealAssistLoyalty();
				}
				addAlert("Cylon Ship Activation is: Heavy Raiders");
				break;
			case "L":
				z.toDoLaunchRaiders = !z.galacticaAway;
				addAlert("Cylon Ship Activation is: Launch Raiders");
				break;
			case "B":
				z.toDoBasestars = !z.galacticaAway;
				addAlert("Cylon Ship Activation is: Basestars");
				break;
			case "R/O":
				z.toDoRaiders = !z.galacticaAway;
				z.toDoOFs = true;
				addAlert("Cylon Ship Activation is: Raiders + Occupation Forces");
				break;
			case "H/O":
				z.toDoHeavies = !z.galacticaAway;
				z.toDoOFs = true;
				if(z.assist !== undefined) {
					revealAssistLoyalty();
				}
				addAlert("Cylon Ship Activation is: Heavy Raiders + Occupation Forces");
				break;
			case "B/O":
				z.toDoBasestars = !z.galacticaAway;
				z.toDoOFs = true;
				addAlert("Cylon Ship Activation is: Basestars + Occupation Forces");
				break;
		}
		if(!z.toDoRaiders && !z.toDoHeavies && !z.toDoLaunchRaiders && !z.toDoBasestars && !z.toDoOFs) {
			primeJumpIcon();
		}
	} else {
		primeJumpIcon();
	}
}

function dealSkillCard(player, colorID) {
	if(z.skillCardDecks[colorID].length > 0) {
		t.value += bold(z.players[player] + " draws a " + colorIDName(colorID) + " card.") + "\r\n";
		let card = drawFromDeck(colorID);
		z.possibleColors[player][colorID] = 1;
		z.skillCardHands[player].push(card);
		return card;
	} else {
		t.value += z.players[player] + " attempted to draw a " + colorIDName(colorID) + " card, but could not as that deck and its discards are depleted.\r\n";
		addAlert("Completely out of " + colorIDName(colorID) + "; its deck and discards are depleted.");
		return undefined;
	}
}

function dealSkillCardToEveryone(startingPlayer, colorID, cylons) {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		let k = (j + startingPlayer) % z.numPlayers;
		if(cylons || z.revealedCylons[k] === 0) {
			let card = dealSkillCard(k, colorID);
			if(k === me) {
				addAlert("You receive " + cardText(card) + ".");
			}
		}
	}
}

function dealQuorumCard(billy) {
	if(z.quorumDeck.length === 0) {
		t.value += "You have completely exhausted the Quorum deck and its discards and cannot draw more Quorums.\r\n";
		return undefined;
	}
	let card = z.quorumDeck.pop();
	if(z.quorumDeck.length === 0) {
		let resignation = Number.isInteger(getContext(me, "Draw a Quorum Card"));
		z.quorumDeck = z.quorumDiscards;
		shuffle(z.quorumDeck);
		t.value += "Quorum deck empty; reshuffling.\r\n";
		z.quorumDiscards = [];
		if(resignation) {
			for(let j = 0; !(j >= z.quorumDeck.length); j++) {
				if(z.quorumDeck[j] === 28) {
					z.quorumDeck.splice(j, 1);
					z.quorumDiscards = [28];
					plainAlert("Resignation is not included in the reshuffle.");
					break;
				}
			}
		}
	}
	if(!billy || z.president === getPlayerNum("Billy")) {
		z.quorumHand.push(card);
		if(me === z.president) {
			addAlert("You drew " + d.quorumNames[card] + ".");
		}
		t.value += "President " + z.players[z.president] + " draws a Quorum card.\r\n";
	} else {
		z.billyHand.push(card);
		if(z.players[me] === "Billy") {
			addAlert("You drew " + d.quorumNames[card] + ".");
		}
		t.value += "Billy draws a Quorum card to his hand.\r\n";
	}
	return card;
}

function discardQuorumCard(pos, peek) {
	if(peek === "Peek") {
		let card = z.quorumPeek.splice(pos, 1)[0];
		z.quorumDiscards.push(card);
		t.value += myPlayer + " discards " + d.quorumNames[card] + ".\r\n";
	} else if(peek === "Billy") {
		let card = z.billyHand.splice(pos, 1)[0];
		z.quorumDiscards.push(card);
		t.value += myPlayer + " discards " + d.quorumNames[card] + ".\r\n";
	} else {
		let card = z.quorumHand.splice(pos, 1)[0];
		z.quorumDiscards.push(card);
		t.value += "President " + z.players[z.president] + " discards " + d.quorumNames[card] + ".\r\n";
	}
}

function someoneCouldSabotage() {
	if(z.daybreak || !z.pegasus) {
		return false;
	}
	if(z.galacticaAway) {
		return false;
	}
	if(z.sabotage) {
		return false;
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.revealedCylons[j] === 1 && z.possibleColors[j][5] === 1) {
			return true;
		}
	}
	return false;
}

function discardSkillCard(player, pos) {
	if(!(pos >= 0) || pos >= z.skillCardHands[player].length) {
		error("Cannot discard a card you do not have in hand!");
		return false;
	}
	let card = z.skillCardHands[player].splice(pos, 1)[0];
	z.skillCardDiscards[cardColorID(card)].push(card);
	reshuffleSkillCardDeck(cardColorID(card));
	t.value += bold(z.players[player] + " discards " + cardText(card)) + ".\r\n";
	if(z.skillCardHands[player].length === 0) {
		z.possibleColors[player] = [0, 0, 0, 0, 0];
		if(z.pegasus || z.daybreak) {
			z.possibleColors[player].push(0);
		}
	}
	if(cardColorID(card) === 5 && z.revealedCylons[player] === 0) {
		z.treacheryDiscarded = true;
		if(!z.sabotageAnnounced && someoneCouldSabotage()) {
			plainAlert("A revealed Cylon could use " + colorText("brown", "Sabotage") + " now.");
			z.sabotageAnnounced = true;
		}
	}
	if(z.dradisBait[player] && (cardName(card) === "Bait" || cardName(card) === "Dradis Contact") && z.revealedCylons[player] === 0) {
		z.dradisBait[player] = false;
		return dealMutiny(player, false);
	}
	return true;
} /* Returns the card id discarded. */
function discardRandomSkillCard(player) {
	if(z.skillCardHands[player].length > 0) {
		let rando = Math.floor((z.seed * z.skillCardHands[player].length) / mLCG);
		updateSeed();
		let card = z.skillCardHands[player].splice(rando, 1)[0];
		z.skillCardDiscards[cardColorID(card)].push(card);
		reshuffleSkillCardDeck(cardColorID(card));
		t.value += z.players[player] + " discards " + cardText(card) + " randomly.\r\n";
		if(z.skillCardHands[player].length === 0) {
			z.possibleColors[player] = [0, 0, 0, 0, 0];
			if(z.pegasus || z.daybreak) {
				z.possibleColors[player].push(0);
			}
		}
		if(cardColorID(card) === 5 && z.revealedCylons[player] === 0) {
			z.treacheryDiscarded = true;
			if(!z.sabotageAnnounced && someoneCouldSabotage()) {
				plainAlert("A revealed Cylon could use " + colorText("brown", "Sabotage") + " now.");
				z.sabotageAnnounced = true;
			}
		}
		return card;
	} else {
		t.value += "ERROR: " + z.players[player] + " has no skill cards to discard, randomly or otherwise.\r\n";
		return -1;
	}
}

function playSkillCard(player, pos, output) {
	if(!(pos >= 0) || pos >= z.skillCardHands[player].length) {
		error("Cannot play a card you do not have in hand!");
		return 0;
	}
	let card = z.skillCardHands[player].splice(pos, 1)[0];
	checkEmptyColors(player);
	z.skillCardDiscards[cardColorID(card)].push(card);
	reshuffleSkillCardDeck(cardColorID(card));
	if(output) {
		t.value += bold(z.players[player] + " plays " + cardText(card)) + ".\r\n";
	}
}

function optionForAll(opt, context, man) {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		addOption(j, opt, context, man);
	}
}

function removeFromAll(opt) {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		removeOption(j, opt);
	}
}

function isCylonLeader(x) {
	/* Note: does not include Sympathetic Cylon */
	return (x === "Cavil" || x === "Leoben" || x === "Six" || x === "Doral" || x === "Simon" || x === "Athena" || x === "D'Anna");
}

function isTheCylonLeader(n){
	return isCylonLeader(z.players[n]);
}

function hasRevealableMotive() {
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		switch (z.loyaltyHands[me][j]) {
			case 53:
			case 54:
			case 60:
			case 61:
				return true;
		}
	}
	return false;
}

function hasActuallyRevealableMotive() {
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		switch (z.loyaltyHands[me][j]) {
			case 53:
				for(let j = 0; !(j >= z.damagedLocations.length); j++) {
					if(z.damagedLocations[j] === "FTL Control" || z.damagedLocations[j] === "Admiral's Quarters") {
						return true;
					}
				}
				break;
			case 54:
				for(let j = 0; (!z.daybreak || z.mutinies[me].length > 0) && !(j >= z.numPlayers); j++) {
					if((z.playerLocations[j] === "Brig" && j !== me && !isOnNewCaprica(me)) || (z.playerLocations[j] === "Detention" && j !== me &&
							isOnNewCaprica(me))) {
						return true;
					}
				}
				break;
			case 60:
				if((z.jumpTrack === 3 || z.jumpTrack === 4) && raidersAway() === z.raiders.length && heaviesAway() === z.heavies.length && basestarsAway() === z.basestars.length) {
					return true;
				}
				break;
			case 61:
				if(z.distance >= 5 && centurionReserves() === z.centurions.length) {
					return true;
				}
				break;
		}
	}
	return false;
}

function getCharacter(name) {
	for(let i = 0; !(i >= d.characters.length); i++) {
		if(d.characters[i ] === name) {
			return i;
		}
	}
	return -1;
}

function prophetInPlay() {
	let prophet = -1;
	for(let i = 0; z.president >= 0 && !(i >= z.quorumTitles[z.president].length); i++) {
		if(z.quorumTitles[z.president][i ] === 0) {
			prophet = i;
		}
	}
	return prophet;
}

function movePresident(player) {
	let oldPresident = z.president;
	let prophet = prophetInPlay();
	if(prophet >= 0) {
		z.quorumTitles[z.president].splice(prophet, 1);
		z.quorumTitles[player].push(0);
	}
	z.president = player;
	boldAlert(z.players[z.president] + " is now the President.");
	if(z.players[z.president] === "Billy") {
		if(z.billyHand.length > 0) {
			plainAlert("Billy adds his Quorum cards to his Presidential Quorum hand.");
		}
		while(z.billyHand.length > 0) {
			z.quorumHand.push(z.billyHand.pop());
		}
	}
	shuffle(z.quorumHand);
	if(prophet !== -1) {
		t.value += "Accept Prophecy has been passed to the new President.\r\n";
	}
	if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && player !== getPlayerNum("Zarek") && (!
			versionAtLeast([2, 0, 1]) || oldPresident !== getPlayerNum("Zarek"))) {
		
		if(versionAtLeast([2,2,25])){
			z.friendsPresident = true;
			plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert(
				"Zarek could use his OPG, Friends in Low Places, to take the title instead; you may want to wait for him to weigh in before looking at the Quorum hand."
				);
			if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "President", false);
			}
		}
	}
	if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" && !z.gameSetup && (!versionAtLeast([
			2, 0, 1
		]) || oldPresident !== getPlayerNum("Gaius"))) {
			
		if(versionAtLeast([2,2,25])){
			z.cultPresident = true;
			plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert(
				"Gaius could use Zarek's OPG, Friends in Low Places, to take the title instead; you may want to wait for him to weigh in before looking at the Quorum hand."
				);
			if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "President", false);
			}
		}
	}
} /* Takes old rank */
function passPresident(old) {
	let best = 99;
	let candidate = -1;
	for(let i = 0; !(i >= z.numPlayers); i++) {
		let rank = d.presidentSuccession[getCharacter(z.players[i ])];
		if(!(rank >= best) && z.revealedCylons[i ] === 0 && rank !== old) {
			candidate = i;
			best = rank;
		}
	}
	if(candidate === -1) {
		candidate = z.president;
	}
	movePresident(candidate);
}

function passAdmiral(old) {
	let oldAdmiral = z.admiral;
	let best = 99;
	let bestBrigged = 99;
	let brigAdmiral = -1;
	for(let i = 0; !(i >= z.numPlayers); i++) {
		let character = getCharacter(z.players[i ]);
		let rank = d.admiralSuccession[character];
		if(!(rank >= best) && z.revealedCylons[i ] === 0 && rank !== old && z.playerLocations[i ] !== "Brig") {
			z.admiral = i;
			best = rank;
		}
		if(!(rank >= bestBrigged) && z.revealedCylons[i ] === 0) {
			bestBrigged = rank;
			brigAdmiral = i;
		}
	}
	if(best === 99) {
		z.admiral = brigAdmiral;
		if(bestBrigged !== old) {
			boldAlert(z.players[z.admiral] + " is now the Admiral.");
		} else {
			t.value += "All eligible humans are in the Brig; the Admiral title is not passed.\r\n";
			return;
		}
	} else {
		boldAlert(z.players[z.admiral] + " is now the Admiral.");
	} /* TODO: Zarek stealing the Admiral/CAG title while in the Brig with everyone else */
	if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !== getPlayerNum("Zarek") && z
		.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) || oldAdmiral !== getPlayerNum("Zarek"))) {
		if(versionAtLeast([2,2,25])){
			z.friendsAdmiral = true;
			plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
			if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
			}
		}
	}
	if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
			oldAdmiral !== getPlayerNum("Gaius"))) {
		if(versionAtLeast([2,2,25])){
			z.cultAdmiral = true;
			plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
			if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
			}
		}
	}
}

function passCAG(old) {
	let best = 99;
	let bestBrigged = 99;
	let brigCAG = -1;
	let oldCAG = z.cag;
	for(let i = 0; !(i >= z.numPlayers); i++) {
		let character = getCharacter(z.players[i ]);
		let rank = d.cagSuccession[character];
		if(!(rank >= best) && z.revealedCylons[i ] === 0 && rank !== old && z.playerLocations[i ] !== "Brig") {
			z.cag = i;
			best = rank;
		}
		if(!(rank >= bestBrigged) && z.revealedCylons[i ] === 0) {
			bestBrigged = rank;
			brigCAG = i;
		}
	}
	if(best === 99) {
		z.cag = brigCAG;
		if(bestBrigged !== old) {
			boldAlert(z.players[z.cag] + " is now the CAG.");
		} else {
			t.value += "All eligible humans are in the Brig; the CAG title is not passed.\r\n";
			return;
		}
	} else {
		boldAlert(z.players[z.cag] + " is now the CAG.");
	}
	if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !== getPlayerNum("Zarek") && z
		.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) || oldCAG !== getPlayerNum("Zarek"))) {
		if(versionAtLeast([2,2,25])){
			z.friendsCAG = true;
			plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert("Zarek could use his OPG, Friends in Low Places, to take the CAG title instead.");
			if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "CAG", false);
			}
		}
	}
	if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
			oldCAG !== getPlayerNum("Gaius"))) {
		if(versionAtLeast([2,2,25])){
			z.cultCAG = true;
			plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
		} else {
			plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the CAG title instead.");
			if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
			} else {
				addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "CAG", false);
			}
		}
	}
}

function someoneInBrig() {
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(z.playerLocations[i ] === "Brig") {
			return true;
		}
	}
	return false;
}

function someoneInDetention() {
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(z.playerLocations[i ] === "Detention") {
			return true;
		}
	}
	return false;
}

function canRepair() {
	if(z.galacticaAway) {
		return false;
	}
	for(let j = 0; !(j >= z.damagedLocations.length); j++) {
		if(z.damagedLocations[j] !== "Food" && z.damagedLocations[j] !== "Fuel") {
			if(z.pegasus && z.pegasusDestroyed && onPegasus(z.damagedLocations[j])) {
				continue;
			}
			return true;
		}
	}
	return false;
}

function raidersAway() {
	let count = 0;
	for(let i = 0; !(i >= z.raiders.length); i++) {
		if(!(z.raiders[i ] > 0)) {
			count++;
		}
	}
	return count;
}

function heaviesAway() {
	let count = 0;
	for(let i = 0; !(i >= z.heavies.length); i++) {
		if(!(z.heavies[i ] > 0)) {
			count++;
		}
	}
	return count;
}

function basestarsAway() {
	let count = 0;
	if(z.basestars.length > 0 && !(z.basestars[0][0] > 0)) {
		count++;
	}
	if(z.basestars.length > 1 && !(z.basestars[1][0] > 0)) {
		count++;
	}
	return count;
}

function versionAtLeast(ver) {
	for(let j = 0; !(j >= z.version.length) && !(j >= ver.length); j++) {
		if(ver[j] > z.version[j]) {
			return false;
		} else if(z.version[j] > ver[j]) {
			return true;
		}
	}
	if(ver.length > z.version.length) {
		return false;
	}
	return true;
}

function versionsAtLeast(ver1, ver2) {
	for(let j = 0; !(j >= ver1.length) && !(j >= ver2.length); j++) {
		if(ver2[j] > ver1[j]) {
			return false;
		} else if(ver1[j] > ver2[j]) {
			return true;
		}
	}
	if(ver2.length > ver1.length) {
		return false;
	}
	return true;
}

function isInfiltrator(player){
	for(let j = 0; !(j>=z.loyaltyDiscards[player].length); j++){
		if(z.loyaltyDiscards[player][j] === 68){
			return cylonCards(player) === 0;
		}
	}
	for(let j = 0; !(j>=z.loyaltyHands[player].length); j++){
		if(z.loyaltyHands[player][j] === 68){
			return cylonCards(player) === 1;
		}
	}
	return false;
}

function endGame(humansWon,noResourceCheck) {
	/* TODO: end of game report */
	z.endGame = true;
	if(z.numPlayers === 0) {
		boldAlert("All players were boxed at Ionian; everyone loses.");
		postSeed();
		clearBackground();
	}
	if(z.luredIntoATrap && humansWon) {
		let deadMenWalking = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.playerLocations[j] === "FTL Control" || z.playerLocations[j] === "Engine Room") {
				deadMenWalking.push(z.players[j]);
			}
		}
		z.luredIntoATrap = false;
		if(deadMenWalking.length > 0) {
			let alertText = "The following individuals must be executed due to Lured into a Trap:";
			t.value += "Dangerous Repairs were Necessary, after we were " + colorText("red", "Lured into a Trap") + ".\r\n";
			t.value += "The following characters gave their lives for their efforts, and their sacrifice will be remembered:\r\n";
			for(let j = 0; !(j >= deadMenWalking.length); j++) {
				t.value += bold(deadMenWalking[j]) + "\r\n";
				alertText += "\n\n" + deadMenWalking[j];
			}
			t.value += bold("Execute those characters now") + ", then return to the end game process.";
			addAlert(alertText + '\n\nExecute those characters now, then press "End Game" once the executions are fully resolved.');
			return undefined;
		} else {
			t.value += "Nobody is executed from Dangerous Repairs are Necessary [Lured into a Trap].\r\n";
		}
	}
	if(z.personalGoals && !noResourceCheck) {
		let killedDee = false;
		for(let j = 0; !killedDee && !(j >= z.numPlayers); j++) {
			let k = (z.turn + j) % z.numPlayers;
			let moraleLoss = 0;
			for(let l = 0; !(l >= z.loyaltyHands[k].length); l++) {
				if(z.revealedCylons[k] === 1) {
					continue;
				}
				switch (z.loyaltyHands[k][l]) {
					case 24:
					case 27:
						plainAlert(z.players[k] + " reveals " + d.loyaltyNames[z.loyaltyHands[k][l]]);
						z.loyaltyDiscards[k].push(z.loyaltyHands[k].splice(l, 1)[0]);
						l--;
						decreasePopulation();
						break;
					case 25:
					case 30:
						plainAlert(z.players[k] + " reveals " + d.loyaltyNames[z.loyaltyHands[k][l]]);
						z.loyaltyDiscards[k].push(z.loyaltyHands[k].splice(l, 1)[0]);
						l--;
						decreaseFuel();
						break;
					case 28:
					case 29:
						plainAlert(z.players[k] + " reveals " + d.loyaltyNames[z.loyaltyHands[k][l]]);
						z.loyaltyDiscards[k].push(z.loyaltyHands[k].splice(l, 1)[0]);
						l--;
						decreaseFood();
						break;
					case 26:
					case 31:
						plainAlert(z.players[k] + " reveals " + d.loyaltyNames[z.loyaltyHands[k][l]]);
						z.loyaltyDiscards[k].push(z.loyaltyHands[k].splice(l, 1)[0]);
						l--;
						moraleLoss++;
						break;
				}
			}
			if(moraleLoss === 1) {
				killedDee = !decreaseMorale();
			} else if(moraleLoss === 2) {
				killedDee = !decreaseMorale();
				if(!decreaseMorale()) {
					killedDee = true;
				}
			}
		}
		if(killedDee) {
			plainAlert('Once Dee\'s execution is fully resolved, select "End Game" to return to the end game process.');
			return;
		}
		if(characterPresent("Zarek") && hasOption(getPlayerNum("Zarek"), "Unconventional Tactics")) {
			plainAlert(
				'Zarek may be able to use his OPT in the final moment here; wait for his input before proceeding, then select "End Game" to return to the end game process.'
				);
			return;
		}
	}
	z.endGame = false;
	z.gameOver = true;
	if(humansWon) {
		if(z.fuel === 0 && !noResourceCheck) {
			addAlert("Fuel is at 0; Cylons Win!");
			t.value += bold("Fuel is at Zero.") + "\r\n";
		}
		if(z.food === 0 && !noResourceCheck) {
			addAlert("Food is at 0; Cylons Win!");
			t.value += bold("Food is at Zero.") + "\r\n";
		}
		if(z.morale === 0 && !noResourceCheck) {
			addAlert("Morale is at 0; Cylons Win!");
			t.value += bold("Morale is at Zero.") + "\r\n";
		}
		if(z.population === 0 && !noResourceCheck) {
			addAlert("Population is at 0; Cylons Win!");
			t.value += bold("Population is at Zero.") + "\r\n";
		}
		if(z.vSoloCylonHandicap && z.fuel > 0 && z.population > 0 && z.food > 0 && z.morale > 0) {
			let damageCount = 0;
			for(let j = 0; !(j >= z.damagedLocations.length); j++) {
				if(onGalactica(z.damagedLocations[j])) {
					damageCount++;
				}
			}
			let centurionThirdBase = false;
			for(let j = 0; !(j >= z.centurions.length); j++) {
				if(z.centurions[j] === 4) {
					centurionThirdBase = true;
					break;
				}
			}
			if(z.fuel === 1 || z.population === 1 || z.food === 1 || z.morale === 1 || (versionAtLeast([1, 2, 2, 6]) && (damageCount === 5 ||
					centurionThirdBase))) {
				let foundCylon = false;
				for(let j = 0; !(j >= z.loyaltyDeck.length) && !foundCylon; j++) {
					foundCylon = isCylonCard(z.loyaltyDeck[j]);
					if(!versionAtLeast([1, 2, 2, 6])) {
						break;
					}
				}
				if(foundCylon) {
					boldAlert("As there was a Cylon card remaining in the Loyalty deck and the Cylons were one away from winning, the Cylons win!");
					humansWon = false;
				}
			}
		}
	}
	if(humansWon && ((z.fuel > 0 && z.population > 0 && z.food > 0 && z.morale > 0) || noResourceCheck)) {
		addAlert("Humans Win!");
		t.value += size(colorText("blue", bold("Humans Win!")), 14) + "\r\n";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.revealedCylons[j] === 0 && cylonCards(j) === 0 && !isCylonLeader(z.players[j]) && j !== z.theSympatheticCylon) {
				t.value += bold(z.players[j] + " wins!") + "\r\n";
			}
		}
	} else {
		humansWon = false;
		t.value += size(colorText("red", bold("Cylons Win!")), 14) + "\r\n";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if((z.revealedCylons[j] === 1 || cylonCards(j) > 0) && (!z.vInfiltration || !isInfiltrator(j) || 
				((z.destination === "Kobol" || z.destination === "Ionian Nebula") && z.distance >= 8) ||
				((z.destination === "Earth" || z.destination === "Ionian Earth") && z.distance >= 10) ||
				(z.destination === "New Caprica" && z.galacticaReturned))
			&& !isCylonLeader(z.players[j]) && j !== z.theSympatheticCylon) {
				t.value += bold(z.players[j] + " wins!") + "\r\n";
			}
		}
	}
	if((z.theCylonLeader !== -1 || z.theSympatheticCylon !== -1) && !z.daybreak && !z.vNoAgendas) {
		let agendaHaver = -1;
		if(z.theCylonLeader !== -1) {
			agendaHaver = z.theCylonLeader;
		} else {
			agendaHaver = z.theSympatheticCylon;
		}
		let agenda = z.loyaltyHands[agendaHaver][0];
		let CLwin = false;
		t.value += bold(z.players[agendaHaver] + " reveals " + d.loyaltyNames[agenda]) + ".\r\n";
		if(!((humansWon && agenda >= 45 && 50 >= agenda) || (!humansWon && (45 > agenda || agenda > 50)))) {
			switch (agenda) {
				case 41:
					if(z.fuel > 3 || z.food > 3 || z.morale > 3 || z.population > 3) {
						t.value += "At least one resource is above 3.\r\n";
					} else {
						t.value += "All resources are at 3 or lower.\r\n";
						CLwin = true;
					}
					break;
				case 42:
					if(z.revealedCylons[agendaHaver] === 1) {
						t.value += z.players[agendaHaver] + " is not infiltrating.\r\n";
					} else if(z.playerLocations[agendaHaver] === "Brig") {
						t.value += z.players[agendaHaver] + " is in the Brig.\r\n";
					} else {
						CLwin = true;
						t.value += z.players[agendaHaver] + " is infiltrating and is not in the Brig or Detention.\r\n";
					}
					break;
				case 43:
					if(z.morale - z.population > 2 || z.population - z.morale > 2) {
						t.value += "Population (" + z.population + ") and Morale (" + z.morale + ") are not within 2 of each other.\r\n";
					} else {
						t.value += "Population (" + z.population + ") and Morale (" + z.morale + ") are within 2 of each other.\r\n";
						CLwin = true;
					}
					break;
				case 44: {
					let destroyedShips = (4 - z.raptors);
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(z.vipersII[j] === -1 || z.vipersII[j] === -2) {
							destroyedShips++;
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === -1 || z.vipersVII[j] === -2) {
							destroyedShips++;
						}
					}
					if(5 > destroyedShips) {
						t.value += "Only " + destroyedShips + " Vipers and Raptors have been damaged or destroyed.\r\n";
					} else {
						t.value += destroyedShips + " Vipers and Raptors have been damaged or destroyed.\r\n";
						CLwin = true;
					}
					break;
				}
				case 45:
					if(6 > z.distance) {
						t.value += "Distance is only " + z.distance + ".\r\n";
					} else {
						t.value += "Distance is " + z.distance + ".\r\n";
						CLwin = true;
					}
					break;
				case 46: {
					let damageCount = 0;
					for(let j = 0; !(j >= z.damagedLocations.length); j++) {
						if(onGalactica(z.damagedLocations[j])) {
							damageCount++;
						}
					}
					t.value += damageCount + " Galactica locations are damaged.\r\n";
					if(2 >= damageCount) {
						CLwin = true;
					}
					break;
				}
				case 47:
					if(z.playerLocations[agendaHaver] === "Brig") {
						t.value += z.players[agendaHaver] + " is in the Brig.\r\n";
						CLwin = true;
					} else if(z.playerLocations[agendaHaver] === "Detention") {
						t.value += z.players[agendaHaver] + " is in Detention.\r\n";
						CLwin = true;
					} else if(z.CLexecuted) {
						t.value += z.players[agendaHaver] + " was executed at least once.\r\n";
						CLwin = true;
					}
					break;
				case 48:
					if(z.fuel > 4 || z.food > 4 || z.morale > 5 || z.population > 6) {
						t.value += "At least one resource is in the blue.\r\n";
					} else {
						t.value += "All resources are in the red.\r\n";
						CLwin = true;
					}
					break;
				case 49: {
					let damageCount = 0;
					for(let j = 0; !(j >= z.damagedLocations.length); j++) {
						if(onGalactica(z.damagedLocations[j]) || onPegasus(z.damagedLocations[j])) {
							damageCount++;
						}
					}
					t.value += damageCount + " Galactica and Pegasus locations are damaged.\r\n";
					t.value += "Morale is at " + z.morale + ".\r\n";
					if(damageCount >= 4 && 3 >= z.morale) {
						CLwin = true;
					}
					break;
				}
				case 50:
					t.value += "Food is at " + z.food + ".\r\n";
					t.value += "Population is at " + z.population + ".\r\n";
					if(2 >= z.food && 2 >= z.population) {
						CLwin = true;
					}
					break;
				case 51:
					t.value += "Food is at " + z.food + ".\r\n";
					t.value += "Morale is at " + z.morale + ".\r\n";
					t.value += "Population is at " + z.population + ".\r\n";
					if(2 >= z.food || 2 >= z.population || 2 >= z.morale) {
						CLwin = true;
					}
					break;
				case 53:
					if(z.mutualAnnihilation) {
						t.value += z.players[agendaHaver] + " has played a Super Crisis card.\r\n";
						CLwin = true;
					} else {
						t.value += z.players[agendaHaver] + " never played a Super Crisis card.\r\n";
					}
					break;
			}
		}
		if(CLwin) {
			t.value += bold(size(z.players[agendaHaver] + " Wins!", 14)) + "\r\n";
			addAlert(z.players[agendaHaver] + " wins!");
		} else {
			boldAlert(z.players[agendaHaver] + " loses!");
		}
	} else if(z.theCylonLeader !== -1 && (z.daybreak || z.vNoAgendas) ) {
		for(let j = 0; !(j >= z.loyaltyHands[z.theCylonLeader].length); j++) {
			let motive = z.loyaltyHands[z.theCylonLeader][j];
			let satisfied = false;
			switch (motive) {
				case 53:
					for(let k = 0; !(k >= z.damagedLocations.length); k++) {
						if(z.damagedLocations[k] === "FTL Control" || z.damagedLocations[k] === "Admiral's Quarters") {
							satisfied = true;
							break;
						}
					}
					break;
				case 54:
					for(let k = 0; ((!z.revealedCylons[z.theCylonLeader] && !z.daybreak) || z.mutinies[z.theCylonLeader].length > 0) && !(k >= z.numPlayers); k++) {
						if((z.playerLocations[k] === "Brig" && k !== z.theCylonLeader && !isOnNewCaprica(z.theCylonLeader)) || (z.playerLocations[k] === "Detention" && k !== z.theCylonLeader &&
								isOnNewCaprica(z.theCylonLeader))) {
							satisfied = true;
							break;
						}
					}
					break;
				case 55: {
					let count = 0;
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(z.vipersII[j] === -1 || z.vipersII[j] === -2) {
							count++;
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === -1 || z.vipersVII[j] === -2) {
							count++;
						}
					}
					for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
						if(z.assaultRaptors[j] === -2) {
							count++;
						}
					}
					satisfied = (count >= 4);
					break;
				}
				case 56: {
					let politics = false;
					let tactics = false;
					let engineering = false;
					for(let j = 0; !(j >= z.skillCardHands[z.theCylonLeader].length); j++) {
						switch (cardColorID(z.skillCardHands[z.theCylonLeader][j])) {
							case 0:
								politics = true;
								break;
							case 2:
								tactics = true;
								break;
							case 4:
								engineering = true;
								break;
						}
					}
					satisfied = (politics && tactics && engineering);
					break;
				}
				case 57:
					satisfied = (6 >= z.population);
					break;
				case 58:
					satisfied = (5 >= z.morale);
					break;
				case 59:
					satisfied = (4 >= z.food);
					break;
				case 60:
					satisfied = ((z.jumpTrack === 3 || z.jumpTrack === 4) && raidersAway() === z.raiders.length && heaviesAway() === z.heavies.length && basestarsAway() === z.basestars
						.length);
					break;
				case 61:
					satisfied = (z.distance >= 5) && (centurionReserves() === z.centurions.length);
					break;
				case 62:
					satisfied = (z.distance >= 7);
					break;
				case 63: {
					let treacheryCount = 0;
					for(let j = 0; !(j >= z.skillCardHands[z.theCylonLeader].length); j++) {
						if(cardColorID(z.skillCardHands[z.theCylonLeader][j]) === 5) {
							treacheryCount++;
						}
					}
					satisfied = (treacheryCount >= 3);
					break;
				}
				case 64:
					satisfied = (z.population >= 4);
					break;
				case 65:
					satisfied = (z.morale >= 3);
					break;
				case 66:
					satisfied = (z.food >= 2);
					break;
			}
			if(satisfied) {
				z.loyaltyDiscards[z.theCylonLeader].push(z.loyaltyHands[z.theCylonLeader].splice(j, 1)[0]);
				j--;
				let alertText = z.players[z.theCylonLeader] + " reveals " + d.loyaltyNames[motive];
				addAlert(alertText);
				alertText = bold(alertText);
				if(motive === 63 || motive === 56) {
					alertText += ", along with:";
					for(let k = 0; !(k >= z.skillCardHands[z.theCylonLeader].length); k++) {
						alertText += "\r\n" + cardText(z.skillCardHands[z.theCylonLeader][k]);
					}
				} else {
					alertText += ".";
				}
				t.value += alertText + "\r\n";
			}
		}
		let cylonMotives = 0;
		let humanMotives = 0;
		for(let j = 0; !(j >= z.loyaltyDiscards[z.theCylonLeader].length); j++) {
			if(z.loyaltyDiscards[z.theCylonLeader][j] >= 60) {
				cylonMotives++;
			} else {
				humanMotives++;
			}
		}
		if(humanMotives >= 2 && (humanMotives + cylonMotives >= 3) && humansWon) {
			addAlert(z.players[z.theCylonLeader] + " wins!");
			t.value += z.players[z.theCylonLeader] + " has " + (humanMotives + cylonMotives) + " revealed Motives, " + humanMotives +
				" of which are with the winning Human team, so...\r\n";
			t.value += bold(size(z.players[z.theCylonLeader] + " Wins!", 14)) + "\r\n";
		} else if(cylonMotives >= 2 && (humanMotives + cylonMotives) >= 3 && !humansWon) {
			addAlert(z.players[z.theCylonLeader] + " wins!");
			t.value += z.players[z.theCylonLeader] + " has " + (humanMotives + cylonMotives) + " revealed Motives, " + cylonMotives +
				" of which are with the winning Cylon team, so...\r\n";
			t.value += bold(size(z.players[z.theCylonLeader] + " Wins!", 14)) + "\r\n";
		} else if(cylonMotives === 2 && !z.sleeper && !humansWon) {
			addAlert(z.players[z.theCylonLeader] + " wins!");
			t.value += z.players[z.theCylonLeader] +
				" has 2 completed Motives, both of which are with the winning Cylon team, and no uncompleted Motives, so...\r\n";
			t.value += bold(size(z.players[z.theCylonLeader] + " Wins!", 14)) + "\r\n";
		} else if(humansWon) {
			addAlert(z.players[z.theCylonLeader] + " loses!");
			t.value += z.players[z.theCylonLeader] + " has " + (humanMotives + cylonMotives) + " revealed Motives, " + humanMotives +
				" of which are with the winning Human team, so...\r\n";
			t.value += bold(z.players[z.theCylonLeader] + " Loses!") + "\r\n";
		} else {
			addAlert(z.players[z.theCylonLeader] + " loses!");
			t.value += z.players[z.theCylonLeader] + " has " + (humanMotives + cylonMotives) + " revealed Motives, " + cylonMotives +
				" of which are with the winning Cylon team, so...\r\n";
			t.value += bold(z.players[z.theCylonLeader] + " Loses!") + "\r\n";
		}
	}
	t.value += "\r\n"+bold("Remember to record the outcome of your game on the [ur"+"l=https:"+"//boardgamegeek.com/wiki/page/BSG_PBF]BSG PBF Wiki[/"+"url]!")+"\r\n";
}
var a0 = "ENDBYCA  [/size] [/c]" + 
" [c][size=1] STARTBYCB";
function resolveCylonAllyQueue() {
	if(z.cylonAllyQueue.length === 0) {
		return true;
	}
	let newAlly = z.cylonAllyQueue.pop();
	boldAlert("New Ally is " + d.allyNames[newAlly] + ".");
	let candidate = -1;
	let mostTrauma = 0;
	let tie = false;
	for(let k = 0; !(k >= z.numPlayers); k++) {
		let l = (z.turn + k) % z.numPlayers;
		let total = z.antagonistic[l] + z.benevolent[l];
		if(z.revealedCylons[l] === 1 && total > 0) {
			if(total === mostTrauma) {
				tie = true;
			} else if(total > mostTrauma) {
				mostTrauma = total;
				tie = false;
				candidate = l;
			}
		}
	}
	if(candidate === -1) {
		let trauma = z.traumaPile.pop();
		if(trauma === undefined){
			z.allies.push([newAlly,null]);
			plainAlert("The Trauma pile is empty; no Trauma is placed on "+d.allyNames[newAlly]+".");
		} else {
			z.allies.push([newAlly, z.traumaPile.pop()]);
			plainAlert("Trauma for " + d.allyNames[newAlly] + " is placed randomly.");
		}
		if(z.cylonAllyQueue.length === 0) {
			return true;
		} else {
			return resolveCylonAllyQueue();
		}
	} else if((!tie || z.executedCurrentPlayer) && mostTrauma === 1) {
		if(z.antagonistic[candidate] === 1) {
			z.allies.push([newAlly, 0]);
			z.antagonistic[candidate] = 0;
			plainAlert(z.players[candidate] + " places their last Trauma on " + d.allyNames[newAlly]+".");
			if(z.cylonAllyQueue.length === 0) {
				return true;
			} else {
				return resolveCylonAllyQueue();
			}
		} else {
			z.allies.push([newAlly, 1]);
			z.benevolent[candidate] = 0;
			plainAlert(z.players[candidate] + " places their last Trauma on " + d.allyNames[newAlly]+".");
			if(z.cylonAllyQueue.length === 0) {
				return true;
			} else {
				return resolveCylonAllyQueue();
			}
		}
	} else if(!tie || z.executedCurrentPlayer) {
		z.cylonAllyQueue.push(newAlly);
		boldAlert(z.players[candidate] + ", as the revealed Cylon with the most Trauma, must place a Trauma on " + d.allyNames[newAlly]);
		return false;
	} else {
		z.cylonAllyQueue.push(newAlly);
		boldAlert("Multiple Cylon players are tied for the most Trauma. " + z.players[z.turn] +
			", as current player, must announce in thread who places the Trauma on " + d.allyNames[newAlly]);
		return false;
	}
}

function damagePegasus(sabotage) {
	if(!z.vAltDamage) {
		let damage = z.pegasusDamage.pop();
		z.damagedLocations.push(damage);
		boldAlert("Damage hits: " + damage);
		if(isPegasusDestroyed()) {
			destroyPegasus(sabotage);
		} else {
			for(let i = 0; !(i >= z.numPlayers); i++) {
				if(z.playerLocations[i ] === damage) {
					if(sabotage && Array.isArray(z.sabotageMove) && i === z.sabotageMove[0]){
						plainAlert(z.players[i ] + " technically moves to "+damage+" after the damage is placed, and is not sent to Sickbay.");
						delete z.sabotageMove;
					} else {
						movePlayer(i, "Sickbay");
						addAlert(z.players[i ] + " is sent to Sickbay.");
					}
				}
			}
			if(sabotage && Array.isArray(z.sabotageMove) && damage === z.sabotageMove[1]){
				movePlayer(z.sabotageMove[0],"Sickbay");
				addAlert(z.players[z.sabotageMove[0]] + " is sent to Sickbay, as the Sabotage technically happens before the movement.");
				delete z.sabotageMove;
			}
		}
	} else {
		for(let j = 0; !(j >= z.damage.length); j++) {
			let damage = z.damage.pop();
			if(onPegasus(damage)) {
				z.damagedLocations.push(damage);
				boldAlert("Damage hits: " + damage);
				if(isPegasusDestroyed()) {
					destroyPegasus(sabotage);
				} else {
					for(let i = 0; !(i >= z.numPlayers); i++) {
						if(z.playerLocations[i ] === damage) {
							if(sabotage && Array.isArray(z.sabotageMove) && i === z.sabotageMove[0]){
								plainAlert(z.players[i ] + " technically moves to "+damage+" after the damage is placed, and is not sent to Sickbay.");
								delete z.sabotageMove;
							} else {
								movePlayer(i, "Sickbay");
								addAlert(z.players[i ] + " is sent to Sickbay.");
							}
						}
					}
					if(sabotage && Array.isArray(z.sabotageMove) && damage === z.sabotageMove[1]){
						movePlayer(z.sabotageMove[0],"Sickbay");
						addAlert(z.players[z.sabotageMove[0]] + " is sent to Sickbay, as the Sabotage technically happens before the movement.");
						delete z.sabotageMove;
					}
				}
				shuffle(z.damage);
				break;
			} else {
				z.damage.unshift(damage);
			}
		}
	}
}

function damageGalactica(sabotage) {
	let damage = z.damage.pop();
	z.damagedLocations.push(damage);
	boldAlert("Damage hits: " + damage);
	if(damage === "Food") {
		decreaseFood();
		return true;
	} else if(damage === "Fuel") {
		decreaseFuel();
		return true;
	} else {
		if(isGalacticaDestroyed()) {
			addAlert("Galactica destroyed; Cylons win!");
			t.value += bold("Galactica is destroyed.") + "\r\n\r\n";
			endGame(false);
			return true;
		}
		if(isPegasusDestroyed()) {
			destroyPegasus(sabotage);
		}
		for(let i = 0; !(i >= z.numPlayers); i++) {
			if(z.playerLocations[i ] === damage) {
				if(sabotage && Array.isArray(z.sabotageMove) && i === z.sabotageMove[0]){
					plainAlert(z.players[i ] + " technically moves to "+damage+" after the damage is placed, and is not sent to Sickbay.");
					delete z.sabotageMove;
				} else {
					movePlayer(i, "Sickbay");
					addAlert(z.players[i ] + " is sent to Sickbay.");
				}
			}
		}
		if(sabotage && Array.isArray(z.sabotageMove) && damage === z.sabotageMove[1]){
			movePlayer(z.sabotageMove[0],"Sickbay");
			addAlert(z.players[z.sabotageMove[0]] + " is sent to Sickbay, as the Sabotage technically happens before the movement.");
			delete z.sabotageMove;
		}
		let killedAllies = 0;
		for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
			if(d.allyLocations[z.allies[j][0]] === damage) {
				killedAllies++;
				plainAlert("The " + d.allyNames[z.allies[j][0]] + " Ally is hit, and is removed from the game.");
				let trauma = z.allies[j][1];
				if(trauma !== null){
					z.traumaPile.push(trauma);
				}
				shuffle(z.traumaPile);
				z.allies.splice(j, 1);
				j--;
			}
		}
		for(let j = killedAllies; j > 0; j--) {
			let newAlly = allyPop();
			if(newAlly === -1) {
				plainAlert("Ally deck exhausted; it does not reshuffle.");
			} else {
				z.cylonAllyQueue.push(newAlly);
			}
		}
		if(z.preCrossroads && z.cylonAllyQueue.length > 0) {
			return resolveCylonAllyQueue();
		} else {
			return true;
		}
	}
}

function getDistance(destinationID) {
	switch (destinationID) {
		case 0:
		case 1:
		case 6:
		case 11:
		case 22:
		case 28:
		case 32:
			return 3;
		case 2:
		case 3:
		case 4:
		case 5:
		case 7:
		case 8:
		case 9:
		case 10:
		case 15:
		case 16:
		case 17:
		case 23:
		case 25:
		case 29:
		case 30:
		case 33:
		case 36:
			return 2;
		case 12:
		case 13:
		case 14:
		case 18:
		case 19:
		case 20:
		case 21:
		case 24:
		case 27:
		case 31:
		case 34:
		case 35:
			return 1;
		case 26:
			return 0;
		default:
			return 0;
	}
}

function allyBanner(ally) {
	switch (ally) {
		case "Baltar":
			return 544202;
		case "Tigh":
			return 544203;
		case "Apollo":
			return 544204;
		case "Zarek":
			return 544205;
		case "Boomer":
			return 544206;
		case "Helo":
			return 544207;
		case "Starbuck":
			return 544208;
		case "Roslin":
			return 544209;
		case "Chief":
			return 544210;
		case "Adama":
			return 544211;
		case "Cavil":
			return 544870;
		case "Cain":
			return 544871;
		case "Dee":
			return 544872;
		case "Kat":
			return 544873;
		case "Leoben":
			return 544874;
		case "Ellen":
			return 544875;
		case "Six":
			return 544876;
		case "Anders":
			return 878727;
		case "Cally":
			return 878729;
		case "Gaeta":
			return 878731;
		case "Tory":
			return 878733;
		case "Cottle":
			return 900674;
		case "Crashdown":
			return 900675;
		case "D'Anna":
			return 900676;
		case "Doral":
			return 900677;
		case "Elosha":
			return 900678;
		case "Seelix":
			return 1419731;
		case "Hoshi":
			return 900680;
		case "Hot Dog":
			return 900681;
		case "Billy":
			return 1418384;
		case "Kelly":
			return 900683;
		case "Romo":
			return 3007562;
		case "Racetrack":
			return 900685;
		case "Shaw":
		case "Kendra":
			return 900686;
		case "Simon":
			return 900687;
	}
}

function cultLeaderUsable() {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(j !== me && z.playerLocations[j] === z.playerLocations[me] && ((z.miracles[j] === 1 && z.miracles[me] !== 3) || (z.miracles[j] === 0 && z.miracles[
				me] !== 0))) {
			return true;
		}
	}
	return false;
} /* what sort of viper is a player piloting?*/
function whatViper(player) {
	if(!inSpace(z.playerLocations[player])) {
		return "NONE";
	}
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === z.players[player]) {
			return "Viper Mk II";
		}
	}
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === z.players[player]) {
			return "Viper Mk VII";
		}
	}
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(z.assaultRaptors[i ] === z.players[player]) {
			return "Assault Raptor";
		}
	}
}

function isCylonCard(card) {
	switch (card) {
		case 11:
		case 12:
		case 13:
		case 14:
		case 18:
		case 37:
		case 38:
			return true;
	}
	if(z.vInfiltration){
		return card === 68;
	}
	return false;
}

function cylonCards(player) {
	let count = 0;
	for(let i = 0; !(i >= z.loyaltyHands[player].length); i++) {
		if(isCylonCard(z.loyaltyHands[player][i ])) {
			count++;
		}
	}
	return count;
}

function movePlayer(player, location) {
	if(inSpace(z.playerLocations[player]) && !inSpace(location)) {
		let foundViper = false;
		for(let i = 0; !foundViper && !(i >= z.vipersII.length); i++) {
			if(z.vipersII[i ] === z.players[player]) {
				z.vipersII[i ] = 0;
				foundViper = true;
			}
		}
		for(let i = 0; !foundViper && z.CFB && !(i >= z.vipersVII.length); i++) {
			if(z.vipersVII[i ] === z.players[player]) {
				z.vipersVII[i ] = 0;
				foundViper = true;
			}
		}
		for(let i = 0; !foundViper && z.daybreak && !(i >= z.assaultRaptors.length); i++) {
			if(z.assaultRaptors[i ] === z.players[player]) {
				z.assaultRaptors[i ] = 0;
				foundViper = true;
			}
		}
	}
	if(z.playerLocations[player] === "Brig" && location !== "Brig" && z.revealedCylons[player] === 0) {
		if(!isCylonLeader(z.players[player]) && player !== z.theSympatheticCylon && z.playerLocations[z.admiral] === "Brig" && player !== z.admiral) {
			z.admiral = player;
			t.value += bold(z.players[player] + " is now the " + colorText("green", "Admiral") + ".") + "\r\n";
		}
		if(!isCylonLeader(z.players[player]) && player !== z.theSympatheticCylon && z.CFB && z.playerLocations[z.cag] === "Brig" && player !== z.cag) {
			z.cag = player;
			t.value += bold(z.players[player] + " is now the " + colorText("red", "CAG") + ".") + "\r\n";
		}
	}
	let oldLocation = z.playerLocations[player];
	z.playerLocations[player] = location;
	if(player !== me || location === "Brig" || location === "Sickbay" || location === "Medical Center" || location === "Detention" || ((z.pegasus || z
			.daybreak) && location === "Resurrection Ship") || location === "Hub Destroyed") {
		t.value += bold(z.players[player] + " is moved to " + location + ".\r\n");
	} else {
		t.value += bold(z.players[player] + " moves to " + location + ".\r\n");
	}
	if(location === "Brig" && player === z.admiral) {
		passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
	}
	if(z.CFB && location === "Brig" && player === z.cag) {
		passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
	}
	let badOutcome = false;
	if(z.preCrossroads && z.vAltTrauma && location === "Sickbay" && oldLocation !== "Sickbay") {
		let trauma = z.sickbayTrauma;
		if(trauma === undefined && (!z.vEuropeanTrauma || z.brigTrauma === undefined)){
			if(z.traumaPile.length === 0){
				t.value += "There is no Trauma in Sickbay or the Trauma pile; no effect.\r\n";
			} else {
				trauma = z.traumaPile.pop();
				t.value += "There is no Trauma in Sickbay; one is drawn from the Trauma pile instead.\r\n";
			}
		} else if (trauma === undefined && z.vEuropeanTrauma){
			trauma = z.brigTrauma;
		}
		if(trauma === 0) {
			z.antagonistic[player]++;
			t.value += z.players[player] + " draws a Trauma from Sickbay, and survives.\r\n";
			if(z.vEuropeanTrauma){
				z.brigTrauma = z.traumaPile.pop();
			} else {
				z.sickbayTrauma = z.traumaPile.pop();
			}
		} else if(trauma === 1) {
			z.benevolent[player]++;
			t.value += z.players[player] + " draws a Trauma from Sickbay, and survives.\r\n";
			if(z.vEuropeanTrauma){
				z.brigTrauma = z.traumaPile.pop();
			} else {
				z.sickbayTrauma = z.traumaPile.pop();
			}
		} else if(trauma === -1) {
			badOutcome = true;
			addAlert(z.players[player] + " draws a DISASTER token from Sickbay, and is executed!");
			t.value += bold(z.players[player] + " draws a " + colorText("red", "DISASTER") + " token from Sickbay!") + "\r\n";
			executePlayer(player,
			false); /* TODO: you are executed by disaster trauma, pick an char corresponding to ally on the board, new ally trauma is placed randomly.  That same disaster token is not reshuffled until AFTERWARDS, then new sickbay/brig trauma placed */
			t.value += "Reshuffling Disaster Token.\r\n";
			z.traumaPile.push(-1);
			shuffle(z.traumaPile);
			if(z.vEuropeanTrauma){
				z.brigTrauma = z.traumaPile.pop();
			} else {
				z.sickbayTrauma = z.traumaPile.pop();
			}
			z.drawSkills = false;
			z.phase = 4;
		}
	}
	if(z.vBrutality && !badOutcome && characterPresent("Gaeta") && !noDrawback(player) && z.players[player] === "Gaeta" && (location === "Sickbay" ||
			location === "Medical Center") && (oldLocation !== "Sickbay" && oldLocation !== "Medical Center")) {
		dealSkillCard(player, 5);
		SPTokenBad("Amputee", player);
	}
}

function drawSuperCrisis(who) {
	if(who === undefined){
		who = me;
	}
	if(z.superCrisisDeck.length === 0) {
		plainAlert("Super Crisis deck is empty!");
	} else {
		let sc = z.superCrisisDeck.pop();
		if(who === me){
			addAlert("You drew " + d.crisisNames[sc]);
		}
		z.superCrisisHands[who].push(sc);
		t.value += bold(z.players[who] + " draws a Super Crisis.\r\n");
		if(z.superCrisisDeck.length === 0) {
			t.value += "Super Crisis deck empty; reshuffling.\r\n";
			z.superCrisisDeck = z.superCrisisDiscards;
			z.superCrisisDiscards = [];
			shuffle(z.superCrisisDeck);
		}
	}
}

function missionSpecialist() {
	for(let i = 0; !(i >= z.numPlayers); i++) {
		for(let j = 0; !(j >= z.quorumTitles[i ].length); j++) {
			if(z.quorumTitles[i ][j] === 4) {
				return z.players[i ];
			}
		}
	}
	return "NONE";
}

function destroyPegasus(sabotage) {
	boldAlert("Pegasus is destroyed!");
	z.pegasusDestroyed = true;
	for(let i = 0; !(i >= z.numPlayers); i++) {
		let loc = z.playerLocations[i ];
		if(loc === "Pegasus CIC" || loc === "Airlock" || loc === "Main Batteries" || loc === "Engine Room") {
			if(sabotage && Array.isArray(z.sabotageMove) && z.sabotageMove[0] === i){
				movePlayer(i,z.sabotageMove[1]);
				addAlert(z.players[ i]+ " is moved back to "+z.sabotageMove[1]+".");
				if(z.sabotageMove.length > 2){
					if(z.sabotageMove[2] === "II"){
						for(let j = 0; !(j>=z.vipersII.length); j++){
							if(z.vipersII[j] === 0){
								z.vipersII[j] = z.players[ i];
								break;
							}
						}
					} else if(z.sabotageMove[2] === "VII"){
						for(let j = 0; !(j>=z.vipersVII.length); j++){
							if(z.vipersVII[j] === 0){
								z.vipersVII[j] = z.players[ i];
								break;
							}
						}
					}
				}
				delete z.sabotageMove;
			} else {
				movePlayer(i, "Sickbay");
				addAlert(z.players[i ] + " sent to Sickbay.");
			}
		}
		if(Array.isArray(z.sabotageMove) && onPegasus(z.sabotageMove[1])){
			movePlayer(z.sabotageMove[0],"Sickbay");
			addAlert(z.players[z.sabotageMove[0] ] + " sent to Sickbay.");
			delete z.sabotageMove;
		}
	}
	if(z.vBrutality) {
		if(z.fuel > 4) {
			decreaseFuel();
		}
		if(z.food > 4) {
			decreaseFood();
		}
		if(z.morale > 5) {
			decreaseMorale();
		}
		if(z.population > 6) {
			decreasePopulation();
		}
	}
}

function recallAllVipers() {
	plainAlert("All vipers in space areas are returned to the Reserves.");
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(!Number.isInteger(z.vipersII[j])) {
			movePlayer(getPlayerNum(z.vipersII[j]), "Hangar Deck");
			z.vipersII[j] = 0;
		} else if(z.vipersII[j] > -1) {
			z.vipersII[j] = 0;
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(!Number.isInteger(z.vipersVII[j])) {
			movePlayer(getPlayerNum(z.vipersVII[j]), "Hangar Deck");
			z.vipersVII[j] = 0;
		} else if(z.vipersVII[j] > -1) {
			z.vipersVII[j] = 0;
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(!Number.isInteger(z.assaultRaptors[j])) {
			movePlayer(getPlayerNum(z.assaultRaptors[j]), "Hangar Deck");
			z.assaultRaptors[j] = 0;
		} else if(z.assaultRaptors[j] >= 0) {
			z.assaultRaptors[j] = 0;
		}
	}
}

function repairAllVipers() {
	plainAlert("All damaged Vipers are repaired.");
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(z.vipersII[j] == -1) {
			z.vipersII[j] = 0;
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(z.vipersVII[j] == -1) {
			z.vipersVII[j] = 0;
		}
	}
} /* for current crisis if no args, crisis x if not */
function difficultyTemplate() {
	if(arguments.length === 0) {
		let text = "";
		if(z.currentSkillCheck === "Airlock" || z.currentSkillCheck === "Brig" || z.currentSkillCheck === "Administration" || z.currentSkillCheck ===
			"Admiral's Quarters" || z.currentSkillCheck === "Resistance HQ" || z.currentSkillCheck === "Detention") {
			text = z.currentSkillCheck;
			if(z.currentSkillCheck === "Admiral's Quarters" || z.currentSkillCheck === "Resistance HQ" || z.currentSkillCheck === "Airlock") {
				text += " vs. " + z.players[z.thisTarget];
			} else {
				text += " (" + z.players[z.thisTarget] + ")";
			}
		} else {
			text = d.crisisNames[z.currentSkillCheck];
		}
		let airlockModifier = 0;
		if(z.currentSkillCheck === "Airlock" && z.playerLocations[z.thisTarget] === "Brig") {
			airlockModifier = 4;
		}
		text += " - ";
		if(z.secondChance) {
			switch (z.currentSkillCheck) {
				case "Airlock":
					text += "(16)";
					break;
				case "Brig":
				case "Admiral's Quarters":
				case "Resistance HQ":
					text += "(11)";
					break;
				case "Detention":
					text += "(13)";
					break;
				default:
					text += "(" + (d.difficulty[z.currentSkillCheck] + 4) + ")";
			}
		}
		if(characterPresent("Cain") && z.currentSkillCheck === "Admiral's Quarters" && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
			text += "(10)";
		}
		text += (z.thisDifficulty - airlockModifier);
		if(z.thisPartial > 0 && z.thisDifficulty > z.thisPartial) {
			text += "(" + z.thisPartial + ")";
		} else if(z.thisConsequence > 0) {
			text += "(*)";
		}
		if(z.thisPolitics > 0) {
			text += colorText("orange", "Y");
		}
		if(z.thisLeadership > 0) {
			text += colorText("green", "G");
		}
		if(z.thisTactics > 0) {
			text += colorText("purple", "P");
		}
		if(z.thisPiloting > 0) {
			text += colorText("red", "R");
		}
		if(z.thisEngineering > 0) {
			text += colorText("blue", "B");
		}
		if(z.thisTreachery > 0) {
			text += colorText("brown", "O");
		}
		return bold(text);
	} else {
		let x = arguments[0];
		let text = d.crisisNames[x];
		if(d.CAC[x] === 0 && d.admiralChooses[x] === 0 && d.presidentChooses[x] === 0 && d.cagChooses[x] === 0) {
			text += " - " + d.difficulty[x];
			if(d.partial[x] > 0) {
				text += "(" + d.partial[x] + ")";
			} else if(d.consequence[x] > 0) {
				text += "(*)";
			}
			if(d.positives[0][x] > 0) {
				text += colorText("orange", "Y");
			}
			if(d.positives[1][x] > 0) {
				text += colorText("green", "G");
			}
			if(d.positives[2][x] > 0) {
				text += colorText("purple", "P");
			}
			if(d.positives[3][x] > 0) {
				text += colorText("red", "R");
			}
			if(d.positives[4][x] > 0) {
				text += colorText("blue", "B");
			}
		}
		return bold(text);
	}
} /* TODO: Calc CO? */ /* TODO: Include played SP in card count here? */
function SPToken(eventName) {
	let sanitizedName = eventName.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	let qre = new RegExp('\\[q' + bl + '="BYC: Interrupts for ' + sanitizedName + '"\\]((?!(\\[q' + bl + '=|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	t.value = t.value.replace(qre, "");
	let text = '[q=' + bl + '"BYC: Interrupts for ' + eventName + '"]\r\n';
	text += bold(size("Interrupts for " + eventName, 14)) + "\r\n";
	text += "Looking for " + colorText("purple", "Strategic Planning") + ".\r\n";
	if((eventName === "FTL Control (Blue -3)" || eventName === "FTL Control (Blue -1)") && characterPresent("Gaeta") && z.FTLOperator && !z.vBrutality) {
		text += "Remember that Gaeta may use his FTL Operator ability to reroll this die.\r\n";
	} else {
		let DRRE = /^(.*) vs\. Occupation Force \((.*)\)$/.exec(eventName);
		if(DRRE !== null) {
			if(z.possibleColors[getPlayerNum(DRRE[1])][3] === 1) {
				text += "Remember that " + z.players[getPlayerNum(DRRE[1])] + " may use a " + colorText("red", "Maximum Firepower") +
				" to reroll this die.\r\n";
			}
		} else if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3]) && (eventName === "Launch Scout" ||
				eventName === "Scout for Fuel" || eventName === "Tylium Planet" || eventName === "Icy Moon")) {
			text += "Remember that Racetrack can use her Expert Raptor Pilot ability to reroll this die.\r\n";
		}
	}
	if(z.eco) {
		text += "Remember that Helo may use his ECO Officer ability to reroll this die.\r\n";
	}
	text += "\r\n";
	for(let i = z.turn; !(i >= z.turn + z.numPlayers); i++) {
		let interruptPlayer = i % z.numPlayers;
		text += z.players[interruptPlayer] + " (" + z.skillCardHands[interruptPlayer].length + ") - ";
		if(z.sps[interruptPlayer] === 0) {
			text += "Pass";
		} else if(z.sps[interruptPlayer] !== null && z.sps[interruptPlayer] > 0) {
			text += colorText("purple", z.sps[interruptPlayer] + " - Strategic Planning");
		} else if(z.revealedCylons[interruptPlayer] === 1) {
			text += "PASS: Cylon";
		} else if(z.skillCardHands[interruptPlayer].length === 0) {
			text += "PASS: No Cards";
		} else if(z.possibleColors[interruptPlayer][2] === 0) {
			text += "PASS: No Tactics";
		}
		text += "\r\n";
	}
	text += "[/" + "q]\r\n";
	t.value += text;
}

function SPTokenBad(eventName, roller) {
	z.dieRollQueue.push(eventName);
	let theRoller = roller;
	if(roller === undefined) {
		theRoller = me;
	}
	if(characterPresent("Billy") && theRoller === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy"))) {
		plainAlert("Billy's No Combat Experience drawback means any die rolls he takes during Action steps may not be modified (or rerolled).");
		if(z.dieRollQueue.length === 1) {
			z.dieRoller = theRoller;
		}
	} else if(z.dieRollQueue.length === 1) {
		addAlert("Asking for Strategic Planning for " + eventName + ".");
		if(z.eco) {
			addAlert("Remember that Helo can use his ECO Officer ability to reroll the die.");
		}
		z.dieRoller = theRoller;
		z.spToken = true;
		SPToken(eventName);
	}
}

function playQuorumCard(pos, peek) {
	let quorum = -1;
	if(peek === "Bypass Billy") {
		quorum = pos;
	} else if(peek === "Billy") {
		quorum = z.billyHand[pos];
		z.billyHand.splice(pos, 1);
	} else if(peek) {
		quorum = z.quorumPeek[pos];
		z.quorumPeek.splice(pos, 1);
	} else {
		quorum = z.quorumHand[pos];
		z.quorumHand.splice(pos, 1);
	}
	if(peek !== "Bypass Billy") {
		t.value += bold(myPlayer + " plays " + d.quorumNames[quorum] + ".") + "\r\n";
	}
	if(characterPresent("Billy") && !versionAtLeast([2, 1, 6]) && (z.miracles[getPlayerNum("Billy")] === 1 || actsOfFaith("Billy")) && !z.theFarm && peek !==
		"Bypass Billy") {
		if(z.revealSecretsPause) {
			plainAlert(
			'Someone has requested a pause for Billy\'s Reveal Secrets OPG.  Please wait for Billy to use or pass on the ability before proceeding.');
			z.revealSecretsPause = false;
		} else {
			addAlert('Select "Process this Quorum Card" to continue.');
		}
		addOption(me, "Process this Quorum Card", quorum, true);
		if(z.miracles[getPlayerNum("Billy")] === 1) {
			addOption(getPlayerNum("Billy"), "Reveal Secrets (OPG)", quorum, false);
		} else {
			addOption(getPlayerNum("Gaius"), "Reveal Secrets (OPG)", quorum, false);
		}
		return;
	}
	if(quorum === 0) {
		z.quorumTitles[z.president].push(0);
		addAlert("You must now draw 1 skill card of any type (it may be from outside your skill set).");
		addOption(me, "Draw 1 Skill Card (any color)", undefined, true);
	} else if(quorum === 3 || quorum === 4 || quorum === 5 || quorum === 17 || (!z.vBrutality && quorum === 23)) {
		if(quorum !== 23) {
			dealSkillCard(me, 0);
			dealSkillCard(me, 0);
			addAlert("You draw " + cardText(z.skillCardHands[me][z.skillCardHands[me].length - 1]) + " and " + cardText(z.skillCardHands[me][z.skillCardHands[
				me].length - 2]) + ".");
		}
		addAlert("Now, assign this Quorum card to another player.");
		t.value += z.players[me] + " must assign this Quorum card to another player.\r\n";
		addOption(me, "[" + d.quorumNames[quorum] + "] Assign this Quorum card", undefined, true);
	} else {
		let name = d.quorumNames[quorum];
		let player = me;
		switch (name) {
			case "Arrest Order":
				if(isOnNewCaprica(z.president)) {
					plainAlert(z.players[player] + " must move a character to Detention.");
					addOption(player, "Move a player to Detention", "Arrest Order", true);
					if(z.galacticaReturned) {
						addOption(player, "Move a player to the Brig", "Arrest Order", true);
					}
				} else {
					plainAlert(z.players[player] + " must move a character to the Brig.");
					addOption(player, "Move a player to the Brig", "Arrest Order", true);
					if(z.galacticaReturned) {
						addOption(player, "Move a player to Detention", "Arrest Order", true);
					}
				}
				break;
			case "Authorization of Brutal Force":
				z.destroyer = me;
				if(!z.galacticaAway && raidersAway() !== z.raiders.length) {
					addOption(player, "Destroy Raider(s)", ["ABF", 3], true);
				}
				if(!z.galacticaAway && heaviesAway() !== z.heavies.length) {
					/* RULES: can ABF target CFB? */
					addOption(player, "Destroy a Heavy Raider", "ABF", true);
				}
				if(!z.galacticaAway && centurionReserves() !== z.centurions.length) {
					addOption(player, "Destroy a Centurion", "ABF", true);
				}
				plainAlert(z.players[player] +
					" must destroy 3 Raiders, 1 Heavy Raider, or 1 Centurion.\r\nThen, roll a die; on a 2 or less, lose 1 Population.");
				SPTokenBad("Authorization of Brutal Force");
				break;
			case "Encourage Mutiny":
				plainAlert(z.players[player] + " must now choose a player (other than the Admiral or themselves), then roll a die.\r\n" +
					"On a 3+, that player receives the Admiral title; on a 1-2, -1 Morale.");
				addOption(player, "[Encourage Mutiny] Choose who would become Admiral", undefined, true);
				break;
			case "Food Rationing":
			case "Inspirational Speech":
				SPTokenBad(name);
				break;
			case "Presidential Pardon":
				if(isOnNewCaprica(z.president)) {
					if(someoneInDetention()) {
						addOption(player, "Move a player out of Detention", "Presidential Pardon", true);
					} else {
						plainAlert("Nobody is in Detention; no effect.");
					}
				} else {
					if(someoneInBrig()) {
						addOption(player, "Move a player out of the Brig", "Presidential Pardon", true);
					} else {
						plainAlert("Nobody is in the Brig; no effect.");
					}
				}
				break;
			case "Release Cylon Mugshots":
				if(z.detectorSabotage) {
					plainAlert("Detector Sabotage means you do not get to inspect a Loyalty card.");
				} else {
					plainAlert(z.players[player] + " must look at a random Loyalty card belonging to another player.\r\n" +
						"Then, roll a die; lose 1 Morale on a 1-3.");
					boldAlert("Remember to inspect Loyalty before rolling the die.");
					addOption(player, "Inspect a random Loyalty card of another player", undefined, true);
				}
				SPTokenBad("Release Cylon Mugshots");
				break;
			case "Civilian Self Defense": {
				let civsInSpace = 0;
				for(let j = 0; !(j >= 6); j++) {
					civsInSpace += z.spaceCivilians[j].length;
				}
				if(civsInSpace > 0) {
					plainAlert(z.players[player] + " must choose a Civilian ship and destroy either 3 Raiders or 1 Heavy Raider " +
						"in that ship's space area.\r\nThen, roll a die; destroy the Civilian on a 1-2.");
					addOption(player, "[Civilian Self Defense] Choose a civilian ship", undefined, true);
				} else {
					plainAlert("There are no Civilian ships in space; no effect.");
				}
				break;
			}
			case "Consult the Oracle":
				addAlert('Select "Process the effect of Consult the Oracle" to continue.');
				addOption(player, "Process the effect of Consult the Oracle", undefined, true);
				break;
			case "Enact Production Quotas":
				increaseFood();
				decreaseMorale();
				break;
			case "Eulogy":
				if(z.eulogy) {
					increaseMorale();
				} else {
					plainAlert("No morale has been lost from executions this game; no effect.");
				}
				break;
			case "Execute Prisoner":
				if(isOnNewCaprica(z.president)) {
					let validTargets = 0;
					let dude = -1;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.playerLocations[j] === "Detention") {
							dude = j;
							validTargets++;
						}
					}
					if(validTargets === 0) {
						plainAlert("Nobody is in Detention; no effect.");
					} else if(validTargets === 1) {
						executePlayer(dude);
					} else {
						plainAlert(z.players[player] + " must execute a player in Detention.");
						addOption(player, "Execute a player", "Detention", true);
					}
				} else {
					let validTargets = 0;
					let dude = -1;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.playerLocations[j] === "Brig") {
							dude = j;
							validTargets++;
						}
					}
					if(validTargets === 0) {
						plainAlert("Nobody is in the Brig; no effect.");
					} else if(validTargets === 1) {
						executePlayer(dude);
					} else {
						plainAlert(z.players[player] + " must execute a player in the Brig.");
						addOption(player, "Execute a player", "Brig", true);
					}
				}
				break;
			case "Resources for Galactica":
				if(z.galacticaAway) {
					if(damagedVipersII() > 0 || damagedVipersVII() > 0) {
						plainAlert("Now, repair up to 2 damaged vipers.");
						if(damagedVipersII() > 0) {
							addOption(player, "Repair a damaged Viper Mk II", ["Resources for Galactica", 2], false);
						}
						if(damagedVipersVII() > 0) {
							addOption(player, "Repair a damaged Viper Mk VII", ["Resources for Galactica", 2], false);
						}
					} else {
						plainAlert("No effect.");
					}
				} else {
					let any = true;
					if(canRepair()) {
						any = true;
						addOption(player, "Repair a location", undefined, false);
					}
					if(damagedVipersII() > 0) {
						any = true;
						addOption(player, "Repair a damaged Viper Mk II", ["Resources for Galactica", 2], false);
					}
					if(damagedVipersVII() > 0) {
						any = true;
						addOption(player, "Repair a damaged Viper Mk VII", ["Resources for Galactica", 2], false);
					}
					if(any){
						plainAlert("Now, repair up to 1 location and 2 damaged vipers.");
					} else {
						plainAlert("No effect.");
					}
				}
				break;
			case "Unsavory Connections":
				if(z.forLove && z.players[player] !== "Athena" && z.skillCardHands[player].length > 0) {
					plainAlert(z.players[player] + " must discard 2 random skill cards and draw 2 Treachery, then increase Food or Fuel by 1.\r\n" +
						"Note that Athena can Love them.");
					promptRandomDiscards(player, 2, true);
					addOption(player, "Draw 2 Treachery", true);
					addOption(player, "Increase a resource", "Unsavory Connections", true);
				} else {
					/* RULES: if you have to discard 2 cards and only have 1, can Athena still Love you? */
					for(let j = 0; !(j >= 2) && z.skillCardHands[player].length > 0; j++) {
						discardRandomSkillCard(player);
					}
					dealSkillCard(player, 5);
					dealSkillCard(player, 5);
					plainAlert(z.players[player] + " must increase Food or Fuel by 1.");
					addOption(player, "Increase a resource", "Unsavory Connections", true);
				}
				break;
			case "Establish Dogsville":
			case "Probation":
				increasePopulation();
				decreaseMorale();
				break;
			case "Presidential Order":
				if(z.CFB) {
					addAlert("Now, choose any player, and make them Admiral or CAG.");
					addOption(player, "Move the CAG title", undefined, true);
				} else {
					addAlert("Now, choose any player, and make them Admiral.");
				}
				addOption(player, "Move the Admiral title", undefined, true);
				break;
			case "Resignation":
				if((me === z.president && z.quorumHand.length > 0) || (z.players[me] === "Billy" && z.billyHand.length > 0)) {
					addAlert(
						"Now, discard any number of Quorums from your hand, draw an equal number of Quorums, then give the President title to another player."
						);
					addOption(player, "Discard a Quorum Card", "Resignation", false);
				} else {
					/* RULES: this */
					addAlert("Choose another player, then make them the President.");
					t.value += myPlayer + " must now make some player (apart from themselves) the " + colorText("orange", "President") + ".\r\n";
				}
				addOption(player, "Move the President title", "Resignation", true);
				break;
		}
		z.quorumDiscards.push(quorum);
	}
	if(characterPresent("Tory")) {
		if(z.vBrutality) {
			plainAlert("After the Quorum card resolves, remember that Tory may play a Consolidate Power due to her Adaptable ability.");
			addOption(getPlayerNum("Tory"), "Adaptable", "Adaptable", false);
		} else {
			plainAlert(
				"After the Quorum card resolves, remember that Tory may draw 2 skill cards (they may be outside her skill set) from her Adaptable ability.");
			if(hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				let n = getContext(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)");
				if(Number.isInteger(n)) {
					addOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)", n + 1, true);
				} else {
					addOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)", 2, true);
				}
				addOption(getPlayerNum("Tory"),"Pass on Adaptable",true);
			} else {
				addOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)", 1, true);
				addOption(getPlayerNum("Tory"),"Pass on Adaptable",true);
			}
		}
	}
}

function interruptsToken() {
	let crisisName = "";
	if(Number.isInteger(z.currentSkillCheck)) {
		crisisName += d.crisisNames[z.currentSkillCheck];
	} else {
		crisisName += z.currentSkillCheck;
	}
	let qre = new RegExp('\\[q=' + bl + '"BYC: Interrupts for ' + crisisName + '"\\]((?!(\\[q' + bl + '=|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	t.value = t.value.replace(qre, "");
	let text = '[q=' + bl + '"BYC: Interrupts for ' + crisisName + '"]\r\n' + size(bold("Interrupts for "), 14) + size(difficultyTemplate(), 14) + "\r\n";
	let interruptPossibilities = [];
	if(!z.investigativeCommittee) {
		interruptPossibilities.push(colorText("orange", "Investigative Committee"));
	}
	if(!z.thisEngineering) {
		interruptPossibilities.push(colorText("blue", "Scientific Research"));
	}
	if(z.daybreak && ((z.miracles[z.turn] === 0 && z.revealedCylons[z.turn] === 0) || (3 > z.miracles[z.turn] && z.players[z.turn] === "Gaius" && z
			.revealedCylons[z.turn] === 0) || (z.revealedCylons[z.turn] === 0 && (!Number.isInteger(z.currentSkillCheck) || !isSuperCrisis(z
			.currentSkillCheck)) && (z.players[z.turn] === "Dee" || (z.players[z.turn] === "Chief" && !z.vBrutality) || (z.players[z.turn] === "Tigh" &&
			z.vBrutality) || z.players[z.turn] === "Cally" || (z.players[z.turn] === "Shaw" && !(versionAtLeast([2,1,14]))) || (z.players[z.turn] === "Cottle" && z.vBrutality))) || (
			isTheCylonLeader(z.turn) && (z.miracles[z.turn] === 0 || (z.players[z.turn] === "Six" && (!Number.isInteger(z.currentSkillCheck) || !
				isSuperCrisis(z.currentSkillCheck)))) || (characterPresent("Apollo") && z.exodus && !z.vBrutality && (z.revealedCylons[z.turn] === 0 || 
				isTheCylonLeader(z.turn)))))) {
		/* RULES: Can apollo use AVP from protect the fleet on a super crisis? */
		interruptPossibilities.push(colorText("purple", "A Second Chance"));
	}
	if(z.daybreak && !z.pegasus && !z.restoreOrder) {
		interruptPossibilities.push(colorText("green", "Restore Order"));
	} else if(z.pegasus && ((z.criticalMission && versionAtLeast([2,1,13])) || !recklessROPlayed())) {
		let recklessText = "";
		if(z.criticalMission && versionAtLeast([2,1,13])){
			recklessText = "ANY of the following: ";
		} else {
			recklessText = "ONE of the following: ";
		}
		if(z.currentSkillCheck !== "Airlock" && z.currentSkillCheck !== "Resistance HQ") {
			recklessText += colorText("green", "At Any Cost") + ", ";
		}
		recklessText += colorText("orange", "Support the People") + ", " + colorText("blue", "Jury Rigged") + ", ";
		if(z.daybreak) {
			recklessText += colorText("purple", "Guts and Initiative");
			if(z.criticalMission && versionAtLeast([2,1,13])){
				recklessText += "; OR ";
			} else {
				recklessText += ", or ";
			}
			recklessText += colorText("green", "Restore Order");
		} else {
			recklessText += "or " + colorText("purple", "Guts and Initiative");
		}
		interruptPossibilities.push(recklessText);
	}
	if(interruptPossibilities.length > 0) {
		text += "Looking for ";
		for(let i = 0; !(i >= interruptPossibilities.length); i++) {
			if(i === interruptPossibilities.length - 1 && i !== 0) {
				text += "and/or ";
			}
			text += interruptPossibilities[i ];
			if(i === interruptPossibilities.length - 1) {
				text += ".\r\n\r\n";
			} else {
				text += ",\r\n";
			}
		}
	}
	if(z.players[z.crisisPlayer] === "Adama" && !z.vBrutality && z.players[z.turn] === "Adama" && Number.isInteger(z.currentSkillCheck) && !isSuperCrisis(z.currentCrisis) && !isMission(z
		.currentCrisis) && !z.capricaCrisis) {
		text += "It is " + bold("Adama") + "'s turn.  All 1-strength skill cards are positive.\r\n";
	}
	if(z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[z.turn] === "Adama" && Number.isInteger(z.currentSkillCheck) && !isSuperCrisis(z.currentCrisis) &&
		!isMission(z.currentCrisis) && !z.capricaCrisis) {
		text += "It is " + bold("Adama") + "'s turn.  All 1-strength skill cards count as 2-strength.\r\n";
	}
	for(let i = z.turn + 1; !(i > z.turn + z.numPlayers); i++) {
		let interruptPlayer = i % z.numPlayers;
		let cards = z.skillCardHands[interruptPlayer].length;
		for(let j = 0; !(j >= z.interrupts[interruptPlayer].length); j++) {
			if(/Scientific Research/.test(z.interrupts[interruptPlayer][j]) || /Investigative Committee/.test(z.interrupts[interruptPlayer][j]) ||
				/Restore Order/.test(z.interrupts[interruptPlayer][j]) || /Support the People/.test(z.interrupts[interruptPlayer][j]) || /At Any Cost/.test(z
					.interrupts[interruptPlayer][j]) || /Guts and Initiative/.test(z.interrupts[interruptPlayer][j]) || /Jury Rigged/.test(z.interrupts[
					interruptPlayer][j]) || /A Second Chance/.test(z.interrupts[interruptPlayer][j]) || /Political Prowess/.test(z.interrupts[interruptPlayer][
					j])) {
				cards++;
			}
		}
		text += z.players[interruptPlayer] + " (" + cards + ") - ";
		if(z.tank[interruptPlayer] && z.interrupts[interruptPlayer].length === 0) {
			text += "TANK";
		} else if(z.revealedCylons[interruptPlayer] === 1) {
			text += "PASS: Cylon";
		} else if(z.skillCardHands[interruptPlayer].length === 0 && z.interrupts[interruptPlayer].length === 0 && interruptChoices(interruptPlayer).length ===
			0) {
			text += "PASS: No Cards";
		} else if(z.interrupts[interruptPlayer].length > 0) {
			for(let j = 0; !(j >= z.interrupts[interruptPlayer].length); j++) {
				text += z.interrupts[interruptPlayer][j];
				if(j !== z.interrupts[interruptPlayer].length - 1) {
					text += ", ";
				}
			}
			if(z.tank[interruptPlayer]) {
				text += ", TANK";
			}
		} else if(!z.pegasus && !z.daybreak && interruptChoices(interruptPlayer).length === 0) {
			if(z.thisEngineering) {
				if(z.possibleColors[interruptPlayer][0] === 0) {
					text += "PASS: No Politics";
				}
			} else {
				if(z.possibleColors[interruptPlayer][0] === 0 && z.possibleColors[interruptPlayer][4] === 0) {
					text += "PASS: No Politics or Engineering";
				}
			}
		}
		text += "\r\n";
	}
	text += "[/" + "q]\r\n";
	t.value += text;
}

function cardCompare(a, b) {
	if(cardColorID(a) > cardColorID(b)) {
		return 1;
	}
	if(cardColorID(b) > cardColorID(a)) {
		return -1;
	}
	if(cardValue(a) > cardValue(b)) {
		return 1;
	}
	if(cardValue(b) > cardValue(a)) {
		return -1;
	}
	if(a > b) {
		return 1;
	}
	if(b > a) {
		return -1;
	}
	return 0;
}

function spaceCiviliansList() {
	let list = [];
	for(let i = 0; !(i >= 6); i++) {
		for(let j = 0; !(j >= z.spaceCivilians[i ].length); j++) {
			list.push([z.spaceCivilians[i ][j], i, j]);
		}
	}
	return list;
}

function sortedSkillCheck(includeDestiny) {
	let list = [];
	for(let i = 0; !(i >= z.skillCheckCards.length); i++) {
		if(i === z.numPlayers && !includeDestiny) {
			break;
		}
		for(let j = 0; !(j >= z.skillCheckCards[i ].length); j++) {
			list.push(z.skillCheckCards[i ][j]);
		}
	}
	list = list.concat(z.fastLearner);
	return list.sort(cardCompare);
}

function isSuperCrisis(crisis) {
	return Number.isInteger(crisis) && crisis >= 160 && !(crisis >= 173);
}

function isMission(crisis) {
	return Number.isInteger(crisis) && crisis >= 203;
}

function consequenceTriggered() {
	for(let j = 0; !(j >= z.revealedCards.length); j++) {
		switch (cardName(z.revealedCards[j])) {
			case "Red Tape":
			case "Iron Will":
			case "Trust Instincts":
			case "Protect the Fleet":
			case "Establish Network":
			case "Force Their Hand":
			case "All Hands on Deck":
			case "Quick Thinking":
			case "Dogfight":
			case "Install Upgrades":
			case "Bait":
			case "Dradis Contact":
			case "A Better Machine":
			case "Personal Vices":
			case "Violent Outbursts":
			case "Exploit Weakness":
			case "By Your Command":
			case "Broadcast Location":
			case "Special Destiny":
				return true;
		}
	}
	return false;
}

function skillCheckEffects() {
	let ef = [];
	if(z.restoreOrder || z.currentSkillCheck >= 203) {
		return ef;
	}
	let redTape = false;
	let ironWill = false;
	let trustInstincts = false;
	let protectTheFleet = false;
	let establishNetwork = false;
	let forceTheirHand = false;
	let allHandsOnDeck = false;
	let quickThinking = false;
	let dogfight = false;
	let installUpgrades = false;
	let bait = false;
	let dradisContact = false;
	let personalVices = false;
	let aBetterMachine = false;
	let violentOutbursts = false;
	let exploitWeakness = false;
	let byYourCommand = false;
	let specialDestiny = false;
	let broadcastLocation = false;
	for(let j = 0; !(j >= z.revealedCards.length); j++) {
		let name = cardName(z.revealedCards[j]);
		switch (name) {
			case "Red Tape":
				if(!redTape && !z.redTape) {
					ef.push(name);
				}
				redTape = true;
				break;
			case "Iron Will":
				if(!ironWill && !z.ironWill) {
					ef.push(name);
				}
				ironWill = true;
				break;
			case "Trust Instincts":
				if(!trustInstincts && !z.trustInstincts) {
					ef.push(name);
				}
				trustInstincts = true;
				break;
			case "Protect the Fleet":
				if(!protectTheFleet && !z.protectTheFleet) {
					ef.push(name);
				}
				protectTheFleet = true;
				break;
			case "Establish Network":
				if(!establishNetwork && !z.establishNetwork) {
					ef.push(name);
				}
				establishNetwork = true;
				break;
			case "Force Their Hand":
				if(!forceTheirHand && !z.forceTheirHand) {
					ef.push(name);
				}
				forceTheirHand = true;
				break;
			case "All Hands on Deck":
				if(!allHandsOnDeck && !z.allHandsOnDeck) {
					ef.push(name);
				}
				allHandsOnDeck = true;
				break;
			case "Quick Thinking":
				if(!quickThinking && !z.quickThinking) {
					ef.push(name);
				}
				quickThinking = true;
				break;
			case "Dogfight":
				if(!dogfight && !z.dogfight) {
					ef.push(name);
				}
				dogfight = true;
				break;
			case "Install Upgrades":
				if(!installUpgrades && !z.installUpgrades) {
					ef.push(name);
				}
				installUpgrades = true;
				break;
			case "Bait":
				if(!bait && !z.bait) {
					ef.push(name);
				}
				bait = true;
				break;
			case "Dradis Contact":
				if(!dradisContact && !z.dradisContact) {
					ef.push(name);
				}
				dradisContact = true;
				break;
			case "Personal Vices":
				if(!personalVices && !z.personalVices) {
					ef.push(name);
				}
				personalVices = true;
				break;
			case "A Better Machine":
				if(!aBetterMachine && !z.aBetterMachine) {
					ef.push(name);
				}
				aBetterMachine = true;
				break;
			case "Violent Outbursts":
				if(!violentOutbursts && !z.violentOutbursts) {
					ef.push(name);
				}
				violentOutbursts = true;
				break;
			case "Exploit Weakness":
				if(!exploitWeakness && !z.exploitWeakness) {
					ef.push(name);
				}
				exploitWeakness = true;
				break;
			case "Special Destiny":
				if(!specialDestiny && !z.specialDestiny && z.reckless) {
					ef.push(name);
				}
				specialDestiny = true;
				break;
			case "By Your Command":
				if(!byYourCommand && !z.byYourCommand && z.reckless) {
					ef.push(name);
				}
				byYourCommand = true;
				break;
			case "Broadcast Location":
				if(!broadcastLocation && !z.broadcastLocation && z.reckless) {
					ef.push(name);
				}
				broadcastLocation = true;
				break;
		}
	}
	return ef;
}

function normalSkillCheckEffects() {
	if(z.players[z.turn] === "Cally" && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && !z.quickFix) {
		return false;
	}
	let ef = skillCheckEffects();
	if(ef.includes("Force Their Hand") && z.revealedCylons[z.turn] === 0 && (z.skillCardHands[z.turn].length > 0 || characterPresent("Tom") || (z.players[z
			.turn] === "Lee" && z.turn !== z.theSympatheticCylon && !noDrawback(z.turn)) || z.mutinies[z.turn].length >= 2 || (z.turn !== z.theMutineer && z
			.mutinies[z.turn].length === 1) || ef.includes("Personal Vices"))) {
		return false;
	}
	if(ef.includes("Quick Thinking")) {
		for(let j = 0; !(j >= z.revealedCards.length); j++) {
			if(3 >= cardValue(z.revealedCards[j]) && cardName(z.revealedCards[j]) !== "Quick Thinking") {
				return false;
			}
		}
	}
	if(ef.includes("Trust Instincts") && (z.daybreak || ef.includes("Red Tape") || ef.includes("Protect the Fleet"))) {
		return false;
	}
	if(ef.includes("Protect the Fleet")) {
		let piloting = 0;
		for(let j = 0; !(j >= z.revealedCards.length); j++) {
			if(cardColorID(z.revealedCards[j]) === 3) {
				piloting += cardValue(z.revealedCards[j]);
			}
		}
		if(piloting >= 3) {
			return false;
		}
	}
	if(ef.includes("Dogfight")) {
		for(let j = 0; !(j >= z.vipersII.length); j++) {
			if(z.vipersII[j] >= 0) {
				return false;
			}
		}
		for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
			if(z.vipersVII[j] >= 0) {
				return false;
			}
		}
		for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(z.assaultRaptors[j] >= 0) {
				return false;
			}
		}
	}
	if(ef.includes("Exploit Weakness")) {
		return false;
	}
	if(ef.includes("Broadcast Location") && ef.includes("By Your Command") && !z.galacticaAway) {
		return false;
	}
	if(ef.includes("A Better Machine") && ef.includes("Personal Vices")) {
		let numHumans = 0;
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.revealedCylons[j] === 0) {
				numHumans++;
			}
		}
		if(2 + numHumans > z.skillCardDecks[5].length) {
			return false;
		}
	}
	if(ef.includes("Violent Outbursts") && z.vAltTrauma && z.preCrossroads) {
		return false;
	}
	return true;
}

function skillCheckTally(revealDestiny) {
	let establishNetwork = z.establishNetwork;
	let restoreOrder = z.restoreOrder || (Number.isInteger(z.currentSkillCheck) && isMission(z.currentCrisis));
	let AHoD = z.allHandsOnDeck;
	let ironWill = z.ironWill;
	let redTape = false;
	let trustInstincts = false;
	let colorTallies = [0, 0, 0, 0, 0, 0];
	let zeroTallies = 0;
	let bigTallies = 0;
	let bigBlueTallies = 0;
	let adama = !z.vBrutality && z.players[z.crisisPlayer] === "Adama" && Number.isInteger(z.currentSkillCheck) && !isSuperCrisis(z.currentCrisis) && !
		isMission(z.currentCrisis) && !z.capricaCrisis;
	let adamaBrutality = z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[z.crisisPlayer] === "Adama" && Number.isInteger(z.currentSkillCheck) && !
		isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis) && !z.capricaCrisis;
	let cardList;
	if(!z.skillCheckRevealed) {
		cardList = sortedSkillCheck(revealDestiny);
	} else {
		cardList = z.revealedCards;
	}
	for(let i = 0; !(i >= cardList.length); i++) {
		let name = cardName(cardList[i ]);
		let value = cardValue(cardList[i ]);
		let color = cardColorID(cardList[i ]);
		if(name === "Establish Network") {
			establishNetwork = true;
		}
		if(name === "Red Tape" && !z.redTape) {
			redTape = true;
		}
		if(name === "Trust Instincts" && !z.trustInstincts) {
			trustInstincts = true;
		}
		if(name === "All Hands on Deck") {
			AHoD = true;
		}
		if(name === "Iron Will") {
			ironWill = true;
		}
		if(value === 0) {
			zeroTallies++;
		} else {
			let sign = -1;
			if((color === 0 && z.thisPolitics) || (color === 1 && z.thisLeadership) || (color === 2 && z.thisTactics) || (color === 3 && z.thisPiloting) || (
					color === 4 && z.thisEngineering) || (color === 5 && z.thisTreachery)) {
				sign = 1;
			}
			if(adama && value === 1 && sign === -1) {
				colorTallies[color] -= 1;
			} else {
				if(adamaBrutality && value === 1) {
					value = 2;
				}
				colorTallies[color] += value;
			}
			if(value >= 5 && z.blindDevotion !== color) {
				bigTallies -= sign * value;
			}
			if(color === 4 && value >= 5) {
				bigBlueTallies -= sign * value;
			}
		}
	}
	let tally = 0;
	let text = "";
	if(!revealDestiny) {
		text += "Running ";
	} else if(skillCheckEffects().length > 0) {
		text += "Preliminary ";
	}
	text += "Tally: ";
	for(let color = 0; !(color >= 6); color++) {
		let sign = -1;
		let plusMinus = "-";
		if((color === 0 && z.thisPolitics) || (color === 1 && z.thisLeadership) || (color === 2 && z.thisTactics) || (color === 3 && z.thisPiloting) || (
				color === 4 && z.thisEngineering) || (color === 5 && z.thisTreachery)) {
			sign = 1;
			plusMinus = "+";
		}
		if(z.blindDevotion === color) {
			text += colorText(colorIDcolor(color), "+ 0 ") + "(Blind Devotion) ";
		} else if(colorTallies[color] > 0) {
			tally += sign * colorTallies[color];
			text += colorText(colorIDcolor(color), plusMinus + " " + colorTallies[color] + " ");
		} else if(0 > colorTallies[color]) {
			/* RULES: chief vs. adama */
			tally += -colorTallies[color];
			text += colorText(colorIDcolor(color), "+ " + (-colorTallies[color]) + " ");
		}
	}
	if(AHoD && zeroTallies > 0 && !restoreOrder) {
		tally += zeroTallies;
		text += "+ " + zeroTallies + " (AHoD) ";
	}
	if(establishNetwork && colorTallies[4] !== 0 && z.blindDevotion !== 4 && !restoreOrder) {
		if(z.thisEngineering) {
			tally += colorTallies[4];
			text += colorText("blue", "+ " + colorTallies[4] + " ") + "(Establish Network) ";
		} else {
			if(0 > colorTallies[4]) {
				tally -= colorTallies[4];
				text += colorText("blue", "+ " + (-colorTallies[4]) + " ") + "(Establish Network) ";
			} else {
				tally -= colorTallies[4];
				text += colorText("blue", "- " + colorTallies[4] + " ") + "(Establish Network) ";
			}
		}
	}
	if(redTape && !restoreOrder) {
		if(establishNetwork && z.blindDevotion !== 4) {
			bigTallies += bigBlueTallies;
		}
		tally += bigTallies;
		if(bigTallies > 0) {
			text += "+ " + bigTallies + " (Red Tape) ";
		} else if(0 > bigTallies) {
			text += "- " + (-bigTallies) + " (Red Tape) ";
		}
	}
	if(!revealDestiny && !z.guts) {
		text += "± Destiny ";
	}
	if(trustInstincts && !restoreOrder) {
		text += "± " + colorText("purple", "Trust Instincts ");
	}
	if(!revealDestiny && z.investigativeCommittee && z.fastLearner.length > 0 && z.vBrutality) {
		text += "± Fast Learner ";
	}
	text += "= ";
	let airlockModifier = 0;
	if(z.currentSkillCheck === "Airlock" && z.playerLocations[z.thisTarget] === "Brig") {
		airlockModifier = 4;
	}
	let result = "";
	if(tally >= (z.thisDifficulty - airlockModifier)) {
		text += bold(colorText("green", tally + " - PASS"));
		result = "PASS";
	} else if(z.thisPartial !== 0 && tally >= z.thisPartial) {
		text += bold(colorText("orange", tally + " - PARTIAL"));
		result = "PARTIAL";
	} else if((z.ironWill || ironWill) && tally >= (z.thisDifficulty - airlockModifier - 4) && !restoreOrder) {
		text += bold(colorText("orange", tally + " - FAIL (prevented by Iron Will)"));
		result = "PREVENTED FAIL";
	} else {
		text += bold(colorText("red", tally + " - FAIL"));
		result = "FAIL";
	}
	if((z.ironWill || ironWill) && 0 >= tally && !restoreOrder) {
		text += bold(colorText("red", " + Morale Loss from Iron Will"));
	}
	if(z.secondChance) {
		let goal = 1000;
		switch (z.currentSkillCheck) {
			case "Airlock":
				goal = 16;
				break;
			case "Brig":
			case "Admiral's Quarters":
			case "Resistance HQ":
				goal = 11;
				break;
			case "Detention":
				goal = 13;
				break;
			default:
				goal = d.difficulty[z.currentSkillCheck] + 4;
		}
		if(tally >= goal && (z.revealedCylons[z.turn] === 0 || isTheCylonLeader(z.turn))) {
			text += " + " + colorText("purple", "A Second Chance");
		}
	}
	if(z.currentSkillCheck === "Admiral's Quarters" && characterPresent("Cain") && tally >= 10 && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
		text += " + Intolerant?";
	}
	return [text, result, tally];
}

function autoPass(contributor) {
	if(contributor === z.numPlayers) {
		return false;
	}
	let j = (z.turn + contributor + 1) % z.numPlayers;
	if(z.tank[j]) {
		return true;
	}
	if(z.skillCardHands[j].length === 0) {
		return true;
	}
	if(z.players[j] === "Cally" && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Detention" && z.revealedCylons[j] === 0 && z.skillCardHands[j]
		.length === 1 && z.skillCheckCards[j].length === 0 && !noDrawback(j)) {
		return true;
	}
	if(z.players[j] === "Doral" && z.vanity) {
		return true;
	}
	if(Array.isArray(z.trialWithoutProcess) && z.trialWithoutProcess[j]){
		return true;
	}
	return false;
}

function checkNotStarted() {
	if(z.skillCheckCards[z.numPlayers].length > 0) {
		return false;
	}
	if(z.revealedCards.length > 0) {
		return false;
	}
	if(z.autoPass || z.processedOutcome) {
		return false;
	}
	if(!z.guts) {
		return true;
	}
	if(z.contributingPlayer === 0) {
		return true;
	}
	for(let j = z.contributingPlayer - 1; j >= 0; j--) {
		if(!autoPass(j)) {
			return false;
		}
	}
	return true;
}

function maxSkillCards(j) {
	if(z.numPlayers + z.boxedPlayers.length === 1 && (z.playerLocations[j] === "Brig" || z.playerLocations[j] === "Detention")) {
		return 3;
	}
	if((z.revealedCylons[j] === 1 && (z.players[j] !== "Simon" || z.currentSkillCheck >= 203)) || z.playerLocations[j] === "Brig") {
		return 1;
	} else if((z.players[j] === "Simon" && (z.revealedCylons[j] === 1 || z.currentSkillCheck >= 203)) || (z.players[j] !== "Simon" && isCylonLeader(z.players[
			j]) && !z.multiCL) || z.playerLocations[j] === "Detention") {
		return 2;
	} else if((z.players[j] === "Simon" && !z.multiCL) || (z.players[j] !== "Simon" && isCylonLeader(z.players[j])) || (z.players[j] === "Gaeta" && !noDrawback(j) && !z.vBrutality)) {
		return 3;
	} else if(z.players[j] === "Simon"){
		return 4;
	}
	return 201;
}

function recklessROPlayed(){
	for(let i = 0; !(i >= z.numPlayers); i++) {
		for(let j = 0; !(j >= z.interrupts[i ].length); j++) {
			if(/Restore Order/.test(z.interrupts[i ][j])){
				return true;
			}
			if(/Support the People/.test(z.interrupts[i ][j])){
				return true;
			}
			if(/At Any Cost/.test(z.interrupts[i ][j])){
				return true;
			}				
		    if(/Guts and Initiative/.test(z.interrupts[i ][j])){
				return true;
			}
			if(/Jury Rigged/.test(z.interrupts[i ][j])) {
				return true;
			}
		}
	}
	return false;
}

function duplicateInterrupts() {
	let SRs = [];
	let ICs = [];
	let RO = [];
	let StP = [];
	let AAC = [];
	let GI = [];
	let JR = [];
	for(let i = 0; !(i >= z.numPlayers); i++) {
		for(let j = 0; !(j >= z.interrupts[i ].length); j++) {
			if(/Scientific Research/.test(z.interrupts[i ][j])) {
				SRs.push([i, j]);
			}
			if(/Investigative Committee/.test(z.interrupts[i ][j])) {
				ICs.push([i, j]);
			}
			if(/Restore Order/.test(z.interrupts[i ][j])){
				RO.push([i, j]);
			}
			if(/Support the People/.test(z.interrupts[i ][j])){
				StP.push([i, j]);
			}
			if(/At Any Cost/.test(z.interrupts[i ][j])){
				AAC.push([i, j]);
			}				
		    if(/Guts and Initiative/.test(z.interrupts[i ][j])){
				GI.push([i, j]);
			}
			if(/Jury Rigged/.test(z.interrupts[i ][j])) {
				JR.push([i, j]);
			}
		}
	}
	let duplicates = [];
	if(SRs.length > 1) {
		duplicates = duplicates.concat(SRs);
	}
	if(ICs.length > 1) {
		duplicates = duplicates.concat(ICs);
	}
	if(z.criticalMission && versionAtLeast([2,1,13])){
		if(RO.length > 0 && (StP.length + AAC.length + GI.length + JR.length > 0)){
			duplicates = duplicates.concat(RO);
			duplicates = duplicates.concat(StP);
			duplicates = duplicates.concat(AAC);
			duplicates = duplicates.concat(GI);
			duplicates = duplicates.concat(JR);
		} else {
			if(RO.length > 1){
				duplicates = duplicates.concat(RO);
			}
			if(StP.length > 1){
				duplicates = duplicates.concat(StP);
			}
			if(AAC.length > 1){
				duplicates = duplicates.concat(AAC);
			}
			if(GI.length > 1){
				duplicates = duplicates.concat(GI);
			}
			if(JR.length > 1){
				duplicates = duplicates.concat(JR);
			}
		}
	} else {
		if(RO.length + StP.length + AAC.length + GI.length + JR.length > 1){
			duplicates = duplicates.concat(RO);
			duplicates = duplicates.concat(StP);
			duplicates = duplicates.concat(AAC);
			duplicates = duplicates.concat(GI);
			duplicates = duplicates.concat(JR);
		}
	}
	return duplicates;
}

function canUseProbation() {
	if(isMission(z.currentSkillCheck)) {
		return false;
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		for(let k = 0; !(k >= z.quorumTitles[j].length); k++) {
			if(d.quorumNames[z.quorumTitles[j][k]] === "Probation" && z.skillCheckCards[j].length > 0) {
				return true;
			}
		}
	}
	return false;
} /* only use when *I* play or pass */
function canIContribute() {
	while(autoPass(z.contributingPlayer)) {
		z.contributingPlayer++;
	}
	if(z.skillCheckCards[me].length >= maxSkillCards(me)) {
		return false;
	}
	let contributingMe = (me - z.turn - 1 + z.numPlayers) % z.numPlayers;
	if(autoPass(contributingMe)) {
		return false;
	}
	if(!(z.contributingPlayer >= contributingMe)) {
		return false;
	}
	if(z.contributingPlayer === contributingMe) {
		return true;
	}
	if(z.skillCheckCards[me].length === 0) {
		return false;
	}
	let b = true;
	for(let i = z.contributingPlayer - 1; b && i > contributingMe; i--) {
		b = autoPass(i);
	}
	return b;
}

function vipersIIReserves() {
	let count = 0;
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === 0) {
			count++;
		}
	}
	return count;
}

function vipersVIIReserves() {
	let count = 0;
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === 0) {
			count++;
		}
	}
	return count;
}

function assaultRaptorsReserves() {
	let count = 0;
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(z.assaultRaptors[i ] === 0) {
			count++;
		}
	}
	return count;
}

function isUnmannedInSpace() {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(Number.isInteger(z.vipersII[i ]) && z.vipersII[i ] > 0) {
			return true;
		}
	}
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(Number.isInteger(z.vipersVII[i ]) && z.vipersVII[i ] > 0) {
			return true;
		}
	}
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(Number.isInteger(z.assaultRaptors[i ]) && z.assaultRaptors[i ] > 0) {
			return true;
		}
	}
}

function playerLocation(player) {
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(player === z.players[i ]) {
			return z.playerLocations[i ];
		}
	}
}

function mannedVipersList() {
	let l = [];
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(!Number.isInteger(z.vipersII[i ])) {
			l.push(["Viper Mk II", i, z.vipersII[i ], playerLocation(z.vipersII[i ])]);
		}
	}
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(!Number.isInteger(z.vipersVII[i ])) {
			l.push(["Viper Mk VII", i, z.vipersVII[i ], playerLocation(z.vipersVII[i ])]);
		}
	}
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(!Number.isInteger(z.assaultRaptors[i ])) {
			l.push(["Assault Raptor", i, z.assaultRaptors[i ], playerLocation(z.assaultRaptors[i ])]);
		}
	}
	return l;
}

function unmannedVipersList() {
	let l = [];
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(Number.isInteger(z.vipersII[i ]) && z.vipersII[i ] > 0) {
			l.push(["Viper Mk II", i, z.vipersII[i ]]);
		}
	}
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(Number.isInteger(z.vipersVII[i ]) && z.vipersVII[i ] > 0) {
			l.push(["Viper Mk VII", i, z.vipersVII[i ]]);
		}
	}
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(Number.isInteger(z.assaultRaptors[i ]) && z.assaultRaptors[i ] > 0) {
			l.push(["Assault Raptor", i, z.assaultRaptors[i ]]);
		}
	}
	return l;
}

function mutinyPlayable(mut) {
	switch (mut) {
		case 1:
			return (me !== z.admiral && z.skillCardHands[me].length >= 5 && z.playerLocations[me] !== "Brig");
		case 4:
			return (me !== z.president && z.skillCardHands[z.president].length >= 3);
		case 5:
			return (isUnmannedInSpace() || mannedVipersList().length > 0);
		case 8:
			return (me !== z.president && z.skillCardHands[me].length >= 5);
		case 9:
			return (!isOnNewCaprica(me) && someoneInBrig()) || (someoneInDetention() && isOnNewCaprica(me));
		case 17:
			return (me !== z.president);
		case 19:
			return (z.nukes !== 0);
		case 21:
			return (z.raptors !== 0);
	}
	return true;
}

function noDrawback(player) {
	return z.players.length + z.boxedPlayers.length === 1 || player === z.momentOfHeroism || player === z.theSympatheticCylon;
}
function playMutiny(mut) {
	addAlert("You play " + d.mutinyNames[mut]);
	t.value += bold(myPlayer + " plays " + d.mutinyNames[mut]) + ".\r\n";
	switch (d.mutinyNames[mut]) {
		case "Feed the People":
			decreaseJump();
			decreaseJump();
			increaseFood();
			t.value += "Feed the People is removed from the game.\r\n";
			z.mutinyDiscards.pop();
			break;
		case "The Strong Survive":
			if(destroyPileCivilian(1)) {
				increaseJump();
			} else {
				plainAlert("Once the civilian destruction is fully resolved, increase the Jump Preparation Track by 1.");
				addOption(me, "Advance the Jump Preparation Track", undefined, true);
			}
			t.value += "The Strong Survive is removed from the game.\r\n";
			z.mutinyDiscards.pop();
			break;
		case "Controversial Speech":
			SPTokenBad("Controversial Speech");
			break;
		case "Betrayal of Trust": {
			let card1 = dealSkillCard(me, 5);
			let card2 = dealSkillCard(me, 5);
			addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + ".  Now, scout the Destination deck.");
			z.scoutingDestination = true;
			z.scout = me;
			let dest = z.destinationDeck.pop();
			z.scouted.push(dest);
			addAlert("The top card of the Destination deck is:\n\n" + d.destinationNames[dest] +
				"\n\nNow, return this card to the top or the bottom of the Destination deck.");
			t.value += myPlayer + " scouts the Destination deck.\r\n";
			break;
		}
		case "Blackmail": {
			let card1 = shuffle(z.skillCardHands[z.president]).pop();
			let card2 = z.skillCardHands[z.president].pop();
			let card3 = z.skillCardHands[z.president].pop();
			addAlert("You steal " + cardText(card1) + ", " + cardText(card2) + ", and " + cardText(card3) + ".");
			t.value += myPlayer + " steals 3 random skill cards from " + colorText("orange", "President") + " " + z.players[z.president] + ".\r\n";
			z.skillCardHands[me].push(card1);
			z.skillCardHands[me].push(card2);
			z.skillCardHands[me].push(card3);
			for(let j = 0; !(j>=z.possibleColors[me].length); j++){
				if(z.possibleColors[z.president][j]){
					z.possibleColors[me][j] = 1;
				}
			}
			checkEmptyColors(z.president);
			break;
		}
		case "Make a Deal":
			if(isOnNewCaprica(me)) {
				if(z.galacticaAway){
					addAlert("Now, choose a character in Detention and move them to any Location on New Caprica. Then, deal a Mutiny card to a player.");
				} else {
					addAlert("Now, choose a character in Detention and move them to any Location on Galactica. Then, deal a Mutiny card to a player.");
				}
				addOption(me, "Move a player out of Detention", "Make a Deal", true);
			} else {
				addAlert("Now, choose a character in the Brig and move them to any Location on Galactica. Then, deal a Mutiny card to a player.");
				addOption(me, "Move a player out of the Brig", "Make a Deal", true);
			}
			break;
		case "Assume Command":
			/* TODO: RULES: CL */ addAlert("Now, discard 5 cards then take the Admiral title.");
			if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
				addOption(me, "Discard a Skill Card", 4, true);
				addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
			} else {
				addOption(me, "Discard a Skill Card", 5, true);
			}
			addOption(me, "Move the Admiral title", "Assume Command", true);
			break;
		case "Impeachment":
			/* RULES: CL */ addAlert("Now, discard 5 cards then take the President title.");
			if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
				addOption(me, "Discard a Skill Card", 4, true);
				addOption(me, "Choose a Skill Card to discard if Athena does not Love you", true);
			} else {
				addOption(me, "Discard a Skill Card", 5, true);
			}
			if(!isTheCylonLeader(me) && me !== z.theSympatheticCylon) {
				addOption(me, "Move the President title", "Impeachment", true);
			}
			break;
		case "Bait and Switch":
			addOption(me, "Draw 2 Skill Cards (any color)", 1, true);
			if(z.skillCardDecks[5].length >= 4) {
				shuffleTreachery();
				addAlert("Now, draw 2 skill cards (they may be from outside your skill set).");
			} else {
				addAlert("Now, draw 2 skill cards (they may be from outside your skill set).  Then, shuffle 2 " + colorText("brown", "Treachery") +
					" into Destiny.");
				addOption(me, "Shuffle 2 Treachery into Destiny", undefined, true);
			}
			break;
		case "Ruined Reputation": {
			let extra = "";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.revealedCylons[j] === 0) {
					if(isOnNewCaprica(j)) {
						extra = " (Detention if on New Caprica)";
					}
				}
			}
			addAlert("Now, choose a Human player to target.  They may draw 2 skill cards of any color, then roll a die to see if they are sent to the Brig" +
				extra + ".");
			t.value += myPlayer +
				" must now choose a Human player.\r\nThat player may draw 2 skill cards (they may be from outside their skill set.)\r\n" +
				"Then, roll a die; on a 1-4, they are sent to the Brig" + extra + ".\r\n";
			addOption(me, "[Ruined Reputation] Choose a target", undefined, true);
			break;
		}
		case "Peaceful Resistance":
			if(z.playerLocations[me] === "Detention") {
				addAlert("You stay in Detention.");
			} else if(z.playerLocations[me] === "Brig") {
				addAlert("You stay in the Brig.");
			} else if(z.playerLocations[me] === "Sickbay") {
				addAlert("You remain in Sickbay");
			} else if(z.playerLocations[me] === "Medical Center") {
				addAlert("You remain in the Medical Center");
			} else if(isOnNewCaprica(me)) {
				addAlert("You are moved to the Medical Center.");
				movePlayer(me, "Medical Center");
			} else {
				addAlert("You are moved to Sickbay.");
				movePlayer(me, "Sickbay");
			}
			if(z.playerLocations[z.admiral] === "Brig") {
				plainAlert("The Admiral is already in the Brig.");
			} else if(z.playerLocations[z.admiral] === "Detention") {
				plainAlert("The Admiral is already in Detention.");
			} else {
				SPTokenBad("Peaceful Resistance");
			}
			break;
		case "Necessary Risk":
			increaseFood();
			if(!z.galacticaAway) {
				addAlert("Now, place 1 Basestar and 3 Raiders in a single space area.\n");
				if(basestarsAway() > 0) {
					addOption(me, "Place a basestar on the main game board", "Necessary Risk", true);
				}
				if(raidersAway() > 0) {
					addOption(me, "Place Raider(s) on the main game board", "Necessary Risk", true);
				}
			}
			t.value += "Necessary Risk is removed from the game.\r\n";
			z.mutinyDiscards.pop();
			break;
		case "Send a Message":
			if(z.galacticaAway) {
				plainAlert("Send a Message has no effect while Galactica is away.");
			} else {
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
					plainAlert(z.players[z.turn] +
						", as current player, decides whether Pegasus or Galactica is damaged.\r\nThen, attack a centurion (if possible).");
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
				} else {
					damageGalactica();
				}
				if(z.centurions.length > centurionReserves()) {
					let centurionBases = [0, 0, 0, 0];
					for(let j = 0; !(j >= z.centurions.length); j++) {
						if(z.centurions[j] > 0) {
							centurionBases[z.centurions[j] - 1]++;
						}
					}
					let num = 0;
					for(let j = 0; !(j >= 4); j++) {
						if(centurionBases[j] > 0) {
							num++;
						}
					}
					z.destroyer = me;
					if(num === 1) {
						SPTokenBad("Send a Message");
						z.dieRollModifier = 2;
						t.value += "Remember that this die roll receives a +2 bonus (which stacks with " + colorText("purple", "Strategic Planning") + ").\r\n";
					} else {
						plainAlert(z.players[me] + " must decide which Centurion to target.");
						addOption(me, "[Send a Message] Target a Centurion", undefined, true);
					}
				}
			}
			break;
		case "Scavenging for Parts":
			if(z.galacticaAway) {
				plainAlert("Scavenging for Parts has no effect while Galactica is away.");
			} else {
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
					plainAlert(z.players[z.turn] +
						", as current player, decides whether Pegasus or Galactica is damaged.\r\nThen, reshuffle a civilian in space.");
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					if(spaceCiviliansList().length > 0) {
						addOption(me, "Reshuffle a Civilian", "Scavenging for Parts", true);
					}
				} else {
					damageGalactica();
					if(spaceCiviliansList().length > 0) {
						addAlert("Now, reshuffle a civilian in a space area.");
						addOption(me, "Reshuffle a Civilian", "Scavenging for Parts", true);
					}
				}
			}
			break;
		case "Clipped Wings": {
			recallAllVipers();
			repairAllVipers();
			let card1 = dealSkillCard(me, 5);
			let card2 = dealSkillCard(me, 5);
			addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + ".");
			break;
		}
		case "Violent Protest": {
			let card1 = dealSkillCard(me, 0);
			let card2 = dealSkillCard(me, 0);
			addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + ".");
			if(z.playerLocations[z.president] === "Detention") {
				plainAlert("The President stays in Detention.");
			} else if(z.playerLocations[z.president] === "Brig") {
				plainAlert("The President stays in the Brig.");
			} else if(z.playerLocations[z.president] === "Stranded on Caprica") {
				plainAlert("President Helo remains Stranded on Caprica.");
			} else if(z.playerLocations[z.president] === "Sickbay") {
				plainAlert("The President remains in Sickbay.");
			} else if(z.playerLocations[z.president] === "Medical Center") {
				plainAlert("The President remains in the Medical Center.");
			} else if(isOnNewCaprica(z.president)) {
				addAlert("The President is moved to the Medical Center.");
				movePlayer(z.president, "Medical Center");
			} else {
				addAlert("The President is moved to Sickbay.");
				movePlayer(z.president, "Sickbay");
			}
			break;
		}
		case "Armed Resistance": {
			if(z.playerLocations[z.admiral] === "Detention") {
				plainAlert("The Admiral stays in Detention.");
			} else if(z.playerLocations[z.admiral] === "Brig") {
				plainAlert("The Admiral stays in the Brig.");
			} else if(z.playerLocations[z.admiral] === "Stranded on Caprica") {
				plainAlert("Admiral Helo remains on Caprica.");
			} else if(z.playerLocations[z.admiral] === "Sickbay") {
				plainAlert("The Admiral remains in Sickbay.");
			} else if(z.playerLocations[z.admiral] === "Medical Center") {
				plainAlert("The Admiral remains in the Medical Center.");
			} else if(isOnNewCaprica(z.admiral)) {
				addAlert("The Admiral is moved to the Medical Center.");
				movePlayer(z.admiral, "Medical Center");
			} else {
				addAlert("The Admiral is moved to Sickbay.");
				movePlayer(z.admiral, "Sickbay");
			}
			z.scoutingCrisis = true;
			z.scout = me;
			let crisis = z.crisisDeck.pop(); /* TODO: in general, fix reshuffle notifications. */
			if(z.crisisDeck.length === 0) {
				plainAlert("Crisis deck reshuffles.");
				z.crisisDeck = shuffle(z.crisisDiscards);
				z.crisisDiscards = [];
			}
			z.scouted.push(crisis);
			addAlert("The top card of the Crisis deck is:\n\n" + d.crisisNames[crisis] +
				"\n\nNow, return this card to the top or the bottom of the Crisis deck.");
			t.value += myPlayer + " scouts the Crisis deck.\r\n";
			break;
		}
		case "Weapons Armed":
			/* RULES: If built all ARs? */ if(unbuiltARs() === 0) {
				addAlert("You have built all Assault Raptors possible.");
				t.value += "You may not build any more Assault Raptors; Raptor is not destroyed.";
			} else {
				destroyRaptor();
				gainAR();
			}
			if(!z.negotiation) {
				launchTwoRaiders();
			} else {
				t.value += "No Raiders are launched, due to the " + colorText("orange", "Negotation") + ".\r\n";
			}
			break;
		case "Unauthorized Usage": {
			let done = true;
			if(z.galacticaAway){
				/* throw them away */
			} else if(z.CFB) {
				addAlert("Now, pick a sector to target.");
				t.value += z.players[me] + " must pick a sector to target with Unauthorized Usage.\r\n";
				addOption(me, "[Unauthorized Usage] Use a Nuke", undefined, true);
				done = false;
			} else if(basestarsAway() === z.basestars.length) {
				plainAlert("There are no Basestars to target.");
			} else {
				if(z.basestars.length > 1 && z.basestars[0][0] > 0 && z.basestars[1][0] > 0 && (z.basestars[0][0] !== z.basestars[1][0] || z.basestars[0]
						.length > 1 || z.basestars[1].length > 1)) {
					addAlert("Now, pick a basestar to target.");
					t.value += z.players[me] + " must pick a basestar to target with Unauthorized Usage.\r\n";
					addOption(me, "[Unauthorized Usage] Use a Nuke", undefined, true);
					done = false;
				} else {
					for(let j = 0; !(j >= z.basestars.length); j++) {
						if(z.basestars[j][0] > 0) {
							z.destroyer = me;
							let bs1 = basestarName(j);
							SPTokenBad("Nuke vs. " + bs1);
							if(/Structural Damage/.test(bs1)) {
								z.dieRollModifier += 2;
								plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
							}
							break;
						}
					}
				}
			}
			if(done) {
				z.nukes = 0;
				t.value += "Unauthorized Usage and all Nukes are removed from the game.\r\n";
				z.mutinyDiscards.pop();
			} else {
				z.nukes = 1;
				t.value += "Unauthorized Usage and all Nukes will be removed from the game after the Nuke is deployed.\r\n";
				z.mutinyDiscards.pop();
			}
			break;
		}
		case "Selfish Act":
			if(z.vBrutality) {
				addAlert("Now, draw 2 Skill Cards, then discard 4 skill cards or draw another Mutiny card.");
				addOption(me, "Draw 2 Skill Cards", undefined, true);
				addOption(me, "Draw a Mutiny card", "Selfish Act", false);
				if(z.players[me] === "Apollo" && !noDrawback(me)) {
					if(z.forLove) {
						addOption(me, "Discard a random Skill Card", 3, false);
						z.randomLove[me] = true;
					} else {
						addOption(me, "Discard a random Skill Card", 4, false);
					}
				} else if(z.forLove && z.players[me] !== "Athena" && z.forLoveCOs[me] === null) {
					addOption(me, "Discard a Skill Card", 3, false);
					addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, false);
				} else {
					addOption(me, "Discard a Skill Card", 4, undefined, false);
				}
			} else {
				addAlert("Now, draw 2 Skill Cards, then draw another Mutiny.");
				addOption(me, "Draw 2 Skill Cards", undefined, true);
				addOption(me, "Draw a Mutiny card", undefined, true);
			}
			break;
		case "Panic":
			/* TODO: RULES: If Apollo AVPs off of this, causes a Mutiny to be drawn, which reshuffles the Mutiny deck, should Panic be in there?*/ if(!z
				.galacticaAway) {
				placeCivilian(4);
				addAlert("Now, activate one unmanned Viper.");
				menuPage = "[Manual Viper Activation]";
				addOption(me, "Activate an unmanned Viper", 1, false);
			}
			break;
		case "Set the Agenda": {
			if(z.quorumPeeker !== -1) {
				z.mutinies[me].push(z.mutinyDiscards.pop());
				addAlert("Please wait for other players to finish handling the Quorum deck before playing Set the Agenda.");
				break;
			}
			let card1 = dealQuorumCard();
			let card2 = dealQuorumCard();
			shuffle(z.quorumHand);
			let message = "\n\nYour Quorum hand, just before you passed it off to " + myPlayer + " for Set the Agenda:";
			let message2 = "";
			let message3 = "";
			for(let j = 0; !(j >= z.quorumHand.length); j++) {
				let extra = "";
				if(z.quorumHand[j] === card1 || z.quorumHand[j] === card2) {
					extra = "(new) ";
				}
				message2 += "\n" + extra + d.quorumNames[z.quorumHand[j]];
				message3 += "\n" + d.quorumNames[z.quorumHand[j]];
			}
			z.secretMessages[z.president] += message + message2;
			z.quorumPeeker = me;
			z.quorumPeek = z.quorumHand;
			z.quorumHand = []; /* RULES: can president indicate which cards they just drew with Set the Agenda? */
			addAlert("You are passed the following Quorum cards.  Note that the President shuffled their hand of Quorums before passing them to you.\n\n" +
				message3);
			addAlert("Now, you must bottom two Quorums.");
			t.value += colorText("orange", "President ") + z.players[z.president] + " passes their Quorum hand to " + myPlayer +
				", who must now bottom two of them.\r\n";
			addOption(me, "[Set the Agenda] Bottom a Quorum card", 2, true);
			break;
		}
	}
}

function isPilot(playerNum) {
	let name = z.players[playerNum];
	return (z.revealedCylons[playerNum] === 0 && playerNum !== z.theSympatheticCylon && (name === "Apollo" || name === "Boomer" || name === "Starbuck" || name === "Helo" || name === "Kat" || name ===
		"Anders" || name === "Hot Dog" || name === "Karl" || name === "Lee" || name === "Athena" || name === "Racetrack" || name === "Crashdown" ||
		name === "Seelix"));
}

function blankArrays(num) {
	let bob = [];
	for(let i = num; i > 0; i--) {
		bob.push([]);
	}
	return bob;
}

function printRevealedCards() {
	let text = "";
	for(let i = 0; !(i >= z.revealedCards.length); i++) {
		text += cardText(z.revealedCards[i ]) + "\r\n";
	}
	text += "\r\n";
	text += skillCheckTally(true)[0] + "\r\n";
	t.value += text;
} /* TODO: We still do this even with base game IC or pegasus IC + guts? */
function revealSkillCheck() {
	z.skillCheckRevealed = true;
	z.revealedCards = sortedSkillCheck(true);
	z.skillCheckCards = blankArrays(z.numPlayers + 1);
	z.fastLearner = [];
	printRevealedCards();
}

function advanceContributor() {
	if(me === z.turn) {
		z.contributingPlayer = z.numPlayers;
	} else {
		z.contributingPlayer = (me - z.turn + z.numPlayers) % z.numPlayers;
		while(autoPass(z.contributingPlayer)) {
			z.contributingPlayer++;
		}
	}
}

function skillCheckToken() {
	let crisisName = "";
	if(Number.isInteger(z.currentSkillCheck)) {
		crisisName = d.crisisNames[z.currentSkillCheck];
	} else {
		crisisName = z.currentSkillCheck;
	}
	let qre = new RegExp('\\[q' + bl + '="BYC: ' + crisisName + '"\\]((?!(\\[q' + bl + '=|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	t.value = t.value.replace(qre, "");
	let text = '[q' + bl + '="BYC: ' + crisisName + '"]\r\n';
	text += size(difficultyTemplate(), 14) + "\r\n";
	if(z.investigativeCommittee) {
		text += bold(colorText("orange", "Investigative Committee")) + " is in play. All cards (";
		if(z.pegasusIC) {
			text += "ex";
		} else {
			text += "in";
		}
		text += "cluding Destiny) are played face up.\r\n";
	}
	if(z.secondChance){
		text += bold(colorText("purple","A Second Chance")+" is in play.\r\n");
	}
	if(z.reckless) {
		let crit = "";
		if(z.criticalMission && versionAtLeast([2,1,13])){
			if(z.reckless === 2){
				crit = " doubly ";
			} else if (z.reckless === 3){
				crit = " triply ";
			} else if (z.reckless === 4){
				crit = " quadruply ";
			}
		}
		text += "This skill check is " +crit+ bold(colorText("brown", "Reckless")) + ".\r\n";
	} else if(z.restoreOrder) {
		text += bold(colorText("green", "Restore Order")) + " is in play.  No skill check effects will occur.\r\n";
	} else if(z.currentSkillCheck >= 203) {
		text += bold("Reminder") +
			": card effects and character abilities (apart from those which limit the number of cards contributed to skill checks) do not affect Missions.\r\n";
	}
	if(z.players[z.crisisPlayer] === "Adama" && !z.vBrutality && Number.isInteger(z.currentSkillCheck) && !isSuperCrisis(z.currentCrisis) && !isMission(z
			.currentCrisis) && !z.capricaCrisis) {
		text += "It is " + bold("Adama") + "'s turn.  All 1-strength skill cards are positive.\r\n";
	}
	if(z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[z.turn] === "Adama" && Number.isInteger(z.currentSkillCheck) && !isSuperCrisis(z.currentCrisis) &&
		!isMission(z.currentCrisis) && !z.capricaCrisis) {
		text += "It is " + bold("Adama") + "'s turn.  All 1-strength skill cards count as 2-strength.\r\n";
	}
	text += "\r\nDestiny - ";
	if(z.investigativeCommittee && !z.pegasusIC) {
		text += cardText(z.skillCheckCards[z.numPlayers][0]) + ", " + cardText(z.skillCheckCards[z.numPlayers][1]) + "\r\n";
	} else {
		text += z.skillCheckCards[z.numPlayers].length + " cards\r\n";
	}
	if(z.fastLearner.length > 0) {
		text += "Dee's Fast Learner - ";
		if(z.investigativeCommittee && !z.vBrutality) {
			for(let k = 0; !(k >= z.fastLearner.length); k++) {
				text += cardText(z.fastLearner[k]) + ", ";
			}
			text = text.slice(0, -2);
			text += "\r\n";
		} else {
			text += z.fastLearner.length + " cards\r\n";
		}
	}
	let doralText = "";
	let contributor = 0;
	let contributingPlayer = z.contributingPlayer;
	while(true){
		contributor = (contributingPlayer + z.turn + 1) % z.numPlayers;
		if(contributingPlayer === z.numPlayers){
			contributor = -1;
			break;
		}
		if(autoPass(contributingPlayer)){
			contributingPlayer++;
			continue;
		}
		if(z.skillCheckCards[contributor].length > 0 && (z.players[contributor] !== "Cally" || z.playerLocations[contributor] === "Brig" || z.playerLocations[contributor] === "Detention" ||
												  z.revealedCylons[contributor] === 1 || noDrawback(contributor) || z.skillCheckCards[contributor].length > 1)){
			contributingPlayer++;
			continue;
		}	
		break;
	}
	for(let i = 0; !(i >= z.numPlayers); i++) {
		let j = (z.turn + 1 + i) % z.numPlayers;
		if(contributor === j){
			text += bold(z.players[j]);
		} else {
			text += z.players[j];
		}
		text +=  " (" + (z.skillCardHands[j].length + z.skillCheckCards[j].length) + ") - ";
		if(z.skillCardHands[j].length === 0 && z.skillCheckCards[j].length === 0) {
			text += "PASS: No Cards\r\n";
		} else if(z.players[j] === "Cally" && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Detention" && z.revealedCylons[j] === 0 && z
			.skillCardHands[j].length === 1 && z.skillCheckCards[j].length === 0 && !noDrawback(j)) {
			text += "PASS: Impulsive\r\n";
		} else if(z.players[j] === "Doral" && z.vanity) {
			text += "PASS: Vanity\r\n";
		} else if(z.hasOwnProperty("trialWithoutProcess") && z.trialWithoutProcess[j]){
			text += "PASS: Trial without Process\r\n";
		} else if(z.tank[j] && z.skillCheckCards[j].length === 0) {
			text += "TANK\r\n";
		} else if(z.skillCheckCards[j].length > 0) {
			if(!z.investigativeCommittee) {
				if(z.players[j] !== "Simon" || z.currentSkillCheck >= 203 || noDrawback(j)) {
					text += z.skillCheckCards[j].length;
					if(z.skillCheckCards[j].length === 1) {
						text += " card ";
					} else {
						text += " cards ";
					}
					text += z.contributionLabels[j] + "\r\n";
				} else {
					text += cardText(z.skillCheckCards[j][0]) + " (Logic Bound)";
					if(z.skillCheckCards[j].length > 1) {
						text += " + " + (z.skillCheckCards[j].length - 1);
						if(z.skillCheckCards[j].length === 2) {
							text += " face-down card ";
						} else {
							text += " face-down cards ";
						}
						text += z.contributionLabels[j];
					}
					text += "\r\n";
				}
			} else {
				for(let k = 0; !(k >= z.skillCheckCards[j].length); k++) {
					text += cardText(z.skillCheckCards[j][k]) + ", ";
				}
				text = text.slice(0, -2);
				text += "\r\n";
			}
		} else {
			if(i >= z.contributingPlayer) {
				if(z.players[j] === "Lee" && z.revealedCylons[j] === 0 && j !== z.theSympatheticCylon && z.vBrutality && versionAtLeast([2, 0, 1]) && !versionAtLeast([2,1,13]) && !Number
					.isInteger(z.currentSkillCheck) && z.skillCardHands[j].length > 0 && !noDrawback(j)) {
					if(maxSkillCards(j) === 1) {
						text += "(exactly 1)";
					} else if(maxSkillCards(j) !== 201) {
						text += "(1 min, " + maxSkillCards(j) + " max)";
					} else {
						text += "(1 min)";
					}
				} else if(maxSkillCards(j) !== 201) {
					text += "(" + maxSkillCards(j) + " max)";
				} else if(z.players[j] === "Cally" && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Detention" && !noDrawback(j)) {
					text += "(not 1)";
				}
				text += "\r\n";
			} else {
				text += "Pass\r\n";
			}
		}
	}
	text += "\r\n";
	text += doralText;
	if(z.investigativeCommittee) {
		text += skillCheckTally(!z.pegasusIC)[0] + "\r\n";
	}
	text += "[/" + "q]";
	t.value += text;
}

function playDestinyToSkillCheck() {
	removeFromAll("Trial without Process (OPG)");
	removeFromAll("[Trial Without Process] Pick a player to bar from the skill check");
	if(z.destiny.length === 0) {
		addAlert("Destiny is empty and cannot be rebuilt.");
		return 0;
	}
	t.value += "Playing Destiny into the skill check.\r\n";
	z.skillCheckCards[z.numPlayers].push(z.destiny.pop());
	if(z.destiny.length === 0) {
		buildDestiny();
	}
	z.skillCheckCards[z.numPlayers].push(z.destiny.pop());
	if(z.destiny.length === 0) {
		buildDestiny();
	}
	skillCheckToken();
}

function checkEmptyColors(player){
	if(z.skillCardHands[player].length === 0){
		for(let j = 0; !(j>=z.possibleColors[player].length); j++){
			z.possibleColors[player][j] = 0;
		}
	}
}

function playCardToSkillCheck(player, pos) {
	if(!(pos >= 0) || pos >= z.skillCardHands[player].length) {
		error("Cannot play into skill check a card you do not have in hand!");
		return 0;
	}
	let card = z.skillCardHands[player].splice(pos, 1)[0];
	checkEmptyColors(player);
	z.skillCheckCards[player].push(card);
	skillCheckToken();
}

function startCrisisSkillCheck() {
	menuPage = "Default";
	if(z.currentCrisis === null) {
		return null;
	}
	z.currentSkillCheck = z.currentCrisis;
	z.thisDifficulty = d.difficulty[z.currentCrisis];
	z.thisPartial = d.partial[z.currentCrisis];
	z.thisConsequence = d.consequence[z.currentCrisis];
	z.thisPolitics = d.positives[0][z.currentCrisis];
	z.thisLeadership = d.positives[1][z.currentCrisis];
	z.thisTactics = d.positives[2][z.currentCrisis];
	z.thisPiloting = d.positives[3][z.currentCrisis];
	z.thisEngineering = d.positives[4][z.currentCrisis];
	z.thisTreachery = 0;
	z.contributingPlayer = 0;
	if(characterPresent("Doral") && z.phase === 3 && z.players[z.turn] !== "Doral" && !noDrawback(getPlayerNum("Doral"))) {
		z.vanity = true;
		plainAlert("Doral's Vanity applies; he may not contribute skill cards to this skill check.");
	}
	if(z.players[z.turn] === "Cain" && !noDrawback(z.turn) && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && z.vBrutality &&
		versionAtLeast([2, 0, 1]) && !versionAtLeast([2,1,9]) && anyUndamagedBasestars() && !isMission(z.currentCrisis)) {
		z.reckless = true;
		plainAlert("Cain's Bent on Revenge applies; this check is automatically Reckless.");
	}
	if(!isMission(z.currentCrisis)) {
		interruptsToken();
	} else {
		t.value += "No interrupts can be played before Missions.\r\n";
		playDestinyToSkillCheck();
	}
	return null;
}

function sleeper() {
	z.sleeper = true;
	t.value += "[ima" + bl + "geid=606443 medium]\r\n";
	plainAlert("Entering Sleeper Phase; dealing new Loyalties.");
	if(z.numPlayers === 2 || (z.assist !== undefined && z.numPlayers === 1)) {
		if(5 > z.fuel && z.notCylonDeck.length > 0) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		if(5 > z.food && z.notCylonDeck.length > 0) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		if(6 > z.morale && z.notCylonDeck.length > 0) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		if(7 > z.population && z.notCylonDeck.length > 0) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		shuffle(z.loyaltyDeck);
	}
	for(let i2 = 0; !(i2 >= z.players.length) && z.numPlayers + z.boxedPlayers.length > 1; i2++) {
		let i = (z.turn + i2) % z.numPlayers;
		if(z.revealedCylons[i ] === 1 && !isCylonLeader(z.players[i ]) && (z.daybreak || z.pegasus || z.vHandoff)) {
			plainAlert(z.players[i ] + " must pass their remaining Loyalty cards to a Human of their choice.");
		}
		if(!isCylonLeader(z.players[i ]) && z.loyaltyDeck.length > 0) {
			let loy = z.loyaltyDeck.pop();
			z.loyaltyHands[i ].push(loy);
			if(loy === 40 && z.revealedCylons[i ] === 0) {
				/* RULES: does Tom do necessary steps in the middle of sleeper draw? */
				becomeMutineer(i);
			} else if(loy === 15 && (z.revealedCylons[i ] === 0 || (!z.pegasus && !z.vHandoff))) {
				becomeSympathizer(i);
			} else if(loy === 17 && z.revealedCylons[i ] === 0) {
				becomeSympatheticCylon(i);
			}
		} else if(z.daybreak || z.vNoAgendas) {
			z.loyaltyHands[i ].push(z.motiveDeck.pop());
			if(!z.multiCL){
				z.loyaltyHands[i ].push(z.motiveDeck.pop());
			}
		}
		if(z.players[i ] === "Boomer" && z.players.length > 1) {
			if(!z.exodus || z.revealedCylons[i ] === 0) {
				let loy = z.loyaltyDeck.pop();
				z.loyaltyHands[i ].push(loy);
				if(loy === 40 && z.revealedCylons[i ] === 0) {
					becomeMutineer(i);
				} else if(loy === 15 && (z.revealedCylons[i ] === 0 || !z.pegasus)) {
					becomeSympathizer(i);
				} else if(loy === 17 && z.revealedCylons[i ] === 0) {
					becomeSympatheticCylon(i);
				}
			}
			if(z.revealedCylons[i ] === 0) {
				movePlayer(i, "Brig");
			}
			addAlert("Boomer is brigged.");
		}
	}
	if(z.assist !== undefined) {
		if(z.loyaltyDeck.length > 0){
			z.assistLoyalty.push(z.loyaltyDeck.pop());
		}
		if(z.loyaltyDeck.length > 0){
			z.assistLoyalty.push(z.loyaltyDeck.pop());
		}
		if(z.loyaltyDeck.length > 0){
			z.assistLoyalty.push(z.loyaltyDeck.pop());
		}
		if(z.loyaltyDeck.length > 0){
			z.assistLoyalty.push(z.loyaltyDeck.pop());
		}
		shuffle(z.assistLoyalty);
	}
	if(z.mutineer && z.theMutineer === -1) {
		t.value += "If, after all revealed Cylons have passed off their unrevealed Loyalties, the Mutineer is still not in play, " + z.players[z.turn] +
			", as current " + "player, must pick someone to draw an additional Loyalty card.\r\n";
	}
	t.value += "\r\n" + bold("You may now relist yourselves on the [ur" + "l=ht" + "tps://" + "boardgamegeek.com/wiki/page/BSG_PBF]PBF Waiting List[/u" +"rl].") + "\r\n";
} /*TODO: destroyed colonial one in graveyard */ /* TODO: check instances of this for support character for OPGs */
function characterPresent(name) {
	for(let i = 0; !(i >= z.players.length); i++) {
		if(z.players[i ] === name && i !== z.theSympatheticCylon && (isCylonLeader(name) || !z.hasOwnProperty("revealedCylons") || z.revealedCylons[i ] === 0)) {
			return true;
		}
	}
	return false;
}

function getPlayerNum(name) {
	for(let i = 0; !(i >= z.players.length); i++) {
		if(z.players[i ] === name) {
			return i;
		}
	}
	return -1;
}

function startLocationSkillCheck(location, target) {
	menuPage = "Default";
	z.thisTarget = target;
	z.currentSkillCheck = location;
	z.thisConsequence = 0;
	z.thisPiloting = 0;
	z.thisEngineering = 0;
	z.thisPartial = 0;
	if(location === "Admiral's Quarters") {
		z.thisDifficulty = 7;
		if(z.players[target] === "Starbuck" && !noDrawback(target) && (!z.vBrutality || !versionAtLeast([1, 2, 4, 2]))) {
			z.thisDifficulty -= 3;
			t.value += "Difficulty is reduced by 3 due to Starbuck's Insubordinate.\r\n";
		}
		if(prophetInPlay() !== -1 && target === z.president) {
			z.quorumDiscards.push(z.quorumTitles[z.president].splice(prophetInPlay(), 1)[0]);
			boldAlert("Accept Prophecy is discarded; difficulty increased by 2.");
			z.thisDifficulty += 2;
		}
		z.thisPolitics = 0;
		z.thisLeadership = 1;
		z.thisTactics = 1;
		z.thisTreachery = 0;
		if(characterPresent("Tigh")) {
			plainAlert("Don't forget Tigh's Cylon Hatred ability.");
		}
	} else if(location === "Brig") {
		z.thisDifficulty = 7;
		z.thisPolitics = 1;
		z.thisLeadership = 0;
		z.thisTactics = 1;
		z.thisTreachery = 0;
		if(characterPresent("Zarek") && !isOnNewCaprica(getPlayerNum("Zarek")) && !z.vBrutality) {
			plainAlert("Don't forget Zarek's Friends in Low Places ability.");
		}
	} else if(location === "Administration") {
		z.thisDifficulty = 5;
		z.thisPolitics = 1;
		z.thisLeadership = 1;
		z.thisTactics = 0;
		z.thisTreachery = 0;
		if(prophetInPlay() !== -1) {
			z.quorumDiscards.push(z.quorumTitles[z.president].splice(prophetInPlay(), 1)[0]);
			boldAlert("Accept Prophecy is discarded; difficulty increased by 2.");
			z.thisDifficulty += 2;
		}
		if(characterPresent("Zarek") && !z.vBrutality) {
			plainAlert("Don't forget Zarek's Friends in Low Places ability.");
		}
	} else if(location === "Airlock") {
		z.thisDifficulty = 12;
		z.thisPolitics = 1;
		z.thisLeadership = 0;
		z.thisTactics = 1;
		z.thisTreachery = 1;
		if(z.playerLocations[target] === "Brig") {
			t.value += "Difficulty is reduced by 4 as " + z.players[target] + " is in the Brig.\r\n";
		}
		if(prophetInPlay() !== -1 && target === z.president && z.vBrutality) {
			z.quorumDiscards.push(z.quorumTitles[z.president].splice(prophetInPlay(), 1)[0]);
			boldAlert("Accept Prophecy is discarded; difficulty increased by 2.");
			z.thisDifficulty += 2;
		}
		if(characterPresent("Tigh") && z.vBrutality) {
			plainAlert("Don't forget Tigh's Cylon Hatred ability.");
		}
	} else if(location === "Resistance HQ") {
		z.thisDifficulty = 7;
		z.thisPolitics = 0;
		z.thisLeadership = 1;
		z.thisTactics = 1;
		z.thisTreachery = 1;
	} else if(location === "Detention") {
		z.thisDifficulty = 9;
		z.thisPolitics = 1;
		z.thisLeadership = 0;
		z.thisTactics = 1;
		z.thisTreachery = 0;
		if(characterPresent("Zarek") && isOnNewCaprica(getPlayerNum("Zarek")) && !z.vBrutality) {
			plainAlert("Don't forget Zarek's Friends in Low Places ability.");
		}
	}
	if(!z.theFarm && z.players[me] === "Seelix" && z.miracles[me] === 1){
		addOption(me,"Trial without Process (OPG)",undefined,false);
	}
	if(!z.theFarm && z.players[me] === "Gaius" && actsOfFaith("Seelix")){
		addOption(me,"Trial without Process (OPG)",undefined,false);
	}
	z.contributingPlayer = 0;
	if(characterPresent("Doral") && z.players[z.turn] !== "Doral" && z.phase === 3 && !noDrawback(getPlayerNum("Doral"))) {
		z.vanity = true;
		plainAlert("Doral's Vanity applies; he may not contribute skill cards to this skill check.");
	}
	if(z.players[z.turn] === "Cain" && !noDrawback(z.turn) && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && z.vBrutality &&
		versionAtLeast([2, 0, 1]) && !versionAtLeast([2,1,9]) && anyUndamagedBasestars()) {
		z.reckless = true;
		plainAlert("Cain's Bent on Revenge applies; this check is automatically Reckless.");
	}
	interruptsToken();
}

function isMale(player) {
	switch (z.players[player]) {
		case "Roslin":
		case "Starbuck":
		case "Boomer":
		case "Cain":
		case "Ellen":
		case "Kat":
		case "Dee":
		case "Six":
		case "Tory":
		case "Cally":
		case "D'Anna":
		case "Athena":
		case "Racetrack":
		case "Elosha":
		case "Shaw":
		case "Seelix":
			return false;
		default:
			return true;
	}
}

function titleList(player) {
	let text = "";
	if(player === z.admiral && player === z.president) {
		if(player === z.cag) {
			if(isMale(player)) {
				text += colorText("purple", "God-King ");
			} else {
				text += colorText("purple", "God-Queen ");
			}
		} else {
			text += colorText("purple", "Dictator ");
		}
	} else {
		if(player === z.admiral) {
			text += colorText("green", "Admiral ");
		} else if(player === z.president) {
			text += colorText("orange", "President ");
		}
		if(player === z.cag) {
			text += colorText("red", "CAG ");
		}
	}
	if(player === z.theMutineer) {
		text += colorText("brown", "Mutineer ");
	}
	for(let i = 0; !(i >= z.quorumTitles[player].length); i++) {
		switch (z.quorumTitles[player][i ]) {
			case 0:
				text += colorText("orange", "Prophet ");
				break;
			case 3:
				text += colorText("orange", "Arbitrator ");
				break;
			case 4:
				text += colorText("orange", "Mission Specialist ");
				break;
			case 5:
				text += colorText("orange", "Vice President ");
				break;
			case 17:
				text += colorText("orange", "Chief of Staff ");
				break;
			case 22:
				text += colorText("orange", "Probationer ");
		}
	}
	if((isTheCylonLeader(player) || player === z.theSympatheticCylon) && z.revealedCylons[player] === 0) {
		text += colorText("magenta", "Infiltrator ");
	}
	return text;
}

function repairLocation(location) {
	for(let i = 0; !(i >= z.damagedLocations.length); i++) {
		if(location === z.damagedLocations[i ]) {
			z.damagedLocations.splice(i, 1);
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && onPegasus(location)) {
				z.pegasusDamage.push(location);
				shuffle(z.pegasusDamage);
			} else {
				z.damage.push(location);
				shuffle(z.damage);
			}
			break;
		}
	}
} /* used for Zarek, Leoben */
function otherPlayerInLocation(player, location, humansOnly) {
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(i !== player) {
			if(z.playerLocations[i ] === location && (!z.revealedCylons[i ] || !humansOnly)) {
				return true;
			}
		}
	}
	return false;
}

function increaseDistance(by) {
	z.distance += by;
	boldAlert("Distance increases by " + by + " to " + z.distance + ".");
}

function repairRaptor() {
	if(z.raptors === 4) {
		boldAlert("You cannot have more than 4 Raptors.");
	} else if(z.raptors > 0) {
		z.raptors++;
		boldAlert("Raptor repaired; there are now " + z.raptors + " Raptors.");
	} else {
		z.raptors++;
		boldAlert("Raptor repaired; there is now " + z.raptors + " Raptor available.");
	}
}

function destroyRaptor() {
	let alertText = "";
	if(z.raptors === 0) {
		alertText = "There are no Raptors left to destroy.";
	} else {
		z.raptors--;
		alertText = "Raptor destroyed; " + z.raptors + " Raptor";
		if(z.raptors !== 1){
			alertText += "s";
		}
		alertText += " remain";
		if(z.raptors === 1){
			alertText += "s";
		}
		alertText += ".";
	}
	boldAlert(alertText);
}

function gainAR() {
	let alertText = "";
	let done = false;
	if(unbuiltARs() === 0) {
		alertText = "You have already gained 3 Assault Raptors, and cannot gain any more.";
	} else {
		for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
			if(z.assaultRaptors[j] === -3) {
				z.assaultRaptors[j] = 0;
				break;
			}
		}
		alertText = "The Humans gain an Assault Raptor.";
		done = true;
	}
	boldAlert(alertText);
	return done;
}

function weaponsDisabled(basestar) {
	if(z.basestars.length === 0 || (z.basestars.length === 1 && basestar === 1)) {
		return false;
	}
	for(let i = 1; !(i >= z.basestars[basestar].length); i++) {
		if(z.basestars[basestar][i ] === "Weapons Disabled") {
			return true;
		}
	}
	return false;
}

function hangarDisabled(basestar) {
	if((z.basestars.length === 1 && basestar === 1) || (z.basestars.length === 0 && basestar === 0)) {
		return false;
	}
	for(let i = 1; !(i >= z.basestars[basestar].length); i++) {
		if(z.basestars[basestar][i ] === "Hangar Disabled") {
			return true;
		}
	}
	return false;
}

function raiderReserves() {
	let count = 0;
	for(let i = 0; !(i >= z.raiders.length); i++) {
		if(z.raiders[i ] === 0) {
			count++;
		}
	}
	return count;
}

function heavyReserves() {
	let count = 0;
	for(let i = 0; !(i >= z.heavies.length); i++) {
		if(z.heavies[i ] === 0) {
			count++;
		}
	}
	return count;
}

function CFBroll(sector) {
	switch (sector) {
		case -1:
			return 7;
		case -2:
			return 5;
		case -3:
			return 3;
		case -4:
			return 1;
		case -5:
			return 2;
		case -6:
			return 4;
		default:
			return 1000;
	}
}

function placeHeavy(sector) {
	let heavy = -1;
	let heavyCandidate = -1;
	let leastCFB = 8;
	for(let i = 0; !(i >= z.heavies.length); i++) {
		if(z.CFB && !(CFBroll(z.heavies[i ]) >= leastCFB)) {
			heavyCandidate = i;
			leastCFB = CFBroll(z.heavies[i ]);
		}
		if(z.heavies[i ] === 0) {
			heavy = i;
			break;
		}
	}
	let CFBflag = false;
	if(heavy === -1) {
		if(heavyCandidate > -1) {
			CFBflag = true;
			heavy = heavyCandidate;
		} else {
			t.value += " All Heavy Raiders are on the main game board; no more can be placed.\r\n";
			return undefined;
		}
	}
	let CFBsector = -z.heavies[heavy];
	z.heavies[heavy] = sector;
	t.value += "Placed a Heavy Raider in Sector " + sector + ".";
	if(CFBflag) {
		t.value += " It came from CFB Sector " + CFBsector + ".";
	}
	t.value += "\r\n";
}

function placeRaider(sector) {
	let raider = -1;
	let raiderCandidate = -1;
	let leastCFB = 8;
	for(let i = 0; !(i >= z.raiders.length); i++) {
		if(z.CFB && !(CFBroll(z.raiders[i ]) >= leastCFB)) {
			raiderCandidate = i;
			leastCFB = CFBroll(z.raiders[i ]);
		}
		if(z.raiders[i ] === 0) {
			raider = i;
			break;
		}
	}
	let CFBflag = false;
	if(raider === -1) {
		if(raiderCandidate > -1) {
			CFBflag = true;
			raider = raiderCandidate;
		} else {
			t.value += " All Raiders are on the main game board; no more can be placed.\r\n";
			return undefined;
		}
	}
	let CFBsector = -z.raiders[raider];
	z.raiders[raider] = sector;
	t.value += "Placed a Raider in Sector " + sector + ".";
	if(CFBflag) {
		t.value += " It came from CFB Sector " + CFBsector + ".";
	}
	t.value += "\r\n";
}

function placeViper(sector) {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === 0) {
			z.vipersII[i ] = sector;
			t.value += "Placed a Viper Mk II in Sector " + sector + ".\r\n";
			if(canAVP()) {
				z.avp.push(i);
			}
			return true;
		}
	}
	t.value += "No Vipers left in the Reserves.\r\n";
	return false;
}

function placeAssaultRaptor(sector) {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.assaultRaptors[i ] === 0) {
			z.assaultRaptors[i ] = sector;
			t.value += "Placed an Assault Raptor in Sector " + sector + ".\r\n";
			if(canAVP()) {
				z.avp.push(12 + i);
			}
			return true;
		}
	}
	t.value += "No Assault Raptors left in the Reserves.\r\n";
	return false;
}

function placeHeavies(sector, num) {
	for(let i = 0; !(i >= num); i++) {
		placeHeavy(sector);
	}
}

function placeVipers(sector, num, CAC) {
	if(CAC && assaultRaptorsReserves() > 0) {
		if(vipersIIReserves() >= num) {
			for(let i = 0; !(i >= num); i++) {
				placeViper(sector);
			}
			return false;
		} else if(vipersIIReserves() > 0) {
			while(vipersIIReserves() > 0) {
				placeViper(sector);
				num--;
			}
			if(num >= assaultRaptorsReserves()) {
				while(assaultRaptorsReserves() > 0) {
					placeAssaultRaptor(sector);
				}
				return true;
			} else {
				for(; num > 0; num--) {
					placeAssaultRaptor(sector);
				}
				return false;
			}
		} else {
			if(num > assaultRaptorsReserves()) {
				num = assaultRaptorsReserves();
			}
			for(; num > 0; num--) {
				placeAssaultRaptor(sector);
			}
			return true;
		}
	} else {
		for(let i = 0; !(i >= num); i++) {
			placeViper(sector);
		}
		return true;
	}
}

function placeRaiders(sector, num) {
	for(let i = 0; !(i >= num); i++) {
		placeRaider(sector);
	}
}


function launchRaiders() {
	let bsCount = 0;
	let sector1 = 0;
	let sector2 = 0;
	if(z.basestars.length > 0 && z.basestars[0][0] > 0 && !hangarDisabled(0)) {
		sector1 = z.basestars[0][0];
		bsCount++;
	}
	if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
		sector2 = z.basestars[1][0];
		bsCount++;
	}
	if(bsCount === 0) {
		if(!z.CFB || z.basestars.length === 0) {
			plainAlert("Launch Raiders icon fizzles.");
			return true;
		} else {
			if(hangarDisabled(0) || hangarDisabled(1)) {
				plainAlert("Launch Raiders icon fizzles, as the Basestar on the main game board has Disabled Hangars.");
				return true;
			} else {
				if(basestarReserves() === 0) {
					let candidateSector = -1;
					let candidateRoll = 0;
					for(let i = 0; !(i >= z.basestars.length); i++) {
						let roll = CFBroll(z.basestars[i ][0]);
						if(roll > candidateRoll) {
							candidateRoll = roll;
							candidateSector = z.basestars[i ][0];
						}
					}
					plainAlert("Launch Raiders activation: no Basestars are on the main board or the reserves, so...");
					let bob = advancePursuit();
					if(z.pursuitTrack !== 0) {
						jumpInSector(-candidateSector);
					}
					return bob;
				} else {
					plainAlert("Roll a die to place a Basestar on the CFB; the Pursuit Track will then advance.");
					z.dieRollQueue.push("CFB Basestar Placement");
					if(z.dieRollQueue.length === 1) {
						z.dieRoller = z.turn;
					}
					return false;
				}
			}
		}
	}
	t.value += "Raiders Launch.\r\n";
	let raidersToLaunch = 0;
	let numRaidersLaunched = 3;
	if(z.cylonSwarm) {
		numRaidersLaunched = 4;
	}
	raidersToLaunch = numRaidersLaunched * bsCount;
	if(raidersAway() === 0) {
		plainAlert("All raiders are on the main game board; nothing launches.");
		return true;
	} else if(raidersToLaunch > raidersAway()) {
		if(bsCount === 2 && sector1 !== sector2) {
			let alertText = "There are not enough Raiders available to launch a full complement of Raiders from each basestar. " + z.players[z.turn] +
				", as current player, must place the Raiders manually.";
			if(z.cylonSwarm) {
				alertText += " Remember that due to Massive Deployment [from Cylon Swarm] each Basestar would launch 4 Raiders, up from 3.";
			}
			let context = [0, 0, 0, 0, 0, 0];
			context[sector1 - 1] = numRaidersLaunched;
			context[sector2 - 1] = numRaidersLaunched;
			addOption(z.turn, "Place Raider(s) on the main game board", context, true);
			plainAlert(alertText);
			return false;
		} else {
			let sector = sector1;
			if(sector1 === 0) {
				sector = sector2;
			}
			raidersToLaunch = raidersAway();
			for(let i = 0; !(i >= raidersToLaunch); i++) {
				placeRaider(sector);
			}
			addAlert("All remaining Raiders launch in Sector " + sector);
			return true;
		}
	} else {
		if(sector1 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector1);
			}
			addAlert("Raiders launch in Sector " + sector1);
		}
		if(sector2 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector2);
			}
			addAlert("Raiders launch in Sector " + sector2);
		}
		return true;
	}
}

function launchTwoRaiders() {
	let bsCount = 0;
	let sector1 = 0;
	let sector2 = 0;
	if(z.basestars.length > 0 && z.basestars[0][0] > 0 && !hangarDisabled(0)) {
		sector1 = z.basestars[0][0];
		bsCount++;
	}
	if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
		sector2 = z.basestars[1][0];
		bsCount++;
	}
	if(bsCount === 0) {
		addAlert("There are no basestars on the main game board with undamaged hangars.  No effect.");
		t.value += "No Basestars available to launch raiders.\r\n";
		return true;
	}
	if(raidersAway() === 0) {
		addAlert("All Raiders are already on the main game board.  No effect.");
		t.value += "No Raiders available to launch.\r\n";
		return true;
	}
	let raidersToLaunch = 0;
	let numRaidersLaunched = 2;
	if(z.cylonSwarm) {
		numRaidersLaunched = 3;
	}
	raidersToLaunch = numRaidersLaunched * bsCount;
	if(raidersToLaunch > raidersAway()) {
		if(bsCount === 2 && sector1 !== sector2) {
			let alertText = "There are not enough ships available to launch a full complement of Raiders from each basestar. " + z.players[z.turn] +
				", as current player, must place the ships manually.";
			if(z.cylonSwarm) {
				alertText += " Remember that due to Massive Deployment [from Cylon Swarm] each Basestar would launch 3 Raiders.";
			}
			plainAlert(alertText);
			let context = [0, 0, 0, 0, 0, 0];
			context[sector1 - 1] = numRaidersLaunched;
			context[sector2 - 1] = numRaidersLaunched;
			addOption(z.turn, "Place Raider(s) on the main game board", context, true);
			return false;
		} else {
			let sector = sector1;
			if(sector === 0) {
				sector = sector2;
			}
			raidersToLaunch = raidersAway();
			for(let i = 0; !(i >= raidersToLaunch); i++) {
				placeRaider(sector);
			}
			addAlert("All remaining Raiders launch in Sector " + sector);
			return true;
		}
	} else {
		if(sector1 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector1);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders launched in Sector " + sector1 + ".\r\n";
			} else {
				t.value += "2 Raiders launched in Sector " + sector1 + ".\r\n";
			}
		}
		if(sector2 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector2);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders launched in Sector " + sector2 + ".\r\n";
			} else {
				t.value += "2 Raiders launched in Sector " + sector2 + ".\r\n";
			}
		}
		if(z.cylonSwarm) {
			addAlert("3 Raiders launched from each Basestar (due to Cylon Swarm).");
		} else {
			addAlert("2 Raiders launched from each Basestar.");
		}
	}
	return true;
}

function sectorsWithCivilians() {
	let count = 0;
	for(let i = 0; !(i >= 6); i++) {
		if(z.spaceCivilians[i ].length > 0) {
			count++;
		}
	}
	return count;
}

function placeCivilian(sector) {
	let alertText = "";
	if(z.civilianPile.length === 0) {
		alertText = "No civilians left to place.";
	} else {
		z.spaceCivilians[sector - 1].push([z.civilianLetters.shift(), z.civilianPile.pop(), z.reshuffledSeen]);
		alertText = "Placed Civilian " + z.spaceCivilians[sector - 1][z.spaceCivilians[sector - 1].length - 1][0] + " in Sector " + sector + ".";
	}
	boldAlert(alertText);
}

function placeCivilians(sector, num) {
	for(let i = 0; !(i >= num); i++) {
		placeCivilian(sector);
	}
}

function advancePursuit() {
	z.pursuitTrack++;
	let sectors = sectorsWithCivilians();
	switch (z.pursuitTrack) {
		case 1:
			addAlert("Pursuit Track advances to 1 Civ.");
			t.value += "Pursuit Track advances to " + colorText("red", "1 Civ") + ".\r\n";
			break;
		case 2:
			addAlert("Pursuit Track advances to Rest.");
			t.value += "Pursuit Track advances to Rest.\r\n";
			return true;
		case 3:
			addAlert("Pursuit Track advances to 2 Civs.");
			t.value += "Pursuit Track advances to " + colorText("red", "2 Civs") + ".\r\n";
			break;
		case 4:
			addAlert("Pursuit Track advances to Auto-Attack; the fleet attacks!");
			t.value += "[ima" + bl + "geid=647924 medium]\r\n";
			t.value += "Pursuit Track increases to Auto-Attack; the CFB jumps to the main board, and the Pursuit Track is reset.\r\n";
			z.pursuitTrack = 0;
			if(z.basestars.length > 0 && !(z.basestars[0][0] >= 0)) {
				z.basestars[0][0] *= -1;
			}
			if(z.basestars.length > 1 && !(z.basestars[1][0] >= 0)) {
				z.basestars[1][0] *= -1;
			}
			for(let i = 0; !(i >= z.heavies.length); i++) {
				if(!(z.heavies[i ] >= 0)) {
					z.heavies[i ] *= -1;
				}
			}
			for(let i = 0; !(i >= z.raiders.length); i++) {
				if(!(z.raiders[i ] >= 0)) {
					z.raiders[i ] *= -1;
				}
			}
			return true;
	}
	if((z.pursuitTrack === 1 || z.pursuitTrack === 3) && z.civilianPile.length === 0) {
		addAlert("No civilians left to place.");
		t.value += "There are no civilians left for the " + colorText("red", "CAG") + " to place.\r\n";
		return true;
	}
	let context = getContext(z.cag,"Place a Civilian on the board");
	if(!Number.isInteger(context)){
		context = 0;
	}
	if(z.pursuitTrack === 1 || (z.pursuitTrack === 3 && z.civilianPile.length === 1)) {
		if(z.pursuitTrack === 3) {
			t.value += "There is only 1 Civilian left in the pile of unused civilian ships.\r\n";
		}
		if(sectors === 0 || sectors === 6) {
			addAlert("CAG must place a civilian.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must place 1 Civilian in any sector.\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 1, true);
			return false;
		} else if(sectors === 5) {
			for(let i = 0; !(i >= 6); i++) {
				if(z.spaceCivilians[i ].length === 0) {
					placeCivilian(i + 1);
					t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " automatically places a Civilian in Sector " + (i + 1) + ".\r\n");
					addAlert("CAG auto-places a civilian in Sector " + (i + 1));
					return true;
				}
			}
		} else {
			addAlert("CAG must place a civilian.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must place 1 Civilian in any sector not already containing a civilian.\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 1, true);
			return false;
		}
	}
	if(z.pursuitTrack === 3) {
		if(sectors === 6) {
			addAlert("CAG must place two civilians.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must place 2 Civilians in any sector(s).\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 2, true);
			return false;
		} else if(sectors === 0) {
			addAlert("CAG must place two civilians.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must place 2 Civilians in any two different sectors.\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 2, true);
			return false;
		} else if(sectors === 4) {
			for(let i = 0; !(i >= 6); i++) {
				if(z.spaceCivilians[i ].length === 0) {
					placeCivilian(i + 1);
					t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " automatically places a Civilian in Sector " + (i + 1) + ".\r\n");
					addAlert("CAG auto-places a civilian in Sector " + (i + 1));
				}
			}
			return true;
		} else if(sectors === 5) {
			for(let i = 0; !(i >= 6); i++) {
				if(z.spaceCivilians[i ].length === 0) {
					placeCivilian(i + 1);
					t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " automatically places a Civilian in Sector " + (i + 1) + ".\r\n");
					addAlert("CAG auto-places a civilian in Sector " + (i + 1));
				}
			}
			addAlert("CAG must place 1 more civilian.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must place 1 more civilian in any sector.\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 1, true);
			return false;
		} else {
			addAlert("CAG must place two civilians.");
			t.value += bold(colorText("red", "CAG ") + z.players[z.cag] +
				" must place 2 Civilians in any two different sectors not already containing a civilian.\r\n");
			addOption(z.cag, "Place a Civilian on the board", context + 2, true);
			return false;
		}
	}
}

function centurionReserves() {
	let count = 0;
	for(let i = 0; !(i >= z.centurions.length); i++) {
		if(z.centurions[i ] === 0) {
			count++;
		}
	}
	return count;
}

function OFReserves() {
	let count = 0;
	for(let i = 0; !(i >= z.OFs.length); i++) {
		if(z.OFs[i ] === 0) {
			count++;
		}
	}
	return count;
}

function boardGalactica() {
	for(let i = 0; !(i >= z.centurions.length); i++) {
		if(z.centurions[i ] === 0) {
			z.centurions[i ] = 1;
			return true;
		}
	}
	addAlert("All Centurions are already on board Galactica.");
	return false;
}

function jumpInSector(sector) {
	if(z.basestars.length > 0 && (z.basestars[0][0] === -sector)) {
		z.basestars[0][0] *= -1;
	}
	if(z.basestars.length > 1 && (z.basestars[1][0] === -sector)) {
		z.basestars[1][0] *= -1;
	}
	for(let i = 0; !(i >= z.heavies.length); i++) {
		if((z.heavies[i ] === -sector)) {
			z.heavies[i ] *= -1;
		}
	}
	for(let i = 0; !(i >= z.raiders.length); i++) {
		if((z.raiders[i ] === -sector)) {
			z.raiders[i ] *= -1;
		}
	}
	boldAlert("Sector " + sector + " of the CFB jumps in to the main board.");
}

function isUnmannedInSector(sector) {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === sector) {
			return true;
		}
	}
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(z.assaultRaptors[i ] === sector) {
			return true;
		}
	}
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === sector) {
			return true;
		}
	}
	return false;
}

function isViperInSector(sector) {
	if(isUnmannedInSector(sector)) {
		return true;
	}
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(z.playerLocations[i ] === ("Sector " + sector)) {
			return true;
		}
	}
	return false;
}

function raiderTarget(sector) {
	if(z.spaceCivilians[sector - 1].length > 0 || isViperInSector(sector)) {
		return sector;
	}
	if(z.spaceCivilians[sector % 6].length > 0) {
		return sector % 6 + 1;
	}
	if(z.spaceCivilians[(sector + 4) % 6].length > 0) {
		return (sector + 4) % 6 + 1;
	}
	if(z.spaceCivilians[(sector + 1) % 6].length > 0) {
		return sector % 6 + 1;
	}
	if(z.spaceCivilians[(sector + 3) % 6].length > 0) {
		return (sector + 4) % 6 + 1;
	}
	if(z.spaceCivilians[(sector + 2) % 6].length > 0) {
		return sector % 6 + 1;
	}
	return sector;
}

function resetRaiderActivations() {
	for(let j = 0; !(j >= z.raiders.length); j++) {
		if(z.raiders[j] > 0) {
			z.raiderActivated[j] = 0;
		} else {
			z.raiderActivated[j] = 1;
		}
	}
	if(z.scar > 0) {
		z.scarActivated = 0;
	}
}

function activateRaiders() {
	addAlert("Activating Raiders.");
	t.value += bold("Raiders Activate.\r\n");
	if(raidersAway() !== z.raiders.length || z.scarCAC) {
		let targets = [raiderTarget(1), raiderTarget(2), raiderTarget(3), raiderTarget(4), raiderTarget(5), raiderTarget(6)];
		let canDoIt = !z.scarCAC;
		for(let i = 0; canDoIt && !(i >= z.raiders.length); i++) {
			canDoIt = !(z.raiders[i ] > 0 && targets[z.raiders[i ] - 1] === z.raiders[i ]);
		}
		if(canDoIt) {
			for(let i = 0; !(i >= z.raiders.length); i++) {
				if(z.raiders[i ] > 0) {
					z.raiders[i ] = targets[z.raiders[i ] - 1];
				}
			}
			addAlert("Raiders moved.");
			t.value += "Raiders move.\r\n";
			if(z.dogfightCAC) {
				return launchTwoRaiders();
			}
			return true;
		} else {
			resetRaiderActivations();
			if(z.dogfightCAC) {
				if(launchTwoRaiders()) {
					resetActivatingSector();
				} else {
					optionForAll("Resume Raider Activation");
				}
			} else {
				resetActivatingSector();
			}
			return false;
		}
	} else {
		if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
			let raiderLaunches = [];
			if(z.basestars[0][0] > 0 && !hangarDisabled(0)) {
				raiderLaunches.push(z.basestars[0][0]);
				raiderLaunches.push(z.basestars[0][0]);
				if(z.cylonSwarm) {
					raiderLaunches.push(z.basestars[0][0]);
				}
			}
			if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
				raiderLaunches.push(z.basestars[1][0]);
				raiderLaunches.push(z.basestars[1][0]);
				if(z.cylonSwarm) {
					raiderLaunches.push(z.basestars[1][0]);
				}
			}
			if(raiderLaunches.length === 0) {
				plainAlert("Hangar Disabled: Raider Activation fizzles.");
				return true;
			} else {
				for(let i = 0; !(i >= raiderLaunches.length); i++) {
					placeRaider(raiderLaunches[i ]);
				}
				return true;
			}
		} else if(z.CFB) {
			if(raiderReserves() === 0) {
				let candidateSector = -1;
				let candidateRoll = 0;
				for(let i = 0; !(i >= z.raiders.length); i++) {
					let roll = CFBroll(z.raiders[i ]);
					if(roll > candidateRoll) {
						candidateRoll = roll;
						candidateSector = z.raiders[i ];
					}
				}
				let bob = advancePursuit();
				if(z.pursuitTrack !== 0) {
					jumpInSector(-candidateSector);
				}
				return bob;
			} else {
				plainAlert("Roll a die to place a Raider on the CFB; the Pursuit Track will then advance.");
				z.dieRollQueue.push("CFB Raider Placement");
				if(z.dieRollQueue.length === 1) {
					z.dieRoller = z.turn;
				}
				return false;
			}
		} else {
			plainAlert("No effect.");
			return true;
		}
	}
}

function destroyNCCivilian() {
	let done = true;
	if(z.lockedCivilians.length > 0) {
		let civ = z.lockedCivilians.pop();
		t.value += bold("The top Locked Civilian is destroyed.\r\n");
		done = destroyCivilian(civ);
	} else if(z.preparedCivilians.length > 0) {
		let civ = z.preparedCivilians.pop();
		t.value += bold("The top Prepared Civilian is destroyed.\r\n");
		done = destroyCivilian(civ);
	} else {
		t.value += "There are no Civilians remaining on New Caprica.";
	}
	return done;
}

function activateOFs() {
	let done = true;
	t.value += bold("Occupation Forces Activated.\r\n");
	addAlert("Activating Occupation Forces.");
	if(OFReserves() === 4) {
		plainAlert("Occupation Force placed on the Occupation Authority.");
		z.OFs[0] = 1;
	} else {
		for(let j = 0; !(j >= 4); j++) {
			if(z.OFs[j] === 3) {
				done = destroyNCCivilian() && done;
				t.value += "Occupation Force on the Shipyard removed.\r\n";
				z.OFs[j] = 0;
			} else if(z.OFs[j] > 0) {
				z.OFs[j]++;
				if(z.OFs[j] === 2) {
					t.value += "Occupation Force advances to Breeder's Canyon.\r\n";
				} else if(z.OFs[j] === 3) {
					t.value += "Occupation Force advances to the Shipyard.\r\n";
				}
			}
		}
	}
	return done;
}

function activateHeavies() {
	let byYourCommand = arguments.length > 0;
	t.value += bold("Heavy Raiders Activated.\r\n");
	addAlert("Activating Heavy Raiders.");
	let centurionActivated = false;
	let centurionVictory = false;
	if(centurionReserves() !== z.centurions.length) {
		for(let i = 0; !(i >= z.centurions.length); i++) {
			if(z.centurions[i ] > 0) {
				centurionActivated = true;
				if(!byYourCommand){
					z.centurions[i ]++;
					if(z.centurions[i ] === 5) {
						centurionVictory = true;
					} else {
						t.value += "A Centurion advances to space " + z.centurions[i ] + " of the Boarding Party Track.\r\n";
					}
				}
			}
		}
	}
	if(centurionVictory) {
		addAlert("Cylons win on Centurions.");
		t.value += bold('A Centurion has advanced to the "Cylons Win" space of the Boarding Party Track.\r\n');
		t.value += "Galactica's atmosphere is quickly vented and its guns turned on the civilian fleet.\r\n";
		endGame(false);
		return true;
	}
	if(z.heavies.length - heaviesAway() > 0) {
		let boardingHeavies5 = [];
		let boardingHeavies6 = [];
		for(let i = 0; !(i >= z.heavies.length); i++) {
			switch (z.heavies[i ]) {
				case 1:
					z.heavies[i ] = 6;
					t.value += "Heavy in Sector 1 moves into Sector 6.\r\n";
					break;
				case 2:
					z.heavies[i ] = 1;
					t.value += "Heavy in Sector 2 moves into Sector 1.\r\n";
					break;
				case 3:
					z.heavies[i ] = 4;
					t.value += "Heavy in Sector 3 moves into Sector 4.\r\n";
					break;
				case 4:
					z.heavies[i ] = 5;
					t.value += "Heavy in Sector 4 moves into Sector 5.\r\n";
					break;
				case 5:
					boardingHeavies5.push(i);
					break;
				case 6:
					boardingHeavies6.push(i);
					break;
			}
		}
		if(boardingHeavies5.length + boardingHeavies6.length > centurionReserves() && boardingHeavies5.length > 0 && boardingHeavies6.length > 0) {
			if(centurionReserves() > 0) {
				plainAlert("There are not enough Centurions for all the Heavy Raiders to board." + z.players[z.turn] +
					", as current player, must choose which ones board.");
				addOption(z.turn, "Have a Heavy Raider board Galactica", undefined, true);
				return false;
			} else {
				plainAlert("All Centurions are on board Galactica; no Heavy Raider can board.");
			}
		} else if((boardingHeavies5.length > 0 || boardingHeavies6.length > 0) && centurionReserves() === 0) {
			plainAlert("All Centurions are on board Galactica; no Heavy Raider can board.");
		} else {
			for(let i = 0; !(i >= boardingHeavies5.length) && centurionReserves() > 0; i++) {
				z.heavies[boardingHeavies5[i ]] = 0;
				boldAlert("Heavy in Sector 5 boards Galactica.");
				boardGalactica();
			}
			for(let i = 0; !(i >= boardingHeavies6.length) && centurionReserves() > 0; i++) {
				z.heavies[boardingHeavies6[i ]] = 0;
				boldAlert("Heavy in Sector 6 boards Galactica.");
				boardGalactica();
			}
		}
	} else {
		if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
			let heavyLaunches = [];
			if(z.basestars[0][0] > 0 && !hangarDisabled(0)) {
				heavyLaunches.push(z.basestars[0][0]);
				if(z.cylonSwarm) {
					heavyLaunches.push(z.basestars[0][0]);
				}
			}
			if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
				heavyLaunches.push(z.basestars[1][0]);
				if(z.cylonSwarm) {
					heavyLaunches.push(z.basestars[1][0]);
				}
			}
			if(heavyLaunches.length === 0) {
				t.value += "Hangar Disabled: no Heavy Raider launches.\r\n";
			} else if(heavyLaunches.length > heaviesAway()) {
				if(z.basestars[0][0] !== z.basestars[1][0]) {
					plainAlert(
						"Due to the combination of The Red Stripes and Massive Deployment [Cylon Swarm], there are not enough Heavy Raiders to launch. " + z
						.players[z.turn] +
						", as current player, must manually place the 2 Heavy Raiders (2 from one basestar, 2 from the other basestar, or 1 from each.)");
					let context = [0, 0, 0, 0, 0, 0];
					context[z.basestars[0][0] - 1] = 2;
					context[z.basestars[1][0] - 1] = 2;
					addOption(z.turn, "Place a Heavy Raider on the main game board", context, true);
					return false;
				} else {
					let numLaunches = heaviesAway();
					for(let i = 0; !(i >= numLaunches); i++) {
						placeHeavy(heavyLaunches[i ]);
					}
				}
			} else {
				for(let i = 0; !(i >= heavyLaunches.length); i++) {
					placeHeavy(heavyLaunches[i ]);
				}
			}
		} else if(z.CFB && !centurionActivated) {
			if(heavyReserves() === 0) {
				let candidateSector = -1;
				let candidateRoll = 0;
				for(let i = 0; !(i >= z.heavies.length); i++) {
					let roll = CFBroll(z.heavies[i ]);
					if(roll > candidateRoll) {
						candidateRoll = roll;
						candidateSector = z.heavies[i ];
					}
				}
				let bob = advancePursuit();
				if(z.pursuitTrack !== 0) {
					jumpInSector(-candidateSector);
				}
				return bob;
			} else {
				plainAlert("Roll a die to place a Heavy Raider on the CFB; the Pursuit Track will then advance.");
				z.dieRollQueue.push("CFB Heavy Raider Placement");
				if(z.dieRollQueue.length === 1) {
					z.dieRoller = z.turn;
				}
				return false;
			}
		} else if(!centurionActivated) {
			plainAlert("No effect.");
		} else if (centurionActivated && byYourCommand){
			plainAlert("No effect.");
		}
	}
	return true;
}

function activateBasestars() {
	t.value += bold("Basestars activate.") + "\r\n";
	if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
		let bsCount = 0;
		if(z.basestars.length > 0 && z.basestars[0][0] > 0 && !weaponsDisabled(0)) {
			bsCount++;
		}
		if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !weaponsDisabled(1)) {
			bsCount++;
		}
		if(bsCount === 0) {
			plainAlert("Weapons Disabled: Basestar Activation fizzles.");
			return true;
		} else if(bsCount === 1) {
			plainAlert("One Basestar shoots at Galactica.");
			if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && z.turn === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
				delete z.stratPlanPause;
				plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
				SPTokenBad("Basestar vs. Galactica",z.turn);
			} else {
				z.dieRollQueue.push("Basestar vs. Galactica");
				if(z.dieRollQueue.length === 1) {
					z.dieRoller = z.turn;
				}
			}
			return false;
		} else {
			plainAlert("Two Basestars shoot at Galactica; roll for each in turn.");
			if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && z.turn === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
				delete z.stratPlanPause;
				plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
				SPTokenBad("Basestar vs. Galactica",z.turn);
			} else {
				z.dieRollQueue.push("Basestar vs. Galactica");
			}
			z.dieRollQueue.push("Basestar vs. Galactica");
			if(z.dieRollQueue.length === 2) {
				z.dieRoller = z.turn;
			}
			return false;
		}
	} else if(!z.CFB || z.basestars.length === 0) {
		plainAlert("Basestar activation fizzles.");
		return true;
	} else {
		if(basestarReserves() === 0) {
			let candidateSector = -1;
			let candidateRoll = 0;
			for(let i = 0; !(i >= z.basestars.length); i++) {
				let roll = CFBroll(z.basestars[i ][0]);
				if(roll > candidateRoll) {
					candidateRoll = roll;
					candidateSector = z.basestars[i ][0];
				}
			}
			plainAlert("Basestar Activation: no Basestars are on the main board or the reserves, so...");
			let bob = advancePursuit();
			if(z.pursuitTrack !== 0) {
				jumpInSector(-candidateSector);
			}
			return bob;
		} else {
			plainAlert("Roll a die to place a Basestar on the CFB; the Pursuit Track will then advance.");
			z.dieRollQueue.push("CFB Basestar Placement");
			if(z.dieRollQueue.length === 1) {
				z.dieRoller = z.turn;
			}
			return false;
		}
	}
} /* TODO: check all of these work if there are no heavies and no basestars (from passing that mission twice) */
function cylonFleetLaunch() {
	t.value += myPlayer + " chooses to launch 2 Raiders and 1 Heavy Raider from each Basestar.\r\n";
	addAlert("Launching 2 Raiders and 1 Heavy Raider from each basestar.");
	let bsCount = 0;
	let sector1 = 0;
	let sector2 = 0;
	if(z.basestars.length > 0 && z.basestars[0][0] > 0 && !hangarDisabled(0)) {
		sector1 = z.basestars[0][0];
		bsCount++;
	}
	if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
		sector2 = z.basestars[1][0];
		bsCount++;
	}
	if(bsCount === 0) {
		addAlert("There are no basestars on the main game board with undamaged hangars.  You may want to try something else.");
		return 0;
	}
	if(raidersAway() === 0 && heaviesAway() === 0) {
		addAlert("All Raiders and Heavy Raiders are already on the main game board. You may want to try something else.");
	}
	let raidersToLaunch = 0;
	let heaviesToLaunch = 0;
	let numRaidersLaunched = 2;
	let numHeaviesLaunched = 1;
	if(z.cylonSwarm) {
		numRaidersLaunched = 3;
		numHeaviesLaunched = 2;
	}
	raidersToLaunch = numRaidersLaunched * bsCount;
	heaviesToLaunch = numHeaviesLaunched * bsCount;
	if(raidersToLaunch > raidersAway() && heaviesToLaunch > heaviesAway()) {
		if(bsCount === 2 && sector1 !== sector2) {
			let alertText = "There are not enough ships available to launch a full complement of Raiders and Heavy Raiders from each basestar. " + z.players[z
				.turn] + ", as current player, must place the ships manually.";
			if(z.cylonSwarm) {
				alertText += " Remember that due to Massive Deployment [from Cylon Swarm] each Basestar would launch 3 Raiders and 2 Heavy Raiders.";
			}
			let contextR = [0, 0, 0, 0, 0, 0];
			contextR[sector1 - 1] = numRaidersLaunched;
			contextR[sector2 - 1] = numRaidersLaunched;
			addOption(z.turn, "Place Raider(s) on the main game board", contextR, true);
			let contextH = [0, 0, 0, 0, 0, 0];
			contextH[sector1 - 1] = numHeaviesLaunched;
			contextH[sector2 - 1] = numHeaviesLaunched;
			addOption(z.turn, "Place a Heavy Raider on the main game board", contextH, true);
			plainAlert(alertText);
		} else {
			let sector = sector1;
			if(sector === 0) {
				sector = sector2;
			}
			raidersToLaunch = raidersAway();
			heaviesToLaunch = heaviesAway();
			for(let i = 0; !(i >= heaviesToLaunch); i++) {
				placeHeavy(sector);
			}
			for(let i = 0; !(i >= raidersToLaunch); i++) {
				placeRaider(sector);
			}
			addAlert("Remaining Raiders and Heavy Raiders placed in Sector " + sector + ".");
		}
	} else if(raidersToLaunch > raidersAway()) {
		if(sector1 > 0) {
			for(let i = 0; !(i >= numHeaviesLaunched); i++) {
				placeHeavy(sector1);
			}
			if(z.cylonSwarm) {
				t.value += "2 Heavies launched in Sector " + sector1 + ".\r\n";
			} else {
				t.value += "1 Heavy Raider launched in Sector " + sector1 + ".\r\n";
			}
		}
		if(sector2 > 0) {
			for(let i = 0; !(i >= numHeaviesLaunched); i++) {
				placeHeavy(sector2);
			}
			if(z.cylonSwarm) {
				t.value += "2 Heavies launched in Sector " + sector2 + ".\r\n";
			} else {
				t.value += "1 Heavy Raider launched in Sector " + sector2 + ".\r\n";
			}
		}
		if(bsCount === 2 && sector1 !== sector2) {
			let alertText = "There are not enough ships available to launch a full complement of Raiders from each basestar. " + z.players[z.turn] +
				", as current player, must place the Raiders manually.";
			if(z.cylonSwarm) {
				alertText += " Remember that due to Massive Deployment [from Cylon Swarm] each Basestar would launch 3 Raiders.";
			}
			let contextR = [0, 0, 0, 0, 0, 0];
			contextR[sector1 - 1] = numRaidersLaunched;
			contextR[sector2 - 1] = numRaidersLaunched;
			plainAlert(alertText);
			addOption(z.turn, "Place Raider(s) on the main game board", contextR, true);
		} else {
			let sector = sector1;
			if(sector === 0) {
				sector = sector2;
			}
			raidersToLaunch = raidersAway();
			for(let i = 0; !(i >= raidersToLaunch); i++) {
				placeRaider(sector);
			}
			addAlert("Remaining Raiders placed in Sector " + sector + ".");
		}
	} else if(heaviesToLaunch > heaviesAway()) {
		if(sector1 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector1);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders launched in Sector " + sector1 + ".\r\n";
			} else {
				t.value += "2 Raiders launched in Sector " + sector1 + ".\r\n";
			}
		}
		if(sector2 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector2);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders launched in Sector " + sector2 + ".\r\n";
			} else {
				t.value += "2 Raiders launched in Sector " + sector2 + ".\r\n";
			}
		}
		if(bsCount === 2 && sector1 !== sector2) {
			let alertText = "There are not enough ships available to launch a full complement of Heavy Raiders from each basestar. " + z.players[z.turn] +
				", as current player, must place the Heavies manually.";
			if(z.cylonSwarm) {
				alertText += " Remember that due to Massive Deployment [from Cylon Swarm] each Basestar would launch 2 Heavy Raiders.";
			}
			let contextH = [0, 0, 0, 0, 0, 0];
			contextH[sector1 - 1] = numHeaviesLaunched;
			contextH[sector2 - 1] = numHeaviesLaunched;
			addOption(z.turn, "Place a Heavy Raider on the main game board", contextH, true);
			plainAlert(alertText);
		} else {
			let sector = sector1;
			if(sector === 0) {
				sector = sector2;
			}
			heaviesToLaunch = heaviesAway();
			for(let i = 0; !(i >= heaviesToLaunch); i++) {
				placeHeavy(sector);
			}
			addAlert("Remaining Heavy Raiders placed in Sector " + sector + ".");
		}
	} else {
		if(sector1 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector1);
			}
			for(let i = 0; !(i >= numHeaviesLaunched); i++) {
				placeHeavy(sector1);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders and 2 Heavies launched in Sector " + sector1 + ".\r\n";
			} else {
				t.value += "2 Raiders and 1 Heavy Raider launched in Sector " + sector1 + ".\r\n";
			}
		}
		if(sector2 > 0) {
			for(let i = 0; !(i >= numRaidersLaunched); i++) {
				placeRaider(sector2);
			}
			for(let i = 0; !(i >= numHeaviesLaunched); i++) {
				placeHeavy(sector2);
			}
			if(z.cylonSwarm) {
				t.value += "3 Raiders and 2 Heavies launched in Sector " + sector2 + ".\r\n";
			} else {
				t.value += "2 Raiders and 1 Heavy Raider launched in Sector " + sector2 + ".\r\n";
			}
		}
		addAlert("Ships launched with Cylon Fleet.");
	}
}

function initializeCrisis(isSuper) {
	if(isSuper) {
		t.value += "\r\n[ima" + bl + "geid=1080529 medium]\r\n";
	}
	if(d.CAC[z.currentCrisis] === 1) {
		if(!isSuper) {
			t.value += "\r\n[ima" + bl + "geid=647924 medium]\r\n";
		}
		t.value += size(colorText("red", italics(bold(d.crisisNames[z.currentCrisis]))), 14) + "\r\n";
		if(!isSuper) {
			addAlert("The Cylons Attack!");
			primeCylonActivation();
		} else {
			if(d.crisisNames[z.currentCrisis] === "Massive Assault" && !z.negotiation) {
				if(activateHeavies()) {
					activateBasestars();
				} else {
					plainAlert("Once that's done, activate Basestars.");
					optionForAll("Activate Basestars");
				}
			} else if(d.crisisNames[z.currentCrisis] === "Lured into a Trap" && !z.negotiation) {
				activateRaiders();
			}
			z.toDoCACSetup = true;
		}
	} else {
		if(!isSuper) {
			if(z.galacticaAway || z.galacticaReturned) {
				t.value += "\r\n[ima" + bl + "geid=713177 medium]\r\n";
			} else {
				t.value += "\r\n[ima" + bl + "geid=735196 medium]\r\n";
			}
		}
		t.value += size(italics(difficultyTemplate(z.currentCrisis)), 14) + "\r\n";
		if((z.currentCrisis === 7 || z.currentCrisis === 131) && z.nukes === 0 && !(z.players[z.admiral] === "Lee" && z.miracles[z.admiral] > 0 && !z.theFarm) && 
		   !(z.vBrutality && actsOfFaith("Lee") && z.players[z.admiral] === "Gaius")) {
			boldAlert("Admiral " + z.players[z.admiral] + " has no nuke tokens, and automatically chooses the bottom option.");
			processBottom();
			primeCylonActivation();
			z.finishedCrisis = true;
		} else if(z.vBrutality && versionAtLeast([1, 2, 4, 2]) && d.crisisNames[z.currentCrisis] === "'Demand Peace' Manifesto" && 2 > z.nukes) {
			boldAlert("Admiral " + z.players[z.admiral] + " does not have two nuke tokens to discard, and automatically chooses the top option.");
			processTop();
			primeCylonActivation();
			z.finishedCrisis = true;
		} else if(z.currentCrisis === 173 && !isOnNewCaprica(z.turn) && !(z.players[z.admiral] === "Lee" && z.miracles[z.admiral] > 0 && !z.theFarm) && 
		   !(z.vBrutality && actsOfFaith("Lee") && z.players[z.admiral] === "Gaius")) {
			boldAlert(z.players[z.turn] + " is not on New Caprica, so Admiral " + z.players[z.admiral] + " automatically chooses the bottom option.");
			processBottom();
			primeCylonActivation();
			z.finishedCrisis = true;
		} else if(d.admiralChooses[z.currentCrisis]) {
			t.value += bold(colorText("green", "Admiral") + " " + z.players[z.admiral]) + ", your choice here.\r\n";
		} else if(d.presidentChooses[z.currentCrisis]) {
			t.value += bold(colorText("orange", "President") + " " + z.players[z.president]) + ", your choice here.\r\n";
		} else if(d.cagChooses[z.currentCrisis]) {
			t.value += bold(colorText("red", "CAG") + " " + z.players[z.cag]) + ", your choice here.\r\n";
		} else if(d.currentPlayerChooses[z.currentCrisis]) {
			if(z.players[z.turn] === "Tory" && z.revealedCylons[z.turn] === 0 && !noDrawback(z.turn)) {
				t.value += bold("Tory automatically chooses the top option.\r\n");
				startCrisisSkillCheck();
			} else {
				t.value += bold(z.players[z.turn]) + ", your choice here.\r\n";
			}
		} else {
			startCrisisSkillCheck();
		}
	}
}

function playCrisis(player) {
	if(z.currentCrisis !== null) {
		if(!isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis)) {
			discardCrisis();
		}
	}
	z.currentCrisis = z.crisisDeck.pop();
	if(z.crisisDeck.length === 0) {
		plainAlert("Crisis deck reshuffles.");
		z.crisisDeck = shuffle(z.crisisDiscards);
		z.crisisDiscards = [];
	}
	if(player === undefined) {
		z.crisisPlayer = z.turn;
	} else {
		z.crisisPlayer = player;
	}
	initializeCrisis(false);
}

function prepareCivilian() {
	/* RULES: can you choose to evacuate/prepare a civilian if that's not legit? */
	if(z.lockedCivilians.length === 0) {
		addAlert("There are no civilians to prepare.");
	} else {
		addAlert("You prepare a civilian.");
		t.value += "A Civilian is prepared.\r\n";
		z.preparedCivilians.unshift(z.lockedCivilians.pop());
	}
}

function evacuateCivilian() {
	if(z.galacticaAway) {
		addAlert("Civilians cannot be evacuated before Galatica returns.");
	} else if(z.preparedCivilians.length === 0) {
		addAlert("There are no Civilians to evacuate.");
	} else {
		plainAlert(z.players[z.turn] + ", as current player, must now evacuate a Civilian to Sector 5 or Sector 6.");
		if(hasOption(z.turn,"Evacuate a Civilian")){
			let num = getContext(z.turn,"Evacuate a Civilian");
			if(Number.isInteger(num)){
				addOption(z.turn,"Evacuate a Civilian",num+1,true);
			} else {
				addOption(z.turn,"Evacuate a Civilian",1,true);
			}
		} else {
			addOption(z.turn,"Evacuate a Civilian",1,true);
		}
	}
} /* TODO: cancelling out of here can be an issue if you're doing it from "Activate Another Location" land */
function activateLocation(location, action) {
	let roslin = function() {
		if(action) {
			didAction();
		}
		removeOption(me, "Activate " + location);
		removeOption(me, "Activate Occupation Authority");
		removeOption(me, "Activate Breeder's Canyon");
		removeOption(me, "Activate Shipyard");
	};
	t.value += bold(z.players[me] + " activates " + location + ".\r\n");
	if(location === "Human Fleet" && !z.daybreak && !z.pegasus) {
		addOption(me, "[Human Fleet] Look at another player's hand and steal a Skill Card", undefined, true);
	} else if(location === "FTL Control") {
		if(action) {
			didAction();
			action = false;
		}
		if(z.jumpTrack === 3) {
			SPTokenBad("FTL Control (Blue -3)");
		} else {
			SPTokenBad("FTL Control (Blue -1)");
		}
		if(location === "FTL Control" && characterPresent("Gaeta") && (z.players[me] !== "Billy" || z.phase !== 3 || noDrawback(me)) && !z.vBrutality) {
			plainAlert("Remember that Gaeta may use his FTL Operator ability to reroll this die.");
		}
		if(z.players[me] === "Gaeta" && z.vBrutality && (10 > z.distance || (8 > z.distance && (z.destination === "Kobol" || z.destination ===
				"Ionian Nebula")))) {
			/* TODO: improve this */
			plainAlert("Remember that Gaeta must use his FTL Operator ability after this roll, but before Destination cards are drawn.");
			addOption(me, "FTL Operator", undefined, false);
		}
	} else if(location === "Armory") {
		let centurionBases = [0, 0, 0, 0];
		for(let j = 0; !(j >= z.centurions.length); j++) {
			if(z.centurions[j] > 0) {
				centurionBases[z.centurions[j] - 1]++;
			}
		}
		let num = 0;
		for(let j = 0; !(j >= 4); j++) {
			if(centurionBases[j] > 0) {
				num++;
			}
		}
		if(num === 1) {
			if(action) {
				didAction();
				action = false;
			}
			z.destroyer = me;
			SPTokenBad("Armory");
		} else {
			let promptText = "Which space on the Boarding Party track are you targeting? (1-4)";
			for(let j = 0; !(j >= 4); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(centurionBases[j] === 0) {
					promptText += "(no centurions here)";
				} else {
					promptText += "Space " + (j + 1);
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 4 || centurionBases[a - 1] === 0, mainMenu, (prompted) => {
				z.destroyer = me;
				if(action) {
					didAction();
					action = false;
				}
				SPTokenBad("Armory vs. Centurion (space " + prompted + ")");
				roslin();
				mainMenu();
			});
			return;
		}
	} else if(location === "Main Batteries") {
		/* RULES: targeting an empty sector? */
		let promptText = "Which Sector are you targeting with Main Batteries? (1-6)";
		promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (choice) => {
			if(action) {
				didAction();
				action = false;
			}
			SPTokenBad("Main Batteries vs. Sector " + choice);
			roslin();
			mainMenu();
		});
		return;
	} else if(location === "Weapons Control") {
		let WCoptions = [];
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(z.basestars[j][0] > 0) {
				if(j === 0 || (j === 1 && (z.basestars[1][0] !== z.basestars[0][0] || z.basestars[1].length > 1 || z.basestars[0].length > 1))) {
					WCoptions.push(basestarName(j));
				}
			}
		}
		let heavies = [0, 0, 0, 0, 0, 0];
		for(let j = 0; !(j >= z.heavies.length); j++) {
			if(z.heavies[j] > 0) {
				heavies[z.heavies[j] - 1] = 1;
			}
		}
		for(let j = 0; !(j >= 6); j++) {
			if(heavies[j] === 1) {
				WCoptions.push("Heavy Raider (Sector " + (j + 1) + ")");
			}
		}
		if(z.scarCAC) {
			WCoptions.push("Scar");
		}
		let raiders = [0, 0, 0, 0, 0, 0];
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] > 0) {
				raiders[z.raiders[j] - 1] = 1;
			}
		}
		for(let j = 0; !(j >= 6); j++) {
			if(raiders[j] === 1) {
				WCoptions.push("Raider (Sector " + (j + 1) + ")");
			}
		}
		let promptText = "Which Cylon ship would you like to target? (1-" + WCoptions.length + ")";
		for(let j = 0; !(j >= WCoptions.length); j++) {
			promptText += "\n" + (j + 1) + ": " + WCoptions[j];
		}
		promptNum(promptText, (a) => 1 > a || a > WCoptions.length, mainMenu, (prompted) => {
			if(action) {
				didAction();
				action = false;
			}
			if(/^Raider/.test(WCoptions[prompted - 1])) {
				plainAlert("Attacking " + WCoptions[prompted - 1]);
				z.dieRollQueue.push("Weapons Control vs. " + WCoptions[prompted - 1]);
				z.dieRoller = me;
			} else {
				SPTokenBad("Weapons Control vs. " + WCoptions[prompted - 1]);
				if(/^Basestar/.test(WCoptions[prompted - 1])) {
					z.destroyer = me;
				}
				if(/Structural Damage/.test(WCoptions[prompted - 1])) {
					z.dieRollModifier += 2;
					plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
				}
			}
			roslin();
			mainMenu();
		});
		return;
	} else if(location === "Pegasus CIC") {
		let bsTarget = "";
		let useCIC = function() {
			if(action) {
				didAction();
				action = false;
			}
			SPTokenBad("Pegasus CIC vs. " + bsTarget);
			z.destroyer = me;
			if(/Structural Damage/.test(bsTarget)) {
				z.dieRollModifier += 2;
				plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
			}
			roslin();
			mainMenu();
		};
		if(z.basestars.length > 1 && z.basestars[0][0] > 0 && z.basestars[1][0] > 0 && (z.basestars[0][0] !== z.basestars[1][0] || z.basestars[0].length > 1 ||
				z.basestars[1].length > 1)) {
			let bs1 = basestarName(0);
			let bs2 = basestarName(1);
			promptNum("Which Basestar are you targeting?\n1: " + bs1 + "\n2: " + bs2, (a) => 1 > a || a > 2, mainMenu, (choice) => {
				if(choice === 1) {
					bsTarget = bs1;
				} else {
					bsTarget = bs2;
				}
				useCIC();
			});
			return;
		} else {
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(z.basestars[j][0] > 0) {
					bsTarget = basestarName(j);
					useCIC();
					break;
				}
			}
			return;
		}
	} else if(location === "Command") {
		menuPage = "[Manual Viper Activation]";
		addOption(me, "Activate an unmanned Viper", 2, false);
		addAlert("You may now activate up to two unmanned vipers.");
	} else if(location === "Hangar Deck") {
		addAlert(
		"You must now launch yourself in a viper in Sector 5 or 6, then you may take another action."); /* TODO: don't populate new actions until you actually launch */
		if(vipersIIReserves() > 0) {
			addOption(me, "Launch in a Viper Mk II in Sector 5", undefined, true);
			addOption(me, "Launch in a Viper Mk II in Sector 6", undefined, true);
		}
		if(z.CFB && vipersVIIReserves() > 0) {
			addOption(me, "Launch in a Viper Mk VII in Sector 5", undefined, true);
			addOption(me, "Launch in a Viper Mk VII in Sector 6", undefined, true);
		}
		if(z.daybreak && assaultRaptorsReserves() > 0) {
			addOption(me, "Launch in an Assault Raptor in Sector 5", undefined, true);
			addOption(me, "Launch in an Assault Raptor in Sector 6", undefined, true);
		}
		if(isUnmannedInSpace() && (vipersIIReserves() === 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0)) {
			addOption(me, "Recall an unmanned Viper", "Launch", true);
		}
		mainMenu();
		return;
	} else if(location === "Communications") {
		if(myPlayer !== "Dee") {
			addAlert("You may now look at up to 2 civilians; you may then move them to adjacent space area(s).");
			addOption(me, "Inspect/Move a Civilian in space", [], false);
		} else {
			addAlert("You may now look at all civilians in space areas; you may then move them to adjacent space area(s).");
			addOption(me, "Inspect all Civilians in space", undefined, false);
			addOption(me, "Inspect/Move a Civilian in space", [], false);
		}
	} else if(location === "Research Lab" && (!z.vBrutality || !versionAtLeast([1, 2, 4, 6]) || (z.destination !== "Earth" && z.destination !==
		"Ionian Earth"))) {
		confirmify("What type of skill card would you like?", () => {
			addAlert("You draw " + cardText(dealSkillCard(me, 2)) + ".");
			roslin();
			mainMenu();
		}, () => {
			addAlert("You draw " + cardText(dealSkillCard(me, 4)) + ".");
			roslin();
			mainMenu();
		}, "Engineering", "Tactics");
		return;
	} else if(location === "Admiral's Quarters" || location === "Airlock" || location === "Resistance HQ") {
		let promptText = "Who are you targeting? (1-" + z.numPlayers + ")";
		let validTargets = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			promptText += "\n" + (j + 1) + ": ";
			validTargets.push(true);
			if(location === "Admiral's Quarters") {
				validTargets[j] = false;
				if(z.revealedCylons[j] === 1) {
					promptText += "[CYLON]";
				} else if(z.playerLocations[j] === "Stranded on Caprica") {
					promptText += "[STRANDED]";
				} else if(z.playerLocations[j] === "Brig") {
					promptText += "[BRIGGED]";
				} else if(z.playerLocations[j] === "Detention") {
					promptText += "[DETAINED]";
				} else {
					validTargets[j] = true;
				}
			} else if(location === "Airlock") {
				if(z.revealedCylons[j] === 1) {
					promptText += "[CYLON]";
					validTargets[j] = false;
				}
			} else if(!isOnNewCaprica(j)) {
				promptText += "[NOT ON NEW CAPRICA]";
				validTargets[j] = false;
			}
			if(validTargets[j]) {
				promptText += z.players[j];
			}
		}
		promptNum(promptText, (a) => 1 > a || a > z.numPlayers || !validTargets[a - 1], mainMenu, (target) => {
			t.value += bold(z.players[me] + " targets " + z.players[target - 1] + ".\r\n");
			if(action) {
				didAction();
				action = false;
			}
			startLocationSkillCheck(location, target - 1);
			roslin();
			mainMenu();
		});
		return;
	} else if(location === "Brig") {
		if(action) {
			didAction();
			action = false;
		}
		startLocationSkillCheck("Brig", me);
	} else if(location === "Detention") {
		if(action) {
			didAction();
			action = false;
		}
		startLocationSkillCheck("Detention", me);
	} else if(location === "Administration" && !z.daybreak) {
		for(let i = 0; !(i >= z.numPlayers); i++) {
			for(let j = 0; !(j >= z.quorumTitles[i ].length); j++) {
				if(z.quorumTitles[i ][j] === 5 && i !== z.president) {
					t.value += titleList(i) + " " + z.players[i ] + " will become President if this skill check passes.\r\n";
					if(action) {
						didAction();
						action = false;
					}
					startLocationSkillCheck("Administration", i);
					roslin();
					mainMenu();
					return;
				}
			}
		}
		let promptText = "Who will become President if this skill check passes? (1-" + z.numPlayers + ")";
		let validTargets = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			promptText += "\n" + (j + 1) + ": ";
			validTargets.push(false);
			if(z.revealedCylons[j] === 1) {
				promptText += "[CYLON]";
			} else if(isTheCylonLeader(j)) {
				promptText += "[CYLON LEADER]";
			} else if(j === z.theSympatheticCylon) {
				promptText += "[SYMPATHETIC CYLON]";
			} else {
				promptText += z.players[j];
				validTargets[j] = true;
			}
		}
		promptNum(promptText, (a) => 1 > a || a > z.numPlayers || !validTargets[a - 1], mainMenu, (target) => {
			let administration = () => {
				t.value += bold(z.players[me] + " chooses " + z.players[target - 1] + " to become President if this skill check passes.\r\n");
				if(action) {
					didAction();
					action = false;
				}
				startLocationSkillCheck("Administration", target - 1);
				roslin();
				mainMenu();
			};
			if(target - 1 === z.president) {
				confirmify(z.players[target - 1] +
					" is already the President. Are you sure you want to continue? (The pass and fail effects of this skill check will be No Effect.)",
					mainMenu, administration);
			} else {
				administration();
			}
		});
		return;
	} else if((location === "Press Room" && !z.daybreak) || (location === "President's Office" && z.daybreak)) {
		dealSkillCard(me, 0);
		dealSkillCard(me, 0);
		addAlert("You drew " + cardText(z.skillCardHands[me][z.skillCardHands[me].length - 2]) + " and " + cardText(z.skillCardHands[me][z.skillCardHands[me]
			.length - 1
		]) + ".");
	} else if((location === "President's Office" && !z.daybreak) || (location === "Quorum Chamber" && z.daybreak)) {
		dealQuorumCard();
		addAlert("You may now play a Quorum card or draw another.");
		addOption(me, "Play a Quorum Card", undefined, true);
		addOption(me, "Draw a Quorum Card", undefined, true);
	} else if(location === "Caprica") {
		let regularCaprica = function() {
			/* TODO: make sure this doesn't screw up if you cancel out */
			t.value += myPlayer + " draws 2 crises.\r\n";
			let promptText = "Which crisis would you like to play? (1-2)\n The other ";
			if(z.daybreak || z.pegasus) {
				promptText += "will be returned to the bottom of the Crisis deck.\n\n";
			} else {
				promptText += "will be discarded.\n\n";
			}
			let crisis1 = z.crisisDeck.pop();
			if(z.crisisDeck.length === 0) {
				plainAlert("Crisis deck reshuffles.");
				z.crisisDeck = shuffle(z.crisisDiscards);
				z.crisisDiscards = [];
			}
			let crisis2 = z.crisisDeck.pop();
			if(z.crisisDeck.length === 0) {
				plainAlert("Crisis deck reshuffles.");
				z.crisisDeck = shuffle(z.crisisDiscards);
				z.crisisDiscards = [];
			}
			promptText += "1: " + d.crisisNames[crisis1] + "\n";
			promptText += "2: " + d.crisisNames[crisis2];
			promptNum(promptText, (a) => 1 > a || a > 2, () => {
				z.crisisDeck.push(crisis2);
				z.crisisDeck.push(crisis1);
				mainMenu();
			}, (prompted) => {
				if(prompted === 2) {
					if(z.daybreak || z.pegasus || z.vCaprica) {
						z.crisisDeck.unshift(crisis1);
					} else {
						z.crisisDiscards.push(crisis1);
						t.value += "Discarded Crisis: " + d.crisisNames[crisis1] + "\n";
					}
					z.crisisDeck.push(crisis2);
				} else {
					if(z.daybreak || z.pegasus || z.vCaprica) {
						z.crisisDeck.unshift(crisis2);
					} else {
						z.crisisDiscards.push(crisis2);
						t.value += "Discarded Crisis: " + d.crisisNames[crisis2] + "\n";
					}
					z.crisisDeck.push(crisis1);
				}
				z.capricaCrisis = true;
				if(action) {
					didAction();
					action = false;
				}
				playCrisis(me);
				let alertText = "Played Crisis: " + d.crisisNames[z.currentCrisis] + ".";
				if((z.turn === me && d.currentPlayerChooses[z.currentCrisis] === 1) || (me === z.admiral && d.admiralChooses[z.currentCrisis] ===
					1) || (me === z.president && d.presidentChooses[z.currentCrisis] === 1) || (me === z.cag && d.cagChooses[z.currentCrisis] === 1)
					) {
					alertText += "\nIt's your choice on this crisis.";
				}
				if(((d.currentPlayerChooses[z.currentCrisis] === 1 || d.CAC[z.currentCrisis] === 1 || z.secretDestinyPause) && (characterPresent(
						"Starbuck") && (z.miracles[getPlayerNum("Starbuck")] === 1 || actsOfFaith("Starbuck")) && !z.theFarm))) {
					plainAlert("Remember that Starbuck can use her OPG here.");
				}
				addAlert(alertText);
				mainMenu();
			});
		};
		let superCaprica = function(sc) {
			if(z.currentCrisis !== null) {
				if(!isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis)) {
					discardCrisis();
				}
			}
			z.currentCrisis = sc;
			z.crisisPlayer = me;
			for(let j = 0; !(j >= z.superCrisisHands[me].length); j++) {
				if(z.superCrisisHands[me][j] === sc) {
					z.superCrisisHands[me].splice(j, 1);
				}
			}
			if(me === z.theCylonLeader || me === z.theSympatheticCylon) {
				z.mutualAnnihilation = true;
			}
			addAlert("Playing " + d.crisisNames[sc] + ".");
			z.capricaCrisis = true;
			if(action) {
				didAction();
				action = false;
			}
			initializeCrisis(true);
			mainMenu();
		};
		if(z.superCrisisHands[me].length > 1) {
			confirmify("Would you like to play a Super Crisis or draw 2 regular Crises and pick one?", regularCaprica, () => {
				let promptText = "Which Super Crisis would you like to play?\n";
				for(let i = 0; !(i >= z.superCrisisHands[me].length); i++) {
					promptText += (i + 1) + ": " + d.crisisNames[z.superCrisisHands[me][i ]] + "\n";
				}
				promptNum(promptText, (a) => 1 > a || a > z.superCrisisHands[me].length, mainMenu, (prompted) => {
					let sc = z.superCrisisHands[me][prompted - 1];
					z.superCrisisHands[me].splice(prompted - 1, 1);
					superCaprica(sc);
				});
			}, "Super Crisis", "Regular Crises");
		} else if(z.superCrisisHands[me].length === 1) {
			confirmify("Would you like to play the Super Crisis " + d.crisisNames[z.superCrisisHands[me][0]] + " or draw 2 regular Crises and pick one?",
				regularCaprica, () => {
					let sc = z.superCrisisHands[me][0];
					z.superCrisisHands[me] = [];
					superCaprica(sc);
				}, "Super Crisis", "Regular Crises");
		} else {
			regularCaprica();
		}
		return;
	} else if(location === "Cylon Fleet") {
		if(z.negotiation) {
			addAlert("As Negotiation is in effect, this will have no effect; perhaps you want to pick another option.");
			removeOption(me, "Activate Cylon Fleet");
		} else {
			let promptText =
				"Which option would you like to pick? (1-4)\n1: Activate Raiders\n2: Activate Heavy Raiders\n3: Activate Basestars\n4: Launch 2 Raiders and 1 Heavy Raider from each Basestar";
			promptNum(promptText, (a) => 1 > a || a > 4, mainMenu, (prompted) => {
				removeOption(me, "Activate Cylon Fleet");
				switch (prompted) {
					case 1:
						activateRaiders();
						break;
					case 2:
						activateHeavies();
						break;
					case 3:
						activateBasestars();
						break;
					case 4:
						cylonFleetLaunch();
						break;
				}
				roslin();
				mainMenu();
			});
			return;
		}
	} else if(location === "Resurrection Ship") {
		if(!z.daybreak && !z.pegasus) {
			let passOff = function() {
				if(z.loyaltyHands[me].length > 0 && !(z.distance > 7) && !z.vHandoff) {
					let promptText = "Who gets your remaining Loyalty cards? (1-" + z.numPlayers + ")\n";
					for(let i = 0; !(i >= z.numPlayers); i++) {
						promptText += (i + 1) + ": "; /* RULES: pass to fellow cylon? */
						if(i === me) {
							promptText += "(cannot choose yourself)\n";
						} else {
							promptText += z.players[i ] + "\n";
						}
					}
					promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me, mainMenu, (prompted) => {
						z.loyaltyHands[prompted - 1] = z.loyaltyHands[prompted - 1].concat(z.loyaltyHands[me]);
						z.loyaltyHands[me] = [];
						addAlert("Passed Loyalties to " + z.players[prompted - 1]);
						t.value += bold(myPlayer + " passes their remaining Loyalties to " + z.players[prompted - 1]) + ".\r\n";
						roslin();
						mainMenu();
					});
				} else {
					roslin();
					mainMenu();
				}
			};
			if(z.superCrisisHands[me].length === 1) {
				confirmify("Do you want to discard your Super Crisis (" + d.crisisNames[z.superCrisisHands[me][0]] + ") and draw a new one?", passOff, () => {
					let old = z.superCrisisHands[me][0];
					t.value += myPlayer + " discards " + d.crisisNames[old] + ".\r\n";
					z.superCrisisDiscards.push(old);
					z.superCrisisHands[me] = [];
					drawSuperCrisis();
					passOff();
				}, "YES", "NO");
			} else {
				passOff();
			}
			return;
		} else {
			drawSuperCrisis();
		}
	} else if(location === "Hub Destroyed") {
		let alertText = "Now, discard 3 Skill Cards, draw a Super Crisis, then move to the Cylon Fleet location.";
		addAlert(alertText); /* TODO: enforce order here */
		if(3 >= z.skillCardHands[me].length && (!z.forLove || myPlayer === "Athena")) {
			while(z.skillCardHands[me].length > 0) {
				discardSkillCard(me, 0);
			}
		} else if(z.forLove && z.players[me] !== "Athena" && z.forLoveCOs[me] === null) {
			addOption(me, "Discard a Skill Card", 2, true);
			addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
		} else {
			addOption(me, "Discard a Skill Card", 3, true);
		}
		addOption(me, "Draw a Super Crisis", undefined, true);
	} else if(location === "Administration" && z.daybreak) {
		if(z.revealedCylons[me] === 0) {
			dealMutiny(me, false);
		} else {
			addAlert("Athena does not receive a Mutiny when activating Administration from a Cylon Location.");
		}
		if(z.mutinies[z.president].length > 0) {
			let prophet = false;
			for(let j = 0; !(j >= z.quorumTitles[z.president].length); j++) {
				if(d.quorumNames[z.quorumTitles[z.president][j]] === "Accept Prophecy") {
					prophet = true;
					break;
				}
			}
			let alertText = "Now, choose a player to receive the Presidency";
			if(prophet) {
				alertText += ".\r\nThen, " + colorText("orange", "President ") + z.players[z.president] + " may discard Accept Prophecy to keep their title.";
				alertText += "\r\nIf they do not do so, give the President title to the player (chosen in thread).\r\n";
				addOption(z.president, "Discard Accept Prophecy to protect your President Title from Administration", undefined, false);
			} else {
				alertText += ", then give the President title to them.\r\n";
			}
			addOption(me, "Move the President title", undefined, true);
			plainAlert(alertText);
		}
	} else if(location === "Human Fleet" && (z.daybreak || z.pegasus)) {
		if(z.revealedCylons[me] === 0 && myPlayer !== "Athena") {
			addAlert("You are infiltrating; you must now move to a non-hazardous location on Galactica.");
			addOption(me, "Infiltrate Galactica", undefined, true);
			mainMenu();
			return;
		}
		let humanFleetScout = function() {
			addOption(me, "Scout the Crisis Deck", undefined, true);
			addOption(me, "Scout the Destination Deck", undefined, true);
			if(z.daybreak) {
				addAlert("Now, scout the Crisis or Destination deck.  Then, draw 2 skill cards.");
				addOption(me, "Draw 2 Skill Cards", undefined, true);
			} else {
				let alertText = "Now, scout the Crisis or Destination deck.  Then, draw 2 skill cards of different types";
				if(isCylonLeader(myPlayer)) {
					alertText += " (they may come from outside your skill set)";
				}
				addAlert(alertText + ".");
				addOption(me, "Draw 2 Skill Cards (any color)", "Pegasus Human Fleet", true);
			}
			roslin();
			mainMenu();
		};
		if((me === z.theSympatheticCylon || isCylonLeader(myPlayer)) && z.revealedCylons[me] !== 0) {
			confirmify("Would you like to infiltrate Galactica or scout and draw cards?", humanFleetScout, () => {
				z.revealedCylons[me] = 0;
				addAlert("Now, infiltrate Galactica.");
				t.value += bold(myPlayer + " is now infiltrating, and must move to a location on Galactica.") + "\r\n";
				addOption(me, "Infiltrate Galactica", undefined, true);
				roslin();
				mainMenu();
			}, "Infiltrate", "Scout");
		} else {
			humanFleetScout();
		}
		return;
	} else if(location === "Press Room" && z.daybreak) {
		let promptText = "Who is getting a Mutiny from Press Room? (1-" + z.numPlayers + ")";
		let illegal = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			promptText += "\n" + (j + 1) + ": ";
			illegal.push(true);
			if(z.revealedCylons[j] === 1) {
				promptText += "CYLON";
			} else if(j === me && z.numPlayers + z.boxedPlayers.length > 1) {
				promptText += "(cannot pick yourself)";
			} else {
				promptText += z.players[j];
				illegal[j] = false;
			}
		}
		promptNum(promptText, (a) => 1 > a || a > z.numPlayers || illegal[a - 1], mainMenu, (prompted) => {
			let target = prompted - 1;
			dealMutiny(target, true);
			let alertText = "";
			let valueText = "";
			if(z.mutinies[target].length > 1) {
				alertText = z.players[target] + " must now discard down to 1 Mutiny card.\r\n";
				valueText = alertText;
				if(z.mutinies[me].length > 0 && z.numPlayers + z.boxedPlayers.length > 1) {
					alertText += "\nThen, you may discard a Mutiny card.";
					valueText += "\r\nThen, " + myPlayer + " may discard a Mutiny card.\r\n";
				}
			} else if(characterPresent("Tom") && z.mutinies[me].length > 0 && z.numPlayers + z.boxedPlayers.length > 1 && (!z.vBrutality || z.players[
					target] !== "Tom")) {
				alertText += "After Tom completes his Necessary Steps, you may discard a Mutiny card.";
				valueText += "After Tom completes his Necessary Steps, " + myPlayer + " may discard a Mutiny card.\r\n";
			} else if(z.mutinies[me].length > 0 && z.numPlayers + z.boxedPlayers.length > 1) {
				alertText += "Now, you may discard a Mutiny card.";
				valueText += "Now, " + myPlayer + " may discard a Mutiny card.\r\n";
			}
			if(z.mutinies[me].length === 1 && z.numPlayers + z.boxedPlayers.length > 1) {
				addOption(me, "Discard my Mutiny card", undefined, true);
				addOption(me, "Do not discard a Mutiny card",undefined,true);
			} else if(z.mutinies[me].length === 2 && z.numPlayers + z.boxedPlayers.length > 1) {
				addOption(me, "Discard a Mutiny card", undefined, true);
				addOption(me, "Do not discard a Mutiny card",undefined,true);
			}
			if(alertText){
				addAlert(alertText);
			}
			t.value += valueText;
			roslin();
			mainMenu();
		});
		return;
	} else if(location === "Captain's Cabin" || (location === "Research Lab" && z.vBrutality && versionAtLeast([1, 2, 4, 6]) && (z.destination === "Earth" || z
			.destination === "Ionian Earth"))) {
		promptNum(
			"Which skill card type would you like to distribute? (1-6)\n1: Politics\n2: Leadership\n3: Tactics\n4: Piloting\n5: Engineering\n6: Treachery",
			(a) => 1 > a || a > 6, mainMenu, (prompted) => {
				addAlert("Everyone gets a " + colorIDName(prompted - 1) + ".");
				dealSkillCardToEveryone(me, prompted - 1, true);
				if(z.vBrutality && versionAtLeast([1, 2, 4, 6])) {
					z.captainsCabin = true;
				}
				roslin();
				mainMenu();
			});
		return;
	} else if(location === "Tactical Plot") {
		if(z.missionDeck.length === 0) {
			addAlert("The Mission deck is completely empty; try something else.");
		} else {
			z.scout = me;
			z.scoutingMission = true;
			t.value += bold(myPlayer + " looks at the top card of the Mission deck.") + "\r\n";
			let mission = z.missionDeck.pop();
			if(z.missionDeck.length === 0) {
				plainAlert("Mission deck reshuffled.");
				z.missionDeck = shuffle(z.missionDiscards);
				z.missionDiscards = [];
			}
			z.scouted.push(mission);
			addAlert("Top card of the Mission deck is:\n\n" + d.crisisNames[mission] + "\n\nNow, top or bottom this scouted Mission.");
		}
	} else if(location === "Bridge") {
		if(z.activeMission !== null) {
			addAlert("You may only do one Mission per jump cycle.");
		} else if(z.missionDeck.length === 0) {
			addAlert("The Mission deck is completely empty; try something else.");
		} else {
			z.activeMission = z.missionDeck.pop();
			if(z.missionDeck.length === 0) {
				plainAlert("Mission deck reshuffled.");
				z.missionDeck = shuffle(z.missionDiscards);
				z.missionDiscards = [];
			}
			addAlert("The Mission is: " + d.crisisNames[z.activeMission]);
			if(z.currentCrisis !== null) {
				if(!isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis)) {
					discardCrisis();
				}
			}
			z.currentCrisis = z.activeMission;
			z.crisisPlayer = me;
			if(action) {
				didAction();
				action = false;
			}
			initializeCrisis();
		}
	} else if(location === "Hybrid Tank" || location === "Datastream" || location === "Raider Bay") {
		if(z.scout !== -1 && location === "Hybrid Tank") {
			addAlert("Please wait for scouting to finish.");
			mainMenu();
			return;
		}
		let activateRebelBasestar = function() {
			if(location === "Hybrid Tank") {
				z.scout = me; /* TODO: we assume the crisis deck never depletes in earth games */
				z.scouted.push(z.crisisDeck.pop());
				z.scouted.push(z.crisisDeck.pop());
				z.scouted.push(z.crisisDeck.pop());
				z.scouted.push(z.crisisDeck.pop());
				z.scouted.push(z.crisisDeck.pop());
				addOption(me, "Top scouted Crisis", "Hybrid Tank", true);
				addAlert(
					"You have drawn the top 5 cards of the Crisis Deck to hand; you may now place them on top of the Crisis deck in an order of your choosing."
					);
				t.value += myPlayer +
					" draws the top 5 cards of the Crisis deck and may now place them on the top of the deck in an order of their choosing.\r\n";
				roslin();
				mainMenu();
			} else if(location === "Raider Bay") {
				addAlert("Now, place 2 Raiders or 4 Vipers in a single space area and activate them.");
				t.value += "Now, " + myPlayer + " will place 2 Raiders or 4 Vipers in a single space area, then activate them.\r\n";
				if(raidersAway() > 0) {
					addOption(me, "Place Raider(s) on the main game board", "Raider Bay", true);
				} else {
					plainAlert("Note that no Raiders are available to be placed.");
				}
				let anyVipers = false;
				if(vipersIIReserves() > 0) {
					anyVipers = true;
					addOption(me, "Place a Viper Mk II in space", "Raider Bay", true);
				}
				if(vipersVIIReserves() > 0) {
					anyVipers = true;
					addOption(me, "Place a Viper Mk VII in space", "Raider Bay", true);
				}
				if(assaultRaptorsReserves() > 0) {
					anyVipers = true;
					addOption(me, "Place an Assault Raptor in space", "Raider Bay", true);
				}
				if(!anyVipers) {
					plainAlert("Note that no Vipers are available to be placed.");
				}
				roslin();
				mainMenu();
			} else if(location === "Datastream") {
				/* TODO: discard deck vague height reports */
				promptNum(
					"What skill dard deck would you like to draw from? (1-6)\n1: Politics\n2: Leadership\n3: Tactics\n4: Piloting\n5: Engineering\n6: Treachery",
					(a) => 1 > a || a > 6, mainMenu, (prompted) => {
						let alertText = "The cards in the " + colorIDName(prompted - 1) + " deck:";
						for(let j = 0; !(j >= z.skillCardDecks[prompted - 1].length); j++) {
							alertText += "\n" + cardText(z.skillCardDecks[prompted - 1][j]);
						}
						addAlert(alertText);
						alertText = "The cards in the " + colorIDName(prompted - 1) + " discards:";
						for(let j = 0; !(j >= z.skillCardDiscards[prompted - 1].length); j++) {
							alertText += "\n" + cardText(z.skillCardDiscards[prompted - 1][j]);
						}
						addAlert(alertText);
						z.skillCardHands[prompted - 1] = z.skillCardHands[prompted - 1].concat(z.skillCardDiscards[prompted - 1]);
						z.skillCardDiscards[prompted - 1] = [];
						let cardsToDraw = 3;
						if(cardsToDraw > z.skillCardHands[prompted - 1].length) {
							cardsToDraw = z.skillCardHands[prompted - 1].length;
						}
						if(cardsToDraw > 0) {
							z.possibleColors[me][prompted - 1] = 1;
						}
						t.value += bold(myPlayer + " takes " + cardsToDraw + " cards of their choice from the " + colorIDName(prompted - 1) +
							" deck and its discards.") + "\r\n";
						let datastream = function(k) {
							if(k === 0) {
								shuffle(z.skillCardDecks[prompted - 1]);
								t.value += colorIDName(prompted - 1) + " deck reshuffled.\r\n";
								roslin();
								mainMenu();
							} else {
								let promptText = "Which skill card would you like to take (" + k + " remaining)? (1-" + z.skillCardDecks[prompted -
									1].length + ")";
								for(let j = 0; !(j >= z.skillCardDecks[prompted - 1].length); j++) {
									promptText += "\n" + (j + 1) + ": " + cardText(z.skillCardDecks[prompted - 1][j]);
								}
								promptNum(promptText, (a) => 1 > a || a > z.skillCardDecks[prompted - 1].length, () => {
									for(let j = k; !(j >= cardsToDraw); j++) {
										z.skillCardDecks[prompted - 1].push(z.skillCardHands[me].pop());
									}
									addAlert(
										"Datastream use cancelled; please activate it again.  You have temporarily been given a Miracle Token so that you can do so."
										);
									z.miracles[me]++;
									mainMenu();
								}, (prompted2) => {
									z.skillCardHands[me].push(z.skillCardDecks[prompted - 1].splice(prompted2 - 1, 1)[0]);
									datastream(k - 1);
								});
							}
						};
						datastream(cardsToDraw);
					});
			}
		};
		let rebelBasestar = function(miracle) {
			if(miracle) {
				z.miracles[me]--;
				addAlert("You spend a Miracle Token.");
				t.value += bold(myPlayer + " discards a Miracle Token to activate " + location + ".") + "\r\n";
				activateRebelBasestar();
			} else if(z.superCrisisHands[me].length === 1) {
				addAlert("You discard " + d.crisisNames[z.superCrisisHands[me][0]]);
				t.value += bold(myPlayer + " discards " + d.crisisNames[z.superCrisisHands[me][0]] + " to activate " + location + ".") + "\r\n";
				z.superCrisisDiscards.push(z.superCrisisHands[me][0]);
				z.superCrisisHands[me] = [];
				activateRebelBasestar();
			} else {
				let promptText = "Which Super Crisis card would you like to discard to activate " + location + "? (1-" + z.superCrisisHands[me].length +
				")";
				for(let j = 0; !(j >= z.superCrisisHands[me].length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.crisisNames[z.superCrisisHands[me][j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.superCrisisHands[me].length, mainMenu, (prompted) => {
					addAlert("You discard " + d.crisisNames[z.superCrisisHands[me][prompted - 1]]);
					t.value += bold(myPlayer + " discards " + d.crisisNames[z.superCrisisHands[me][prompted - 1]] + " to activate " + location +
						".") + "\r\n";
					z.superCrisisDiscards.push(z.superCrisisHands[me].splice(prompted - 1, 1)[0]);
					activateRebelBasestar();
				});
			}
		};
		if(z.miracles[me] > 0 && z.superCrisisHands[me].length > 0) {
			confirmify("Would you like to discard a Miracle Token or a Super Crisis to activate " + location + "?", () => {
				rebelBasestar(false);
			}, () => {
				rebelBasestar(true);
			}, "Miracle Token", "Super Crisis");
		} else {
			rebelBasestar(z.miracles[me] > 0);
		}
		return;
	} else if(location === "Basestar Bridge") {
		let promptText = "Which ability would you like to perform first? (1-4)";
		promptText += "\n1: The CAG must place 1 civilian ship.";
		promptText += "\n2: Place 1 Basestar or 3 Raiders on the CFB.";
		promptText += "\n3: Roll to adjust Jump or Pursuit Tracks.";
		promptText += "\n4: Roll to damage Galactica.";
		promptNum(promptText, (a) => 1 > a || a > 4, mainMenu, (firstChoice) => {
			let promptText = "Which ability would you like to perform second? (1-4)";
			if(firstChoice !== 1) {
				promptText += "\n1: The CAG must place 1 civilian ship.";
			} else {
				promptText += "\n1: (cannot perform the same ability twice)";
			}
			if(firstChoice !== 2) {
				promptText += "\n2: Place 1 Basestar or 3 Raiders on the CFB.";
			} else {
				promptText += "\n2: (cannot perform the same ability twice)";
			}
			if(firstChoice !== 3) {
				promptText += "\n3: Roll to adjust Jump or Pursuit Tracks.";
			} else {
				promptText += "\n3: (cannot perform the same ability twice)";
			}
			if(firstChoice !== 4) {
				promptText += "\n4: Roll to damage Galactica.";
			} else {
				promptText += "\n4: (cannot perform the same ability twice)";
			}
			promptNum(promptText, (a) => 1 > a || a > 4 || a === firstChoice, mainMenu, (secondChoice) => {
				let raiderCount = 0;
				let bigRaiderCount = 0;
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] > 0) {
						raiderCount++;
						bigRaiderCount++;
					} else if(z.raiders[j] !== 0) {
						bigRaiderCount++;
					}
				}
				let firstChoiceText = "";
				let secondChoiceText = "";
				switch (firstChoice) {
					case 1:
						firstChoiceText = "The CAG must place 1 civilian ship.";
						break;
					case 2:
						firstChoiceText = "Place 1 Basestar or 3 Raiders on the CFB.";
						break;
					case 3:
						firstChoiceText = "Roll to adjust Jump or Pursuit Tracks.";
						break;
					case 4:
						firstChoiceText = "Roll to damage Galactica.";
						break;
				}
				switch (secondChoice) {
					case 1:
						secondChoiceText = "The CAG must place 1 civilian ship.";
						addOption(z.cag, "Place a Civilian on the board", 1, true);
						break;
					case 2:
						secondChoiceText = "Place 1 Basestar or 3 Raiders on the CFB.";
						if(basestarReserves() > 0) {
							addOption(me, "Place a basestar on the Cylon Fleet Board", undefined, true);
						}
						if(raiderReserves() > 0) {
							addOption(me, "Place 3 Raiders on the Cylon Fleet Board", undefined, true);
						}
						break;
					case 3:
						secondChoiceText = "Roll to adjust Jump or Pursuit Tracks.";
						if(firstChoice !== 4) {
							SPTokenBad("Basestar Bridge: Jump/Pursuit Tracks");
						}
						break;
					case 4:
						secondChoiceText = "Roll to damage Galactica.";
						if(raiderCount > 1 && 8 >= raiderCount && firstChoice !== 3) {
							SPTokenBad("Basestar Bridge: Damage Roll (" + z.players[me] + ")");
						} else if(raiderCount > 8) {
							z.damagePlayer = me;
						}
						break;
				}
				addAlert("You have chosen to do:\n" + firstChoiceText + "\n" + secondChoiceText);
				t.value += bold(myPlayer + " chooses to do the following abilities, in order:") + "\r\n" + firstChoiceText + "\r\n" +
					secondChoiceText + "\r\n\r\n";
				switch (firstChoice) {
					case 1:
						/* TODO: autoplacement */ addAlert(
							"Now, the CAG must place a Civilian on the main game board, following usual CAG placement rules.");
						t.value += bold(colorText("red", "CAG ") + z.players[z.cag] + " must now place a Civilian on the main game board") +
							", following usual CAG placement rules.\r\n";
						addOption(z.cag, "Place a Civilian on the board", 1, true);
						break;
					case 2:
						addAlert(
							"Now, you must place a Basestar or 3 Raiders in a single sector of the CFB.\nNote that you cannot use this to move ships that are already on the CFB or the main game board."
							);
						if(basestarReserves() > 0) {
							addOption(me, "Place a basestar on the Cylon Fleet Board", undefined, true);
						}
						if(raiderReserves() > 0) {
							addOption(me, "Place 3 Raiders on the Cylon Fleet Board", undefined, true);
						}
						break;
					case 3:
						addAlert("Now, roll 1d8:\n1-3: Decrease the Jump Preparation Track by 1.\n4-8: Advance the Pursuit Track by 1.");
						SPTokenBad("Basestar Bridge: Jump/Pursuit Tracks");
						if(secondChoice === 4 && (raiderCount > 1 || (z.pursuitTrack === 3 && bigRaiderCount > 1)) && 8 >= raiderCount) {
							z.dieRollQueue.push("Basestar Bridge: Damage Roll (" + z.players[me] + ")"); /* TODO: fix these. */
							if(z.pursuitTrack === 3 && bigRaiderCount > 8) {
								plainAlert(
									"If the Tracks roll brings in the fleet, BYC will require you to still roll the die for damage (even though the damage is automatic)."
									);
							} else if(z.pursuitTrack === 3 && 1 >= raiderCount) {
								plainAlert(
									"If the Tracks roll does not bring in the fleet, BYC will require you to still roll the die for damage (even though no damage can possibly occur)."
									);
							}
						}
						break;
					case 4:
						if(raiderCount > 8) {
							plainAlert("Damage is automatic.");
							z.damagePlayer = me;
							if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
								if(me !== z.turn) {
									boldAlert(z.players[z.turn] + ", as current player, must deal " + z.players[me] +
										" two damage tokens from Pegasus and/or Galactica.");
								} else {
									boldAlert(z.players[z.turn] + " must draw two damage tokens from Pegasus and/or Galactica.");
								}
							} else {
								let damageText = "You draw: ";
								for(let i = 0; !(i >= 2) && z.damage.length > 0; i++) {
									let damage = z.damage.pop();
									z.damageHand.push(damage);
									damageText += "[" + damage + "] ";
								}
								addAlert(damageText);
							}
							if(secondChoice === 3) {
								SPTokenBad("Basestar Bridge: Jump/Pursuit Tracks");
							}
						} else if(raiderCount >= 2) {
							SPTokenBad("Basestar Bridge: Damage Roll (" + z.players[me] + ")");
							if(secondChoice === 3) {
								z.dieRollQueue.push("Basestar Bridge: Jump/Pursuit Tracks");
							}
						} else if(2 > raiderCount) {
							plainAlert("Not enough Raiders to do damage.");
							if(secondChoice === 3) {
								SPTokenBad("Basestar Bridge: Jump/Pursuit Tracks");
							}
						}
						break;
				}
				if(secondChoice === 4 && raiderCount > 8) {
					plainAlert("Damage will be automatic.");
				}
				roslin();
				mainMenu();
			});
		});
		return;
	} else if(location === "Engine Room") {
		z.engineRoom = true;
		if(z.vBrutalityPlus){
			movePlayer(me,"Sickbay");
			addAlert("You are sent to Sickbay and must discard 2 skill cards.  Then, the next crisis drawn this turn has its pass effect replaced with \"Increase the Jump Preparation Track by 1.\"");
		} else {
			addAlert("Discard 2 skill cards.  Then, the next crisis drawn counts as having Jump Prep.");
		}
		if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
			plainAlert("Athena could love " + z.players[me] + " here.");
			addOption(me, "Discard a Skill Card", 1, true);
			addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
		} else {
			addOption(me, "Discard a Skill Card", 2, true);
		}
		if(z.vBrutalityPlus){
			t.value += myPlayer + ' must discard 2 skill cards.\r\nThen, the next crisis drawn this turn has its pass effect replaced with "Increase the Jump Preparation Track by 1."';
		} else {
			t.value += myPlayer + ' must discard 2 skill cards.\r\nThen, the next crisis drawn this turn counts as having a "Prepare for Jump" icon.\r\n';
		}
	} else if(location === "Occupation Authority (Human)") {
		if(me !== z.president) {
			plainAlert("Athena cannot activate the Human version of Occupation Authority.");
		} else {
			confirmify("Confirming you want to draw a Quorum card.", () => {
				addAlert("You may now play a Quorum card.");
				addOption(me, "Play a Quorum Card", undefined, false);
				roslin();
				mainMenu();
			}, () => {
				dealQuorumCard();
				addAlert("You may now play a Quorum card.");
				addOption(me, "Play a Quorum Card", undefined, false);
				roslin();
				mainMenu();
			});
			return;
		}
	} else if(location === "Occupation Authority (Cylon)") {
		if(OFReserves() === 4) {
			plainAlert("Occupation Force placed on the Occupation Authority.");
			z.OFs[0] = 1;
			roslin();
			mainMenu();
			return;
		} else {
			let locations = [0, 0, 0];
			for(let j = 0; !(j >= 4); j++) {
				if(z.OFs[j] > 0) {
					locations[z.OFs[j] - 1] = 1;
				}
			}
			if(locations[0] + locations[1] + locations[2] === 1) {
				for(let j = 0; !(j >= 4); j++) {
					if(z.OFs[j] === 3) {
						z.OFs[j] = 1;
						destroyNCCivilian();
						t.value += "Occupation Force on the Shipyard removed.\r\n";
						t.value += "Occupation Force placed on the Occupation Authority.\r\n";
						break;
					} else if(z.OFs[j] > 0) {
						z.OFs[j]++;
						t.value += "Occupation Force advances to ";
						if(z.OFs[j] === 3) {
							t.value += "the Shipyard.\r\n";
						} else {
							t.value += "Breeder's Canyon.\r\n";
						}
						if(OFReserves() !== 4) {
							for(let k = 0; !(k >= 4); k++) {
								if(z.OFs[k] === 0) {
									t.value += "Occupation Force placed on the Occupation Authority.\r\n";
									z.OFs[k] = 1;
									break;
								}
							}
						}
						break;
					}
				}
				roslin();
				mainMenu();
				return;
			} else {
				let promptText = "Activate an Occupation Force on which of these locations? (1-" + (locations[0] + locations[1] + locations[2]) + ")";
				let options2 = [];
				let numbers2 = [];
				for(let j = 0; !(j >= 3); j++) {
					if(locations[j] === 1) {
						if(j === 0) {
							options2.push("Occupation Authority");
						} else if(j === 1) {
							options2.push("Breeder's Canyon");
						} else {
							options2.push("Shipyard");
						}
						numbers2.push(j + 1);
						promptText += "\n" + (options2.length) + ": " + options2[options2.length - 1];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > options2.length, mainMenu, (prompted) => {
					t.value += bold(myPlayer + " activates an Occupation Force on " + options2[prompted - 1]) + ".\r\n";
					for(let j = 0; !(j >= 4); j++) {
						if(z.OFs[j] === numbers2[prompted - 1]) {
							if(z.OFs[j] === 3) {
								z.OFs[j] = 1;
								destroyNCCivilian();
								t.value += "Occupation Force on the Shipyard removed.\r\n";
								t.value += "Occupation Force placed on the Occupation Authority.\r\n";
								break;
							} else if(z.OFs[j] > 0) {
								z.OFs[j]++;
								t.value += "Occupation Force advances to ";
								if(z.OFs[j] === 3) {
									t.value += "the Shipyard.\r\n";
								} else {
									t.value += "Breeder's Canyon.\r\n";
								}
								if(OFReserves() !== 4) {
									for(let k = 0; !(k >= 4); k++) {
										if(z.OFs[k] === 0) {
											t.value += "Occupation Force placed on the Occupation Authority.\r\n";
											z.OFs[k] = 1;
											break;
										}
									}
								}
								break;
							}
						}
					}
					roslin();
					mainMenu();
				});
			}
		}
		return;
	} else if(location === "Breeder's Canyon (Human)") {
		let candidateResource = "Population";
		let maxResource = z.population;
		let tie = false;
		if(z.morale > maxResource) {
			candidateResource = "Morale";
			maxResource = z.morale;
			tie = false;
		} else if(z.morale === maxResource) {
			tie = true;
		}
		if(z.food > maxResource) {
			candidateResource = "Food";
			maxResource = z.food;
			tie = false;
		} else if(z.food === maxResource) {
			tie = true;
		}
		if(z.fuel > maxResource) {
			candidateResource = "Fuel";
			maxResource = z.fuel;
			tie = false;
		} else if(z.fuel === maxResource) {
			tie = true;
		}
		if(tie) {
			boldAlert("There is a tie for highest resource; " + z.players[z.turn] +
				" must break the tie.  Then, increase Jump Prep by 1 if Galactica has not returned.");
			addOption(z.turn, "Decrease a resource", "tie", true);
			if(!z.galacticaReturned) {
				optionForAll("Advance the Jump Preparation Track");
			}
		} else {
			switch (candidateResource) {
				case "Population":
					decreasePopulation();
					increaseJump();
					break;
				case "Morale":
					if(decreaseMorale()) {
						increaseJump();
					} else {
						plainAlert("After resolving Dee's execution, increase the Jump Preparation Track by 1 if Galactica has not returned.");
						if(!z.galacticaReturned) {
							optionForAll("Advance the Jump Preparation Track");
						}
					}
					break;
				case "Food":
					decreaseFood();
					increaseJump();
					break;
				case "Fuel":
					decreaseFuel();
					increaseJump();
					break;
			}
		}
	} else if(location === "Breeder's Canyon (Cylon)") {
		/* RULES:/TODO: Breeder's Canyon and SoE/Athena/Cavil hijinks? */
		z.establishSanitation = true;
		z.capricaCrisis = true;
		if(action) {
			didAction();
			action = false;
		}
		playCrisis(me);
		addAlert("You drew "+d.crisisNames[z.currentCrisis]+".");
		if(((d.currentPlayerChooses[z.currentCrisis] === 1 || z.secretDestinyPause) && (characterPresent("Starbuck") && (z.miracles[getPlayerNum(
				"Starbuck")] === 1 || actsOfFaith("Starbuck")) && !z.theFarm))) {
			plainAlert("Remember that Starbuck can use her OPG here.");
		}
	} else if(location === "Shipyard (Human)") {
		if((z.galacticaAway || z.preparedCivilians.length === 0) && z.lockedCivilians.length === 0) {
			addAlert("No Effect; no ships can be prepared or evacuated at this time.");
			roslin();
			mainMenu();
		} else if(z.galacticaAway || z.preparedCivilians.length === 0) {
			prepareCivilian();
			roslin();
			mainMenu();
		} else if(z.lockedCivilians.length === 0) {
			evacuateCivilian();
			if(z.playerLocations[me] !== "Shipyard") {
				plainAlert("As they are not standing on the Shipyard, " + z.players[me] + " does not get to move to Galactica.");
			} else if(me === z.turn) {
				addAlert("Now, you may move to any non-hazardous Galactica location.");
				addOption(me, "Move to Galactica from the Shipyard", undefined, false);
			} else {
				addAlert("Once the ship has been evacuated, you may move to any non-hazardous Galactica location.");
				t.value += "Once the evacuation is complete, " + myPlayer + " may move to any location on Galactica.\r\n";
				addOption(me, "Move to Galactica from the Shipyard", undefined, false);
			}
			roslin();
			mainMenu();
		} else {
			confirmify("Would you like to prepare a ship or evacuate one?", () => {
				evacuateCivilian();
				if(z.playerLocations[me] !== "Shipyard") {
					plainAlert("As they are not standing on the Shipyard, " + z.players[me] + " does not get to move to Galactica.");
				} else if(me === z.turn) {
					addAlert("Now, you may move to any non-hazardous Galactica location.");
					addOption(me, "Move to Galactica from the Shipyard", undefined, false);
				} else {
					addAlert("Once the ship has been evacuated, you may move to any non-hazardous Galactica location.");
					t.value += "Once the evacuation is complete, " + myPlayer + " may move to any location on Galactica.\r\n";
					addOption(me, "Move to Galactica from the Shipyard", undefined, false);
				}
				roslin();
				mainMenu();
			}, () => {
				prepareCivilian();
				roslin();
				mainMenu();
			}, "Prepare", "Evacuate");
		}
		return;
	} else if(location === "Shipyard (Cylon)") {
		/* TODO: flag ships in the shipyard as "seen" if inspected in this fashion */
		if(z.lockedCivilians.length === 0) {
			addAlert("There are no locked Civilians; no effect.");
			roslin();
			mainMenu();
		} else if(z.lockedCivilians.length === 1) {
			addAlert("The only ship in the Locked Civilians stack is: " + z.lockedCivilians[0] + ".");
			t.value += myPlayer + " looks at the last ship in the Locked Civilians stack.\r\n";
			roslin();
			mainMenu();
		} else {
			confirmify("The ship on top of the Locked Civilians stack is: " + z.lockedCivilians[z.lockedCivilians.length - 1] +
				"\n\nWould you like to place this ship on the top of the stack or the bottom?", () => {
					z.lockedCivilians.unshift(z.lockedCivilians.pop());
					t.value += bold(myPlayer + " looks that the top ship of the Locked Civilians stack and moves it to the bottom.") + "\r\n";
					roslin();
					mainMenu();
				}, () => {
					t.value += bold(myPlayer + " looks that the top ship of the Locked Civilians stack and leaves it there.") + "\r\n";
					roslin();
					mainMenu();
				}, "Top", "Bottom");
		}
		return;
	}
	roslin();
	mainMenu();
}

function placeBasestar(sector) {
	let cfbflag = false;
	let bs = -1;
	if(z.basestars.length === 0 || (z.basestars[0][0] > 0 && (z.basestars.length === 1 || z.basestars[1][0] > 0))) {
		plainAlert("All basestars are on the main game board; no more can be placed.");
		return undefined;
	}
	if(z.basestars[0][0] === 0) {
		bs = 0;
	} else if(z.basestars.length > 1 && z.basestars[1][0] === 0) {
		bs = 1;
	} else if(z.basestars[0][0] > 0 && z.basestars.length > 1) {
		bs = 1;
		cfbflag = true;
	} else if(z.basestars.length === 1 || z.basestars[1][0] > 0) {
		bs = 0;
		cfbflag = true;
	} else if(CFBroll(z.basestars[1][0]) > CFBroll(z.basestars[0][0])) {
		bs = 0;
		cfbflag = true;
	} else {
		bs = 1;
		cfbflag = true;
	}
	let alertText = "Basestar placed in Sector " + sector + ".";
	if(cfbflag) {
		alertText += " It came from CFB Sector " + (-z.basestars[bs][0]) + ".";
	}
	plainAlert(alertText);
	z.basestars[bs] = [sector];
}

function basestarReserves() {
	let count = 0;
	if(z.basestars.length > 0 && (z.basestars[0][0] === 0)) {
		count++;
	}
	if(z.basestars.length > 1 && (z.basestars[1][0] === 0)) {
		count++;
	}
	return count;
}

function destroyBasestar(target) {
	let done = true;
	let bsName = basestarName(target);
	while(z.basestars[target].length > 1) {
		z.basestarDamage.push(z.basestars[target].pop());
	}
	z.basestars[target] = [0];
	shuffle(z.basestarDamage);
	if(arguments.length === 1) {
		boldAlert(bsName + " destroyed.");
		if(z.thirtyThree) {
			t.value += "Relentless Pursuit [Thirty-Three] cancelled.\r\n";
			z.thirtyThree = false;
			if(z.galacticaReturned){
				z.oldCrisisDiscards.push(59);
			} else {
				z.crisisDiscards.push(59);
			}
		}
		if(z.hornetsNest) {
			t.value += "Suppressive Fire [Hornet's Nest] cancelled.\r\n";
			z.hornetsNest = false;
			if(z.galacticaReturned){
				z.oldCrisisDiscards.push(143);
			} else {
				z.crisisDiscards.push(143);
			}
		}
		if(z.lockdown) {
			t.value += "Concerted Attack [Lockdown] cancelled.\r\n";
			z.lockdown = false;
			if(z.galacticaReturned){
				z.oldCrisisDiscards.push(147);
			} else {
				z.crisisDiscards.push(147);
			}
		}
		if(z.theGuardians) {
			t.value += "Raptor Crew Captured [The Guardians] triggers:\r\n";
			done = decreaseMorale();
			destroyRaptor();
		}
		if(z.vBrutality && characterPresent("Karl") && !noDrawback(getPlayerNum("Karl"))) {
			t.value += "Karl's Conflicted triggers.\r\n";
			promptAllyDiscards(getPlayerNum("Karl"), 2);
		}
		if(Number.isInteger(z.destroyer) && z.destroyer >= 0 && z.possibleColors[z.destroyer][1] === 1 && z.pegasus && !z.majorVictory) {
			plainAlert(z.players[z.destroyer] + " may want to use Major Victory here.");
			let mv = false;
			for(let j = 0; !(j >= z.skillCardHands[z.destroyer].length) && !mv; j++) {
				mv = cardName(z.skillCardHands[z.destroyer][j]) === "Major Victory";
			}
			if(mv) {
				addOption(z.destroyer, "Play a Major Victory", undefined, false);
			}
		}
		z.destroyer = -1;
	} else {
		boldAlert(bsName + " removed.");
	}
	return done;
}

function damageBasestar(target) {
	let isDestroyed = false;
	if(z.basestarDamage.length === 0) {
		isDestroyed = true;
		t.value += "\r\n";
	} else {
		let damage = z.basestarDamage.pop();
		addAlert("Damage is " + damage);
		z.basestars[target].push(damage);
		t.value += bold(damage + ".\r\n");
		if(damage === "Collateral Damage") {
			let raiderCount = 0;
			for(let j = 0; !(j >= z.raiders.length) && 3 > raiderCount; j++) {
				if(z.raiders[j] === z.basestars[target][0]) {
					raiderCount++;
					z.raiders[j] = 0;
				}
			}
			if(raiderCount === 0) {
				plainAlert("No Effect.");
			} else if(raiderCount === 1) {
				plainAlert("1 Raider destroyed.");
			} else {
				plainAlert(raiderCount + " Raiders destroyed.");
			}
		}
		if(damage === "Damage to Personnel") {
			if(!z.preCrossroads) {
				plainAlert("No Effect.");
			} else {
				let anyEffect = false;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						drawTraumas(k, 2);
						anyEffect = true;
					}
				}
				if(!anyEffect) {
					plainAlert("No Effect.");
				}
			}
		}
		if(z.basestars[target].length === 4 || (z.basestars[target].length === 3 && (z.basestars[target][1] === "Critical Hit" || z.basestars[target][2] ===
				"Critical Hit"))) {
			isDestroyed = true;
		}
	}
	if(isDestroyed) {
		plainAlert("Basestar destroyed.");
		destroyBasestar(target);
	}
}

function clearCivilians() {
	for(let i = 0; !(i >= 6); i++) {
		while(z.spaceCivilians[i ].length > 0) {
			let civ = z.spaceCivilians[i ].pop();
			z.civilianLetters.push(civ[0]);
			z.civilianPile.push(civ[1]);
		}
	}
	z.reshuffledSeen = false;
	shuffle(z.civilianPile);
	z.civilianLetters.sort();
}

function destroyCivilian(name) {
	let done = true;
	boldAlert(name + " ship destroyed.");
	switch (name) {
		case "2 Pop":
			done = decreasePopulation();
			/* fallthrough */
		case "1 Pop":
			done = decreasePopulation() && done;
			break;
		case "Pop/Morale":
			done = decreasePopulation();
			done = decreaseMorale() && done;
			break;
		case "Pop/Fuel":
			done = decreasePopulation();
			decreaseFuel();
	}
	if(z.thirtyThree) {
		t.value += "Relentless Pursuit (from Thirty-Three) is cancelled.\r\n";
		z.thirtyThree = false;
		if(z.galacticaAway || z.galacticaReturned){
			z.oldCrisisDiscards.push(59);
		} else {
			z.crisisDiscards.push(59);
		}
	}
	z.destroyedCivilians.push(name);
	return done;
}

function availableCivilians(){
	let n = z.civilianPile.length;
	for(let j = 0; !(j >= 6); j++) {
		n += z.spaceCivilians[j].length;
	}
	return n;
}

function destroyPileCivilian(n) {
	if(n === 0) {
		return true;
	} else if(z.civilianPile.length === 0) {
		let civiliansInSpace = 0;
		for(let j = 0; !(j >= 6); j++) {
			civiliansInSpace += z.spaceCivilians[j].length;
		}
		if(civiliansInSpace === 0) {
			plainAlert("There are no civilians in the pile of civilian ships or in space areas; no effect.");
			return true;
		}
		if(civiliansInSpace === 1 && (!characterPresent("Hot Dog") || z.miracles[getPlayerNum("Hot Dog")] === 0 || z.theFarm)) {
			for(let j = 0; !(j >= 6); j++) {
				if(z.spaceCivilians[j].length > 0) {
					plainAlert("There are no civilians in the pile of civilian ships, and only 1 on the main game board.");
					boldAlert("Civilian " + z.spaceCivilians[j][0][0] + " destroyed.");
					let done = destroyCivilian(z.spaceCivilians[j][0][1]);
					z.spaceCivilians[j].splice(0, 1);
					z.reshuffledSeen = false;
					return done;
				}
			}
		} else {
			plainAlert("No civilians left in the pile of civilian ships; " + z.players[z.turn] + " must destroy a civilian on the main game board instead.");
			addOption(z.turn, "Destroy a Civilian in space", n, true);
			return false;
		}
	} else {
		boldAlert("Drawing and destroying a civilian ship.");
		let civ = z.civilianPile.pop();
		let done = destroyCivilian(civ);
		if(done) {
			return destroyPileCivilian(n - 1);
		}
		if(n > 1) {
			optionForAll("Draw and destroy a Civilian", n - 1);
		}
		return false;
	}
}

function becomeSympatheticCylon(player) {
	let position = z.loyaltyHands[player].length - 1;
	if(arguments.length > 1) {
		position = arguments[1];
	}
	z.theSympatheticCylon = player;
	z.loyaltyDiscards[player].push(z.loyaltyHands[player].splice(position, 1)[0]);
	boldAlert(z.players[player] + " reveals the Sympathetic Cylon card.");
	z.revealedCylons[player] = 1;
	if(z.skillCardHands[player].length > 3) {
		plainAlert(z.players[player] + " must discard down to 3 skill cards.");
	}
	if(z.admiral === player) {
		passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
	}
	if(z.president === player) {
		passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
		if(z.skillCardHands[player].length > 3) {
			t.value += size("Technically, the President title is not passed until after the revealing Cylon discards their cards.  As a result, " + colorText(
				"orange", "President ") + z.players[z.president] + " should not look at their Quorum cards until the Cylon finishes discarding.\r\n", 8);
		}
	}
	if(z.CFB && z.cag === player) {
		passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
	}
	while(z.quorumTitles[player].length > 0) {
		/* RULES: I assume you lose Probation */
		let title = z.quorumTitles[player].pop();
		z.quorumDiscards.push(title);
		t.value += z.players[player] + " discards " + d.quorumNames[title] + "\r\n";
	}
	z.miracles[player] = 0;
	if(z.galacticaAway) {
		movePlayer(player, "Medical Center");
	} else {
		movePlayer(player, "Resurrection Ship");
	}
	if(z.loyaltyHands[player].length > 0 && 7 > z.distance) {
		plainAlert(z.players[player] + " must pass off their remaining Loyalty cards to a player of their choosing.");
		let agendaDeck = [];
		for(let j = 0; !(j >= 6); j++) {
			agendaDeck.push(41 + j);
		}
		shuffle(agendaDeck);
		z.loyaltyHands[player].unshift(agendaDeck.pop());
		t.value += z.players[player] + " receives an Agenda card.\r\n";
		return false;
	}
	let agendaDeck = [];
	for(let j = 0; !(j >= 6); j++) {
		agendaDeck.push(41 + j);
	}
	shuffle(agendaDeck);
	z.loyaltyHands[player].unshift(agendaDeck.pop());
	t.value += z.players[player] + " receives an Agenda card.\r\n";
	return (3 >= z.skillCardHands[player].length); /* RULES: when do they get the agenda? */
}

function becomeSympathizer(player) {
	let position = z.loyaltyHands[player].length - 1;
	if(arguments.length > 1) {
		position = arguments[1];
	}
	z.theSympathizer = player;
	z.loyaltyDiscards[z.theSympathizer].push(z.loyaltyHands[z.theSympathizer].splice(position, 1)[0]);
	boldAlert(z.players[player] + " reveals the Sympathizer card.");
	if(z.revealedCylons[player] === 1) {
		/* RULES: passing it off is optional? */
		plainAlert(z.players[player] + " must now give the Sympathizer card to a Human player of their choice.");
		return false;
	} else if(4 >= z.fuel || 4 >= z.food || 5 >= z.morale || 6 >= z.population) {
		t.value += "At least one resource is in the red, so " + z.players[player] + " remains Human, but is moved to the Brig.\r\n";
		if(isOnNewCaprica(player)) {
			movePlayer(player, "Detention");
		} else if(z.playerLocations[player] === "Stranded on Caprica") {
			plainAlert("Helo is not moved to the Brig as he is still Stranded.");
		} else {
			movePlayer(player, "Brig");
		}
		z.sympathizer = false;
		z.theSympathizer = -1;
		return true;
	} else {
		z.sympathizer = false;
		z.revealedCylons[player] = 1;
		t.value += "No resources are in the red, so " + z.players[player] + " becomes a Cylon.\r\n";
		if(z.skillCardHands[player].length > 3) {
			plainAlert(z.players[player] + " must discard down to 3 skill cards.");
		}
		if(z.admiral === player) {
			passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
		}
		if(z.president === player) {
			passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
			if(z.skillCardHands[player].length > 3) {
				t.value += size("Technically, the President title is not passed until after the revealing Cylon discards their cards.  As a result, " +
					colorText("orange", "President ") + z.players[z.president] +
					" should not look at their Quorum cards until the Cylon finishes discarding.\r\n");
			}
		}
		if(z.CFB && z.cag === player) {
			passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
		}
		while(z.quorumTitles[player].length > 0) {
			/* RULES: I assume you lose Probation */
			let title = z.quorumTitles[player].pop();
			z.quorumDiscards.push(title);
			t.value += z.players[player] + " discards " + d.quorumNames[title] + "\r\n";
		}
		z.miracles[player] = 0;
		if(z.galacticaAway) {
			movePlayer(player, "Medical Center");
		} else {
			movePlayer(player, "Resurrection Ship");
		}
		if(z.pegasus && z.loyaltyHands[player].length > 0 && 7 > z.distance) {
			plainAlert(z.players[player] + " must pass off their remaining Loyalty cards to a player of their choosing.");
			return false;
		}
		return (3 >= z.skillCardHands[player].length);
	}
}

function becomeMutineer(player) {
	let position = z.loyaltyHands[player].length - 1;
	if(arguments.length > 1) {
		position = arguments[1];
	}
	z.theMutineer = player;
	boldAlert(z.players[z.theMutineer] + " is the Mutineer.");
	z.loyaltyDiscards[z.theMutineer].push(z.loyaltyHands[z.theMutineer].splice(position, 1)[0]);
	if(arguments.length === 1 && z.loyaltyDeck.length > 0) {
		plainAlert(z.players[z.theMutineer] + " draws another Loyalty card.");
		z.loyaltyHands[z.theMutineer].push(z.loyaltyDeck.pop());
	} else {
		plainAlert(z.players[z.theMutineer] + " does not draw an additional Loyalty card in this circumstance.");
	}
	dealMutiny(z.theMutineer, false);
	if(z.theMutineer === z.president) {
		passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
	}
	if(z.theMutineer === z.admiral) {
		passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
	}
	if(z.CFB && z.theMutineer === z.cag) {
		passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
	}
}

function deathWish(player) {
	if(z.players[player] !== "Racetrack" || z.revealedCylons[player] === 1 || player === z.theSympatheticCylon || !isInSpace(player) || !versionAtLeast([2, 1,
			3]) || noDrawback(player)) {
		return false;
	}
	let sector = parseInt(z.playerLocations[me].slice(7));
	let numShips = 0;
	for(let j = 0; !(j >= z.raiders.length); j++) {
		if(z.raiders[j] === sector) {
			numShips++;
		}
	}
	for(let j = 0; !(j >= z.heavies.length); j++) {
		if(z.heavies[j] === sector) {
			numShips++;
		}
	}
	if(z.scar === sector) {
		numShips++;
	}
	for(let j = 0; !(j >= z.basestars.length); j++) {
		if(z.basestars[j][0] === sector) {
			numShips++;
		}
	}
	return numShips >= 6;
}

function executePlayer(player, boxed, thirtyFive) {
	/* TODO: clear TODO flags if current player executed by choice crisis */
	if(player === z.thisTarget && z.currentSkillCheck !== "Resistance HQ") {
		z.thisTarget = null;
	}
	if(z.turn === player) {
		z.stim = null;
	}
	if(player === z.momentOfHeroism || (versionAtLeast([2,1,13]) && z.players[player] === "Billy" && z.momentOfHeroism >= 0)) {
		plainAlert("Billy's Moment of Heroism ends.");
		if(characterPresent("Dee") && 2 >= z.morale && z.momentOfHeroism === getPlayerNum("Dee")) {
			t.value += italics("I know you think you can get that gun....You're not trained for that.  You've got nothing to prove.\r\n");
			optionForAll("Execute a player","Dee",true);
			boldAlert("Once Billy's execution is resolved, execute Dee.");
		}
		z.momentOfHeroism = -1;
		if(z.momentOfHeroismExtra) {
			z.momentOfHeroismExtra = false;
		}
		
	}
	if(z.xo1 === player) {
		z.xo1 = undefined;
		if(z.forwardThinker && characterPresent("Lee") && player !== getPlayerNum("Lee")) {
			let leeLocation = z.playerLocations[getPlayerNum("Lee")];
			if((!inSpace(leeLocation) && leeLocation !== "Sickbay" && leeLocation !== "Medical Center" && !z.damagedLocations.includes(leeLocation)) || z
				.vBrutality) {
				addOption(getPlayerNum("Lee"), "Forward Thinker", undefined, true);
				addOption(getPlayerNum("Lee"), "Pass on Forward Thinker", undefined, true);
			}
			z.forwardThinker = false;
		}
	}
	if(z.xo2 === player) {
		z.xo2 = undefined;
		if(z.forwardThinker && characterPresent("Lee") && player !== getPlayerNum("Lee")) {
			let leeLocation = z.playerLocations[getPlayerNum("Lee")];
			if((!inSpace(leeLocation) && leeLocation !== "Sickbay" && leeLocation !== "Medical Center" && !z.damagedLocations.includes(leeLocation)) || z
				.vBrutality) {
				addOption(getPlayerNum("Lee"), "Forward Thinker", undefined, true);
				addOption(getPlayerNum("Lee"), "Pass on Forward Thinker", undefined, true);
			}
			z.forwardThinker = false;
		}
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(z.vipersII[j] === z.players[player]) {
			z.vipersII[j] = 0;
			break;
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(z.vipersVII[j] === z.players[player]) {
			z.vipersVII[j] = 0;
			break;
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(z.assaultRaptors[j] === z.players[player]) {
			z.assaultRaptors[j] = 0;
			break;
		}
	}
	boldAlert(z.players[player] + " is executed!");
	discardEntireHand(player);
	let prophet = false;
	while(z.quorumTitles[player].length > 0) {
		/* RULES: I assume you lose Probation */
		let title = z.quorumTitles[player].pop();
		if(title !== 0) {
			z.quorumDiscards.push(title);
			t.value += z.players[player] + " discards " + d.quorumNames[title] + ".\r\n";
		} else {
			prophet = true;
		}
	}
	if(prophet) {
		z.quorumTitles[player].push(0);
	}
	if(z.players[player] === "Billy") {
		while(z.billyHand.length > 0) {
			let card = z.billyHand.pop();
			z.quorumDiscards.push(card);
			t.value += z.players[player] + " discards " + d.quorumNames[card] + " from his hand.\r\n";
		}
	}
	if(z.daybreak) {
		z.miracles[player] = 0;
		while(z.mutinies[player].length > 0) {
			let mut = z.mutinies[player].pop();
			z.mutinyDiscards.push(mut);
			t.value += z.players[player] + " discards " + d.mutinyNames[mut] + "\r\n";
		}
	}
	/*TODO: many other such fixes */
	removeOption(player,"Draw 2 Skill Cards (any color)");
	removeOption(player,"Adaptable");
	
	
	if(player === z.manipulativeVictim) {
		z.manipulativeVictim = 1000;
	}
	if(cylonCards(player) > 0 && z.revealedCylons[player] === 0) {
		addAlert(z.players[player] + " is a Cylon!");
		if(z.vBrutality && characterPresent("D'Anna")) {
			boldAlert("D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card.");
			addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", 1], true);
		}
		z.miracles[player] = 0;
		t.value += bold(z.players[player] + " is a " + colorText("red", "Cylon") + "!") + "\r\n";
		let couldHaveTwo = ((z.numPlayers + z.boxedPlayers.length) >= 6) || ((z.numPlayers + z.boxedPlayers.length) === 5 && !z.cylonLeader);
		for(let j = 0; couldHaveTwo && !(j >= z.numPlayers); j++) {
			if(z.revealedCylons[j] === 1 && !isCylonLeader(z.players[j]) && j !== z.sympatheticCylon) {
				couldHaveTwo = false;
			}
		}
		if(z.loyaltyHands[player].length === 1) {
			couldHaveTwo = false;
		}
		for(let j = 0; couldHaveTwo && !(j >= z.boxedPlayers.length); j++) {
			for(let k = 0; couldHaveTwo && !(k >= z.boxedPlayers[j][2].length); k++) {
				if(isCylonCard(z.boxedPlayers[j][2][k])) {
					couldHaveTwo = false;
				}
			}
			for(let k = 0; couldHaveTwo && !(k >= z.boxedPlayers[j][3].length); k++) {
				if(isCylonCard(z.boxedPlayers[j][3][k])) {
					couldHaveTwo = false;
				}
			}
		}
		if(couldHaveTwo && !z.v20Super) {
			if(!boxed) {
				plainAlert(z.players[player] + " must now reveal a Cylon Loyalty card.");
				z.cylonExecuted = player;
			} else {
				plainAlert(z.players[player] + " should, at their leisure, reveal a Cylon Loyalty card.");
				/* TODO: what if he was the only character outside of the brig? */
				if(z.admiral === player) {
					passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
				}
				if(z.president === player) {
					passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
				}
				if(z.CFB && z.cag === player) {
					passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
				}
				if(z.turn === player) {
					z.executedCurrentPlayer = true;
					addAlert("You should, most likely, end the turn now.");
				}
			}
		} else {
			let cylonCard = -1; /* RULES: a boxed cylon with 2 cylon loyalty cards only reveals one of them? */
			for(let j = 0; !(j >= z.loyaltyHands[player].length); j++) {
				if(isCylonCard(z.loyaltyHands[player][j])) {
					cylonCard = z.loyaltyHands[player].splice(j, 1)[0];
					z.loyaltyDiscards[player].push(cylonCard);
					break;
				}
			}
			boldAlert(z.players[player] + " reveals " + d.loyaltyNames[cylonCard] + ".");
			if(characterPresent("Cavil") && !noDrawback(getPlayerNum("Cavil"))) {
				if(z.vBrutality) {
					boldAlert("Cavil must discard five skill cards due to his Lies and Secrets drawback.");
					promptAllyDiscards(getPlayerNum("Cavil"), 5);
				} else {
					boldAlert("Cavil discards his skill card hand due to his Lies and Secrets drawback.");
					discardEntireHand(getPlayerNum("Cavil"));
				}
			}
			if(!boxed) {
				if(z.galacticaAway) {
					movePlayer(player, "Medical Center");
				} else if(z.hubDestroyed) {
					movePlayer(player, "Hub Destroyed");
				} else {
					movePlayer(player, "Resurrection Ship");
				}
				z.revealedCylons[player] = 1;
				if(Array.isArray(z.personalGoalsBrutality)){
					z.personalGoalsBrutality[player] = null;
				}
			}
			if(z.admiral === player) {
				passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
			}
			if(z.president === player) {
				passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
			}
			if(z.CFB && z.cag === player) {
				passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
			}
			if(z.v20Super){
				drawSuperCrisis();
			}
			if((z.pegasus || z.daybreak || z.vHandoff) && 7 > z.distance && z.loyaltyHands[player].length > 0) {
				plainAlert("Now, " + z.players[player] + " must pass their remaining Loyalties off to a player of their choice.");
			}
			if(z.v20Super){
				drawSuperCrisis(player);
				delete z.v20Super;
			}
			if(z.turn === player) {
				z.executedCurrentPlayer = true; /* TODO: execution improvements */
				addAlert("You should, most likely, end the turn now.");
			}
		}
	} else if(isCylonLeader(z.players[player]) || player === z.theSympatheticCylon || z.revealedCylons[player] === 1) {
		if(!boxed) {
			if(z.galacticaAway) {
				movePlayer(player, "Medical Center");
			} else if(z.hubDestroyed) {
				movePlayer(player, "Hub Destroyed");
			} else {
				movePlayer(player, "Resurrection Ship");
			}
		}
		z.revealedCylons[player] = 1;
		if(isCylonLeader(z.players[player]) || player === z.theSympatheticCylon) {
			z.CLexecuted = true;
		}
		if(z.turn === player) {
			z.executedCurrentPlayer = true;
			addAlert("You should, most likely, end the turn now.");
		}
	} else {
		boldAlert(z.players[player] + " was Human!");
		if(z.exodus && z.turn === player){
			z.executedCurrentPlayer = true;
		}
		let oldMorale = z.morale;
		if(z.players[player] === "Dee" && 2 >= z.morale && !noDrawback(player)) {
			t.value += "No morale is lost from Emotionally Fragile.\r\n";
			addAlert("Dee was Emotionally Fragile; no morale lost.");
		} else {
			decreaseMorale(true);
			if(z.morale !== oldMorale) {
				z.eulogy = true;
			}
		}
		shuffle(z.loyaltyHands[player]);
		let alertText = "They discard the following Loyalty Cards:\r\n";
		let finalFivesCount = 0;
		while(z.loyaltyHands[player].length > 0) {
			let loy = z.loyaltyHands[player].pop();
			if(thirtyFive !== 2){
				if(isFinalFive(loy) && (!thirtyFive || loy !== 35)) {
					finalFivesCount++;
				}
			}
			z.loyaltyDiscards[player].push(loy);
			alertText += "\r\n" + d.loyaltyNames[loy];
		}
		plainAlert(alertText);
		if(finalFivesCount > 0) {
			if(z.vBrutality && characterPresent("D'Anna")) {
				boldAlert(
					"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card for each Final Five revealed."
					);
				addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", finalFivesCount], true);
			}
			addAlert("All players must discard " + (2 * finalFivesCount) + " skill cards.  Remember that revealed Cylons can ignore these discards.");
			t.value += bold("All other players must now discard " + (2 * finalFivesCount) + " skill cards.") + "\r\n";
			if(!z.vBrutality) {
				t.value += "Remember that revealed Cylons can ignore these discards.\r\n";
			}
			for(let j = 0; !(j >= z.numPlayers); j++) {
				let k = (z.turn + j) % z.numPlayers;
				if(z.revealedCylons[k] === 0 || z.vBrutality) {
					promptAllyDiscards(k, 2 * finalFivesCount, true);
				}
			}
		}
		if(z.preCrossroads && !boxed) {
			if(z.antagonistic[player] + z.benevolent[player] > 0) {
				addAlert("Trauma tokens discarded.");
				t.value += z.players[player] + " discards their Trauma tokens.\r\n";
			}
			while(z.benevolent[player] > 0) {
				z.traumaPile.push(1);
				z.benevolent[player]--;
			}
			while(z.antagonistic[player] > 0) {
				z.traumaPile.push(0);
				z.antagonistic[player]--;
			}
			shuffle(z.traumaPile);
		}
		if(z.vBrutality) {
			if(z.admiral === player) {
				passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
			}
			if(z.president === player) {
				passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
			}
			if(z.CFB && z.cag === player) {
				passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
			}
		}
		if(!boxed) {
			if(availableCharacters().length === 0) {
				addAlert("You have unlocked the secret loss condition: no characters remain, so Cylons Win!");
				t.value += "There are no characters available.";
				endGame(false);
			} else {
				if(z.players[player] === "Boomer" && !z.exodus && z.loyaltyDeck.length > 0) {
					let loy = z.loyaltyDeck.pop();
					z.loyaltyHands[player].push(loy);
					if(player === me) {
						addAlert("As you were Boomer and were executed before sleeper, your new character will receive: " + d.loyaltyNames[loy]);
					} else {
						addAlert("As Boomer was executed before sleeper, " + z.usernames[player] + " draws a Loyalty now for their new character.");
					}
					t.value += "As Boomer was executed before sleeper, " + z.usernames[player] +
					" draws a Loyalty now for their new character.\r\n"; /* RULES: uh, what happens here? */
					if(loy === 40) {
						becomeMutineer(player);
					} else if(loy === 15) {
						becomeSympathizer(player);
					} else if(loy === 17) {
						becomeSympatheticCylon(player);
					}
				}
				plainAlert(z.usernames[player] + " must now pick a new character.");
				z.humanExecuted = player; /* RULES: NC execution: pick a new character? */
			}
		} else {
			z.graveyard.push(z.players[player]);
			if(z.admiral === player) {
				passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
			}
			if(z.president === player) {
				passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
			}
			if(z.CFB && z.cag === player) {
				passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
			}
			if(z.turn === player) {
				z.executedCurrentPlayer = true;
				addAlert("You should, most likely, end the turn now.");
			}
		}
	}
}

function drawTraumas(player, num) {
	let drawnDisasters = 0;
	let blueCount = 0;
	let redCount = 0;
	t.value += bold(z.players[player] + " draws " + num + " Trauma.") + "\r\n";
	while(num > 0) {
		if(z.traumaPile.length === 0) {
			plainAlert("Trauma pile is completely exhausted.");
			break;
		}
		let trauma = z.traumaPile.pop();
		if(trauma === -1) {
			drawnDisasters++;
			if(z.revealedCylons[player] === 1) {
				addAlert(z.players[player] + " draws a Disaster token, and draws 2 more Traumas!");
				t.value += bold(z.players[player] + " draws a " + colorText("red", "DISASTER") + " token, and draws 2 more Traumas!") + "\r\n";
				num += 2;
			}
		} else if(trauma === 0) {
			z.antagonistic[player]++;
			redCount++;
		} else if(trauma === 1) {
			z.benevolent[player]++;
			blueCount++;
		}
		num--;
	}
	let alertText = "";
	if(blueCount > 0) {
		alertText += "You drew " + blueCount + " Benevolent Trauma.\n";
	}
	if(redCount > 0) {
		alertText += "You drew " + redCount + " Antagonistic Trauma.\n";
	}
	if(drawnDisasters > 0 && z.revealedCylons[player] === 0) {
		alertText += "You drew " + drawnDisasters + " DISASTER Trauma.\n";
		t.value += bold(z.players[player] + " drew " + drawnDisasters + colorText("red", " DISASTER ") + "Trauma.") + "\r\n";
	}
	if(me === player) {
		addAlert(alertText);
	}
	if(drawnDisasters > 0 && z.revealedCylons[player] === 0) {
		executePlayer(player, false); /* RULES: what if an unrevealed cylon draws 2 disasters? */
	}
	for(let j = drawnDisasters; j > 0; j--) {
		z.traumaPile.push(-1);
		t.value += "Disaster token reshuffled.\r\n";
		shuffle(z.traumaPile);
	}
}

function boxPlayer(player) {
	executePlayer(player, true);
	addAlert(z.players[player] + " is eliminated!");
	t.value += bold(z.players[player] + " is boxed!") + "\r\n";
	t.value += bold(z.players[player] + " Loses!") + "\r\n";
	z.superCrisisHands[player].sort();
	while(z.superCrisisHands[player].length > 0) {
		plainAlert(z.players[player] + " discards " + d.crisisNames[z.superCrisisHands[player][0]]);
		z.superCrisisDiscards.push(z.superCrisisHands[player].shift());
	}
	z.dradisBait[player] = false;
	while(z.skillCardHands[player].length > 0){
		discardSkillCard(player,0);
	}
	if(z.theMutineer > player) {
		z.theMutineer--;
	} else if(z.theMutineer === player) {
		z.theMutineer = -2;
	}
	if(z.theCylonLeader > player) {
		z.theCylonLeader--;
	} else if(z.theCylonLeader === player) {
		z.theCylonLeader = -1;
	}
	if(z.theSympathizer > player) {
		z.theSympathizer--;
	} else if(z.theSympathizer === player) {
		z.theSympathizer = -1;
	}
	if(z.theSympatheticCylon > player) {
		z.theSympatheticCylon--;
	} else if(z.theSympatheticCylon === player) {
		z.theSympatheticCylon = -1;
	}
	if(z.president > player) {
		z.president--;
	}
	if(z.admiral > player) {
		z.admiral--;
	}
	if(z.CFB && z.cag > player) {
		z.cag--;
	}
	if(z.manipulativeVictim > player) {
		z.manipulativeVictim--;
	} else if(z.manipulativeVictim === player) {
		z.manipulativeVictim = 1000;
	}
	if(z.xo1 > player){
		z.xo1--;
	}
	if(z.xo2 > player){
		z.xo2--;
	}
	if(z.turn > player) {
		z.turn--;
	} else if(z.turn === player) {
		if(z.turn === 0) {
			z.turn = z.numPlayers - 2;
			z.round--;
		} else {
			z.turn--;
		}
		plainAlert(
			"The current player has been boxed; for accounting purposes, it is now the previous player's turn, but make sure to end the turn immediately once the Crossroads phase has been completely resolved."
			);
	}
	z.dieRoller = z.turn;
	if(me > player) {
		me--;
	}
	if(z.revealedCylons[player] === 1) {
		z.graveyard.push(z.players[player]);
	}
	z.boxedPlayers.push([z.usernames[player], z.players[player], z.loyaltyHands[player], z.loyaltyDiscards[player], z.banners[player]]);
	if(me === player) {
		meBoxed = z.boxedPlayers.length - 1;
	}
	z.skillCardHands.splice(player, 1);
	z.loyaltyHands.splice(player, 1);
	z.loyaltyDiscards.splice(player, 1);
	if(z.daybreak) {
		z.mutinies.splice(player, 1);
	}
	z.interrupts.splice(player, 1);
	z.skillCheckCards.splice(player, 1);
	z.superCrisisHands.splice(player, 1);
	z.quorumTitles.splice(player, 1);
	z.revealedCylons.splice(player, 1);
	z.contributionLabels.splice(player, 1);
	z.secretMessages.splice(player, 1);
	z.miracles.splice(player, 1);
	z.playerLocations.splice(player, 1);
	z.banners.splice(player, 1);
	z.possibleColors.splice(player, 1);
	if(Array.isArray(z.allForLove)){
		z.allForLove.splice(player, 1);
	}
	z.usernames.splice(player, 1);
	z.benevolent.splice(player, 1);
	z.antagonistic.splice(player, 1);
	for(let j = 0; !(j >= z.mandatory[player].length); j++) {
		if(z.mandatory[player][j]) {
			plainAlert("It looks like " + z.players[player] + " may still have had to " + z.crisisOptions[j] +
				"; if this is the case, you may need to use the deep menus or rewind.");
		}
	}
	z.crisisOptions.splice(player, 1);
	z.context.splice(player, 1);
	z.mandatory.splice(player, 1);
	z.dradisBait.splice(player, 1);
	z.tank.splice(player, 1);
	z.sps.splice(player, 1);
	z.promptStyle.splice(player, 1);
	z.players.splice(player, 1);
	z.numPlayers--; /* TODO: things contingent on "me" may break here! */
}

function startBoxing() {
	t.value += "\r\n[Ima" + bl + "geID=954448 medium]\r\n";
	let mostTrauma = 0;
	let tiedHumans = 0;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		t.value += z.players[j] + " has " + z.benevolent[j] + colorText("blue", " Benevolent") + " Trauma and " + z.antagonistic[j] + colorText("red",
			" Antagonistic") + " Trauma.\r\n";
		if(z.revealedCylons[j] === 1) {
			z.antagonistic[j] = 0;
			if(3 > z.benevolent[j]) {
				z.benevolent[j] = 0;
			} else {
				if(z.benevolent[j] > mostTrauma) {
					mostTrauma = z.benevolent[j];
					tiedHumans = 0;
				}
			}
		} else {
			z.benevolent[j] = 0;
			if(3 > z.antagonistic[j]) {
				z.antagonistic[j] = 0;
			} else {
				if(z.antagonistic[j] > mostTrauma) {
					mostTrauma = z.antagonistic[j];
					tiedHumans = 1;
				} else if(z.antagonistic[j] === mostTrauma) {
					tiedHumans++;
				}
			}
		}
	}
	if(mostTrauma === 0) {
		addAlert("No one is boxed!");
		t.value += bold("No players are boxed.");
		z.preCrossroads = false;
		if(z.destinationDiscards[z.destinationDiscards.length - 1] === 32 || (z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z
				.destinationDiscards[z.destinationDiscards.length - 2] === 32 && z.distance >= 9)) {
			addAlert("Increasing Jump Prep by 2 from Lion's Head Nebula.");
			t.value += "Jump Prep increases due to Lion's Head Nebula.\r\n";
			increaseJump();
			increaseJump();
		}
		if(z.v20Jump){
			plainAlert("Jump Prep increases by 2 due to the 20 Loyalty Card variant rules, as there were 3 Cylons.");
			increaseJump();
			increaseJump();
		}
		textGameState(true);
	} else if(!z.vNoBoxing && (tiedHumans === 0 || tiedHumans === 1)) {
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.antagonistic[j] === mostTrauma || z.benevolent[j] === mostTrauma) {
				boxPlayer(j);
				j--;
			}
		}
		z.preCrossroads = false;
		if(z.numPlayers === 0) {
			endGame();
		} else {
			if(z.destinationDiscards[z.destinationDiscards.length - 1] === 32 || (z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z
					.destinationDiscards[z.destinationDiscards.length - 2] === 32 && z.distance >= 9)) {
				addAlert("Increasing Jump Prep by 2 from Lion's Head Nebula.");
				t.value += "Jump Prep increases due to Lion's Head Nebula.\r\n";
				increaseJump();
				increaseJump();
			}
			if(z.v20Jump){
				plainAlert("Jump Prep increases by 2 due to the 20 Loyalty Card variant rules, as there were 3 Cylons.");
				increaseJump();
				increaseJump();
			}
			textGameState(true);
		}
	} else if(tiedHumans >= 2 && !z.vNoBoxing) {
		let alertText = "The following Humans are tied for most Trauma:\n";
		t.value += bold("The following Humans are tied for most Trauma:");
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.benevolent[j] === mostTrauma) {
				boxPlayer(j);
				j--;
			}
			if(z.antagonistic[j] === mostTrauma) {
				alertText += "\n" + z.players[j];
				t.value += "\n - " + bold(z.players[j]);
			} else {
				z.antagonistic[j] = 0;
			}
		}
		alertText += "\n\nPresident " + z.players[z.president] + " must now box 1 of these Humans.";
		addAlert(alertText);
		t.value += "\n\n" + bold(colorText("orange", "President ") + z.players[z.president] + " must now box 1 of these Humans.") + "\r\n";
	} else {
		if(z.destinationDiscards[z.destinationDiscards.length - 1] === 32 || (z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z
				.destinationDiscards[z.destinationDiscards.length - 2] === 32 && z.distance >= 9)) {
			addAlert("Increasing Jump Prep by 2 from Lion's Head Nebula.");
			t.value += "Jump Prep increases due to Lion's Head Nebula.\r\n";
			increaseJump();
			increaseJump();
		}
		if(z.v20Jump){
			plainAlert("Jump Prep increases by 2 due to the 20 Loyalty Card variant rules, as there were 3 Cylons.");
			increaseJump();
			increaseJump();
		}
		let deathList = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.antagonistic[j] === mostTrauma) {
				deathList.push(j);
			} else if(z.benevolent[j] === mostTrauma) {
				executePlayer(j);
				while(z.superCrisisHands[j].length > 0){
					t.value += z.players[j] +" discards "+d.crisisNames[z.superCrisisHands[j][0]]+".\r\n";
					z.superCrisisDiscards.push(z.superCrisisHands[j].shift());
				}
			}
		}
		if(deathList.length === 1){
			executePlayer(deathList[0]);
			if(z.jumpTrack === 5 && z.morale === 0){
				boldAlert("The Cylons actually win!");
			}
		} else if(deathList.length > 1) {
			let alertText = "The following players must now be executed: ";
			for(let j = 0; !(j>=deathList.length); j++){
				alertText += "\n"+deathList[j];
			}
			boldAlert(alertText);
			optionForAll("Execute a player","No Boxing",false);
			if(z.jumpTrack === 5 && deathList.length >= z.morale && z.morale > 0){
				boldAlert("If Morale is at 0 after these executions, the Cylons actually win!");
			}
		}
		z.preCrossroads = false;
	}
}

function processCrossroads(choice) {
	let player = z.players[z.crossroadsPlayer];
	let done = false;
	switch (z.crossroadsCards[z.crossroadsPlayer]) {
		case "Testimony":
			if(choice === 0) {
				addAlert(player + " chose Scapegoat.  They must pick another player, who will draw 2 skill cards and 2 trauma tokens.");
				t.value += bold(player + " chose " + colorText("red", "Scapegoat")) + ".\r\n" +
					"They must now choose another player; that player will then draw 2 skill cards and 2 trauma tokens.\r\n";
				addOption(z.crossroadsPlayer, "[Scapegoat] Pick a target", undefined, true);
			} else {
				addAlert(player + " chose Forgiven.  They must pick a player, who will discard 2 random skill cards and may discard 2 trauma tokens.");
				t.value += bold(player + " chose " + colorText("blue", "Forgiven")) + ".\r\n" +
					"They must now choose a player; that player will then discard 2 random skill cards and may discard 2 trauma tokens.\r\n";
				addOption(z.crossroadsPlayer, "[Forgiven] Pick a target", undefined, true);
			}
			break;
		case "The Opera House":
			if(choice === 0) {
				addAlert(player + " chose The Door is Shut.  No Effect.");
				t.value += bold(player + " chose " + colorText("red", "The Door is Shut")) + ".\r\n" + "No Effect.\r\n";
				done = true;
			} else {
				addAlert(player + " chose The Opera House Revealed.");
				t.value += bold(player + " chose " + colorText("blue", "The Opera House Revealed")) + ".\r\n";
				drawTraumas(z.crossroadsPlayer, 3);
				addAlert(player + " must now choose another player to draw 3 trauma tokens.");
				t.value += player + " must now deal 3 Trauma Tokens (from the pool) to another player.\r\n";
				addOption(z.crossroadsPlayer, "[The Opera House] Deal Trauma Tokens", undefined, true);
			}
			break;
		case "Scanned":
			if(choice === 0) {
				addAlert(player + " chose Order an Attack.");
				t.value += bold(player + " chose " + colorText("red", "Order an Attack")) + ".\r\n";
				if((z.scarCAC || raidersAway() !== z.raiders.length) && !z.negotiation) {
					if(z.dogfightCAC || z.scarCAC) {
						/* RULES: dogfight CAC + this card */
						plainAlert("Activate all raiders on the Main Board, then increase the Jump Preparation track by 1.");
						if(z.dogfightCAC) {
							plainAlert(
								"This probably doesn't trigger the extra launch from Dogfight, but if you think it should, launch those after the Raiders have finished activating."
								);
							let context = [0, 0, 0, 0, 0, 0];
							if(z.basestars.length > 0 && z.basestars[0][0] > 0 && !hangarDisabled(0)) {
								context[z.basestars[0][0] - 1] += 2;
								if(z.cylonSwarm) {
									context[z.basestars[0][0] - 1] += 1;
								}
							}
							if(z.basestars.length > 1 && z.basestars[1][0] > 0 && !hangarDisabled(1)) {
								context[z.basestars[1][0] - 1] += 2;
								if(z.cylonSwarm) {
									context[z.basestars[1][0] - 1] += 1;
								}
							}
							optionForAll("Place Raider(s) on the main game board", context, false);
						}
						resetRaiderActivations();
						resetActivatingSector();
						optionForAll("Advance the Jump Preparation Track");
					} else if(activateRaiders()) {
						increaseJump();
						done = true;
					} else {
						plainAlert("Once the Raiders have finished activating, increase the Jump Preparation Track by 1.");
						optionForAll("Advance the Jump Preparation Track");
					}
				} else if(z.negotiation) {
					addAlert("Negotiation prevents the Raider activation.");
					t.value += colorText("orange", "Negotiation ") + "prevents the Raider activation.\r\n";
					increaseJump();
					done = true;
				} else {
					plainAlert("There are no Raiders to activate.");
					increaseJump();
					done = true;
				}
			} else {
				addAlert(player + " chose Order a Retreat.");
				t.value += bold(player + " chose " + colorText("blue", "Order an Retreat")) + ".\r\n";
				if(z.raiders.length > raidersAway()) {
					addOption(z.crossroadsPlayer, "Destroy Raider(s)", ["Scanned", 4], true);
				}
				if(characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && z.preventative !== "Morale" && z.morale === 3) {
					addAlert(player + " must remove 4 Raiders from the main game board, then decrease Morale by 1.");
					t.value += player + " must remove 4 Raiders from the main game board, then decrease Morale by 1.\r\n";
					addOption(z.crossroadsPlayer, "Decrease a resource", "Forced Water Mining", true);
				} else {
					decreaseMorale();
					addAlert(player + " must remove 4 Raiders from the main game board.");
					t.value += player + " must remove 4 Raiders from the main game board.\r\n";
				}
			}
			break;
		case "Strange Music":
			if(choice === 0) {
				addAlert(player + " chose I Hear It.");
				t.value += bold(player + " chose " + colorText("red", "I Hear It")) + ".\r\n";
				if(z.notCylonDeck.length > 0){
					z.loyaltyDeck.push(z.notCylonDeck.pop());
					shuffle(z.loyaltyDeck);
					plainAlert('1 "You Are Not a Cylon" card shuffled into the Loyalty deck.');
				}
				if(z.loyaltyDeck.length > 0){
					plainAlert(player + " must now choose a Human player to draw 1 Loyalty card.");
					addOption(z.crossroadsPlayer, "[Strange Music] I Hear It", undefined, true);
				}
			} else {
				addAlert(player + " chose Nothing But Static.");
				t.value += bold(player + " chose " + colorText("blue", "Nothing But Static")) + ".\r\n";
				if(z.detectorSabotage) {
					if(z.antagonistic[z.crossroadsPlayer] === 0 && z.benevolent[z.crossroadsPlayer] === 0) {
						plainAlert("Loyalty cards may not be inspected due to Detector Sabotage, and " + player + " has no Trauma to discard; no effect.");
						done = true;
					} else if(z.antagonistic[z.crossroadsPlayer] + z.benevolent[z.crossroadsPlayer] === 1) {
						plainAlert("Loyalty cards may not be inspected due to Detector Sabotage; " + player + " discards their last remaining Trauma token.");
						if(z.antagonistic[z.crossroadsPlayer] === 1) {
							z.traumaPile.push(0);
							z.antagonistic[z.crossroadsPlayer] = 0;
						} else {
							z.traumaPile.push(1);
							z.benevolent[z.crossroadsPlayer] = 0;
						}
						shuffle(z.traumaPile);
						done = true;
					} else {
						plainAlert("Loyalty cards may not be inspected due to Detector Sabotage; the only effect is that " + player +
							" must now discard 1 Trauma Token.");
						addOption(z.crossroadsPlayer, "Discard a Trauma Token", undefined, true);
					}
				} else {
					plainAlert(player + " must now choose a player and inspect all of their Loyalty cards, then discard 1 Trauma Token.");
					addOption(z.crossroadsPlayer, "[Strange Music] Nothing But Static", undefined, true);
				}
			}
			break;
		case "Perjury":
			if(choice === 0) {
				addAlert(player + " chose Cast Aspersions.");
				t.value += bold(player + " chose " + colorText("red", "Cast Aspersions")) + ".\r\n";
				addAlert(player + " draws 2 Trauma Tokens.");
				drawTraumas(z.crossroadsPlayer, 2);
				addAlert(player + " may now draw 2 skill cards.");
				t.value += player + " may now draw 2 skill cards.\r\n";
				addOption(z.crossroadsPlayer, "Draw 2 Skill Cards", undefined, false);
			} else {
				addAlert(player + " chose Gain Sympathy.");
				t.value += bold(player + " chose " + colorText("blue", "Gain Sympathy")) + ".\r\n";
				if(!z.forLove) {
					addAlert(player + " discards 2 random skill cards.");
					if(z.skillCardHands[z.crossroadsPlayer].length > 0) {
						discardRandomSkillCard(z.crossroadsPlayer);
					}
					if(z.skillCardHands[z.crossroadsPlayer].length > 0) {
						discardRandomSkillCard(z.crossroadsPlayer);
					}
				} else {
					plainAlert(player + " now must discard 2 random skill cards, but Athena can Love " + player + ".");
					promptRandomDiscards(z.crossroadsPlayer, 2, true);
				}
				if(z.antagonistic[z.crossroadsPlayer] > 0 || z.benevolent[z.crossroadsPlayer] > 0) {
					addAlert(player + " may now discard 2 Traumas.");
					t.value += player + " may now discard 2 Traumas.\r\n";
					addOption(z.crossroadsPlayer, "Discard a Trauma Token", 2, false);
				}
			}
			break;
		case "Miraculous Return":
			if(choice === 0) {
				addAlert(player + " chose It's a Trick.");
				t.value += bold(player + " chose " + colorText("red", "It's a Trick")) + ".\r\n";
				if(decreaseMorale()) {
					destroyPileCivilian(1);
					if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
						plainAlert(player + " must now damage a basestar on the main game board.");
						addOption(z.crossroadsPlayer, "Damage a basestar", "Miraculous Return", true);
					} else {
						plainAlert("There are no basestars on the main game board to damage.");
					}
				} else {
					/*DEE*/
					t.value += "After resolving Dee's execution, draw and destroy a civilian, then " + player +
						" must damage a basestar on the main game board.\r\n";
					if(player !== "Dee"){
						addOption(z.crossroadsPlayer,"Draw and destroy a Civilian","Miraculous Return",true);
					} else {
						optionForAll("Draw and destroy a Civilian","Miraculous Return",true);
					}
				}
			} else {
				addAlert(player + " chose I Believe.");
				t.value += bold(player + " chose " + colorText("blue", "I Believe")) + ".\r\n";
				increaseMorale();
				let destroyedCount = 0;
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(z.vipersII[j] === -2) {
						destroyedCount++;
					}
				}
				for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
					if(z.vipersVII[j] === -2) {
						destroyedCount++;
					}
				}
				for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
					if(z.assaultRaptors[j] === -2) {
						destroyedCount++;
					}
				}
				if(destroyedCount === 0) {
					plainAlert("There are no destroyed Vipers to repair.");
					if(z.negotiation) {
						addAlert("Negotiation prevents the Raider activations.");
						t.value += colorText("orange", "Negotiation") + " prevents the Raider activations.\r\n";
					} else {
						if(activateRaiders()) {
							done = activateRaiders();
						} else {
							plainAlert("Once the Raiders are done activating, activate Raiders again.");
							optionForAll("Activate Raiders");
						}
					}
				} else if(destroyedCount === 1) {
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(z.vipersII[j] === -2) {
							z.vipersII[j] = 0;
							plainAlert("Repaired a destroyed Viper Mk II.");
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === -2) {
							z.vipersVII[j] = 0;
							plainAlert("Repaired a destroyed Viper Mk VII.");
						}
					}
					for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
						if(z.assaultRaptors[j] === -2) {
							z.assaultRaptors[j] = 0;
							plainAlert("Repaired a destroyed Assault Raptor.");
						}
					}
					if(z.negotiation) {
						addAlert("Negotiation prevents the Raider activations.");
						t.value += colorText("orange", "Negotiation") + " prevents the Raider activations.\r\n";
					} else {
						if(activateRaiders()) {
							done = activateRaiders();
						} else {
							plainAlert("Once the Raiders are done activating, activate Raiders again.");
							optionForAll("Activate Raiders");
						}
					}
				} else {
					done = true;
					if(destroyedVipersII() > 0 && destroyedVipersVII() === 0 && destroyedAssaultRaptors() === 0) {
						for(let j = 0; !(j >= z.vipersII.length); j++) {
							if(z.vipersII[j] === -2) {
								z.vipersII[j] = 0;
								plainAlert("A destroyed Viper Mk II is returned to the Reserves.");
								done = true;
								break;
							}
						}
					} else if(destroyedVipersII() === 0 && destroyedVipersVII() > 0 && destroyedAssaultRaptors() === 0) {
						for(let j = 0; !(j >= z.vipersVII.length); j++) {
							if(z.vipersVII[j] === -2) {
								z.vipersVII[j] = 0;
								plainAlert("A destroyed Viper Mk VII is returned to the Reserves.");
								done = true;
								break;
							}
						}
					} else if(destroyedVipersII() === 0 && destroyedVipersVII() === 0 && destroyedAssaultRaptors() > 0) {
						for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
							if(z.assaultRaptors[j] === -2) {
								z.assaultRaptors[j] = 0;
								plainAlert("A destroyed Assault Raptor is returned to the Reserves.");
								done = true;
								break;
							}
						}
					} else {
						done = false;
						plainAlert(player + " must repair a destroyed Viper, then activate Raiders twice.");
						if(destroyedVipersII() > 0) {
							addOption(z.crossroadsPlayer, "Repair a destroyed Viper Mk II", "Miraculous Return", true);
						}
						if(destroyedVipersVII() > 0) {
							addOption(z.crossroadsPlayer, "Repair a destroyed Viper Mk VII", "Miraculous Return", true);
						}
						if(destroyedAssaultRaptors() > 0) {
							addOption(z.crossroadsPlayer, "Repair a destroyed Assault Raptor", "Miraculous Return", true);
						}
					}
					if(done) {
						if(activateRaiders()) {
							done = activateRaiders();
						} else {
							done = false;
							plainAlert("Once the Raiders are done activating, activate Raiders again.");
							optionForAll("Activate Raiders");
						}
					}
				}
			}
			break;
		case "Disturbing Vision":
			if(choice === 0) {
				addAlert(player + " chose What Have You Done?.");
				t.value += bold(player + " chose " + colorText("red", "What Have You Done?")) + ".\r\n";
				addAlert("Each Cylon player draws 2 trauma tokens.");
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (j + z.turn) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						drawTraumas(k, 2);
					}
				}
				executePlayer(z.admiral, false);
			} else {
				addAlert(player + " chose It Wasn't Real.");
				t.value += bold(player + " chose " + colorText("blue", "It Wasn't Real")) + ".\r\n";
				if(z.antagonistic[z.crossroadsPlayer] + z.benevolent[z.crossroadsPlayer] > 2) {
					plainAlert(player + " must discard 2 Trauma Tokens and 2 random skill cards.");
					addOption(z.crossroadsPlayer, "Discard a Trauma Token", 2, true);
					if(z.forLove && player !== "Athena") {
						plainAlert("Athena can Love them.");
						addOption(z.crossroadsPlayer, "Discard a random Skill Card", 1, true);
						z.randomLove[z.crossroadsPlayer] = true;
					} else {
						addOption(z.crossroadsPlayer, "Discard a random Skill Card", 2, true);
					}
				} else {
					if(z.antagonistic[z.crossroadsPlayer] + z.benevolent[z.crossroadsPlayer] === 0) {
						plainAlert(player + " has no Trauma to discard.");
					} else {
						plainAlert(player + " discards their remaining Trauma.");
					}
					while(z.antagonistic[z.crossroadsPlayer] > 0) {
						z.antagonistic[z.crossroadsPlayer]--;
						z.traumaPile.push(0);
					}
					while(z.benevolent[z.crossroadsPlayer] > 0) {
						z.benevolent[z.crossroadsPlayer]--;
						z.traumaPile.push(1);
					}
					shuffle(z.traumaPile);
					done = promptRandomDiscards(z.crossroadsPlayer, 2, true);
				}
			}
	}
	if(done && z.humanExecuted === -1) {
		z.crossroadsPlayer++;
		z.crossroadsPlayer %= z.numPlayers;
		if(z.crossroadsPlayer === z.turn) {
			z.lateCrossroads = true;
			startBoxing();
		} else {
			flipCrossroads();
		}
	}
}

function flipCrossroads() {
	boldAlert(z.players[z.crossroadsPlayer] + " reveals their Crossroads card, " + z.crossroadsCards[z.crossroadsPlayer]);
	if(z.crossroadsTrauma[z.crossroadsPlayer] === true) {
		plainAlert(z.players[z.crossroadsPlayer] + " has a free choice on their Crossroads card.");
	} else {
		processCrossroads(z.crossroadsTrauma[z.crossroadsPlayer]);
	}
}

function startCrossroads() {
	z.earlyCrossroads = true;
	if(z.jumpTrack > 0) {
		boldAlert("Jump Track reset to Start.");
		z.jumpTrack = 0;
	}
	let crossroadsDeck = ["Testimony", "The Opera House", "Scanned", "Strange Music", "Perjury", "Miraculous Return", "Disturbing Vision"];
	shuffle(crossroadsDeck);
	z.crossroadsCards = blankArrays(z.numPlayers);
	z.crossroadsTrauma = [];
	let mustWait = false;
	addAlert("Dealing Crossroads cards.");
	t.value += "\r\n[Ima" + bl + "geID=954448 medium]\r\n";
	t.value += "Crossroads cards dealt.\r\n";
	for(let k = 0; !(k >= z.numPlayers); k++) {
		z.crossroadsCards[k] = crossroadsDeck.pop();
		if(z.antagonistic[k] + z.benevolent[k] === 0) {
			z.crossroadsTrauma.push(true);
			t.value += z.players[k] + " has no Trauma tokens and will make their choice once their card is revealed.\r\n";
		} else if(z.antagonistic[k] === 1 && z.benevolent[k] === 0) {
			z.crossroadsTrauma.push(0);
			z.antagonistic[k]--;
			t.value += z.players[k] + " places their last Trauma token on their Crossroads card.\r\n";
		} else if(z.antagonistic[k] === 0 && z.benevolent[k] === 1) {
			z.crossroadsTrauma.push(1);
			z.benevolent[k]--;
			t.value += z.players[k] + " places their last Trauma token on their Crossroads card.\r\n";
		} else {
			z.crossroadsTrauma.push(false);
			mustWait = true;
		}
	}
	if(z.vDisasterDeferred) {
		z.traumaPile.push(-1);
		if(!z.vEuropeanTrauma){
			z.traumaPile.push(-1);
			boldAlert("One DISASTER token added to the pile of Trauma tokens.");
		} else {
			boldAlert("Two DISASTER tokens added to the pile of Trauma tokens.");
		}
		shuffle(z.traumaPile);
		
	}
	if(!mustWait) {
		z.midCrossroads = true;
		z.crossroadsPlayer = z.turn;
		flipCrossroads();
	}
}

function brutalityPersonalGoalsResolution(){
	for(let j = 0; !(j>=z.numPlayers); j++){
		if(z.personalGoalsBrutality[j] !== null){
			plainAlert(z.players[j] + ' discards their unrevealed Personal Goal and shuffles a "You Are Not a Cylon" card into the Loyalty Deck.');
			if(z.notCylonDeck.length > 0){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		}
	}
	shuffle(z.loyaltyDeck);
	for(let j = 0; !(j>=z.numPlayers); j++){
		if(z.personalGoalsBrutality[j] !== null){
			plainAlert(z.players[j] + " draws a Loyalty card.");
			if(z.loyaltyDeck.length > 0){
				z.loyaltyHands[j].push(z.loyaltyDeck.pop());
			}
		}
	}
	z.personalGoalsBrutality = undefined;
	
}

function v20Check(){
	delete z.v20;
	let cylonCount = 0;
	for(let j = 0; !(j >= z.loyaltyHands.length); j++) {
		if(z.revealedCylons[j] === 1){
			cylonCount++;
			continue;
		}
		if(cylonCards(j) > 0){
			cylonCount++;
			continue;
		}
	}
	if(cylonCount === 0){
		boldAlert("There are no Cylons!");
		endGame(true,true);
	} else if(cylonCount === 1){
		boldAlert("There is 1 Cylon!");
		z.brutalityPenalty = true;
		let dealt = false;
		for(let j = 0; !(j >= z.numPlayers); j++) {
			let k = (z.turn + j) % z.numPlayers;
			if(z.revealedCylons[k] === 1) {
				dealt = true;
				if(z.superCrisisDeck.length === 0) {
					plainAlert("Super Crisis Deck entirely depleted.");
				} else {
					t.value += z.players[k] + " draws a Super Crisis.\r\n";
					z.superCrisisHands[k].push(z.superCrisisDeck.pop());
					if(z.superCrisisDeck.length === 0) {
						t.value += "Super Crisis deck reshuffled.\r\n";
						z.superCrisisDeck = shuffle(z.superCrisisDiscards);
						z.superCrisisDiscards = [];
					}
				}
			}
		}
		if(!dealt){
			z.v20Super = true;
			plainAlert("The unrevealed Cylon will receive an additional Super Crisis if they reveal (even if executed).");
		}
		decreaseFuel();
		decreaseFood();
		decreasePopulation();
		decreaseMorale();
	} else if(cylonCount === 2){
		boldAlert("There are 2 Cylons!");
		plainAlert("No effect.");
	} else if(cylonCount === 3){
		boldAlert("There are 3 Cylons!");
		for(let j = 0; !(j >= z.loyaltyHands.length); j++) {
			if(z.revealedCylons[j] === 0){
				if(cylonCards(j) > 0){
					boldAlert(z.players[j] + " is an unrevealed Cylon!");
				} else {
					if(z.miracles[j] === 0 || (z.players[j] === "Gaius" && z.miracles[j] !== 3)){
						z.miracles[j]++;
						boldAlert(z.players[j] + " gains a Miracle Token.");
					}
					if(z.playerLocations[j] === "Brig" && z.destination !== "New Caprica"){
						addOption(j,"Move a player out of the Brig","Escape",true);
						boldAlert(z.players[j] + " must move out of the Brig to any location on Galactica.");
					}
				}
			}
		}
		if(z.destination === "Ionian Nebula" || z.destination === "Ionian Earth"){
			plainAlert("The Jump Preparation Track will be set to "+colorText("red", "Red 2")+" after the Crossroads Phase.");
			z.v20Jump = true;
		} else if(z.destination === "New Caprica"){
			z.v20Jump = true;
		} else {
			increaseJump();
			if(z.jumpTrack !== 5){
				increaseJump();
			}
		}
		
	} else if(cylonCount === 4){
		boldAlert("There are 4 Cylons!");
		endGame(true,true);
	}
}

function brutalityCylonCheck() {
	let alertText = "The Loyalty deck is revealed:";
	let foundOne = false;
	for(let j = 0; !(j >= z.loyaltyDeck.length); j++) {
		alertText += "\n" + d.loyaltyNames[z.loyaltyDeck[j]];
		if(isCylonCard(z.loyaltyDeck[j])) {
			foundOne = true;
			z.loyaltyDeck.splice(j, 1);
			j--;
		}
	}
	plainAlert(alertText);
	if(foundOne) {
		boldAlert(
			"There was a Cylon card in the Loyalty Deck!  It is removed from the game, all Cylons get a Super Crisis, and when the fleet would next jump, the Jump Preparation Track is reset instead."
			);
		z.brutalityPenalty = true;
		for(let j = 0; !(j >= z.numPlayers); j++) {
			let k = (z.turn + j) % z.numPlayers;
			if(z.revealedCylons[k] === 1) {
				if(z.superCrisisDeck.length === 0) {
					plainAlert("Super Crisis Deck entirely depleted.");
				} else {
					t.value += z.players[k] + " draws a Super Crisis.\r\n";
					z.superCrisisHands[k].push(z.superCrisisDeck.pop());
					if(z.superCrisisDeck.length === 0) {
						t.value += "Super Crisis deck reshuffled.\r\n";
						z.superCrisisDeck = shuffle(z.superCrisisDiscards);
						z.superCrisisDiscards = [];
					}
				}
			}
		}
	} else {
		plainAlert("There were no Cylon cards in the Loyalty Deck; the game proceeds as normal.");
		z.brutalityPenalty = false;
	}
}



function setupIN() {
	if(z.vSoloCylonBrutality && !z.v20) {
		brutalityCylonCheck();
	}
	if(z.v20){
		v20Check();
	}
	z.ionianBattle = true;
	let fine = true;
	if(raidersAway() >= 8) {
		placeRaiders(2, 4);
		placeRaiders(3, 4);
	} else if(raidersAway() > 0) {
		plainAlert(z.players[z.turn] + " must place the Raiders for the battle.");
		addOption(z.turn, "Place Raider(s) on the main game board", [0, 4, 4, 0, 0, 0], true);
	}
	if(basestarsAway() === 2) {
		placeBasestar(2);
		placeBasestar(3);
	} else if(basestarsAway() === 1) {
		boldAlert(z.players[z.turn] + ", as current player, must place a Basestar in either Sector 2 or Sector 3.");
		fine = false;
		addOption(z.turn, "Place a basestar on the main game board", [0, 1, 1, 0, 0, 0], true);
	}
	if(vipersIIReserves() === 0 && (!z.CFB || vipersVIIReserves() === 0) && (!z.daybreak || assaultRaptorsReserves() === 0)) {
		plainAlert("There are no Vipers to launch.");
	}
	if(vipersIIReserves() >= 4 && (!z.CFB || vipersVIIReserves() === 0) && (!z.daybreak || assaultRaptorsReserves() === 0)) {
		placeVipers(5, 2);
		placeVipers(6, 2);
		if(canAVP()) {
			addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
			addAlert("Remember that Apollo may have a chance to use Alert Viper Pilot here.");
			t.value += "Remember that Apollo may have a chance to use Alert Viper Pilot here.\r\n";
			if(z.jumpTrack === 5) {
				t.value +=
					"NOTE: Technically, the Jump Preparation Track is at Auto-Jump.  No jump prep may be gained or lost during the ability, if he uses it.\r\n";
			}
			fine = false;
		}
	} else {
		boldAlert(z.players[z.turn] + ", as current player, must launch 2 Vipers in Sector 5 and 2 Vipers in Sector 6, as able.");
		if(vipersIIReserves() > 0) {
			addOption(z.turn, "Launch a Viper Mk II in Sector 5", 2, true);
			addOption(z.turn, "Launch a Viper Mk II in Sector 6", 2, true);
		}
		if(vipersVIIReserves() > 0) {
			addOption(z.turn, "Launch a Viper Mk VII in Sector 5", 2, true);
			addOption(z.turn, "Launch a Viper Mk VII in Sector 6", 2, true);
		}
		if(assaultRaptorsReserves() > 0) {
			addOption(z.turn, "Launch an Assault Raptor in Sector 5", 2, true);
			addOption(z.turn, "Launch an Assault Raptor in Sector 6", 2, true);
		}
		fine = false;
	}
	if(z.vExodusMinusCFB || (z.vBrutality && !z.CFB)) {
		if(z.civilianPile.length >= 2) {
			placeCivilian(5);
			placeCivilian(6);
		} else if(z.civilianPile.length === 1) {
			boldAlert(z.players[z.turn] + ", as current player, must place a Civilian in Sector 5 or Sector 6.");
			addOption(z.turn, "Place a Civilian on the board", [0, 0, 0, 0, 1, 1], true);
			fine = false;
		}
	}
	textGameState(true);
	if(fine) {
		startCrossroads();
	}
}

function setupNC() {
	if(z.vSoloCylonBrutality) {
		brutalityCylonCheck();
	}
	if(z.v20){
		v20Check();
	}
	z.reshuffledSeen = false;
	z.galacticaAway = true;
	t.value += "[ima" + bl + "geid=713177 medium]\r\n";
	boldAlert("The New Caprica phase begins!");
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.revealedCylons[j] === 1) {
			movePlayer(j, "Occupation Authority");
		} else if(z.playerLocations[j] !== "Stranded on Caprica") {
			movePlayer(j, "Resistance HQ");
		}
	}
	for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
		if(z.assaultRaptors[j] > 0) {
			z.assaultRaptors[j] = 0;
		}
	}
	for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
		if(z.vipersVII[j] > 0) {
			z.vipersVII[j] = 0;
		}
	}
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(z.vipersII[j] > 0) {
			z.vipersII[j] = 0;
		}
	}
	clearCivilians();
	z.lockedCivilians = z.civilianPile;
	t.value += "All remaining Civilians placed on the Locked Civilian pile.\r\n";
	shuffle(z.lockedCivilians);
	z.civilianPile = [];
	if(d.destinationNames[z.destinationDiscards[z.destinationDiscards.length-1]] !== "Gas Cloud"){
		if(z.hasOwnProperty("oldCrisisDiscards")){
			let temp = z.oldCrisisDiscards;
			z.oldCrisisDiscards = z.crisisDiscards;
			z.crisisDiscards = temp;
			z.crisisDeck = [];
			for(let j = 173; !(j >= 203); j++) {
				if(!z.crisisDiscards.includes(j)){
					z.crisisDeck.push(j);
				}
			}
		} else {
			z.oldCrisisDiscards = z.crisisDiscards;
			z.crisisDiscards = [];
			z.crisisDeck = [];
			for(let j = 173; !(j >= 203); j++) {
				z.crisisDeck.push(j);
			}
		}
		shuffle(z.crisisDeck);
	}
	if(z.jumpTrack !== 0 && z.destinationDiscards[z.destinationDiscards.length - 1] !== 32) {
		z.jumpTrack = 0;
		boldAlert("Jump Track reset to Start.");
	}
	if(z.v20Jump){
		increaseJump();
		increaseJump();
		prepareCivilian();
		prepareCivilian();
	}
	z.OFs = [0, 0, 0, 0];
	z.toDoOFs = false;
	textGameState(true);
}

function OFPresent(loc) {
	let slot = 0;
	if(loc === "Occupation Authority") {
		slot = 1;
	} else if(loc === "Breeder's Canyon") {
		slot = 2;
	} else if(loc === "Shipyard") {
		slot = 3;
	} else {
		return false;
	}
	for(let j = 0; !(j >= 4); j++) {
		if(z.OFs[j] === slot) {
			return true;
		}
	}
	return false;
}

function canDetain(cylon) {
	if(z.revealedCylons[cylon] === 0) {
		return false;
	}
	let loc = z.playerLocations[cylon];
	if(!OFPresent(loc)) {
		return false;
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.playerLocations[j] === loc && z.revealedCylons[j] === 0) {
			return true;
		}
	}
	return false;
}

function processDestination() {
	z.blindJump = false;
	let name = d.destinationNames[z.destinationDiscards[z.destinationDiscards.length - 1]];
	t.value += bold("Destination is " + name) + "\r\n";
	if(name !== "Legendary Discovery" && name !== "Digging up the Past" && name !== "The Search for Home") {
		/* TODO: fix this for NC/Crossroads */
		if(!z.CFB) {
			z.escortPause = false;
		}
		z.jumpTrack = 0;
	}
	let input = false;
	switch (name) {
		case "Asteroid Field":
			increaseDistance(3);
			decreaseFuel();
			decreaseFuel();
			input = !destroyPileCivilian(1);
			break;
		case "Barren Planet":
			increaseDistance(2);
			decreaseFuel();
			decreaseFuel();
			break;
		case "Cylon Ambush":
			increaseDistance(3);
			decreaseFuel();
			placeBasestar(1);
			placeRaiders(1, 3);
			placeCivilians(4, 3);
			break;
		case "Cylon Refinery": {
			increaseDistance(2);
			decreaseFuel();
			let intactVipers = 0;
			for(let i = 0; !(i >= z.vipersII.length); i++) {
				if(z.vipersII[i ] === 0) {
					intactVipers++;
				}
			}
			for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
				if(z.vipersVII[i ] === 0) {
					intactVipers++;
				}
			} /* RULES: cannot risk assault raptors in space, right?*/
			for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
				if(z.assaultRaptors[i ] === 0) {
					intactVipers++;
				}
			}
			let alertText = "";
			if(intactVipers >= 2) {
				alertText = "Admiral " + z.players[z.admiral] + " must decide whether to risk 2 Vipers in the Reserves to gain 2 Fuel.";
				addOption(z.admiral, "[Cylon Refinery] Sometimes you have to roll the hard six", undefined, true);
				addOption(z.admiral, "[Cylon Refinery] Do not risk the vipers", undefined, true);
				input = true;
			} else {
				alertText = "There are not enough Vipers left to risk.";
			}
			plainAlert(alertText);
			break;
		}
		case "Deep Space":
			increaseDistance(2);
			decreaseFuel();
			input = !decreaseMorale();
			break;
		case "Desolate Moon":
			increaseDistance(3);
			decreaseFuel();
			decreaseFuel();
			decreaseFuel();
			break;
		case "Icy Moon": {
			increaseDistance(1);
			decreaseFuel();
			let alertText = "";
			if(z.raptors === 0) {
				alertText = "There are no Raptors left to risk.";
			} else {
				/* TODO: jscompress */
				alertText = "Admiral " + z.players[z.admiral] + " must decide whether to risk a Raptor to gain a Food.";
				addOption(z.admiral, "Risk a Raptor for Icy Moon", undefined, true);
				addOption(z.admiral, "Do not risk a Raptor for Icy Moon", undefined, true);
				input = true;
			}
			plainAlert(alertText);
			break;
		}
		case "Tylium Planet": {
			increaseDistance(1);
			decreaseFuel();
			let alertText = "";
			if(z.raptors === 0) {
				alertText = "There are no Raptors left to risk.";
			} else {
				alertText = "Admiral " + z.players[z.admiral] + " must decide whether to risk a Raptor to gain 2 Fuel.";
				addOption(z.admiral, "Risk a Raptor for Tylium Planet", undefined, true);
				addOption(z.admiral, "Do not risk a Raptor for Tylium Planet", undefined, true);
				input = true;
			}
			plainAlert(alertText);
			break;
		}
		case "Ragnar Anchorage": {
			increaseDistance(1);
			let alertText = "The Admiral may repair up to 3 vipers and 1 Raptor. These ships may be damaged or even destroyed.";
			if(damagedVipersII() > 0) {
				addOption(z.admiral, "Repair a damaged Viper Mk II", ["Ragnar Anchorage", 3], false);
			}
			if(damagedVipersVII() > 0) {
				addOption(z.admiral, "Repair a damaged Viper Mk VII", ["Ragnar Anchorage", 3], false);
			}
			if(destroyedVipersII() > 0) {
				addOption(z.admiral, "Repair a destroyed Viper Mk II", ["Ragnar Anchorage", 3], false);
			}
			if(destroyedVipersVII() > 0) {
				addOption(z.admiral, "Repair a destroyed Viper Mk VII", ["Ragnar Anchorage", 3], false);
			}
			if(destroyedAssaultRaptors() > 0) {
				addOption(z.admiral, "Repair a destroyed Assault Raptor", ["Ragnar Anchorage", 3], false);
			}
			if(z.raptors !== 4) {
				addOption(z.admiral, "Repair a Raptor", undefined, false);
			}
			plainAlert(alertText);
			input = true;
			break;
		}
		case "Remote Planet":
			increaseDistance(2);
			decreaseFuel();
			destroyRaptor();
			break;
		case "The Search for Home":
			increaseDistance(2);
			break;
		case "Legendary Discovery":
		case "Digging up the Past":
			increaseDistance(1);
			break;
		case "Algae Planet":
			increaseDistance(1);
			decreaseFuel();
			increaseFood();
			break;
		case "Cylon Raiders":
			increaseDistance(3);
			decreaseFuel();
			decreaseFuel();
			placeRaiders(4, 3);
			break;
		case "Derelict Basestar":
			increaseDistance(2);
			decreaseFuel();
			placeBasestar(1);
			placeCivilians(4, 2);
			addAlert("The Basestar is damaged: ");
			if(z.basestars.length > 0 && z.basestars[0][0] === 1) {
				damageBasestar(0);
			} else if(z.basestars.length > 1 && z.basestars[1][0] === 1) {
				damageBasestar(1);
			}
			break;
		case "Dying Star":
			increaseDistance(2);
			decreaseFuel();
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				plainAlert("Now, " + z.players[z.turn] + ", as current player, must choose whether to damage Pegasus or Galactica.");
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				input = true;
			} else {
				input = !damageGalactica();
			}
			break;
		case "Gas Giant":
			increaseDistance(1);
			plainAlert("Now, the Admiral may destroy 1 Viper to gain 1 Fuel.");
			addOption(z.admiral, "Destroy a Viper", "Gas Giant", false);
			input = true;
			break;
		case "Lion's Head Nebula":
			increaseDistance(3);
			decreaseFuel();
			decreaseFuel();
			decreaseFuel();
			decreaseFuel();
			if(((z.destination === "Ionian Nebula" && z.distance >= 8) || (z.destination === "Ionian Earth" && z.distance >= 10)) && !z.ionianBattle) {
				plainAlert("The advance in the Jump Preparation Track from Lion's Head Nebula will occur automatically after the Crossroads phase.");
			} else {
				increaseJump();
				increaseJump();
			}
			break;
		case "Radioactive Cloud":
			increaseDistance(2);
			decreaseFuel();
			input = !decreasePopulation();
			break;
		case "A Civilian Convoy":
			increaseDistance(3);
			decreaseFuel();
			decreaseFuel();
			decreaseFuel();
			increasePopulation();
			if(z.morale > 0) {
				/* RULES: can you make this trade if Morale is 0? */
				plainAlert("Now, Admiral " + z.players[z.admiral] + " must decide whether to decrease Morale by 1 to increase Fuel by 1.");
				addOption(z.admiral, "[A Civilian Convoy] Trade Morale for Fuel", undefined, true);
				addOption(z.admiral, "[A Civilian Convoy] Decline to make the trade", undefined, true);
				input = true;
			}
			break;
		case "Binary Star":
			increaseDistance(2);
			decreaseFuel();
			if(z.civilianPile.length >= 2) {
				placeCivilian(4);
				placeCivilian(1);
			} else if(z.civilianPile.length === 0) {
				plainAlert("There are no Civilians left to place.\r\n");
			} else {
				plainAlert(z.players[z.turn] + ", as current player, must place a Civilian in Sector 1 or Sector 4.");
				addOption(z.turn, "Place a Civilian on the board", [1, 0, 0, 1, 0, 0], true);
				input = true;
			}
			break;
		case "Mining Asteroid": {
			increaseDistance(2);
			decreaseFuel();
			let damagedII = 0;
			for(let j = 0; 2 > damagedII && !(j >= z.vipersII.length); j++) {
				if(z.vipersII[j] === -1) {
					damagedII++;
					z.vipersII[j] = 0;
					addAlert("Repaired a Viper Mk II.");
					t.value += "Viper Mk II Repaired.\r\n";
				}
			}
			if(damagedII === 0) {
				plainAlert("There are no damaged vipers to repair.");
			}
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
				if(z.daybreak && assaultRaptorsReserves() > 0) {
					addAlert("The current player may place Assault Raptors instead.");
					t.value += "Vipers Mk II were placed automatically; " + z.players[z.turn] +
						", as current player, may swap one or more of them for Assault Raptors.\r\n";
					addOption(z.turn, "Swap out a Viper Mk II for an Assault Raptor", [0, 0, 0, 0, 1, 1], false);
					input = true;
				}
			} else if(vipersIIReserves() === 0) {
				if(!z.daybreak || assaultRaptorsReserves() === 0) {
					addAlert("You managed to destroy all Vipers.  Good work!");
				} else if(assaultRaptorsReserves() === 1) {
					plainAlert(z.players[z.turn] + ", as current player, must place an Assault Raptor in Sector 5 or Sector 6.\r\n");
					addOption(z.turn, "Place an Assault Raptor in space", [0, 0, 0, 0, 1, 1], true);
					input = true;
				} else {
					plainAlert("1 Assault Raptor placed in Sector 5; 1 Assault Raptor placed in Sector 6.");
					for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
						if(z.assaultRaptors[j] === 0) {
							z.assaultRaptors[j] = 5;
							if(canAVP()) {
								z.avp.push(12 + j);
							}
							break;
						}
					}
					for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
						if(z.assaultRaptors[j] === 0) {
							z.assaultRaptors[j] = 6;
							if(canAVP()) {
								z.avp.push(12 + j);
							}
							break;
						}
					}
				}
			} else if(vipersIIReserves() === 1) {
				addOption(z.turn, "Place a Viper Mk II in space", [0, 0, 0, 0, 1, 1], true);
				if(z.daybreak && assaultRaptorsReserves() > 0) {
					plainAlert(z.players[z.turn] + ", as current player, must place 1 Viper in Sector 5 and 1 Viper in Sector 6.\r\n");
					addOption(z.turn, "Place an Assault Raptor in space", [0, 0, 0, 0, 1, 1], true);
				} else {
					addAlert("You managed to destroy 7 Vipers; wow!  Current player must place a Viper in Sector 5 or Sector 6.");
					t.value += z.players[z.turn] + ", as current player, must place a Viper in Sector 5 or Sector 6.\r\n";
				}
				input = true;
			}
			placeCivilians(4, 2);
			let foundScar = false;
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] === 0) {
					z.raiders.splice(j, 1);
					foundScar = true;
					break;
				}
			}
			if(foundScar) {
				addAlert("Scar placed in Sector 2.");
				z.scar = 2;
				z.scarCAC = true;
			} else {
				addAlert("Scar is not placed due to component limitations.");
				t.value += "All raiders are on the board already; Scar cannot be placed.\r\n";
			}
			for(let j = 0; !(j >= z.crisisDeck.length); j++) {
				if(z.crisisDeck[j] === 83) {
					/* RULES: how carefully do you get to look? */
					z.crisisDeck.splice(j, 1);
					break;
				}
			}
			if(canAVP()) {
				addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
				addAlert("Apollo may have an opportunity to use Alert Viper Pilot here."); /*RULES: Jump Prep and this */
				t.value += "Apollo may have an opportunity to use Alert Viper Pilot here.\nRemember to reshuffle the Crisis deck after he finishes.\r\n" +
					"NOTE: Technically, the Jump Track is still at Auto-Jump.  No jump prep may be gained during the ability, if he uses it.";
				input = true;
				optionForAll("[Mining Asteroid] Reshuffle the Crisis deck", undefined, true);
			} else {
				/* RULES: does this shuffle the discards in? */
				shuffle(z.crisisDeck);
			}
			break;
		}
		case "Misjump":
			if(z.civilianPile.length > 0) {
				input = !destroyPileCivilian(1);
				if(!input) {
					let dest = z.destinationDeck.pop();
					z.destinationDiscards.push(dest);
					addAlert("New Destination is: " + d.destinationNames[dest] + ".");
					processDestination();
				}
			} else if(z.destroyedCivilians.length === 12) {
				plainAlert("All civilians have already been destroyed.");
				z.destinationDiscards.push(z.destinationDeck.pop());
				processDestination();
			} else {
				addAlert(
					"All civilians are on the board; the current player must choose a civilian on the board to destroy, then jump to the top card of the Destination deck."
					);
				t.value += "All civilians are on the board.\n" + z.players[z.turn] +
					", as current player, must choose a civilian on the board to destroy, then jump to the top card of the Destination deck.\r\n";
				addOption(z.turn, "Destroy a Civilian in space", 1, true);
				addOption(z.turn, "[Misjump] Draw and resolve the next card of the Destination deck", undefined, true);
				input = true;
			}
			break;
		case "Gas Cloud":
			increaseDistance(1); /* TODO: make this optional */
			z.scout = z.admiral;
			if(z.destination === "New Caprica" && z.distance >= 7){
				boldAlert("The Admiral looks at the top 3 New Caprica Crisis cards, and may place them on the top or bottom of the deck in any order.");
				if(z.hasOwnProperty("oldCrisisDiscards")){
					let temp = z.oldCrisisDiscards;
					z.oldCrisisDiscards = z.crisisDiscards;
					z.crisisDiscards = temp;
					z.crisisDeck = [];
					for(let j = 173; !(j >= 203); j++) {
						if(!z.crisisDiscards.includes(j)){
							z.crisisDeck.push(j);
						}
					}
				} else {
					z.oldCrisisDiscards = z.crisisDiscards;
					z.crisisDiscards = [];
					z.crisisDeck = [];
					for(let j = 173; !(j >= 203); j++) {
						z.crisisDeck.push(j);
					}
				}
				shuffle(z.crisisDeck);
			} else {
				boldAlert("The Admiral looks at the top 3 Crisis cards, and may place them on the top or bottom of the deck in any order.");
			}
			z.scoutingCrisis = true; /* TODO: what if the crisis deck depletes? */
			z.scouted.push(z.crisisDeck.pop());
			z.scouted.push(z.crisisDeck.pop());
			z.scouted.push(z.crisisDeck.pop());
			if(me === z.admiral) {
				addAlert("You draw:\n" + d.crisisNames[z.scouted[0]] + "\n" + d.crisisNames[z.scouted[1]] + "\n" + d.crisisNames[z.scouted[2]]);
			}
			input = true;
	}
	
	if(!input && hasContext(0,"Execute a player","Lured into a Trap")){
		input = false;
		plainAlert("You should now resolve the executions from Lured into a Trap.");
	}
	if(!input && !z.sleeper && z.distance >= 4) {
		sleeper();
	}
	if(!input && z.distance >= 6 && Array.isArray(z.personalGoalsBrutality)){
		brutalityPersonalGoalsResolution();
	}
	let displayed = false;
	if(!input && ((z.destination === "Ionian Nebula" && z.distance >= 8) || (z.destination === "Ionian Earth" && z.distance >= 10)) && !z.ionianBattle) {
		setupIN();
		displayed = true;
	}
	if(!input && z.destination === "New Caprica" && z.distance >= 7) {
		setupNC();
		displayed = true;
	}
	if(!input && z.vSoloCylonBrutality && ((z.destination === "Earth" && z.distance >= 10) || (z.destination === "Kobol" && z.distance >= 8))) {
		brutalityCylonCheck();
	}
	if(!input && z.v20 && ((z.destination === "Earth" && z.distance >= 10) || (z.destination === "Kobol" && z.distance >= 8))){
		v20Check();
	}
	if(!displayed){
		textGameState(true);
	}
}

function clearSkillCheck() {
	if(z.installUpgrades) {
		let outcome = skillCheckTally(true)[1];
		if(outcome === "FAIL" || outcome === "PREVENTED FAIL") {
			t.value += z.players[z.turn] + " gets 1 " + colorText("blue", "Engineering") + " from " + colorText("blue", "Install Upgrades") + ":\r\n";
			let card = dealSkillCard(z.turn, 4);
			if(z.turn === me) {
				addAlert("You received " + cardText(card) + " from Install Upgrades");
			} else {
				addAlert(z.players[z.turn] + " gets 1 Engineering from Install Upgrades.");
			}
		} else if(outcome === "PASS") {
			t.value += z.players[z.turn] + " gets 2 " + colorText("blue", "Engineering") + " from " + colorText("blue", "Install Upgrades") + ".\r\n";
			let card = dealSkillCard(z.turn, 4);
			let card2 = dealSkillCard(z.turn, 4);
			if(z.turn === me) {
				addAlert("You received " + cardText(card) + " and " + cardText(card2) + " from Install Upgrades");
			} else {
				addAlert(z.players[z.turn] + " gets 2 Engineering from Install Upgrades.");
			}
		} else {
			t.value += colorText("blue", "Install Upgrades") + " has no effect on a Partial.\r\n";
			addAlert("Install Upgrades has no effect on a Partial.");
		}
	}
	while(z.revealedCards.length > 0) {
		let card = z.revealedCards.pop();
		z.skillCardDiscards[cardColorID(card)].push(card);
	}
	removeFromAll("[Command Authority] Take a card from the skill check");
	refreshSkillDecks();
	if(z.criticalMission) {
		z.criticalMission = false;
	}
	if(z.hasOwnProperty("trialWithoutProcess")){
		z.trialWithoutProcess = undefined;
	}
	delete z.cylonHatred;
	z.currentSkillCheck = null;
	z.thisDifficulty = null;
	z.thisPartial = null;
	z.thisConsequence = null;
	z.thisPolitics = null;
	z.thisLeadership = null;
	z.thisTactics = null;
	z.thisPiloting = null;
	z.thisEngineering = null;
	z.thisTreachery = null;
	z.thisTarget = null;
	z.investigativeCommittee = false;
	z.restoreOrder = false;
	z.reckless = false;
	z.secondChance = false;
	z.guts = false;
	z.juryRigged = false;
	z.supportThePeople = false;
	z.vanity = false;
	z.skillCheckRevealed = false;
	z.redTape = false;
	z.ironWill = false;
	z.trustInstincts = false;
	z.protectTheFleet = false;
	z.establishNetwork = false;
	z.forceTheirHand = false;
	z.allHandsOnDeck = false;
	z.quickThinking = false;
	z.dogfight = false;
	z.installUpgrades = false;
	z.broadcastLocation = false;
	z.byYourCommand = false;
	z.specialDestiny = false;
	z.bait = false;
	z.dradisContact = false;
	z.personalVices = false;
	z.aBetterMachine = false;
	z.violentOutbursts = false;
	z.exploitWeakness = false;
	z.blindDevotion = -1;
	z.changeOfPlans = false;
	z.processedOutcome = false;
	z.quickFix = false;
	z.des = [];
	z.deToken = false;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.tank[j] = false;
		z.des[j] = null;
	}
	z.interrupts = blankArrays(z.numPlayers);
	z.contributingPlayer = 0;
	z.revealedCards = [];
	z.contributionLabels = [];
	for(let i = 0; !(i >= z.numPlayers); i++) {
		z.contributionLabels.push("");
	}
	z.blindDevotionPause = false;
	z.humanDelusionPause = false;
	z.commandAuthorityPause = false;
	z.changeOfPlansPause = false;
	z.probationPause = false;
	if(arguments.length === 0 && z.currentCrisis !== null) {
		/* TODO: Issues if AVP -> AQ and the like */
		primeCylonActivation();
		z.finishedCrisis = true;
	}
}

function jumpTrackName() {
	switch (z.jumpTrack) {
		case 0:
			return "Start";
		case 1:
			return colorText("red", "Red 1");
		case 2:
			return colorText("red", "Red 2");
		case 3:
			return colorText("blue", "Blue -3");
		case 4:
			return colorText("blue", "Blue -1");
		case 5:
			return "Auto Jump";
		default:
			return z.jumpTrack;
	}
}

function interruptChoices() {
	let player = me;
	if(arguments.length > 0) {
		player = arguments[0];
	}
	let interrupts = [];
	if(z.revealedCylons[player] === 1) {
		return interrupts;
	}
	for(let i = 0; !(i >= z.skillCardHands[player].length); i++) {
		let card = z.skillCardHands[player][i ];
		let name = cardName(card);
		if(name === "Scientific Research" || name === "Investigative Committee" || name === "Support the People" || name === "At Any Cost" || name ===
			"Guts and Initiative" || name === "Jury Rigged" || name === "Restore Order" || name === "A Second Chance") {
			interrupts.push(card);
		} /* RULES: Political Prowess timing, etc. */
		if(name === "Political Prowess" && !Number.isInteger(z.currentSkillCheck) && (z.interrupts[player].length === 0 || z.interrupts[player][0].slice(0, 4)
				.toLowerCase() === "pass")) {
			interrupts.push(card);
		}
	}
	if(((z.players[player] === "Shaw" && z.miracles[player] === 1 && !versionAtLeast([2,1,14])) || (z.assist === "Shaw" && z.assistMiracle === 1 && !versionAtLeast([2,1,14])) || (z.players[player] === "Gaius" &&
			actsOfFaith("Shaw") && !versionAtLeast([2,1,14]))) && Number.isInteger(z.currentSkillCheck) && (!(z.currentSkillCheck >= 160) || z.currentSkillCheck >= 173) && !z.theFarm) {
		interrupts.push("Critical Mission");
	}
	if(((z.players[player] === "Starbuck" && z.miracles[player] === 1) || (z.assist === "Starbuck" && z.assistMiracle === 1) || (z.players[player] ===
			"Gaius" && actsOfFaith("Starbuck"))) && Number.isInteger(z.currentSkillCheck) && (!(z.currentSkillCheck >= 160) || z.currentSkillCheck >= 173) && d
		.currentPlayerChooses[z.currentSkillCheck] === 0 && (z.interrupts[player].length === 0 || z.interrupts[player][0].slice(0, 4).toLowerCase() ===
		"pass") && !z.theFarm) {
		interrupts.push("Secret Destiny");
	} else if(((z.players[player] === "Helo" && z.miracles[player] === 1) || (z.assist === "Helo" && z.assistMiracle === 1) || (z.players[player] === "Gaius" &&
			actsOfFaith("Helo"))) && Number.isInteger(z.currentSkillCheck) && (!(z.currentSkillCheck >= 160) || z.currentSkillCheck >= 173) && d
		.currentPlayerChooses[z.currentSkillCheck] === 1 && (z.interrupts[player].length === 0 || z.interrupts[player][0].slice(0, 4).toLowerCase() ===
		"pass") && !z.theFarm) {
		interrupts.push("Moral Compass");
	} else if(((z.players[player] === "Boomer" && z.miracles[player] === 1) || (z.assist === "Boomer" && z.assistMiracle === 1) || (z.players[player] ===
			"Gaius" && actsOfFaith("Boomer"))) && Number.isInteger(z.currentSkillCheck) && (!(z.currentSkillCheck >= 160) || z.currentSkillCheck >= 173) && !z
		.theFarm && !z.criticalMission) {
		interrupts.push("Mysterious Intuition (Pass)");
		interrupts.push("Mysterious Intuition (Fail)");
	} else if(((z.players[player] === "Dee" && z.miracles[player] === 1) || (z.assist === "Dee" && z.assistMiracle === 1) || (z.players[player] === "Gaius" &&
			actsOfFaith("Dee"))) && (!Number.isInteger(z.currentSkillCheck) || (!(z.currentSkillCheck >= 160) || z.currentSkillCheck >= 173)) && !z.theFarm) {
		interrupts.push("Fast Learner");
	}
	if(z.players[player] === "Zarek" && !z.vBrutality && ((z.currentSkillCheck === "Brig" && !isOnNewCaprica(player)) || (z.currentSkillCheck === "Detention" &&
			isOnNewCaprica(player)) || z.currentSkillCheck === "Administration")) {
		interrupts.push("Friends in Low Places (increase difficulty by 2)");
		interrupts.push("Friends in Low Places (decrease difficulty by 2)");
	} else if(z.players[player] === "Tigh" && !z.cylonHatred && (z.currentSkillCheck === "Admiral's Quarters" || (z.currentSkillCheck === "Airlock" && z.vBrutality))) {
		interrupts.push("Cylon Hatred");
	}
	for(let i = 0; !(i >= z.quorumTitles[player].length); i++) {
		let title = z.quorumTitles[player][i ];
		if(title === 17 && !z.thisPolitics) {
			/* RULES: play Chief of Staff if politics positive? */
			interrupts.push("Chief of Staff");
		} else if(title === 3 && (z.currentSkillCheck === "Admiral's Quarters" || (z.vBrutality && z.currentSkillCheck === "Airlock"))) {
			interrupts.push("Arbitrator (increase difficulty by 3)");
			interrupts.push("Arbitrator (decrease difficulty by 3)");
		}
	}
	return interrupts;
} 
function shortWarning(type) {
	plainAlert("There are not enough " + type + " to deploy; " + z.players[z.turn] + ", as current player, must choose where they go.");
}

function noWarning(type) {
	plainAlert("All " + type + " are already on the game board; none placed.");
}

function warning(type, context) {
	let reserves = 0;
	switch (type) {
		case "Basestars":
			reserves = basestarsAway();
			if(reserves > 0) {
				shortWarning(type);
				addOption(z.turn, "Place a basestar on the main game board", context, true);
			}
			break;
		case "Raiders":
			reserves = raidersAway();
			if(reserves > 0) {
				shortWarning(type);
				addOption(z.turn, "Place Raider(s) on the main game board", context, true);
			}
			break;
		case "Heavy Raiders":
			reserves = heaviesAway();
			if(reserves > 0) {
				shortWarning(type);
				addOption(z.turn, "Place a Heavy Raider on the main game board", context, true);
			}
			break;
		case "Civilians":
			reserves = z.civilianPile.length;
			if(reserves > 0) {
				shortWarning(type);
				addOption(z.turn, "Place a Civilian on the board", context, true);
			}
			break;
		case "Vipers":
			reserves = vipersIIReserves();
			if(reserves > 0) {
				shortWarning(type);
				addOption(z.turn, "Place a Viper Mk II in space", context, true);
				if(assaultRaptorsReserves() > 0) {
					addOption(z.turn, "Place an Assault Raptor in space", context, true);
				}
			} else if(assaultRaptorsReserves() > 0) {
				let total = 0;
				for(let j = 0; !(j >= context.length); j++) {
					total += context[j];
				}
				if(total > assaultRaptorsReserves()) {
					shortWarning(type);
					addOption(z.turn, "Place an Assault Raptor in space", context, true);
				} else {
					for(let j = 0; !(j >= context.length); j++) {
						for(let k = 0; !(k >= context[j]); k++) {
							for(let l = 0; !(l >= z.assaultRaptors.length); l++) {
								if(z.assaultRaptors[l] === 0) {
									z.assaultRaptors[l] = j;
									if(canAVP()) {
										z.avp.push(12 + l);
									}
									break;
								}
							}
						}
					}
					plainAlert("No Vipers Mk II left in the reserves; Assault Raptors were placed instead.");
				}
				return;
			}
			break;
	}
	if(reserves === 0) {
		noWarning(type);
	}
}

function increaseJump() {
	if(z.toDoJumpIcon && !z.capricaCrisis && z.turn === z.theMutineer && (z.jumpTrack !== 4 || z.galacticaAway)) {
		addAlert("The Mutineer draws a Mutiny card.");
		t.value += bold("The Mutineer automatically draws a Mutiny card.") + "\r\n";
		dealMutiny(z.theMutineer, false);
	}
	let boomer = z.toDoJumpIcon && z.players[z.turn] === "Boomer" && characterPresent("Boomer") && !z.capricaCrisis;
	z.toDoJumpIcon = false;
	if(z.galacticaReturned) {
		plainAlert("Galactica has returned; the Jump Preparation Track is no longer in play.");
		if(boomer){
			plainAlert("Boomer may now use her Recon ability.");
		}
		return;
	}
	z.jumpTrack++;
	boldAlert("Jump Prep advances to " + jumpTrackName() + ".");
	if(z.jumpTrack === 5 && z.galacticaAway) {  
		if(z.brutalityPenalty) {
			boldAlert("The Cylons aren't done with their experiment yet; Jump Prep reset to Start.");
			z.jumpTrack = 0;
			z.brutalityPenalty = false;
			if(boomer){
				plainAlert("Boomer may now use her Recon ability.");
			}
			return;
		}
		let done = true;
		z.galacticaAway = false;
		z.galacticaReturned = true;
		addAlert("Galactica Returns!");
		t.value += bold("Galactica Returns!") + "\r\n\r\n";
		if(basestarsAway() === 2) {
			placeBasestar(2);
			placeBasestar(3);
		} else if(basestarsAway() === 1) {
			plainAlert("There is only 1 Basestar left to place.\n\n" + z.players[z.turn] + ", as current player, must place it in Sector 2 or Sector 3.");
			addOption(z.turn, "Place a basestar on the main game board", [0, 1, 1, 0, 0, 0], true);
			done = false;
		} else if(basestarsAway() === 0) {
			addAlert("No Basestars are placed.");
			t.value += "Both Basestars are already on the main game board; none are placed.\r\n";
		}
		if(raidersAway() >= 8) {
			placeRaiders(2, 4);
			placeRaiders(3, 4);
		} else if(raidersAway() === 0) {
			addAlert("No Raiders are placed.");
			t.value += "All Raiders are already on the main game board; none are placed.\r\n";
		} else {
			addAlert("There are not enough Raiders to place; " + z.players[z.turn] + ", as current player, must place as many Raiders as possible.");
			t.value += "There are not enough Raiders to place. " + z.players[z.turn] +
				", as current player, must place as many Raiders as possible in Sectors 2 and 3 (no more than 4 per sector).\r\n";
			addOption(z.turn, "Place Raider(s) on the main game board", [0, 4, 4, 0, 0, 0], true);
			done = false;
		}
		if(vipersIIReserves() >= 4 && (!z.CFB || vipersVIIReserves() === 0) && (!z.daybreak || assaultRaptorsReserves() === 0)) {
			placeVipers(5, 2);
			placeVipers(6, 2);
		} else {
			boldAlert(z.players[z.turn] + ", as current player, must launch 2 Vipers in Sector 5 and 2 Vipers in Sector 6, as able.");
			if(vipersIIReserves() > 0) {
				addOption(z.turn, "Launch a Viper Mk II in Sector 5", 2, true);
				addOption(z.turn, "Launch a Viper Mk II in Sector 6", 2, true);
			}
			if(vipersVIIReserves() > 0) {
				addOption(z.turn, "Launch a Viper Mk VII in Sector 5", 2, true);
				addOption(z.turn, "Launch a Viper Mk VII in Sector 6", 2, true);
			}
			if(assaultRaptorsReserves() > 0) {
				addOption(z.turn, "Launch an Assault Raptor in Sector 5", 2, true);
				addOption(z.turn, "Launch an Assault Raptor in Sector 6", 2, true);
			}
			done = false;
		}
		textGameState(true);
		if(done && boomer){
			plainAlert("Boomer may now use her Recon ability.");
		}
	} else if(z.jumpTrack === 5) {
		/* TODO: what if you somehow jump twice in the same turn? */
		z.FTLOperator = true;
		t.value += "[ima" + bl + "geid=606444 medium]\r\n\r\n";
		boldAlert("The Fleet jumps!");
		if(((z.destination === "Kobol" || (z.destination === "Ionian Nebula" && !z.preCrossroads)) && 11 >= z.distance && z.distance >= 8) || ((z
				.destination === "Earth" || (z.destination === "Ionian Earth" && !z.preCrossroads)) && 15 >= z.distance && z.distance >= 10)) {
			if(z.brutalityPenalty) {
				z.jumpTrack = 0;
				boldAlert("The Cylons aren't done with you yet...Jump Prep reset to Start.");
				z.brutalityPenalty = false;
				if(boomer){
					plainAlert("Boomer may now use her Recon ability.");
				}
			} else {
				if(z.destination === "Ionian Nebula"){
					boldAlert("The fleet escapes the Ionian Nebula...");
				} else if(z.destination === "Ionian Earth"){
					boldAlert("The fleet escapes the Ionian Nebula and reaches Earth...");
				} else {
					boldAlert("The fleet reaches " + z.destination + "...");
				}
				endGame(true);
			}
		} else {
			if(z.thirtyThree && !z.vBrutality) {
				z.crisisDeck.push(59);
				shuffle(z.crisisDeck);
				t.value += "Relentless Pursuit triggered; Thirty-Three reshuffled into Crisis deck.\r\n";
				addAlert("Relentless Pursuit triggered.");
				z.thirtyThree = false;
			}
			if(z.ambush) {
				z.ambush = false;
				t.value += "Training New Pilots [Ambush] cancelled.\r\n";
				z.crisisDiscards.push(2);
			}
			if(z.cylonSwarm) {
				t.value += "Massive Deployment [Cylon Swarm] cancelled.\r\n";
				z.cylonSwarm = false;
				z.crisisDiscards.push(13);
			}
			if(z.jammedAssault) {
				t.value += "Communications Jamming [Jammed Assault] cancelled.\r\n";
				z.jammedAssault = false;
				z.crisisDiscards.push(29);
			}
			if(z.dogfightCAC) {
				t.value += "Constant Barrage (from the Dogfight Cylon Attack Card) cancelled.\r\n";
				z.dogfightCAC = false;
				z.crisisDiscards.push(76);
			}
			if(z.scarCAC) {
				t.value += "You escape Scar (for now...)\r\n";
				z.scar = -1;
				z.raiders.push(0);
				z.scarCAC = false;
				z.crisisDiscards.push(83);
			}
			if(z.theGuardians) {
				t.value += "Raptor Crew Captured [The Guardians] cancelled.\r\n";
				z.theGuardians = false;
				z.crisisDiscards.push(87);
			}
			if(z.eventHorizon) {
				z.eventHorizon = false;
				t.value += "Gravity Well [Event Horizon] cancelled.\r\n";
				z.crisisDiscards.push(140);
			}
			if(z.hornetsNest) {
				z.hornetsNest = false;
				t.value += "Suppressive Fire [Hornet's Nest] cancelled.\r\n";
				z.crisisDiscards.push(143);
			}
			if(z.lockdown) {
				z.lockdown = false;
				t.value += "Concerted Attack [Lockdown] cancelled.\r\n";
				z.crisisDiscards.push(147);
			}
			if(z.luredIntoATrap) {
				z.luredIntoATrap = false;
				let deadMenWalking = [];
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.playerLocations[k] === "FTL Control" || z.playerLocations[k] === "Engine Room") {
						deadMenWalking.push(z.players[k]);
					}
				}
				z.superCrisisDiscards.push(167);
				if(deadMenWalking.length === 0) {
					t.value += "Dangerous Repairs are Necessary [Lured into a Trap] cancelled.\r\n";
				} else {
					let alertText = "The following individuals must be executed due to Lured into a Trap, once the jump completely resolves:";
					t.value += "Dangerous Repairs were Necessary, after we were " + colorText("red", "Lured into a Trap") + ".\r\n";
					t.value += "The following characters were mortally wounded in their efforts, and their sacrifice will be remembered:\r\n";
					for(let j = 0; !(j >= deadMenWalking.length); j++) {
						t.value += bold(deadMenWalking[j]) + "\r\n";
						alertText += "\n\n" + deadMenWalking[j];
					} /* TODO: make this better */
					addAlert(alertText);
					optionForAll("Execute a player", "Lured into a Trap", false);
					boldAlert("Once the jump and Destination resolve, execute those players.  If the jump takes you to Sleeper, New Caprica, or Crossroads, execute the players before beginning the new phase.");
				}
			}
			if(!z.CFB) {
				if(z.thirtyThree) {
					plainAlert("Relentless Pursuit triggered; Basestars and Civilian ships are not removed from the game board.");
					plainAlert("All Cylon Raiders and Heavy Raiders and all Mk II Vipers are removed from the game board.");
				} else {
					plainAlert("All Cylon ships, civilians, and Mk II Vipers on the game board are returned to the Reserves.");
				}
				for(let i = 0; !(i >= z.raiders.length); i++) {
					z.raiders[i ] = 0;
				}
				if(Number.isInteger(z.heavyCasualties)){
					z.heavyCasualties = 0;
				}
				for(let i = 0; !(i >= z.heavies.length); i++) {
					z.heavies[i ] = 0;
				}
				for(let i = 0; !(i >= z.basestars.length) && !z.thirtyThree; i++) {
					z.basestars[i ] = [0];
				}
				for(let i = 0; !(i >= z.vipersII.length); i++) {
					if(!Number.isInteger(z.vipersII[i ])) {
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.players[j] === z.vipersII[i ]) {
								z.vipersII[i ] = 0;
								plainAlert(z.players[j] + " lands on the Hangar Deck.");
								movePlayer(j, "Hangar Deck");
							}
						}
					} else if(z.vipersII[i ] > 0) {
						z.vipersII[i ] = 0;
					}
				}
				if(!z.thirtyThree) {
					clearCivilians();
					z.reshuffledSeen = false;
				}
			} else {
				plainAlert("All Mk II and Mk VII Vipers in space are returned to the Reserves; all Cylon ships are sent to the Cylon Fleet Board.");
				for(let i = 0; !(i >= z.raiders.length); i++) {
					if(z.raiders[i ] > 0) {
						z.raiders[i ] *= -1;
					}
				}
				for(let i = 0; !(i >= z.heavies.length); i++) {
					if(z.heavies[i ] > 0) {
						z.heavies[i ] *= -1;
					}
				}
				for(let i = 0; !(i >= z.basestars.length); i++) {
					if(z.basestars[i ][0] > 0) {
						z.basestars[i ][0] *= -1;
					}
					while(z.basestars[i ].length > 1) {
						z.basestarDamage.push(z.basestars[i ].pop());
					}
				}
				for(let i = 0; !(i >= z.vipersII.length); i++) {
					if(!Number.isInteger(z.vipersII[i ])) {
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.players[j] === z.vipersII[i ]) {
								z.vipersII[i ] = 0;
								plainAlert(z.players[j] + " lands on the Hangar Deck.");
								movePlayer(j, "Hangar Deck");
							}
						}
					} else if(z.vipersII[i ] > 0) {
						z.vipersII[i ] = 0;
					}
				}
				for(let i = 0; !(i >= z.vipersVII.length); i++) {
					if(!Number.isInteger(z.vipersVII[i ])) {
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.players[j] === z.vipersVII[i ]) {
								z.vipersVII[i ] = 0;
								plainAlert(z.players[j] + " lands on the Hangar Deck.");
								movePlayer(j, "Hangar Deck");
							}
						}
					} else if(z.vipersVII[i ] > 0) {
						z.vipersVII[i ] = 0;
					}
				}
			}
			if((z.destination === "Earth" || z.destination === "Ionian Earth") && z.activeMission !== null) {
				if(z.activeMission === 206) {
					if(z.destinationDiscards.length === 0 || (z.destinationDiscards[z.destinationDiscards.length - 1] !== 35 && !(z.destinationDiscards.length >
							1 && z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z.destinationDiscards[z.destinationDiscards.length -
							2] === 35))) {
						z.missionDeck.push(z.activeMission);
						shuffle(z.missionDeck);
						plainAlert("Digging up the Past is reshuffled into the Mission Deck.");
					}
				} else if(z.activeMission === 210) {
					if(z.destinationDiscards.length === 0 || (z.destinationDiscards[z.destinationDiscards.length - 1] !== 36 && !(z.destinationDiscards.length >
							1 && z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z.destinationDiscards[z.destinationDiscards.length -
							2] === 36))) {
						z.missionDeck.push(z.activeMission);
						shuffle(z.missionDeck);
						plainAlert("The Search for Home is reshuffled into the Mission Deck.");
					}
				} else {
					z.missionDiscards.push(z.activeMission);
					if(z.missionDeck.length === 0) {
						z.missionDeck = shuffle(z.missionDiscards);
						z.missionDiscards = [];
					}
				}
				z.activeMission = null;
			}
			let ARflag1 = false;
			let ARflag2 = false;
			if(z.daybreak) {
				for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
					if(!Number.isInteger(z.assaultRaptors[j])) {
						boldAlert(z.assaultRaptors[j] + " must decide whether they are staying in space or landing on the Hangar Deck.");
						addOption(getPlayerNum(z.assaultRaptors[j]), "Stay in space", true);
						addOption(getPlayerNum(z.assaultRaptors[j]), "Land on the Hangar Deck", true);
						ARflag1 = true;
					} else if(z.assaultRaptors[j] > 0 && !ARflag2) {
						ARflag2 = true;
						boldAlert(z.players[z.turn] +
							", as current player, must, for each Assault Raptor in space, either recall it to the Reserves, or announce in thread that it is staying there."
							);
						addOption(z.turn, "Recall an unmanned Viper", undefined, false);
					}
				}
			}
			let preText = "";
			if(ARflag1 || ARflag2) {
				preText += "After the Assault Raptors are dealt with, ";
			}
			let mS = missionSpecialist();
			if(z.blindJump) {
				addAlert("Admiral " + z.players[z.admiral] + " must now reveal the top Destination for this Blind Jump.");
				t.value += preText + colorText("green", "Admiral ") + z.players[z.admiral] + " must now reveal the top Destination for this Blind Jump.\r\n";
			} else if(mS === "NONE") {
				addAlert("Admiral " + z.players[z.admiral] + " must now pick a Destination.");
				t.value += preText + colorText("green", "Admiral ") + z.players[z.admiral] + " must pick a Destination.\r\n";
			} else {
				addAlert("Mission Specialist " + mS + " must now pick a Destination.");
				t.value += preText + colorText("orange", "Mission Specialist ") + mS + " must pick a Destination.\r\n";
			}
		}
	} else if(boomer){
		plainAlert("Boomer may now use her Recon ability.");
	}
}

function decreaseJump() {
	let alertText = "";
	if(z.galacticaReturned) {
		alertText = "Galactica has returned to orbit; the Jump Preparation Track is no longer in play.";
	} else if(z.jumpTrack === 0) {
		alertText = "Jump Prep is at Start and does not decrease further.";
	} else if(z.jumpTrack === 5) {
		alertText = "Jump Prep cannot be reduced at this time.";
	} else {
		z.jumpTrack--;
		alertText = "Jump Prep decreases to " + jumpTrackName() + ".";
	}
	plainAlert(alertText);
}

function setupCAC() {
	if(z.vBrutalityPlus){
		z.engineRoom = false;
	}
	z.toDoCACSetup = false;
	z.toDoCACSpecial = true;
	let shortVipers = false;
	let singleFine = false;
	let vipers = [];
	switch (d.crisisNames[z.currentCrisis]) {
		case "Ambush":
			placeBasestar(4);
			if(raidersAway() >= 8) {
				placeRaiders(1, 4);
				placeRaiders(4, 4);
			} else {
				warning("Raiders", [4, 0, 0, 4, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 2, 0];
			singleFine = placeVipers(5, 2, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(3);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 1, 0, 1, 1]);
			}
			break;
		case "Besieged": {
			placeBasestar(5);
			placeHeavy(4);
			let oldRaiders = 0;
			for(let j = 0; !(j>=z.raiders.length); j++){
				if(z.raiders[j] === 6){
					oldRaiders++;
				}
			}
			placeRaiders(6, 4);
			let newRaiders = 0;
			for(let j = 0; !(j>=z.raiders.length); j++){
				if(z.raiders[j] === 6){
					newRaiders++;
				}
			}
			z.heavyCasualties = newRaiders - oldRaiders;
			vipers = [0, 0, 0, 0, 0, 2];
			singleFine = placeVipers(6, 2, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(1);
				placeCivilian(2);
				placeCivilian(6);
			} else {
				warning("Civilians", [1, 1, 0, 0, 0, 1]);
			}
			break;
		}
		case "Boarding Parties":
			placeBasestar(2);
			if(heaviesAway() >= 4) {
				placeHeavies(1, 2);
				placeHeavies(3, 2);
			} else {
				warning("Heavy Raiders", [2, 0, 2, 0, 0, 0]);
			}
			placeRaiders(2, 4);
			if(z.civilianPile.length >= 3) {
				placeCivilian(4);
				placeCivilians(5, 2);
			} else {
				warning("Civilians", [0, 0, 0, 1, 2, 0]);
			}
			addAlert("No special for this CAC; you may now end turn if no more ships need to be placed.");
			t.value += "Surprise Assault: There are no Vipers in this setup.\r\n";
			z.toDoCACSpecial = false;
			z.finishedCrisis = true;
			break;
		case "Cylon Swarm":
			placeBasestar(1);
			placeHeavy(2);
			placeRaiders(1, 5);
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 3) {
				placeCivilian(4);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 0, 1, 1, 1]);
			}
			break;
		case "Heavy Assault":
			if(basestarsAway() >= 2) {
				placeBasestar(1);
				placeBasestar(2);
			} else {
				warning("Basestars", [1, 1, 0, 0, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 0, 1];
			singleFine = placeVipers(6, 1, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(4);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 0, 1, 1, 1]);
			}
			break;
		case "Jammed Assault":
			placeBasestar(3);
			placeHeavies(3, 2);
			placeRaiders(2, 4);
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 4) {
				placeCivilian(1);
				placeCivilian(4);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [1, 0, 0, 1, 1, 1]);
			}
			break;
		case "Raiding Party":
			placeBasestar(3);
			placeHeavies(4, 2);
			if(raidersAway() >= 5) {
				placeRaiders(3, 3);
				placeRaiders(4, 2);
			} else {
				warning("Raiders", [0, 0, 3, 2, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 0, 2];
			singleFine = placeVipers(6, 2, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(5);
				placeCivilians(6, 2);
			} else {
				warning("Civilians", [0, 0, 0, 0, 1, 2]);
			}
			break;
		case "Surrounded":
			placeBasestar(2);
			placeHeavy(3);
			if(raidersAway() >= 7) {
				placeRaiders(1, 4);
				placeRaiders(3, 3);
			} else {
				warning("Raiders", [4, 0, 3, 0, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 3) {
				placeCivilian(4);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 0, 1, 1, 1]);
			}
			break;
		case "Tactical Strike":
			placeBasestar(6);
			placeHeavy(1);
			placeRaiders(6, 5);
			vipers = [0, 0, 0, 0, 2, 0];
			singleFine = placeVipers(5, 2, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(3);
				placeCivilian(4);
				placeCivilian(5);
			} else {
				warning("Civilians", [0, 0, 1, 1, 1, 0]);
			}
			break;
		case "Thirty-Three":
			placeBasestar(1);
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 4) {
				placeCivilian(3);
				placeCivilian(4);
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 1, 1, 1, 1]);
			}
			break;
		case "Dogfight":
			placeBasestar(3);
			if(raidersAway() >= 4) {
				placeRaiders(3, 2);
				placeRaiders(4, 2);
			} else {
				warning("Raiders", [0, 0, 2, 2, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			placeCivilian(6);
			break;
		case "Scar": {
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			placeCivilians(4, 2); /* RULES: Apollo can't shoot down scar on a 3-6 on AVP, presumably */
			let foundScar = false;
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] === 0) {
					z.raiders.splice(j, 1);
					foundScar = true;
					break;
				}
			}
			if(foundScar) {
				addAlert("Scar placed in Sector 2.");
				z.scar = 2;
				z.scarCAC = true;
			} else {
				addAlert("Scar is not placed due to component limitations.");
				t.value += "All raiders are on the board already; Scar cannot be placed.\r\n";
			}
			z.toDoCACSpecial = false;
			z.finishedCrisis = true;
			break;
		}
		case "The Guardians":
			placeBasestar(1);
			placeHeavy(3);
			if(raidersAway() >= 4) {
				placeRaiders(2, 2);
				placeRaiders(6, 2);
			} else {
				warning("Raiders", [0, 2, 0, 0, 0, 2]);
			}
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			placeCivilian(4);
			break;
		case "Blindsided":
			if(basestarsAway() >= 2) {
				placeBasestar(1);
				placeBasestar(4);
			} else {
				warning("Basestars", [1, 0, 0, 1, 0, 0]);
			}
			if(heaviesAway() >= 2) {
				placeHeavy(1);
				placeHeavy(4);
			} else {
				warning("Heavy Raiders", [1, 0, 0, 1, 0, 0]);
			}
			placeRaiders(2, 3);
			vipers = [0, 0, 0, 0, 0, 1];
			singleFine = placeVipers(6, 1, true);
			if(z.civilianPile.length >= 3) {
				placeCivilian(5);
				placeCivilians(6, 2);
			} else {
				warning("Civilians", [0, 0, 0, 0, 1, 2]);
			}
			break;
		case "Event Horizon":
			if(basestarsAway() >= 2) {
				placeBasestar(2);
				placeBasestar(4);
			} else {
				warning("Basestars", [0, 1, 0, 1, 0, 0]);
			}
			if(raidersAway() >= 4) {
				placeRaiders(1, 2);
				placeRaiders(4, 2);
			} else {
				warning("Raiders", [2, 0, 0, 2, 0, 0]);
			}
			vipers = [1, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 3) {
				placeViper(1);
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			break;
		case "Hornet's Nest":
			placeBasestar(3);
			if(raidersAway() >= 6) {
				placeRaiders(1, 3);
				placeRaiders(4, 3);
			} else {
				warning("Raiders", [3, 0, 0, 3, 0, 0]);
			}
			vipers = [1, 0, 0, 0, 1, 0];
			if(vipersIIReserves() >= 2) {
				placeViper(1);
				placeViper(5);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 3) {
				placeCivilian(1);
				placeCivilians(6, 2);
			} else {
				warning("Civilians", [1, 0, 0, 0, 0, 2]);
			}
			break;
		case "Lockdown":
			placeBasestar(2);
			if(heaviesAway() >= 4) {
				placeHeavies(1, 2);
				placeHeavies(2, 2);
			} else {
				warning("Heavy Raiders", [2, 2, 0, 0, 0, 0]);
			}
			vipers = [0, 0, 0, 1, 0, 0];
			singleFine = placeVipers(4, 1, true);
			if(z.civilianPile.length >= 2) {
				placeCivilian(4);
				placeCivilian(5);
			} else {
				warning("Civilians", [0, 0, 0, 1, 1, 0]);
			}
			break;
		case "Reprisal":
			placeBasestar(6);
			placeHeavy(4);
			if(raidersAway() >= 5) {
				placeRaiders(1, 2);
				placeRaiders(4, 3);
			} else {
				warning("Raiders", [2, 0, 0, 3, 0, 0]);
			}
			vipers = [0, 1, 1, 0, 0, 0];
			if(vipersIIReserves() >= 2) {
				placeViper(2);
				placeViper(3);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 2) {
				placeCivilian(1);
				placeCivilian(5);
			} else {
				warning("Civilians", [1, 0, 0, 0, 1, 0]);
			}
			break;
		case "Trial by Fire":
			placeBasestar(4);
			placeHeavies(1, 2);
			placeRaiders(1, 3);
			vipers = [0, 1, 0, 0, 0, 0];
			singleFine = placeVipers(2, 1, true);
			placeCivilian(6);
			break;
		case "Massive Assault":
			if(basestarsAway() >= 2) {
				placeBasestar(2);
				placeBasestar(3);
			} else {
				warning("Basestars", [0, 1, 1, 0, 0, 0]);
			}
			placeHeavy(3);
			if(raidersAway() >= 6) {
				placeRaiders(2, 4);
				placeRaiders(3, 2);
			} else {
				warning("Raiders", [0, 4, 2, 0, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 4) {
				placeCivilians(5, 2);
				placeCivilians(6, 2);
			} else {
				warning("Civilians", [0, 0, 0, 0, 2, 2]);
			}
			break;
		case "Lured into a Trap":
			if(basestarsAway() >= 2) {
				placeBasestar(2);
				placeBasestar(3);
			} else {
				warning("Basestars", [0, 1, 1, 0, 0, 0]);
			}
			placeHeavy(4);
			if(raidersAway() >= 6) {
				placeRaiders(2, 3);
				placeRaiders(3, 3);
			} else {
				warning("Raiders", [0, 3, 3, 0, 0, 0]);
			}
			vipers = [0, 0, 0, 0, 1, 1];
			if(vipersIIReserves() >= 2) {
				placeViper(5);
				placeViper(6);
			} else {
				warning("Vipers", vipers);
				shortVipers = true;
			}
			if(z.civilianPile.length >= 2) {
				placeCivilian(5);
				placeCivilian(6);
			} else {
				warning("Civilians", [0, 0, 0, 0, 1, 1]);
			}
			break;
	}
	if(canAVP() && d.crisisNames[z.currentCrisis] !== "Boarding Parties") {
		plainAlert("Note that Apollo may have a chance to use Alert Viper Pilot here.");
		addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
	}
	if(z.daybreak && assaultRaptorsReserves() > 0 && vipers.length === 6 && !shortVipers && !singleFine) {
		addAlert("Note: only Mk II Vipers were placed automatically; Current Player may replace with Assault Raptors.");
		t.value += "Note: only Mk II Vipers were placed automatically. " + z.players[z.turn] +
			", as current player, may choose to swap out any placed Vipers Mk II for Assault Raptors.";
		addOption(z.turn, "Swap out a Viper Mk II for an Assault Raptor", vipers, false);
	}
	textGameState(true);
}

function shuffleTreachery() {
	let count = 0;
	for(let j = 0; !(j >= 2); j++) {
		let card = drawFromDeck(5);
		if(card !== undefined) {
			z.destiny.push(card);
			shuffle(z.destiny);
			count++;
		} else {
			t.value += "Attempted to shuffle a Treachery card into Destiny, but could not as that deck and its discards are depleted.\r\n";
			addAlert("Treachery deck and its discards completely depleted.");
		}
	}
	plainAlert("Shuffled " + count + " Treachery into Destiny.");
}

function dealMutiny(player, pressRoom) {
	if(z.revealedCylons[player] === 1) {
		addAlert("Cannot deal a Mutiny to a Cylon");
		return true;
	} else if(z.mutinies[player].length === 3 || (z.mutinies[player].length === 2 && player !== z.theMutineer)) {
		plainAlert(z.players[player] + " must discard a Mutiny before they can draw another one.");
		addOption(player, "Draw a Mutiny card", undefined, true);
		return false;
	} else {
		addAlert(z.players[player] + " gets a Mutiny.");
		let done = true;
		if(z.players[player] === "Lee" && !noDrawback(player) && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
			if(Array.isArray(z.allForLove) && z.allForLove[player]){
				/* This works because it's always a dradis/bait situation, so it can't trigger again.*/
				t.value += bold("Lee must discard 2 additional skill cards due to Moral Dilemma; he therefore discards his entire hand.");
				discardEntireHand(player,true);
			} else {
				t.value += bold("Lee must discard 2 skill cards due to Moral Dilemma.") + "\r\n";
				if(player === me) {
					if(characterPresent("Tom")) {
						addAlert("You must discard 2 skill cards due to Moral Dilemma; you may wait until after Tom resolves Necessary Steps if you like.");
					} else {
						addAlert("You must discard 2 skill cards due to Moral Dilemma.");
					}
				} else {
					addAlert("Lee must discard 2 skill cards due to Moral Dilemma.");
				}
				let context = getContext(player, "Discard a Skill Card"); /* TODO: do this throughout */
				if(Number.isInteger(context)) {
					addOption(player, "Discard a Skill Card", Math.min(context + 2, z.skillCardHands[player].length+1), true);
					done = false;
				} else if(z.skillCardHands[player].length === 0) {
					plainAlert("Lee has no skill cards to discard.");
				} else {
					if(z.forLove && z.forLoveCOs[player] === null && z.players[player] !== "Athena") {
						addOption(player, "Discard a Skill Card", 1, true);
						addOption(player, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
						plainAlert("Athena may be able to love him.");
					} else {
						addOption(player, "Discard a Skill Card", 2, true);
					}
					done = false;
				}
			}
		}
		t.value += bold(z.players[player] + " gets a Mutiny.") + "\r\n";
		if(z.playerLocations[player] !== "Stranded on Caprica" && (z.mutinies[player].length === 2 || (z.mutinies[player].length === 1 && player !== z
				.theMutineer))) {
			if(isOnNewCaprica(player)){
				if(z.playerLocations[player] !== "Detention") {
					movePlayer(player, "Detention");
					addAlert(z.players[player] + " is sent to Detention.");
				}
			} else if(z.playerLocations[player] !== "Brig" && !pressRoom) {
				movePlayer(player, "Brig");
				addAlert(z.players[player] + " is sent to the Brig.");
			}
		}
		if(characterPresent("Tom") && (!z.vBrutality || z.players[player] !== "Tom")) {
			z.necessarySteps.push(player);
			if(z.necessarySteps.length === 1) {
				for(let j = 0; !(j >= 2); j++) {
					let mut = z.mutinyDeck.pop();
					if(z.mutinyDeck.length === 0) {
						t.value += "Mutiny deck empty; reshuffling.\r\n";
						z.mutinyDeck = shuffle(z.mutinyDiscards);
						z.mutinyDiscards = [];
						z.buriedMutinies = 0;
					}
					z.necessarySteps.push(mut);
					if(pressRoom){
						z.pressRoomMutineer = true;
					}
					if(z.vBrutality) {
						break;
					}
				}
			}
			addAlert("Necessary Steps dispatched to Tom.");
			t.value += bold("Tom must now take Necessary Steps.") + "\r\n";
			return false;
		} else {
			let mut = z.mutinyDeck.pop();
			if(z.mutinyDeck.length === 0) {
				t.value += "Mutiny deck empty; reshuffling.\r\n";
				z.mutinyDeck = shuffle(z.mutinyDiscards);
				z.buriedMutinies = 0;
				z.mutinyDiscards = [];
			}
			z.mutinies[player].push(mut);
			if(player === me) {
				addAlert("You receive " + d.mutinyNames[mut] + ".");
			}
			if(z.mutinies[player].length === 3 || z.mutinies[player].length === 2) {
				if(z.mutinies[player].length === 3 && pressRoom) {
					addOption(player, "Discard a Mutiny card", "Press Room Mutineer", true);
					boldAlert(z.players[player] + " must now discard 2 Mutiny cards.");
				} else if (z.mutinies[player].length === 2 && pressRoom){
					addOption(player, "Discard a Mutiny card", "Press Room Mutineer", true);
					boldAlert(z.players[player] + " must now discard a Mutiny.");
				} else if(z.mutinies[player].length === 2 && player === z.theMutineer){
					return done;
				} else {
					boldAlert(z.players[player] + " must now discard a Mutiny.");
				}
				return false;
			}
			return done;
		}
	}
}

function discardCrisis() {
	let per = false;
	switch (d.crisisNames[z.currentCrisis]) {
		case "Ambush":
			per = z.ambush;
			break;
		case "Cylon Swarm":
			per = z.cylonSwarm;
			break;
		case "Jammed Assault":
			per = z.jammedAssault;
			break;
		case "Thirty-Three":
			per = z.thirtyThree;
			break;
		case "Dogfight":
			per = z.dogfightCAC;
			break;
		case "The Guardians":
			per = z.theGuardians;
			break;
		case "Event Horizon":
			per = z.eventHorizon;
			break;
		case "Hornet's Nest":
			per = z.hornetsNest;
			break;
		case "Lockdown":
			per = z.lockdown;
			break;
		case "Detector Sabotage":
			per = z.detectorSabotage;
			break;
		case "Legendary Discovery":
			per = z.destinationDiscards.includes(34);
			break;
	}
	if(!per) {
		if((z.galacticaAway || z.galacticaReturned) && 160 > z.currentCrisis){
			z.oldCrisisDiscards.push(z.currentCrisis);
		} else {
			z.crisisDiscards.push(z.currentCrisis);
		}
	}
	z.currentCrisis = null;
	z.crisisPlayer = null;
}

function specialCAC() {
	let s = "";
	let didIt = false;
	let done = true;
	z.toDoCACSpecial = false;
	z.finishedCrisis = true;
	switch (d.crisisNames[z.currentCrisis]) {
		case "Ambush":
			s = "Training New Pilots: Keep this card in play until the Fleet Jumps. Each Unmanned Viper suffers a -2 penalty to its attack rolls.";
			z.ambush = true;
			break;
		case "Besieged": {
			s = "Heavy Casualties: The 4 Raiders that were just setup are immediately activated.";
			if(z.heavyCasualties === 0){
				plainAlert(s);
				plainAlert("Those raiders were never set up or they have since been destroyed.");
				didIt = true;
			} else {
				let numActivating = 0;
				resetRaiderActivations();
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] !== 6) {
						z.raiderActivated[j] = 1;
					} else if(z.heavyCasualties > numActivating) {
						numActivating++;
					} else {
						z.raiderActivated[j] = 1;
					}
					z.activatingSector = 6;
					optionForAll("Resume Raider Activation");
					done = false;
				}
			}
			delete z.heavyCasualties;
			break;
		}
		case "Cylon Swarm":
			s =
			"Massive Deployment: Keep this card in play until the Fleet Jumps. Each time a Basestar launches Raiders or Heavy Raiders, it launches 1 additional ship of the same type.";
			z.cylonSwarm = true;
			break;
		case "Heavy Assault":
			s = "Heavy Bombardment: Each Basestar immediately attacks Galactica.";
			if(z.basestars.length > 0 && basestarsAway() !== z.basestars.length) {
				optionForAll("Activate Basestars");
				done = false;
			}
			break;
		case "Jammed Assault":
			s = 'Communications Jamming: Keep this card in play until the Fleet Jumps. Players may not activate the "Communications" location.';
			z.jammedAssault = true;
			break;
		case "Raiding Party":
			s = "FTL Failure: Move the Fleet token 1 space towards the start of the Jump Prep track.";
			plainAlert(s);
			decreaseJump();
			didIt = true;
			break;
		case "Surrounded":
			didIt = true;
			if(z.revealedCylons[z.turn] === 0) {
				plainAlert("Panic: The Current Player must discard 3 Skill Cards.");
				done = promptDiscards(z.turn,3);
			} else {
				s = "Panic: " + z.players[z.turn] + " is a Cylon; no effect.";
				plainAlert(s);
			}
			break;
		case "Tactical Strike":
			s = "Hangar Assault: Damage 2 Vipers in the reserves.";
			if(vipersIIReserves() >= 1 && (!z.daybreak || assaultRaptorsReserves() === 0)) {
				plainAlert(s);
				let count = 0;
				for(let j = 0; !(j >= z.vipersII.length) && !(count >= 2); j++) {
					if(z.vipersII[j] === 0) {
						z.vipersII[j] = -1;
						count++;
					}
				}
				let s2 = "Damaged 2 Vipers Mk II in the Reserves.";
				if(count === 1) {
					s2 = "Damaged 1 Viper Mk II in the Reserves.";
				}
				plainAlert(s2);
				didIt = true;
			} else {
				let count = vipersIIReserves() + assaultRaptorsReserves();
				if(count > 2) {
					count = 2;
				}
				if(count === 0) {
					plainAlert(s);
					plainAlert("There are no Vipers in the Reserves to damage.");
					didIt = true;
				} else {
					addOption(z.turn, "Damage a Viper", ["Tactical Strike", count], true);
					done = false;
				}
			}
			break;
		case "Thirty-Three":
			if(z.vBrutality) {
				s =
				"Relentless Pursuit: Keep in play until a Civilian ship or Basestar is destroyed. When the fleet jumps, do not remove basestars or civilian ships from the game board.";
			} else {
				s =
				"Relentless Pursuit: Keep in play until a Civilian ship or Basestar is destroyed. If this card is in play when the Fleet Jumps, shuffle it back into the Crisis deck.";
			}
			z.thirtyThree = true;
			break;
		case "Dogfight":
			s =
			"Constant Barrage: Keep this card in play until the Fleet Jumps or no Raiders remain on the board. Each time Raiders are activated, launch two Raiders from each Basestar (do not activate the new Raiders).";
			z.dogfightCAC = true;
			if(raidersAway() === z.raiders.length && !z.scarCAC) {
				plainAlert("Wow, Apollo is a beast! Constant Barrage never applies.");
				z.dogfightCAC = false;
				didIt = true;
			}
			break;
		case "The Guardians":
			s = "Raptor Crew Captured: Keep this card in play until the Fleet Jumps. When a Basestar is destroyed, lose 1 Morale and destroy 1 Raptor.";
			z.theGuardians = true;
			break;
		case "Blindsided":
			s = "Pluck Out Their Eyes: Destroy 1 Raptor.";
			plainAlert(s);
			destroyRaptor();
			didIt = true;
			break;
		case "Event Horizon":
			s = "Gravity Well: Keep this card in play until the fleet jumps.  No player can activate a viper unless they first discard a Skill Card.";
			z.eventHorizon = true;
			break;
		case "Hornet's Nest":
			s = "Suppressive Fire: Keep this card in play until the fleet jumps or a basestar is destroyed.  Players cannot use actions on Piloting Cards.";
			z.hornetsNest = true;
			break;
		case "Lockdown":
			s = "Concerted Attack: Keep this card in play until the fleet jumps or a Basestar is destroyed. Players cannot activate the Armory location.";
			z.lockdown = true;
			break;
		case "Reprisal":
			s = "Opportunity for Treason: Shuffle 2 Treachery Cards into the Destiny Deck.  Then the Current Player draws a Mutiny Card.";
			plainAlert(s);
			shuffleTreachery();
			done = dealMutiny(z.turn, false);
			didIt = true;
			break;
		case "Trial by Fire": {
			removeFromAll("Swap out a Viper Mk II for an Assault Raptor");
			s =
			"Cavalry's Here: The human fleet gains an Assault Raptor.  The current player places it in a space area with a viper launch icon and may immediately activate it.";
			plainAlert(s);
			let built = gainAR();
			didIt = true;
			if(built) {
				addOption(z.turn, "Launch an Assault Raptor in Sector 5", "Trial by Fire", true);
				addOption(z.turn, "Launch an Assault Raptor in Sector 6", "Trial by Fire", true);
				done = false;
			}
			break;
		}
		case "Massive Assault":
			if(z.vBrutality) {
				s = "Power Failure: Move the Fleet token 1 space towards the start of the Jump Preparation track.";
				plainAlert(s);
				decreaseJump();
			} else {
				s = "Power Failure: Move the Fleet token 2 spaces towards the start of the Jump Preparation track.";
				plainAlert(s);
				decreaseJump();
				decreaseJump();
			}
			didIt = true;
			z.superCrisisDiscards.push(164);
			break;
		case "Lured into a Trap":
			s =
			'Dangerous Repairs are Necessary: Keep this card in play until after the Fleet Jumps. Any character in either "Engine Room" or "FTL Control" when the fleet jumps is Executed.';
			z.luredIntoATrap = true;
			break;
	}
	if(!didIt) {
		plainAlert(s);
	}
	if(done && !z.capricaCrisis && characterPresent("Boomer") && z.players[z.turn] === "Boomer"){
		plainAlert("Boomer may now use her Recon ability.");
	}
}

function damagedVipersII() {
	let count = 0;
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === -1) {
			count++;
		}
	}
	return count;
}

function destroyedVipersII() {
	let count = 0;
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === -2) {
			count++;
		}
	}
	return count;
}

function damagedVipersVII() {
	let count = 0;
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === -1) {
			count++;
		}
	}
	return count;
}

function destroyedVipersVII() {
	let count = 0;
	for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === -2) {
			count++;
		}
	}
	return count;
}

function destroyedAssaultRaptors() {
	let count = 0;
	for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
		if(z.assaultRaptors[i ] === -2) {
			count++;
		}
	}
	return count;
}

function repairIID() {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === -2) {
			z.vipersII[i ] = 0;
			addAlert("Repaired a destroyed Viper Mk II");
			t.value += bold(myPlayer + " repaired a destroyed Viper Mk II.\r\n");
			break;
		}
	}
}

function repairVIID() {
	for(let i = 0; !(i >= z.vipersVII.length); i++) {
		if(z.vipersVII[i ] === -2) {
			z.vipersVII[i ] = 0;
			addAlert("Repaired a destroyed Viper Mk VII");
			t.value += bold(myPlayer + " repaired a destroyed Viper Mk VII.\r\n");
			break;
		}
	}
}

function repairAR() {
	for(let i = 0; !(i >= z.assaultRaptors.length); i++) {
		if(z.assaultRaptors[i ] === -2) {
			z.assaultRaptors[i ] = 0;
			addAlert("Repaired a destroyed Assault Raptor");
			t.value += bold(myPlayer + " repaired a destroyed Assault Raptor.\r\n");
			break;
		}
	}
}

function repairII() {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersII[i ] === -1) {
			z.vipersII[i ] = 0;
			addAlert("Repaired a Viper Mk II");
			t.value += bold(myPlayer + " repaired a Viper Mk II.\r\n");
			break;
		}
	}
}

function repairVII() {
	for(let i = 0; !(i >= z.vipersII.length); i++) {
		if(z.vipersVII[i ] === -1) {
			z.vipersVII[i ] = 0;
			addAlert("Repaired a Viper Mk VII");
			t.value += bold(myPlayer + " repaired a Viper Mk VII.\r\n");
			break;
		}
	}
}

function isLocationDamaged(loc) {
	for(let j = 0; !(j >= z.damagedLocations.length); j++) {
		if(z.damagedLocations[j] === loc) {
			return true;
		}
	}
	return false;
}

function availableCharacters() {
	let players = ["Adama", "Apollo", "Chief", "Helo", "Starbuck", "Tigh", "Zarek"];
	if(z.numPlayers + z.boxedPlayers.length !== 2) {
		players.push("Baltar");
	}
	if(z.numPlayers + z.boxedPlayers.length >= 2) {
		players.push("Roslin");
	}
	if(z.numPlayers + z.boxedPlayers.length >= 3) {
		players.push("Boomer");
	}
	if(!z.vAllCharacters) {
		if(z.pegasus) {
			if(!z.vNoCain && (!z.vBrutality || z.daybreak)) {
				players.push("Cain");
			}
			players = players.concat(["Dee", "Ellen", "Kat"]);
		}
		if(z.exodus) {
			players = players.concat(["Anders", "Cally"]);
			if(!z.vBrutality || z.daybreak) {
				players.push("Gaeta");
			}
			players.push("Tory");
		}
		if(z.daybreak) {
			players = players.concat(["Cottle", "Hoshi", "Hot Dog", "Romo", "Gaius", "Karl", "Lee", "Tom"]);
		}
	} else {
		players = players.concat(["Kat", "Anders"]);
		if(!z.vBrutality || z.daybreak) {
			players.push("Gaeta");
		}
		players = players.concat(["Tory", "Cottle", "Hoshi", "Hot Dog", "Romo", "Karl", "Racetrack", "Billy", "Seelix"]);
		if(!versionAtLeast([2,1,13]) || versionAtLeast([2,1,14])){
			players.push("Shaw");
		} else if (z.pegasus && z.daybreak){
			players.push("Shaw");
		}
		if(z.vBrutality && z.pegasus && z.daybreak) {
			players.push("Cain");
		}
		if(z.pegasus || z.exodus) {
			if(!z.vNoCain && !z.vBrutality) {
				players.push("Cain");
			}
			players = players.concat(["Dee", "Cally"]);
		}
		if(z.pegasus || z.daybreak) {
			players.push("Ellen");
		}
		if(z.daybreak) {
			players.push("Gaius");
		}
		if(z.daybreak || z.vBrutality || z.numPlayers + z.boxedPlayers.length === 1) {
			players.push("Lee");
		}
		if(z.daybreak) {
			players.push("Tom");
		}
	}
	let appeared = z.players.concat(z.graveyard);
	if(z.assist !== undefined) {
		appeared.push(z.assist);
	}
	for(let j = 0; !(j >= appeared.length); j++) {
		if(isCylonLeader(appeared[j])) {
			continue;
		}
		for(let k = 0; !(k >= players.length); k++) {
			if(appeared[j] === players[k]) {
				players.splice(k, 1);
				if(!z.daybreak || (appeared[j] !== "Apollo" && appeared[j] !== "Lee" && appeared[j] !== "Helo" && appeared[j] !== "Karl" && appeared[j] !==
						"Baltar" && appeared[j] !== "Gaius" && appeared[j] !== "Tom" && appeared[j] !== "Zarek")) {
					break;
				} else {
					k--;
				}
			}
			if(z.daybreak && ((appeared[j] === "Apollo" && players[k] === "Lee") || (appeared[j] === "Lee" && players[k] === "Apollo") || (appeared[j] ===
					"Helo" && players[k] === "Karl") || (appeared[j] === "Karl" && players[k] === "Helo") || (appeared[j] === "Baltar" && players[k] ===
					"Gaius") || (appeared[j] === "Gaius" && players[k] === "Baltar") || (appeared[j] === "Tom" && players[k] === "Zarek") || (appeared[
					j] === "Zarek" && players[k] === "Tom"))) {
				players.splice(k, 1);
			}
		}
	}
	return players;
}

function isFinalFive(loy) {
	return (loy >= 32 && 36 >= loy);
}

function canRevealStandAndFight() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 24) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 24){
		foundIt = true;
	}
	if(foundIt) {
		if(Array.isArray(z.personalGoalsBrutality)){
			return 6 >= z.population;
		} else {
			let raiderCount = 0;
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] > 0) {
					raiderCount++;
				}
			}
			return raiderCount >= 10;
		}
	}
	return false;
}

function canRevealSacrifice() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 25) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 25){
		foundIt = true;
	}
	if(foundIt) {
		let count = 0;
		for(let j = 0; !(j >= z.vipersII.length); j++) {
			if(Number.isInteger(z.vipersII[j]) && 0 > z.vipersII[j]) {
				count++;
			}
		}
		for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
			if(Number.isInteger(z.vipersVII[j]) && 0 > z.vipersVII[j]) {
				count++;
			}
		}
		for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] === -2) {
				count++;
			}
		}
		if(Array.isArray(z.personalGoalsBrutality)){
			count += (4 - z.raptors);
		}
		if(6 > count) {
			return false;
		}
	}
	return foundIt;
}

function canRevealDevastation() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 26) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 26){
		foundIt = true;
	}
	if(foundIt && Array.isArray(z.personalGoalsBrutality)){
		return 5 >= z.morale;
	}
	if(z.nukes > 0) {
		return false;
	}
	return foundIt;
}

function canRevealUseCaution() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 27) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 27){
		return true;
	}
	if(foundIt) {
		for(let j = 0; !(j >= z.destinationDiscards.length); j++) {
			if(z.destinationDiscards[j] !== 34 && z.destinationDiscards[j] !== 35 && getDistance(z.destinationDiscards[j]) === 1) {
				return true;
			}
		}
	}
	return false;
}

function canRevealAcquirePower() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 28) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 28){
		foundIt = true;
	}
	if(foundIt) {
		if(Array.isArray(z.personalGoalsBrutality)){
			return 4 >= z.food;
		} else {
			if(!z.CFB) {
				return me === z.president && me === z.admiral;
			} else {
				return ((me === z.president && me === z.admiral) || (me === z.cag && me === z.admiral) || (me === z.president && me === z.cag));
			}
		}
	}
	return false;
}

function canRevealPoliticalIntrigue() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 29) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 29){
		foundIt = true;
	}
	if(foundIt) {
		if(Array.isArray(z.personalGoalsBrutality)){
			return true;
		}
		return (!isOnNewCaprica(me) && z.playerLocations[z.president] === "Brig") || (isOnNewCaprica(me) && z.playerLocations[z.president] === "Detention");
	}
	return false;
}

function canRevealSelfish() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 30) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 30){
		foundIt = true;
	}
	if(foundIt){
		if(Array.isArray(z.personalGoalsBrutality)){
			if(z.pegasusDestroyed){
				return true;
			}
			let damageCount = 0;
			for(let j = 0; !(j >= z.damagedLocations.length); j++) {
				if(onGalactica(z.damagedLocations[j]) || onPegasus(z.damagedLocations[j])) {
					damageCount++;
				}
			}
			return damageCount >= 5;
		} else {
			let total = 0;
			for(let j = 0; !(j>=z.skillCardHands[me].length); j++){
				total += cardValue(z.skillCardHands[me][j]);
			}
			return total >= 20;
		}
	}
	
	return false;
}

function canRevealSelfDestruction() {
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = false;
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		if(z.loyaltyHands[me][j] === 31) {
			foundIt = true;
			break;
		}
	}
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 31){
		foundIt = true;
	}
	if(foundIt) {
		if(Array.isArray(z.personalGoalsBrutality)){
			/* Personal Goals can't be on New Caprica in this variant */
			for(let j = 0; !(j>=z.numPlayers); j++){
				if(z.playerLocations[j] === "Brig"){
					return true;
				}
			}
			return false;
		} else {
			return (z.playerLocations[me] === "Brig" || z.playerLocations[me] === "Sickbay" || z.playerLocations[me] === "Detention" || z.playerLocations[me] ===
				"Medical Center");
		}
	}
	return false;
}

function canRevealInfiltration(){
	if(!z.personalGoals) {
		return false;
	}
	let foundIt = true;
	if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[me] === 67){
		foundIt = true;
	}
	if(foundIt){
		for(let j = 0; !(j>=z.centurions.length); j++){
			if(z.centurions[j] >= 2){
				return true;
			}
		}
	}
	return false;
}

function promptAllyDiscards(player, num, noAuto) {
	if(z.skillCardHands[player].length === 0) {
		plainAlert(z.players[player] + " has no skill cards; no effect.");
		if(z.forLove && z.players[player] !== "Athena"){
			plainAlert("Athena may still be able to use For Love to draw a Treachery.");
			z.selfishLove = true;
		}
		return true;
	} else if(z.players[player] === "Apollo" && !noDrawback(player)) {
		if(!z.forLove && !noAuto) {
			for(let j = 0; !(j >= num) && z.skillCardHands[player].length > 0; j++) {
				discardRandomSkillCard(player);
			}
			return true;
		} else if(z.forLove){
			plainAlert("Apollo must randomly discard " + num + " skill cards; but Athena can Love them.");
			if(num > 1) {
				addOption(player, "Discard a random Skill Card", num - 1, true);
			}
			z.randomLove[player] = true;
			return false;
		} else {
			plainAlert("Apollo must randomly discard "+ num+ " skill cards.");
			addOption(player,"Discard a random Skill Card",num,true);
		}
	} else if(num >= z.skillCardHands[player].length && !characterPresent("Tom") && !z.forLove && !noAuto) {
		/* TODO: Sabotage CO */
		if(player === me) {
			addAlert("You discard your entire hand.");
		}
		z.skillCardHands[player].sort(cardCompare);
		while(z.skillCardHands[player].length > 0) {
			discardSkillCard(player, 0);
		}
		return true;
	} else {
		if(num === 1) {
			plainAlert(z.players[player] + " must discard 1 skill card.");
		} else {
			plainAlert(z.players[player] + " must discard " + num + " skill cards.");
		}
		if(z.forLove && z.players[player] !== "Athena" && z.forLoveCOs[player] === null) {
			plainAlert("Athena may be able to Love them.");
			if(num > 1) {
				addOption(player, "Discard a Skill Card", num - 1, true);
			}
			if(z.skillCardHands[player].length >= num){
				addOption(player, "Choose a Skill Card to discard if Athena does not Love you");
			} else {
				z.selfishLove = true;
			}
		} else {
			addOption(player, "Discard a Skill Card", num, true);
		}
		return false;
	}
}

function couldLove() {
	if(!z.forLove) {
		return false;
	}
	if(z.selfishLove){
		return true;
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.randomLove[j]) {
			return true;
		}
		if(z.allForLove[j]) {
			return true;
		}
		if(z.forLoveCOs[j] !== null) {
			return true;
		}
		if(hasOption(j, "Choose a Skill Card to discard if Athena does not Love you")) {
			return true;
		}
		if(hasOption(j, "[Kleptomania] Choose a Skill Card to discard if Athena does not Love you")) {
			return true;
		}
		if(hasOption(j, "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you")) {
			return true;
		}
	}
	return false;
}

function cleanLove() {
	delete z.selfishLove;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		let k = (z.turn + j) % z.numPlayers;
		if(Array.isArray(z.randomLove) && z.randomLove[k]) {
			discardRandomSkillCard(k);
			z.randomLove[k] = false;
		}
		if(Array.isArray(z.allForLove) && z.allForLove[k]) {
			z.allForLove[k] = false;
			discardEntireHand(k,true);
		}
		if(hasOption(k, "Discard a random Skill Card")) {
			let context = getContext(k, "Discard a random Skill Card");
			if(Number.isInteger(context)) {
				for(let l = 0; !(l >= context) && z.skillCardHands[k].length > 0; l++) {
					discardRandomSkillCard(k);
				}
			}
			removeOption(k, "Discard a random Skill Card");
		}
		if(Array.isArray(z.forLoveCOs) && z.forLoveCOs[k] !== null) {
			let pos = z.skillCardHands[k].indexOf(z.forLoveCOs[k]);
			if(pos === -1) {
				plainAlert(z.players[k] +
					" has already discarded the card they had decided to discard for For Love!  This should not have happened.  They must discard another skill card now."
					);
				let num = getContext(k, "Discard a Skill Card");
				if(Number.isInteger(num)) {
					addOption(k, "Discard a Skill Card", num + 1, true);
				} else {
					addOption(k, "Discard a Skill Card", 1, true);
				}
			} else {
				discardSkillCard(k, pos);
			}
			z.forLoveCOs[k] = null;
		}
		if(hasOption(k, "Choose a Skill Card to discard if Athena does not Love you")) {
			let num = getContext(k, "Discard a Skill Card");
			if(Number.isInteger(num)) {
				addOption(k, "Discard a Skill Card", num + 1, true);
			} else {
				addOption(k, "Discard a Skill Card", 1, true);
			}
			removeOption(k, "Choose a Skill Card to discard if Athena does not Love you");
		}
		if(hasOption(k, "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you")) {
			removeOption(k, "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you");
			addOption(k, "[Terminal Illness] Discard another Skill Card", undefined, true);
		}
		if(hasOption(k, "[Kleptomania] Choose a Skill Card to discard if Athena does not Love you")) {
			let num = getContext(k, "[Kleptomania] Discard a Skill Card");
			if(Number.isInteger(num)) {
				addOption(k, "[Kleptomania] Discard a Skill Card", num + 1, true);
			} else {
				addOption(k, "[Kleptomania] Discard a Skill Card", 1, true);
			}
			removeOption(k, "[Kleptomania] Choose a Skill Card to discard if Athena does not Love you");
		}
	}
} /* TODO: Sabotage interaction */
function promptDiscards(player, num) {
	let noAutoDiscards = arguments.length > 2;
	if(z.players[player] === "Romo") {
		num--;
		if(num === 0) {
			plainAlert("Romo is Deceitful, and ignores the discard.");
			return true;
		} else if (num > 0){
			plainAlert("Romo is Deceitful, and discards 1 fewer card.");
		}
	}
	if(z.skillCardHands[player].length === 0) {
		plainAlert(z.players[player] + " has no skill cards; no effect.");
		if(z.forLove && z.players[player] !== "Athena"){
			plainAlert("Athena could still use For Love to draw a Treachery.");
			z.selfishLove = true;
		}
		return true;
	} else if(z.players[player] === "Apollo" && !noDrawback(player)) {
		if(!z.forLove && !noAutoDiscards) {
			for(let j = 0; !(j >= num) && z.skillCardHands[player].length > 0; j++) {
				discardRandomSkillCard(player);
			}
			return true;
		} else {
			if(num === 1){
				plainAlert("Apollo must randomly discard 1 skill card.");
			} else {
				plainAlert("Apollo must randomly discard " + num + " skill cards.");
			}
			if(z.forLove) {
				plainAlert("Athena can Love them.");
				z.randomLove[player] = true;
				if(num > 1) {
					addOption(player, "Discard a random Skill Card", num - 1, true);
				}
			} else {
				addOption(player, "Discard a random Skill Card", num, true);
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(j !== player) {
						addOption(j, "Make Apollo discard randomly", undefined, false);
					}
				}
			}
			return false;
		}
	} else if(num >= z.skillCardHands[player].length && !characterPresent("Tom") && !z.forLove && !noAutoDiscards) {
		if(player === me) {
			addAlert("You discard your entire hand.");
		}
		z.skillCardHands[player].sort(cardCompare);
		while(z.skillCardHands[player].length > 0) {
			discardSkillCard(player, 0);
		}
		return true;
	} else {
		if(num === 1) {
			plainAlert(z.players[player] + " must discard 1 skill card.");
		} else {
			plainAlert(z.players[player] + " must discard " + num + " skill cards.");
		}
		if(z.forLove && z.players[player] !== "Athena") {
			plainAlert("Athena may be able to Love them.");
			if(num > 1) {
				addOption(player, "Discard a Skill Card", num - 1, true);
			}
			if(z.skillCardHands[player].length >= num){
				addOption(player, "Choose a Skill Card to discard if Athena does not Love you");
			} else {
				z.selfishLove = true;
			}
		} else {
			addOption(player, "Discard a Skill Card", num, true);
		}
		return false;
	}
}

function promptRandomDiscards(player, num, noRomo) {
	if(z.players[player] === "Romo" && !noRomo) {
		num--;
		if(num === 0) {
			plainAlert("Romo is Deceitful, and ignores the discard.");
			return true;
		}
		plainAlert("Romo is Deceitful, and will discard 1 fewer card.");
	}
	if(z.skillCardHands[player].length === 0) {
		plainAlert(z.players[player] + " has no skill cards; no effect.");
		return true;
	} else if(z.forLove && z.players[player] !== "Athena") {
		if(num === 1) {
			boldAlert(z.players[player] + " must discard 1 random skill card, but Athena could Love them.");
			z.randomLove[player] = true;
		} else {
			boldAlert(z.players[player] + " must discard " + num + " random skill cards, but Athena could Love them.");
			addOption(player, "Discard a random Skill Card", num - 1, true);
			z.randomLove[player] = true;
		}
		return false;
	} else {
		for(let j = 0; !(j >= num) && z.skillCardHands[player].length > 0; j++) {
			let card = discardRandomSkillCard(player);
			if(me === player) {
				addAlert("You discarded " + cardText(card) + " randomly.");
			}
		}
		return true;
	}
}

function processOR() {
	if(z.currentCrisis === null) {
		return null;
	}
	let done = true;
	switch (d.crisisNames[z.currentCrisis]) {
		case "A Traitor Accused":
			if(z.revealedCylons[z.turn] === 0) {
				done = promptDiscards(z.turn, 5);
			} else {
				plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
			}
			break;
		case "Admiral Grilled":
		case "Colonial Day":
		case "Unsettling Stories":
		case "Familiar Face":
		case "Hera Rescued":
		case "Mysterious Guide":
			done = decreaseMorale();
			break;
		case "Analyze Enemy Fighter":
			addAlert("Roll a die.  If 4 or lower, -1 Population and " + z.players[z.turn] + " discards 2 skill cards.");
			done = false;
			SPTokenBad("Analyze Enemy Fighter", z.turn);
			break;
		case "Bomb Threat":
			addAlert("Roll a die.  If 4 or lower, -1 Morale and draw and destroy a civilian ship.");
			done = false;
			SPTokenBad("Bomb Threat", z.turn);
			break;
		case "Crippled Raider":
			addAlert("Roll a die.  If 4 or lower, place 3 Raiders in Sector 1 and 1 Civilian in Sector 4.");
			done = false;
			SPTokenBad("Crippled Raider", z.turn);
			break;
		case "Cylon Screenings":
			done = false;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.revealedCylons[j] === 0) {
					promptDiscards(j, 2, true);
				}
			}
			break;
		case "Forced Water Mining":
			increaseFood();
			if(decreaseMorale()) {
				if(z.forLove) {
					boldAlert("All Humans must discard a random skill card.");
					if(characterPresent("Romo")) {
						plainAlert("Romo is Deceitful, and does not need to discard.");
					}
					plainAlert("Athena can Love someone.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0 && (z.players[j] !== "Romo" && j !== z.theSympatheticCylon) && z.skillCardHands[j].length > 0) {
							if(z.players[j] === "Athena") {
								addOption(j, "Discard a random Skill Card", 1, true);
							} else {
								z.randomLove[j] = true;
							}
						}
					}
					done = false;
				} else {
					addAlert("All players discard a random skill card.");
					for(let i = 0; !(i >= z.numPlayers); i++) {
						if(z.skillCardHands[i ].length === 0) {
							plainAlert(z.players[i ] + " has no skill cards to discard.");
						} else if(z.revealedCylons[i ] === 1) {
							plainAlert("As a Cylon, " + z.players[i ] + " can ignore the random discard.");
						} else if(z.players[i ] === "Romo") {
							plainAlert(strikethrough("Romo") + " Nur-Ab-Sal ignores the discard as he is the Atlantean god of deceit.");
						} else {
							let discard = discardRandomSkillCard(i);
							addAlert(z.players[i ] + " discards " + cardText(discard) + " randomly.");
						}
					}
				}
			} else {
				plainAlert("Once Dee's execution is fully resolved, all Humans must discard a random skill card."); /*DEE*/
				done = false;
			}
			break;
		case "Fulfiller of Prophecy":
			if(z.capricaCrisis) {
				plainAlert("This crisis was played from Caprica, so there is no Activate Cylon Ships step; no effect.");
			} else {
				addAlert("Make sure to discard a skill card, then activate Basestars, then draw a new crisis.");
				t.value += "There will be a new crisis once " + z.players[z.turn] + " discards a skill card and basestars activate.\r\n";
				z.crisisDiscards.push(z.currentCrisis);
				if(z.engineRoom) {
					addAlert("The Engine Room does not benefit this crisis or the next.");
					t.value += "Note that the Engine Room does not benefit this crisis or the next.\r\n";
					z.engineRoom = false;
				}
				promptDiscards(z.turn, 1);
				addOption(z.turn, "Activate Basestars", undefined, true);
				if(characterPresent("Simon") && z.miracles[getPlayerNum("Simon")] === 1 && (!z.theFarm || z.revealedCylons[getPlayerNum("Simon")] === 1)) {
					addOption(getPlayerNum("Simon"), "Modifications (OPG)", "Fulfiller of Prophecy", false);
					if(z.modificationsPause) {
						boldAlert("A pause has been requested for Simon's Modifications ability; please wait for Simon before proceeding.");
						z.modificationsPause = false;
					}
				}
				z.currentCrisis = null;
				z.crisisPlayer = null;
				z.phase = 3;
				done = false;
			}
			break;
		case "Informing the Public":
			addAlert("Roll a die.  If 4 or lower, -1 Morale and -1 Population.");
			done = false;
			SPTokenBad("Informing the Public", z.turn);
			break;
		case "Keep Tabs on Visitor":
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
			} else {
				promptRandomDiscards(z.turn, 4);
			}
			break;
		case "Network Computers":
			done = decreasePopulation();
			decreaseJump();
			break;
		case "Scouting for Fuel":
			addAlert("Roll a die.  If 4 or lower, -1 Fuel.");
			done = false;
			SPTokenBad("Scouting for Fuel", z.turn);
			break;
		case "Scouting for Water":
		case "Water Sabotaged":
			decreaseFood();
			break;
		case "Send Survey Team":
			addAlert("Roll a die.  If 5 or lower, -1 Fuel.");
			done = false;
			SPTokenBad("Send Survey Team", z.turn);
			break;
		case "Code Blue":
		case "Arrests at Night":
		case "NCP Recruitment": {
			boldAlert("Each player discards 2 skill cards and draws 2 Treachery cards.");
			let numDrawers = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				let k = (z.turn + j) % z.numPlayers;
				if(z.revealedCylons[k] === 0) {
					if(z.possibleColors[k][5] === 1 && z.dradisBait[k]) {
						numDrawers++;
					}
					promptDiscards(k, 2, true);
				}
			}
			let athena = 0;
			if(z.forLove) {
				athena++;
			} /* TODO: cover consult the oracle treachery inspection */
			if(2 * z.numPlayers + athena > z.skillCardDecks[5].length || !z.daybreak || numDrawers > z.mutinyDeck.length - z.buriedMutinies) {
				plainAlert("The order of discards and Treachery draws may matter here.");
			}
			optionForAll("Draw 2 Treachery");
			done = false;
			break;
		}
		case "Reunite the Fleet":
		case "Playing with Emotions":
			if(z.revealedCylons[z.turn] === 1) {
				dealSkillCard(z.turn, 5);
				dealSkillCard(z.turn, 5);
			} else {
				if(promptRandomDiscards(z.turn, 2)) {
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
				} else {
					done = false;
					plainAlert("After discarding, " + z.players[z.turn] + " must draw 2 Treachery cards.");
					addOption(z.turn, "Draw 2 Treachery", undefined, true);
				}
			}
			break;
		case "The Black Market": {
			decreaseFood();
			let numDrawers = 0;
			boldAlert("Each player discards 1 skill card and draws 1 Treachery card.");
			for(let j = 0; !(j >= z.numPlayers); j++) {
				let k = (z.turn + j) % z.numPlayers;
				if(z.revealedCylons[k] === 0) {
					if(z.players[k] !== "Romo" && z.possibleColors[k][5] === 1 && z.dradisBait[k]) {
						numDrawers++;
					}
					promptDiscards(k, 1, true);
				}
			}
			let athena = 0;
			if(z.forLove) {
				athena++;
			}
			if(z.numPlayers + athena > z.skillCardDecks[5].length || !z.daybreak || numDrawers > z.mutinyDeck.length - z.buriedMutinies) {
				plainAlert("The order of discards and Treachery draws may matter here.");
			}
			optionForAll("Draw 1 Treachery");
			done = false;
			break;
		}
		case "Consult the Prisoner":
			if(z.admiral === z.turn) {
				done = promptDiscards(z.turn, 5);
			} else if(z.revealedCylons[z.turn] === 1) {
				done = promptDiscards(z.admiral, 2);
			} else {
				done = promptDiscards(z.admiral, 2);
				if(done) {
					done = promptDiscards(z.turn, 3);
				} else {
					promptDiscards(z.turn, 3, true);
				}
			}
			break;
		case "Cylon Genocide":
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is conveniently Stranded, and does not have to pay for his insubordination.");
			} else {
				addAlert("Roll a die.  If 4 or lower, " + z.players[z.turn] + " is sent to the Brig.");
				done = false;
				SPTokenBad("Cylon Genocide", z.turn);
			}
			break;
		case "Mysterious Message":
			done = activateBasestars();
			break;
		case "Raptor Malfunction":
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is Stranded, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Sickbay") {
				plainAlert(z.players[z.turn] + " is already in Sickbay.");
			} else if(isOnNewCaprica(z.turn)) {
				plainAlert("Damn, Apollo!");
				movePlayer(z.turn, "Medical Center");
			} else if(z.playerLocations[z.turn] === "Brig") {
				plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
			} else {
				movePlayer(z.turn, "Sickbay");
			}
			break;
		case "Set a Trap":
			addAlert("Roll a die.  If 4 or lower, a Centurion boards Galactica.");
			done = false;
			SPTokenBad("Set a Trap", z.turn);
			break;
		case "The Passage":
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is Stranded on Caprica with an ample supply of anti-radiation medication; no effect.");
			} else {
				addAlert("Roll a die.  If 6 or lower, " + z.players[z.turn] + " is sent to Sickbay.");
				done = false;
				SPTokenBad("The Passage", z.turn);
			}
			break;
		case "A Desperate Pact":
			if(promptDiscards(z.president, 3)) {
				if(z.revealedCylons[z.turn] === 0) {
					dealMutiny(z.turn, false);
					done = !characterPresent("Tom") && (z.players[z.turn] !== "Lee" || noDrawback(z.turn));
				}
			} else if(z.revealedCylons[z.turn] === 0) {
				if(z.turn !== z.president && z.players[z.president] !== "Tom") {
					dealMutiny(z.turn, false);
					done = !characterPresent("Tom") && (z.players[z.turn] !== "Lee" || noDrawback(z.turn));
					plainAlert("Make sure not to discuss the Mutiny until " + z.players[z.president] + " finishes discarding.");
				} else if(characterPresent("Tom")) {
					boldAlert("Once the President discards, Tom must deal " + z.players[z.turn] + " a Mutiny.");
					addOption(getPlayerNum("Tom"), "Deal a Mutiny card", "A Desperate Pact", true);
					done = false;
				} else {
					boldAlert("Once the President discards, they must draw a Mutiny.");
					addOption(z.president, "Draw a Mutiny card", undefined, true);
					done = false;
				}
			}
			break;
		case "Earth in Ruins":
			decreaseFood();
			if(z.revealedCylons[z.turn] === 0) {
				dealMutiny(z.turn, false);
				done = !characterPresent("Tom") && (z.players[z.turn] !== "Lee" || noDrawback(z.turn));
			}
			break;
		case "Enemy of my Enemy":
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				done = false;
				addOption(z.turn, "Damage Pegasus", 2, true);
				addOption(z.turn, "Damage Galactica", 2, true);
				boldAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica twice");
			} else {
				if(damageGalactica()) {
					done = damageGalactica();
				} else {
					done = false;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 1) {
							addOption(j, "Damage Galactica", undefined, false);
						}
					}
					plainAlert("Once the damage is fully resolved, damage Galactica again.");
				}
			}
			break;
		case "Galactica Falling Apart":
			addAlert("Roll a die.  If 6 or lower, -1 Food.");
			done = false;
			SPTokenBad("Galactica Falling Apart", z.turn);
			break;
		case "One Last Cocktail":
			addAlert("Roll a die.  If 6 or lower, -1 Morale and send the President to Sickbay.");
			done = false;
			SPTokenBad("One Last Cocktail", z.turn);
			break;
		case "Religious Turmoil":
			addAlert("Roll a die.  If 4 or lower, -1 Food and -1 Population.");
			done = false;
			SPTokenBad("Religious Turmoil", z.turn);
			break;
		case "Secret Meetings":
			if(z.revealedCylons[z.turn] === 0) {
				dealMutiny(z.turn, false);
			}
			done = false;
			addOption(z.turn, "Deal a Mutiny card", undefined, true);
			boldAlert(z.players[z.turn] + " must pick a player to draw a Mutiny card.");
			break;
		case "Brutal Treatment":
		case "Hiding Underground": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
						plainAlert(z.players[j] + " is the only Human on New Caprica not already in Detention, and is automatically detained.");
						movePlayer(j, "Detention");
					}
				}
			} else {
				boldAlert(z.players[z.turn] + " must send a Human on New Caprica to Detention.");
				addOption(z.turn, "Move a player to Detention", undefined, true);
				done = false;
			}
			break;
		}
		case "Contact Informant":
			done = decreasePopulation();
			break;
		case "Held for Questioning":
			if(z.revealedCylons[z.turn] === 0) {
				done = promptRandomDiscards(z.turn, 3);
			} else {
				plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
			}
			break;
		case "Prepare for a Fight": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0) {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0) {
						plainAlert(z.players[j] + " is the only Human on New Caprica, and is automatically sent to the Medical Center.");
						movePlayer(j, "Medical Center");
					}
				}
			} else {
				boldAlert(z.players[z.turn] + " must send a Human on New Caprica to the Medical Center.");
				addOption(z.turn, "Move a player to the Medical Center", undefined, true);
				done = false;
			}
			break;
		}
		case "Rescue Detainees": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0) {
					validTargets++;
					break;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else {
				addAlert("Roll a die.  If 4 or lower, " + z.players[z.turn] + " chooses a Human on New Caprica to send to Detention.");
				done = false;
				SPTokenBad("Rescue Detainees", z.turn);
			}
			break;
		}
		default:
			plainAlert("ERROR: No OR choice found.");
	}
}

function refreshSkillDecks() {
	for(let j = 0; !(j >= z.skillCardDecks.length); j++) {
		reshuffleSkillCardDeck(j);
	}
}

function discardEntireHand(player,noLove) {
	if(z.skillCardHands[player].length === 0) {
		plainAlert(z.players[player] + " has no skill cards to discard.");
		return true;
	} else if(!z.forLove || noLove){
		z.skillCardHands[player].sort(cardCompare);
		
		let cardList = z.players[player] + " discards their entire hand of skill cards:\r\n";
		while(z.skillCardHands[player].length > 0) {
			let card = z.skillCardHands[player].shift();
			z.skillCardDiscards[cardColorID(card)].push(card);
			if(cardColorID(card) === 5 && z.revealedCylons[player] === 0) {
				z.treacheryDiscarded = true;
				if(!z.sabotageAnnounced && someoneCouldSabotage()) {
					plainAlert("A revealed Cylon could use " + colorText("brown", "Sabotage") + " now.");
					z.sabotageAnnounced = true;
				}
			}
			cardList += cardText(card) + "\r\n";
		}
		plainAlert(cardList);
		z.possibleColors[player] = [0, 0, 0, 0, 0];
		if(z.pegasus || z.daybreak) {
			z.possibleColors[player].push(0);
		}
		refreshSkillDecks();
		return true;
	} else {
		plainAlert(z.players[player] + " could keep a single card if Athena loves them.");
		z.allForLove[player] = true;
		return false;
	}
}

function processGoodDieRoll(roll) {
	if(roll.slice(0, 6) === "Detain") {
		let target = roll.slice(7);
		movePlayer(getPlayerNum(target), "Medical Center");
		addAlert(target + " is moved to the Medical Center.");
		return 0;
	}
	let DRRE = /^Armory vs\. Centurion \(space (\d)\)$/.exec(roll);
	if(DRRE === null) {
		DRRE = /^Send a Message vs\. Centurion \(space (\d)\)$/.exec(roll);
	}
	if(DRRE !== null) {
		let space = parseInt(DRRE[1]);
		for(let j = 0; !(j >= z.centurions.length); j++) {
			if(z.centurions[j] === space) {
				z.centurions[j] = 0;
				break;
			}
		}
		boldAlert("Destroyed a Centurion on space " + space + " of the Boarding Party Track.");
		if(z.vBrutality && characterPresent("Karl") && !noDrawback(getPlayerNum("Karl"))) {
			t.value += "Karl's Conflicted triggers.\r\n";
			if(getPlayerNum("Karl") === z.destroyer && z.pegasus && !z.majorVictory && z.possibleColors[z.destroyer][1] === 1) {
				promptAllyDiscards(z.destroyer, 2, true);
			} else {
				promptAllyDiscards(getPlayerNum("Karl"), 2);
			}
		}
		if(Number.isInteger(z.destroyer) && z.destroyer >= 0 && z.possibleColors[z.destroyer][1] === 1 && z.pegasus && !z.majorVictory) {
			plainAlert(z.players[z.destroyer] + " may want to use Major Victory here.");
			let mv = false;
			for(let j = 0; !(j >= z.skillCardHands[z.destroyer].length) && !mv; j++) {
				mv = cardName(z.skillCardHands[z.destroyer][j]) === "Major Victory";
			}
			if(mv) {
				addOption(z.destroyer, "Play a Major Victory", undefined, false);
			}
		}
		z.destroyer = -1;
		return 0;
	}
	DRRE = /^Encourage Mutiny \((.*)\)$/.exec(roll);
	if(DRRE !== null) {
		let target = DRRE[1];
		boldAlert(target + " is now the Admiral.");
		z.admiral = getPlayerNum(target);
		if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
			plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
		}
		return 0;
	}
	switch (roll) {
		case "FTL Control (Blue -3)":
			z.jumpTrack = 4;
			increaseJump();
			break;
		case "FTL Control (Blue -1)":
			increaseJump();
			break;
		case "Basestar Bridge: Jump/Pursuit Tracks":
			advancePursuit();
			break;
		case "Scout for Fuel":
			increaseFuel();
			break;
		case "Major Victory":
			increaseMorale();
			break;
		case "Send a Message":
		case "Armory": {
			for(let j = 0; !(j >= z.centurions.length); j++) {
				if(z.centurions[j] > 0) {
					z.centurions[j] = 0;
					break;
				}
			}
			if(z.vBrutality && characterPresent("Karl") && !noDrawback(getPlayerNum("Karl"))) {
				t.value += "Karl's Conflicted triggers.\r\n";
				if(getPlayerNum("Karl") === z.destroyer && z.pegasus && !z.majorVictory && z.possibleColors[z.destroyer][1] === 1) {
					promptAllyDiscards(z.destroyer, 2, true);
				} else {
					promptAllyDiscards(getPlayerNum("Karl"), 2);
				}
			}
			boldAlert("Destroyed a Centurion on the Boarding Party Track.");
			if(Number.isInteger(z.destroyer) && z.destroyer >= 0 && z.possibleColors[z.destroyer][1] === 1 && z.pegasus && !z.majorVictory) {
				plainAlert(z.players[z.destroyer] + " may want to use Major Victory here.");
				let mv = false;
				for(let j = 0; !(j >= z.skillCardHands[z.destroyer].length) && !mv; j++) {
					mv = cardName(z.skillCardHands[z.destroyer][j]) === "Major Victory";
				}
				if(mv) {
					addOption(z.destroyer, "Play a Major Victory", undefined, false);
				}
			}
			break;
		}
		case "Inspirational Speech":
			increaseMorale();
			plainAlert("Removed the Inspirational Speech from the game.");
			z.quorumDiscards.pop();
			if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
			}
			break;
		case "Food Rationing":
			increaseFood();
			plainAlert("Removed the Food Rationing from the game.");
			z.quorumDiscards.pop();
			if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
			}
			break;
		case "Encourage Mutiny":
			if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability once the Admiral title is moved.");
			}
			break;
		case "Controversial Speech":
			increaseMorale();
			plainAlert("Removed Controversial Speech from the game.");
			z.mutinyDiscards.pop();
			break;
		case "Tylium Planet":
		case "Cylon Refinery":
			increaseFuel();
			increaseFuel();
			break;
		case "Icy Moon":
			increaseFood();
			break;
		default:
			plainAlert("Error: no good outcome associated with die roll.");
	}
}

function basestarName(index) {
	let bs1 = "Basestar in Sector " + z.basestars[index][0];
	if(z.basestars[index].length > 1) {
		bs1 += " with damage: ";
		for(let i = 1; !(i >= z.basestars[index].length); i++) {
			bs1 += "(" + z.basestars[index][i ] + ")";
		}
	}
	return bs1;
}

function processBadDieRoll(roll) {
	let done = true;
	if(roll.slice(0, 6) === "Detain") {
		let target = roll.slice(7);
		movePlayer(getPlayerNum(target), "Detention");
		return 0;
	}
	let DRRE = /^Encourage Mutiny/.exec(roll);
	if(DRRE !== null) {
		done = decreaseMorale();
		if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
			plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
		}
		return 0;
	}
	DRRE = /^Civilian Self Defense \((.)\)/.exec(roll);
	if(DRRE !== null) {
		let civiliansInSpace = 0;
		if(characterPresent("Hot Dog") && numUndamagedVipers() > 0 && !z.theFarm && z.miracles[getPlayerNum("Hot Dog")] === 1){
			plainAlert("Civilian "+DRRE[1]+" will be destroyed.");
			addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",["Civilian Self Defense",DRRE[1]],false);
			optionForAll("Destroy a Civilian in space",["Civilian Self Defense",DRRE[1]],true);
		} else {
			for(let j = 0; !(j >= 6); j++) {
				for(let k = 0; !(k >= z.spaceCivilians[j].length); k++) {
					if(z.spaceCivilians[j][k][0] === DRRE[1]) {
						let civ = z.spaceCivilians[j].splice(k, 1)[0];
						destroyCivilian(civ[1]);
						break;
					}
				}
				civiliansInSpace += z.spaceCivilians[j].length;
			}
			if(civiliansInSpace === 0) {
				z.reshuffledSeen = false;
			}
			if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
			}
		}
		return 0;
	}
	switch (roll) {
		case "Amputee":
			dealMutiny(getPlayerNum("Gaeta"));
			break;
		case "Presidential Detention":
			movePlayer(z.president, "Detention");
			break;
		case "Basestar Bridge: Jump/Pursuit Tracks":
			decreaseJump();
			break;
		case "FTL Control (Blue -3)":
			done = decreasePopulation();
			done = decreasePopulation() && done;
			done = decreasePopulation() && done;
			if(done) {
				z.jumpTrack = 4;
				increaseJump();
			} else {
				optionForAll("Jump the Fleet");
			}
			break;
		case "FTL Control (Blue -1)":
			done = decreasePopulation();
			if(done) {
				increaseJump();
			} else {
				optionForAll("Jump the Fleet");
			}
			break;
		case "Test the Limits":
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				plainAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica.");
			} else if(!z.galacticaAway) {
				damageGalactica();
			}
			break;
		case "Scout for Fuel":
		case "Tylium Planet":
		case "Icy Moon":
			destroyRaptor();
			break;
		case "Cylon Refinery":
			if(vipersIIReserves() > 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) {
				let c = 0;
				plainAlert("Two vipers damaged.");
				for(let j = 0; !(j >= z.vipersII.length) && !(c >= 2); j++) {
					if(z.vipersII[j] === 0) {
						z.vipersII[j] = -1;
						c++;
					}
				}
			} else {
				plainAlert(z.players[z.admiral] + " must now damage the 2 Vipers they risked.");
				optionForAll("Damage a Viper", ["Cylon Refinery", 2], true);
			}
			break;
		case "Peaceful Resistance":
			if(isOnNewCaprica(z.admiral)) {
				movePlayer(z.admiral, "Detention");
			} else if(z.playerLocations[z.admiral] === "Stranded on Caprica") {
				plainAlert("Helo can't hear you from Caprica.");
			} else {
				movePlayer(z.admiral, "Brig");
			}
			break;
		case "Controversial Speech":
			/* RULES: where does this start? */ dealSkillCardToEveryone(z.turn, 5, true);
			break;
		case "Analyze Enemy Fighter":
			done = decreasePopulation();
			if(!done && z.players[z.turn] === "Hot Dog") {
				promptDiscards(z.turn, 2, true);
			} else if(z.revealedCylons[z.turn] === 0) {
				done = promptDiscards(z.turn, 2);
			}
			break;
		case "Bomb Threat":
			if(decreaseMorale()) {
				done = destroyPileCivilian(1);
			} else {
				optionForAll("Draw and destroy a Civilian", undefined, true);
				plainAlert("After Dee's execution is resolved, draw and destroy a Civilian ship.");
			}
			break;
		case "Crippled Raider":
			placeRaiders(1, 3);
			placeCivilian(4);
			break;
		case "Informing the Public":
			done = decreasePopulation();
			if(!done && characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && z.morale === 3 && z.preventative !== "Morale") {
				plainAlert("After Hot Dog resolves his Memento, lose 1 Morale.");
				optionForAll("Decrease a resource", "Forced Water Mining", true);
			} else {
				done = decreaseMorale();
			}
			break;
		case "Keep Tabs on Visitor":
			done = decreasePopulation();
			done = decreasePopulation() && done;
			break;
		case "Scouting for Fuel":
		case "Send Survey Team":
		case "An Ambitious Operation":
			decreaseFuel();
			break;
		case "Defending a Prisoner":
			if(z.revealedCylons[z.turn] === 0) {
				if(z.executedCurrentPlayer && z.exodus){
					plainAlert("The current player has already been executed, ending their turn; you cannot execute them again.");
				} else {
					executePlayer(z.turn);
					done = false;
				}
			}
			break;
		case "Food Hoarding in the Fleet":
			done = destroyPileCivilian(1);
			break;
		case "Cylon Genocide":
			if(z.revealedCylons[z.turn] === 0 && z.playerLocations[z.turn] !== "Stranded on Caprica") {
				movePlayer(z.turn, "Brig");
			}
			break;
		case "Set a Trap":
			if(boardGalactica()) {
				boldAlert("A Centurion boards Galactica.");
			} else {
				t.value += "All Centurions are already on board Galactica.\r\n";
			}
			break;
		case "The Passage":
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is Stranded, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Sickbay") {
				plainAlert(z.players[z.turn] + " is already in Sickbay.");
			} else if(isOnNewCaprica(z.turn)) {
				plainAlert("Damn, Apollo!");
				movePlayer(z.turn, "Medical Center");
			} else if(z.playerLocations[z.turn] === "Brig") {
				plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
			} else {
				movePlayer(z.turn, "Sickbay");
			}
			break;
		case "Galactica Falling Apart":
			decreaseFood();
			break;
		case "One Last Cocktail":
			if(decreaseMorale()) {
				if(z.playerLocations[z.president] === "Stranded on Caprica") {
					plainAlert("President Helo is Stranded, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.president] === "Sickbay") {
					plainAlert(z.players[z.president] + " is already in Sickbay.");
				} else if(isOnNewCaprica(z.president)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.president, "Medical Center");
				} else if(z.playerLocations[z.president] === "Brig") {
					plainAlert(z.players[z.president] + " is in the Brig, and is not sent to Sickbay.");
				} else {
					movePlayer(z.president, "Sickbay");
				}
			} else {
				done = false; /*DEE*/
				plainAlert("After fully resolving Dee's execution, move the President to Sickbay.");
			}
			break;
		case "Religious Turmoil":
			decreaseFood();
			done = decreasePopulation();
			break;
		case "Requisition for Demetrius":
			shuffleTreachery();
			break;
		case "Starvation in Dogsville - Top Option":
			done = decreasePopulation();
			decreaseFood();
			break;
		case "Starvation in Dogsville - Bottom Option":
			decreaseFood();
			decreaseFood();
			break;
		case "A Cylon Ally":
			if(z.revealedCylons[z.turn] === 0 && isOnNewCaprica(z.turn) && z.playerLocations[z.turn] !== "Detention") {
				movePlayer(z.turn, "Detention");
			}
			break;
		case "Execution List": {
			let currentPlayer = (z.president === z.turn && !z.capricaCrisis);
			executePlayer(z.president);
			if(currentPlayer){
				z.toDoHeavies = false;
				z.toDoOFs = false;
				z.toDoJumpIcon = false;
			}
			done = false;
			break;
		}
		case "Rescue Detainees": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
						plainAlert(z.players[j] + " is the only Human on New Caprica not already in Detention, and is automatically detained.");
						movePlayer(j, "Detention");
					}
				}
			} else {
				boldAlert(z.players[z.turn] + " must send a Human on New Caprica to Detention.");
				addOption(z.turn, "Move a player to Detention", undefined, true);
				done = false;
			}
			break;
		}
		case "Authorization of Brutal Force":
		case "Inexperienced Leader (Crashdown)":
			done = decreasePopulation();
			if(roll === "Authorization of Brutal Force" && characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
			}
			break;
		case "Encourage Mutiny":
		case "Release Cylon Mugshots":
		case "Troublemaker (Hot Dog)":
		case "Mood Swings (Cally)":
		case "Unpopular Decisions (Helo)":
			done = decreaseMorale();
			if(roll === "Encourage Mutiny" && characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
				plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
			}
			break;
		default:
			plainAlert("Error: no outcome associated with die roll.");
	}
}

function canCalc() {
	if(!z.pegasus) {
		return false;
	}
	let anyEngineering = false;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.possibleColors[j][4] === 1 && z.revealedCylons[j] === 0) {
			anyEngineering = true;
		}
	}
	if(!anyEngineering) {
		return false;
	}
	let value = z.lastDieRollValue + z.lastDieRollModifier;
	if(z.lastDieRoll.slice(0, 6) === "Detain") {
		return value === 8 || value === 7 || value === 4 || value === 3;
	}
	let DRRE = /Basestar Bridge: Damage Roll \((.*)\)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return z.raiders.length - raidersAway() === value || z.raiders.length - raidersAway() - 1 === value;
	}
	DRRE = /^Ruined Reputation/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 4 || value === 5;
	}
	DRRE = /vs\. Raider \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 2 || value === 3;
	}
	if(/vs\. Scar/.test(z.lastDieRoll)) {
		return value === 6 || value === 7;
	}
	DRRE = /(.*) vs\. Heavy Raider \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		if(z.vBrutality) {
			let pilot = DRRE[1];
			let sector = DRRE[2];
			if(pilot === "Assault Raptor") {
				return value === 5 || value === 6;
			} else if(z.daybreak) {
				for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
					if(z.assaultRaptors[j] === pilot) {
						return value === 5 || value === 6;
					}
				}
			}
			if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector && pilot !==
				"Weapons Control") {
				return value === 5 || value === 6;
			}
		}
		return value === 6 || value === 7;
	}
	DRRE = /Nuke vs\. (Basestar.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let basestar = DRRE[1];
		let anyDamage = false;
		let anyRaiders = false;
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(z.basestars[j].length > 1) {
					anyDamage = true;
				}
				let sector = z.basestars[j][0];
				if(z.scarCAC && z.scar === sector) {
					anyRaiders = true;
				}
				for(let k = 0; !anyRaiders && !(k >= z.raiders.length); k++) {
					if(z.raiders[k] === sector) {
						anyRaiders = true;
					}
				}
				if((value === 2 || value === 3) && !anyDamage) {
					return true;
				}
				if((value === 6 || value === 7) && anyRaiders) {
					return true;
				}
				return false;
			}
		}
	}
	DRRE = /Nuke vs\. Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		let numRaiders = 0;
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] === sector) {
				numRaiders++;
			}
		}
		let numBasestars = 0;
		let undamagedBasestar = false;
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(z.basestars[j][0] === sector) {
				numBasestars++;
				if(z.basestars[j].length === 1) {
					undamagedBasestar = true;
				}
			}
		}
		let collateralAvailable = false;
		let personnelAvailable = false;
		for(let j = 0; !(j >= z.basestarDamage.length); j++) {
			if(z.basestarDamage[j] === "Collateral Damage" && numRaiders > 0) {
				collateralAvailable = true;
			}
			if(z.basestarDamage[j] === "Damage to Personnel" && z.preCrossroads) {
				personnelAvailable = true;
			}
		}
		if(undamagedBasestar && (value === 2 || value === 3)) {
			return true;
		}
		if((collateralAvailable || personnelAvailable) && numBasestars > 0 && (value === 2 || value === 3)) {
			return true;
		}
		if((value === 6 || value === 7) && numRaiders > 0) {
			return true;
		}
		let anyOtherShips = (numRaiders > 3) || (numBasestars > 1) || (z.spaceCivilians[sector - 1].length > 0);
		for(let j = 0; !anyOtherShips && !(j >= z.heavies.length); j++) {
			if(z.heavies[j] === sector) {
				anyOtherShips = true;
			}
		}
		for(let j = 0; !anyOtherShips && !(j >= z.vipersII.length); j++) {
			if(z.vipersII[j] === sector) {
				anyOtherShips = true;
			} else if(!Number.isInteger(z.vipersII[j]) && z.playerLocations[getPlayerNum(z.vipersII[j])] === "Sector " + sector) {
				anyOtherShips = true;
			}
		}
		for(let j = 0; !anyOtherShips && !(j >= z.vipersVII.length); j++) {
			if(z.vipersVII[j] === sector) {
				anyOtherShips = true;
			} else if(!Number.isInteger(z.vipersVII[j]) && z.playerLocations[getPlayerNum(z.vipersVII[j])] === "Sector " + sector) {
				anyOtherShips = true;
			}
		}
		for(let j = 0; !anyOtherShips && z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(z.assaultRaptors[j] === sector) {
				anyOtherShips = true;
			} else if(!Number.isInteger(z.assaultRaptors[j]) && z.playerLocations[getPlayerNum(z.assaultRaptors[j])] === "Sector " + sector) {
				anyOtherShips = true;
			}
		}
		if(anyOtherShips && (value === 7 || value === 8)) {
			return true;
		}
		return false;
	}
	DRRE = /Main Batteries vs\. Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		if(z.scarCAC && z.scar === sector && (value === 6 || value === 7)) {
			return true;
		}
		let c = 0;
		for(let j = 0; !(j >= z.raiders.length) && !(c >= 4); j++) {
			if(z.raiders[j] === sector) {
				c++;
			}
		}
		if(c > 2 && (value === 6 || value === 7)) {
			return true;
		}
		if(c > 0 && (value === 3 || value === 4)) {
			return true;
		}
		if(z.spaceCivilians[sector - 1].length > 0 && (value === 1 || value === 2)) {
			return true;
		}
		let anyVipers = false;
		for(let j = 0; !anyVipers && !(j >= z.vipersII.length); j++) {
			if(!Number.isInteger(z.vipersII[j]) && z.playerLocations[getPlayerNum(z.vipersII[j])] === "Sector " + sector) {
				anyVipers = true;
			} else if(z.vipersII[j] === sector) {
				anyVipers = true;
			}
		}
		for(let j = 0; !anyVipers && z.CFB && !(j >= z.vipersVII.length); j++) {
			if(!Number.isInteger(z.vipersVII[j]) && z.playerLocations[getPlayerNum(z.vipersVII[j])] === "Sector " + sector) {
				anyVipers = true;
			} else if(z.vipersVII[j] === sector) {
				anyVipers = true;
			}
		}
		for(let j = 0; !anyVipers && z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(!Number.isInteger(z.assaultRaptors[j]) && z.playerLocations[getPlayerNum(z.assaultRaptors[j])] === "Sector " + sector) {
				anyVipers = true;
			} else if(z.assaultRaptors[j] === sector) {
				anyVipers = true;
			}
		}
		if(anyVipers && (value === 1 || value === 2 || value === 3 || value === 4)) {
			return true;
		}
		return false;
	}
	DRRE = /Weapons Control vs\. (Basestar.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 4 || value === 5;
	}
	DRRE = /Pegasus CIC vs\. (Basestar.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let basestar = DRRE[1];
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(!(z.basestars[j].length === 3 || z.basestars[j][1] === "Critical Hit") && (value === 6 || value === 7)) {
					return true;
				}
				break;
			}
		}
		return value === 3 || value === 4;
	}
	DRRE = /^(.*) vs\. (Basestar.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let pilot = DRRE[1];
		if(pilot === "Assault Raptor") {
			if(z.vBrutality) {
				return value === 5 || value === 6;
			}
			return value === 6 || value === 7;
		} else if(z.daybreak) {
			for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === pilot) {
					if(z.vBrutality) {
						return value === 5 || value === 6;
					}
					return value === 6 || value === 7;
				}
			}
		}
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3])) {
			let sector = 0;
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(basestarName(j) === DRRE[2]) {
					sector = z.basestars[j][0];
					break;
				}
			}
			if(z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
				if(z.vBrutality) {
					return value === 5 || value === 6;
				}
				return value === 6 || value === 7;
			}
		}
		return value === 7 || value === 8;
	}
	DRRE = /vs\. Viper Mk II \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let sector = DRRE[1];
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
			if(z.vBrutality) {
				return value === 5 || value === 6;
			}
			return value === 6 || value === 7;
		}
		return value === 4 || value === 5 || value === 7 || value === 8;
	}
	DRRE = /vs\. Viper Mk VII \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let sector = DRRE[1];
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
			if(z.vBrutality) {
				return value === 5 || value === 6;
			}
			return value === 6 || value === 7;
		}
		return value === 5 || value === 6 || value === 7 || value === 8;
	}
	DRRE = /vs\. Assault Raptor \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		if(z.vBrutality) {
			return value === 5 || value === 6;
		}
		return value === 6 || value === 7;
	}
	if(z.lastDieRoll === "Raider vs. Galactica" || z.lastDieRoll === "Scar vs. Galactica") {
		return value === 7 || value === 8;
	}
	if(z.lastDieRoll === "Basestar vs. Galactica") {
		return value === 3 || value === 4;
	}
	DRRE = /^(.*) vs\. Occupation Force \((.*)\)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 4 || value === 5;
	}
	DRRE = /(Raider|Scar) vs\. (.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let pilot = DRRE[2];
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === z.playerLocations[getPlayerNum(
			pilot)]) {
			if(z.vBrutality) {
				return value === 5 || value === 6;
			}
			return value === 6 || value === 7;
		}
		for(let j = 0; !(j >= z.vipersII.length); j++) {
			if(z.vipersII[j] === pilot) {
				return value === 4 || value === 5 || value === 7 || value === 8;
			}
		}
		for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
			if(z.vipersVII[j] === pilot) {
				return value >= 5;
			}
		}
		for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(z.assaultRaptors[j] === pilot && value >= 7) {
				if(z.vBrutality) {
					return value === 5 || value === 6;
				}
				return value === 6 || value === 7;
			}
		}
	}
	DRRE = /Best of the Best \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		if(value > 8) {
			return false;
		} else if(0 >= value) {
			return false;
		}
		let c = 0;
		for(let j = 0; !(j >= z.raiders.length) && value > c; j++) {
			if(z.raiders[j] === sector) {
				c++;
			}
		}
		if(z.scarCAC && z.scar === sector){
			if(value === 6 || value === 7){
				return true;
			}
			if(value === 8 && c === 7){
				return true;
			}
		}
		if(value > c) {
			return false;
		}
		return true;
	}
	DRRE = /^Send a Message/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 6 || value === 7;
	}
	DRRE = /^Armory/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 6 || value === 7;
	}
	DRRE = /^Civilian Self Defense/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return value === 2 || value === 3;
	}
	switch (z.lastDieRoll) {
		case "Basestar Bridge: Jump/Pursuit Tracks":
		case "Scout for Fuel":
		case "Food Hoarding in the Fleet":
		case "Release Cylon Mugshots":
		case "Presidential Detention":
		case "Amputee":
			return value === 3 || value === 4;
		case "FTL Control (Blue -3)":
		case "FTL Control (Blue -1)":
		case "The Passage":
		case "Galactica Falling Apart":
		case "One Last Cocktail":
		case "Requisition for Demetrius":
		case "Cylon Refinery":
			return value === 6 || value === 7;
		case "Test the Limits":
		case "Send Survey Team":
		case "A Cylon Ally":
		case "Execution List":
		case "Controversial Speech":
		case "Inspirational Speech":
		case "Food Rationing":
			return value === 5 || value === 6;
		case "Peaceful Resistance":
		case "Analyze Enemy Fighter":
		case "Bomb Threat":
		case "Crippled Raider":
		case "Informing the Public":
		case "Keep Tabs on Visitor":
		case "Scouting for Fuel":
		case "An Ambitious Operation":
		case "Defending a Prisoner":
		case "Cylon Genocide":
		case "Set a Trap":
		case "Religious Turmoil":
		case "Starvation in Dogsville - Top Option":
		case "Starvation in Dogsville - Bottom Option":
		case "Rescue Detainees":
		case "Inexperienced Leader (Crashdown)":
		case "Troublemaker (Hot Dog)":
		case "Mood Swings (Cally)":
		case "Unpopular Decisions (Helo)":
		case "Major Victory":
		case "Human Fleet":
			return value === 4 || value === 5;
		case "Authorization of Brutal Force":
		case "Encourage Mutiny":
		case "Launch Scout":
		case "Tylium Planet":
		case "Icy Moon":
			return value === 2 || value === 3;
		case "CFB Raider Placement":
		case "CFB Basestar Placement":
		case "CFB Heavy Raider Placement":
			return value >= 1 && 7 >= value;
		default:
			return false;
	}
} /* TODO: EM token? */
function canEM() {
	let anyPiloting = false;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.possibleColors[j][3] === 1 && z.revealedCylons[j] === 0) {
			anyPiloting = true;
		}
	}
	if(!anyPiloting) {
		return false;
	}
	let DRRE = /vs\. Viper Mk II \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return true;
	}
	DRRE = /vs\. Viper Mk VII \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return true;
	}
	DRRE = /vs\. Assault Raptor \(Sector (\d)/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return true;
	}
	if(z.lastDieRoll === "Raider vs. Galactica" || z.lastDieRoll === "Scar vs. Galactica") {
		return false;
	}
	DRRE = /(Raider|Scar) vs\. (.*)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		return true;
	}
	return false;
}

function canModifyDieRoll() {
	if(z.players[z.dieRoller] === "Billy" && z.revealedCylons[getPlayerNum("Billy")] === 0 && getPlayerNum("Billy") !== z.theSympatheticCylon && z.phase ===
		3 && !noDrawback(z.dieRoller)) {
		return false;
	}
	if(z.eco) {
		return true;
	}
	if(characterPresent("Gaeta") && z.FTLOperator && !z.vBrutality && (z.lastDieRoll === "FTL Control (Blue -3)" || z.lastDieRoll ===
		"FTL Control (Blue -1)")) {
		return true;
	}
	if(canEM() || canCalc()) {
		return true;
	}
	let DRRE = /^(.*) vs\. Occupation Force \((.*)\)$/.exec(z.lastDieRoll);
	if(DRRE !== null) {
		if(z.possibleColors[getPlayerNum(DRRE[1])][3] === 1) {
			return true;
		}
	}
	if(characterPresent("Racetrack") && !versionAtLeast([2, 1, 3]) && z.players[z.dieRoller] === "Racetrack" && (z.lastDieRoll === "Launch Scout" || 
			z.lastDieRoll === "Scout for Fuel" || z.lastDieRoll === "Tylium Planet" || z.lastDieRoll === "Icy Moon")) {
		return true;
	}
	return false;
}
var a1 = "ENDBYCB  [/size][/c] " + 
" [c][size=1] STARTBYCC";

function processDieRoll() {
	let value = z.lastDieRollValue + z.lastDieRollModifier;
	let roll = z.lastDieRoll;
	z.lastDieRollValue = 0;
	z.lastDieRollModifier = 0;
	z.lastDieRoll = null;
	if(characterPresent("Racetrack") && !versionAtLeast([2, 1, 3])) {
		z.expertRaptorPilot = false;
	}
	z.dieRollModifier = 0;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.sps[j] = null;
	}
	if(roll.slice(0, 6) === "Detain") {
		if(value >= 8) {
			plainAlert("No Effect.");
		} else if(value >= 4) {
			processGoodDieRoll(roll);
		} else {
			processBadDieRoll(roll);
		}
		return 0;
	}
	let DRRE = /Basestar Bridge: Damage Roll \((.*)\)/.exec(roll);
	if(DRRE !== null) {
		if((z.raiders.length - raidersAway()) > value) {
			z.damagePlayer = getPlayerNum(DRRE[1]);
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				if(z.turn !== z.damagePlayer) {
					boldAlert(z.players[z.turn] + ", as current player, must now deal 2 damage tokens to " + DRRE[1] + ", who will resolve 1.");
				} else {
					boldAlert(DRRE[1] + " must now draw 2 damage tokens and resolve 1.");
				}
			} else {
				plainAlert(DRRE[1] + " draws 2 damage tokens and must resolve 1.");
				for(let i = 0; !(i >= 2) && z.damage.length > 0; i++) {
					let damage = z.damage.pop();
					z.damageHand.push(damage);
				}
			}
		} else {
			plainAlert("No Effect.");
		}
		return 0;
	}
	if(roll === "Launch Scout") {
		if(value >= 3) {
			if((z.destination === "Earth" || z.destination === "Ionian Earth") && z.vBrutality && versionAtLeast([1, 2, 4, 6])) {
				plainAlert(z.players[z.dieRoller] + " must now scout the Crisis, Destination, or Mission deck.");
				addOption(z.dieRoller, "Scout the Crisis Deck", undefined, true);
				addOption(z.dieRoller, "Scout the Destination Deck", undefined, true);
				addOption(z.dieRoller, "Scout the Mission Deck", undefined, true);
			} else {
				plainAlert(z.players[z.dieRoller] + " must now scout the Crisis or Destination deck.");
				addOption(z.dieRoller, "Scout the Crisis Deck", undefined, true);
				addOption(z.dieRoller, "Scout the Destination Deck", undefined, true);
			}
		} else {
			destroyRaptor();
		}
		return 0;
	}
	DRRE = /^(.*) vs\. Raider \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let pilot = DRRE[1];
		let sector = parseInt(DRRE[2]);
		if(value >= 3) {
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] === sector) {
					z.raiders[j] = 0;
					plainAlert("Raider destroyed.");
					if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
						plainAlert(
							"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					} else if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
						z.heavyCasualties--;
						let left = 0;
						for(let j = 0; !(j>=z.raiders.length); j++){
							if(z.raiders[j] === 6){
								left++;
							}
						}	
						if(left > z.heavyCasualties){
							plainAlert("BYC assumes this is one of the raiders that was just placed; if not, you can fix this in the deep menus.");
						}
					}					
					let pilotNum = getPlayerNum(pilot);
					if(pilotNum !== -1){
						let HRcount = 0;
						for(let k = 0; !(k >= z.raiders.length); k++){
							if(z.raiders[k] === sector){
								HRcount++;
								break;
							}
						}
						if(HRcount === 0){
							removeOption(pilotNum,"Attack a Raider");
						}
					}
					break;
				}
			}
		} else {
			addAlert("Miss");
		}
		return 0;
	}
	if(/vs\. Scar/.test(roll)) {
		if(value >= 7) {
			z.scarCAC = false;
			z.scar = -1;
			z.raiders.push(0);
			if(z.galacticaReturned){
				z.oldCrisisDiscards.push(83);
			} else {
				z.crisisDiscards.push(83);
			}
			boldAlert("Scar is destroyed!");
			if(z.dogfightCAC && raidersAway() === z.raiders.length) {
				plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
				z.dogfightCAC = false;
				if(z.galacticaReturned){
					z.oldCrisisDiscards.push(76);
				} else {
					z.crisisDiscards.push(76);
				}
			}
			removeFromAll("Attack Scar");
		} else {
			addAlert("Miss");
		}
		return 0;
	}
	DRRE = /^(.*) vs\. Heavy Raider \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let pilot = DRRE[1];
		let viper = true;
		let sector = parseInt(DRRE[2]);
		if(pilot === "Assault Raptor") {
			viper = false;
		} else if(z.daybreak) {
			for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === pilot) {
					viper = false;
					break;
				}
			}
		}
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector && pilot !==
			"Weapons Control") {
			viper = false;
		}
		if(value >= 7 || (!viper && z.vBrutality && value === 6)) {
			for(let j = 0; !(j >= z.heavies.length); j++) {
				if(z.heavies[j] === sector) {
					z.heavies[j] = 0;
					plainAlert("Heavy Raider destroyed.");
					let pilotNum = getPlayerNum(pilot);
					if(pilotNum !== -1){
						let HRcount = 0;
						for(let k = 0; !(k >= z.heavies.length); k++){
							if(z.heavies[k] === sector){
								HRcount++;
								break;
							}
						}
						if(HRcount === 0){
							removeOption(pilotNum,"Attack a Heavy Raider");
						}
					}
					break;
				}
			}
		} else {
			addAlert("Miss.");
		}
		return 0;
	}
	DRRE = /Nuke vs\. (Basestar.*)$/.exec(roll);
	if(DRRE !== null) {
		let basestar = DRRE[1];
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(value >= 7) {
					let sector = z.basestars[j][0];
					destroyBasestar(j);
					if(z.scarCAC && z.scar === sector) {
						let c = 0;
						for(let k = 0; !(k >= z.raiders.length) && !(c >= 3); k++) {
							if(z.raiders[k] === sector) {
								if(c !== 2) {
									z.raiders[k] = 0;
								}
								c++;
							}
						}
						if(c === 3) {
							plainAlert("The Nuke also destroys 3 Raiders in the Sector. " + z.players[z.turn] +
								" may choose Scar to be one of the destroyed Raiders.");
							addOption(z.turn, "Destroy Scar", undefined, true);
							addOption(z.turn, "Destroy Raider(s)", "Nuke", true);
							if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
								z.heavyCasualties -= 2;
								if(0 > z.heavyCasualties){
									z.heavyCasualties = 0;
								}
								let left = 0;
								for(let j = 0; !(j>=z.raiders.length); j++){
									if(z.raiders[j] === 6){
										left++;
									}
								}
								if(left > z.heavyCasualties){
									plainAlert("BYC assumes that, of the two regular raiders guaranteed to be destroyed here, the raiders that were just placed were prioritized; if not, you can fix this in the deep menus.");
								}
							}
						} else {
							let s = "s";
							if(c === 1){
								s = "";
							}
							plainAlert("The Nuke destroys Scar and " + c + " regular Raider"+s+" in the sector.");
							z.scarCAC = false;
							z.scar = -1;
							z.raiders.push(0);
							if(z.galacticaReturned){
								z.oldCrisisDiscards.push(83);
							} else {
								z.crisisDiscards.push(83);
							}
							if(z.dogfightCAC && raidersAway() === z.raiders.length) {
								plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
								z.dogfightCAC = false;
								if(z.galacticaReturned){
									z.oldCrisisDiscards.push(76);
								} else {
									z.crisisDiscards.push(76);
								}
							}
							if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
								z.heavyCasualties-=c;
								if(0 > z.heavyCasualties){
									z.heavyCasualties = 0;
								}
								let left = 0;
								for(let j = 0; !(j>=z.raiders.length); j++){
									if(z.raiders[j] === 6){
										left++;
									}
								}	
								if(left > z.heavyCasualties){
									plainAlert("BYC assumes the raiders just placed were prioritized; if not, you can fix this in the deep menus.");
								}
							}
						}
					} else {
						let c = 0;
						for(let k = 0; !(k >= z.raiders.length) && !(c >= 3); k++) {
							if(z.raiders[k] === sector) {
								z.raiders[k] = 0;
								c++;
							}
						}
						
						let s = "s";
						if(c === 1){
							s = "";
						}
						plainAlert("Destroyed " + c + " Raider"+s+" in the same sector.");
						if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
							plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
							z.dogfightCAC = false;
							if(z.galacticaReturned){
								z.oldCrisisDiscards.push(76);
							} else {
								z.crisisDiscards.push(76);
							}
						}
						if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
							z.heavyCasualties-=c;
							if(0 > z.heavyCasualties){
								z.heavyCasualties = 0;
							}
							let left = 0;
							for(let j = 0; !(j>=z.raiders.length); j++){
								if(z.raiders[j] === 6){
									left++;
								}
							}	
							if(left > z.heavyCasualties){
								plainAlert("BYC assumes the raiders just placed were prioritized; if not, you can fix this in the deep menus.");
							}
						}
					}
				} else if(value >= 3) {
					destroyBasestar(j);
				} else {
					plainAlert("The Basestar is damaged twice.");
					damageBasestar(j);
					if(z.basestars[j][0] !== 0) {
						damageBasestar(j);
					}
				}
				z.destroyer = -1;
				return 0;
			}
		}
	}
	DRRE = /Nuke vs\. Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		if(value >= 8) {
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] === sector) {
					z.raiders[j] = 0;
				}
			}
			for(let j = 0; !(j >= z.heavies.length); j++) {
				if(z.heavies[j] === sector) {
					z.heavies[j] = 0;
				}
			}
			for(let j = 0; !(j >= z.vipersII.length); j++) {
				if(z.vipersII[j] === sector) {
					z.vipersII[j] = -2;
					plainAlert("Viper Mk II destroyed.");
				} else if(!Number.isInteger(z.vipersII[j]) && z.playerLocations[getPlayerNum(z.vipersII[j])] === "Sector " + sector) {
					plainAlert("Viper Mk II destroyed.");
					movePlayer(getPlayerNum(z.vipersII[j]), "Sickbay");
					z.vipersII[j] = -2;
				}
			}
			for(let j = 0; !(j >= z.vipersVII.length); j++) {
				if(z.vipersVII[j] === sector) {
					z.vipersVII[j] = -2;
					plainAlert("Viper Mk VII destroyed.");
				} else if(!Number.isInteger(z.vipersVII[j]) && z.playerLocations[getPlayerNum(z.vipersVII[j])] === "Sector " + sector) {
					plainAlert("Viper Mk VII destroyed.");
					movePlayer(getPlayerNum(z.vipersVII[j]), "Sickbay");
					z.vipersVII[j] = -2;
				}
			}
			for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === sector) {
					z.assaultRaptors[j] = -2;
					plainAlert("Assault Raptor destroyed.");
				} else if(!Number.isInteger(z.assaultRaptors[j]) && z.playerLocations[getPlayerNum(z.assaultRaptors[j])] === "Sector " + sector) {
					plainAlert("Assault Raptor destroyed.");
					movePlayer(getPlayerNum(z.assaultRaptors[j]), "Sickbay");
					z.assaultRaptors[j] = -2;
				}
			}
			let bs1 = -1;
			let both = false;
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(z.basestars[j][0] === sector) {
					if(bs1 === -1) {
						bs1 = j;
					} else {
						both = true;
					}
				}
			}
			let moraleCivDead = false;
			for(let j = 0; !(j >= z.destroyedCivilians.length); j++) {
				if(z.destroyedCivilians[j] === "Pop/Morale") {
					moraleCivDead = true;
					break;
				}
			}
			if(z.theGuardians && characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && 5 >= z.morale) {
				let possibleMoraleLoss = 1;
				if(both) {
					possibleMoraleLoss += 2;
				} else if(bs1 !== -1) {
					possibleMoraleLoss++;
				}
				if(moraleCivDead || z.spaceCivilians[sector - 1].length === 0) {
					possibleMoraleLoss--;
				}
				if(possibleMoraleLoss > 0 && z.preventative === "Morale") {
					possibleMoraleLoss--;
				}
				if(2 >= z.morale - possibleMoraleLoss) {
					plainAlert(z.players[z.turn] + " must destroy any remaining ships in the sector.");
					if(bs1 !== 1) {
						addOption(z.turn, "Destroy a basestar", "Big Nuke", true);
					}
					if(z.spaceCivilians[sector - 1].length > 0) {
						addOption(z.turn, "Destroy a Civilian in space", ["Nuke", sector], true);
					}
					return 0;
				}
			}
			if(both) {
				destroyBasestar(0);
				destroyBasestar(1);
			} else if(bs1 !== -1) {
				destroyBasestar(bs1);
			}
			let anyInspected = false;
			for(let j = 0; !(j >= z.spaceCivilians[sector - 1].length) && !anyInspected; j++) {
				anyInspected = z.spaceCivilians[sector - 1][j][2];
			}
			if((anyInspected && ((characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && z.morale === 3 && z.preventative !== "Morale" && 
					z.spaceCivilians[sector - 1].length > 1 && !moraleCivDead) || (characterPresent("Hot Dog") && !z.mementoUsed && z.spaceCivilians[
					sector - 1].length > 1))) || (characterPresent("Hot Dog") && z.miracles[getPlayerNum("Hot Dog")] === 1 && !z.theFarm && numUndamagedVipers() > 0 &&
					z.spaceCivilians[sector - 1].length > 1)) {
				plainAlert(z.players[z.turn] + " must destroy any remaining ships in the sector.");
				addOption(z.turn, "Destroy a Civilian in space", ["Nuke", sector], true);
				return 0;
			}
			while(z.spaceCivilians[sector - 1].length > 0) {
				destroyCivilian(z.spaceCivilians[sector - 1].shift()[1]);
			}
			let civiliansInSpace = 0;
			for(let j = 0; !(j >= 6); j++) {
				civiliansInSpace += z.spaceCivilians[j].length;
			}
			if(civiliansInSpace === 0) {
				z.reshuffledSeen = false;
			}
			z.destroyer = -1;
		} else if(value === 7) {
			if(z.basestars.length === 2 && z.basestars[0][0] === sector && z.basestars[1][0] === sector && (z.basestars[0].length > 1 || z.basestars[1].length >
					1)) {
				plainAlert(z.players[z.turn] + " must destroy a Basestar in Sector " + sector + ".");
				addOption(z.turn, "Destroy a basestar", "Small Nuke", true);
			} else {
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === sector) {
						destroyBasestar(j);
						z.destroyer = -1;
						break;
					}
				}
			}
			let c = 0;
			for(let k = 0; !(k >= z.raiders.length) && !(c >= 3); k++) {
				if(z.raiders[k] === sector) {
					z.raiders[k] = 0;
					c++;
				}
			}
			plainAlert("Destroyed " + c + " Raiders.");
		} else if(value >= 3) {
			if(z.basestars.length === 2 && z.basestars[0][0] === sector && z.basestars[1][0] === sector && (z.basestars[0].length > 1 || z.basestars[1].length >
					1)) {
				plainAlert(z.players[z.turn] + " must destroy a Basestar in Sector " + sector + ".");
				addOption(z.turn, "Destroy a basestar", "Small Nuke", true);
			} else {
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === sector) {
						destroyBasestar(j);
						z.destroyer = -1;
						break;
					}
				}
			}
		} else {
			if(z.basestars.length === 2 && z.basestars[0][0] === sector && z.basestars[1][0] === sector && (z.basestars[0].length > 1 || z.basestars[1].length >
					1)) {
				plainAlert(z.players[z.turn] + " must choose a Basestar in Sector " + sector + " to damage twice.");
				addOption(z.turn, "Damage a basestar", "Nuke", true);
			} else {
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === sector) {
						damageBasestar(j);
						if(z.basestars[j][0] !== 0) {
							damageBasestar(j);
						}
						z.destroyer = -1;
						break;
					}
				}
			}
		}
		return 0;
	}
	DRRE = /Main Batteries vs\. Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		if(value >= 7) {
			let scar = z.scarCAC && z.scar === sector;
			let c = 0;
			for(let j = 0; !(j >= z.raiders.length) && !(c >= 4); j++) {
				if(z.raiders[j] === sector) {
					if(c !== 3 || !scar) {
						z.raiders[j] = 0;
					}
					c++;
				}
			}
			if(scar && c === 4) {
				plainAlert("3 Raiders destroyed; " + z.players[z.turn] + " must decide whether the 4th raider destroyed is Scar or a regular raider.");
				addOption(z.turn, "Destroy Scar", undefined, true);
				addOption(z.turn, "Destroy Raider(s)", "Main Batteries", true);
				if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
					z.heavyCasualties-=3;
					if(0 > z.heavyCasualties){
						z.heavyCasualties = 0;
					}
					let left = 0;
					for(let j = 0; !(j>=z.raiders.length); j++){
						if(z.raiders[j] === 6){
							left++;
						}
					}	
					if(left > z.heavyCasualties){
						plainAlert("BYC assumes the three regular raiders guaranteed to be destroyed were prioritized to be those just placed; if not, you can fix this in the deep menus.");
					}
				}
			} else if(scar) {
				let s = "s";
				if(c === 1){
					s = "";
				}
				plainAlert("Main Batteries destroys Scar and " + c + " regular Raider"+s+".");
				z.scarCAC = false;
				z.scar = -1;
				z.raiders.push(0);
				if(z.galacticaReturned){
					z.oldCrisisDiscards.push(83);
				} else {
					z.crisisDiscards.push(83);
				}
				if(z.dogfightCAC && raidersAway() === z.raiders.length) {
					plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
					z.dogfightCAC = false;
					if(z.galacticaReturned){
						z.oldCrisisDiscards.push(76);
					} else {
						z.crisisDiscards.push(76);
					}
				}
				if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
					z.heavyCasualties-=c;
					if(0 > z.heavyCasualties){
						z.heavyCasualties = 0;
					}
					let left = 0;
					for(let j = 0; !(j>=z.raiders.length); j++){
						if(z.raiders[j] === 6){
							left++;
						}
					}	
					if(left > z.heavyCasualties){
						plainAlert("BYC assumes that the Raiders just placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
					}
				}
			} else {
				plainAlert("Main Batteries destroys " + c + " Raiders.");
				if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
					plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
					z.dogfightCAC = false;
					if(z.galacticaReturned){
						z.oldCrisisDiscards.push(76);
					} else {
						z.crisisDiscards.push(76);
					}
				}
				if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
					z.heavyCasualties-=c;
					if(0 > z.heavyCasualties){
						z.heavyCasualties = 0;
					}
					let left = 0;
					for(let j = 0; !(j>=z.raiders.length); j++){
						if(z.raiders[j] === 6){
							left++;
						}
					}	
					if(left > z.heavyCasualties){
						plainAlert("BYC assumes that the Raiders just placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
					}
				}
			}
		} else if(value >= 4) {
			let c = 0;
			for(let j = 0; !(j >= z.raiders.length) && !(c >= 2); j++) {
				if(z.raiders[j] === sector) {
					z.raiders[j] = 0;
					c++;
				}
			}
			let s = "s";
			if(c === 1){
				s = "";
			}
			plainAlert("Main Batteries destroys " + c + " Raider"+s+".");
			if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
				plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
				z.dogfightCAC = false;
				if(z.galacticaReturned){
					z.oldCrisisDiscards.push(76);
				} else {
					z.crisisDiscards.push(76);
				}
			} 
			if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
				z.heavyCasualties-=c;
				if(0 > z.heavyCasualties){
					z.heavyCasualties = 0;
				}
				let left = 0;
				for(let j = 0; !(j>=z.raiders.length); j++){
					if(z.raiders[j] === 6){
						left++;
					}
				}	
				if(left > z.heavyCasualties){
					plainAlert("BYC assumes that the Raiders just placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
				}	
			}
		} else if(value >= 2) {
			let ii = false;
			let vii = false;
			let AR = false;
			let piloted = 0;
			for(let j = 0; !(j >= z.vipersII.length); j++) {
				if(!Number.isInteger(z.vipersII[j]) && z.playerLocations[getPlayerNum(z.vipersII[j])] === "Sector " + sector) {
					piloted++;
				} else if(z.vipersII[j] === sector) {
					ii = true;
				}
			}
			for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
				if(!Number.isInteger(z.vipersVII[j]) && z.playerLocations[getPlayerNum(z.vipersVII[j])] === "Sector " + sector) {
					piloted++;
				} else if(z.vipersVII[j] === sector) {
					vii = true;
				}
			}
			for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
				if(!Number.isInteger(z.assaultRaptors[j]) && z.playerLocations[getPlayerNum(z.assaultRaptors[j])] === "Sector " + sector) {
					piloted++;
				} else if(z.assaultRaptors[j] === sector) {
					AR = true;
				}
			}
			if(!ii && !vii && !AR && piloted === 0) {
				plainAlert("No Effect.");
			} else if(ii && !vii && !AR && piloted === 0) {
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(z.vipersII[j] === sector) {
						z.vipersII[j] = -1;
						plainAlert("Viper Mk II damaged.");
						return 0;
					}
				}
			} else if(!ii && vii && !AR && piloted === 0) {
				for(let j = 0; !(j >= z.vipersVII.length); j++) {
					if(z.vipersVII[j] === sector) {
						z.vipersVII[j] = -1;
						plainAlert("Viper Mk VII damaged.");
						return 0;
					}
				}
			} else if(!ii && !vii && AR && piloted === 0) {
				for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
					if(z.assaultRaptors[j] === sector) {
						z.assaultRaptors[j] = -2;
						plainAlert("Assault Raptor destroyed.");
						return 0;
					}
				}
			} else if(!ii && !vii && !AR && piloted === 1) {
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(!Number.isInteger(z.vipersII[j]) && z.playerLocations[getPlayerNum(z.vipersII[j])] === "Sector " + sector) {
						let pilot = z.vipersII[j];
						if(pilot === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) {
							boldAlert("Hot Dog's Viper Mk II destroyed as he was Forced to Eject; he is sent to Sickbay.");
							z.vipersII[j] = -2;
						} else {
							boldAlert(pilot + "'s Viper Mk II damaged; they are sent to Sickbay.");
							z.vipersII[j] = -1;
						}
						movePlayer(getPlayerNum(pilot), "Sickbay");
						return 0;
					}
				}
				for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
					if(!Number.isInteger(z.vipersVII[j]) && z.playerLocations[getPlayerNum(z.vipersVII[j])] === "Sector " + sector) {
						let pilot = z.vipersVII[j];
						if(pilot === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) {
							boldAlert("Hot Dog's Viper Mk VII destroyed as he was Forced to Eject; he is sent to Sickbay.");
							z.vipersVII[j] = -2;
						} else {
							boldAlert(pilot + "'s Viper Mk VII damaged; they are sent to Sickbay.");
							z.vipersVII[j] = -1;
						}
						movePlayer(getPlayerNum(pilot), "Sickbay");
						return 0;
					}
				}
				for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
					if(!Number.isInteger(z.assaultRaptors[j]) && z.playerLocations[getPlayerNum(z.assaultRaptors[j])] === "Sector " + sector) {
						let pilot = z.assaultRaptors[j];
						boldAlert(pilot + "'s Assault Raptor destroyed; they are sent to Sickbay.");
						movePlayer(getPlayerNum(pilot), "Sickbay");
						z.assaultRaptors[j] = -2;
						return 0;
					}
				}
			} else {
				plainAlert(z.players[z.turn] + " must choose a Viper in Sector " + sector + " to damage.");
				addOption(z.turn, "Damage a Viper", ["Main Batteries", 1], true);
			}
		} else {
			if(z.spaceCivilians[sector - 1].length === 0) {
				plainAlert("No Effect");
			} else if(characterPresent("Hot Dog") && z.miracles[getPlayerNum("Hot Dog")] === 1 && !z.theFarm && numUndamagedVipers() > 0) {
				if(z.spaceCivilians[sector - 1].length === 1){
					plainAlert("The Pegasus will destroy the Civilian in Sector "+sector+".");
					optionForAll("Destroy a Civilian in space", ["Main Batteries", sector], true);
					addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",["Main Batteries", sector],false);
				} else {
					plainAlert(z.players[z.turn] + " must choose a Civilian in Sector " + sector + " to destroy.");
					addOption(z.turn,"Destroy a Civilian in space", ["Main Batteries", sector], true);
					let anyInspected = false;
					for(let j = 0; !(j >= z.spaceCivilians[sector - 1].length) && !anyInspected; j++) {
						anyInspected = z.spaceCivilians[sector - 1][j][2];
					}
					if(!anyInspected){
						addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",["Main Batteries", sector],false);
					}
				}
				
			} else if(z.spaceCivilians[sector - 1].length === 1) {
				let civiliansInSpace = 0;
				for(let j = 0; !(j >= 6); j++) {
					civiliansInSpace += z.spaceCivilians[j].length;
				}
				if(civiliansInSpace === 1) {
					z.reshuffledSeen = false;
				}
				destroyCivilian(z.spaceCivilians[sector - 1].pop()[1]);
			} else {
				let anyInspected = false;
				for(let j = 0; !(j >= z.spaceCivilians[sector - 1].length) && !anyInspected; j++) {
					anyInspected = z.spaceCivilians[sector - 1][j][2];
				}
				if(anyInspected) {
					plainAlert(z.players[z.turn] + " must choose a Civilian in Sector " + sector + " to destroy.");
					addOption(z.turn, "Destroy a Civilian in space", ["Main Batteries", sector], true);
				} else {
					destroyCivilian(z.spaceCivilians[sector - 1].shift()[1]);
				}
			}
		}
		return 0;
	}
	DRRE = /Weapons Control vs\. (Basestar.*)$/.exec(roll);
	if(DRRE !== null) {
		let basestar = DRRE[1];
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(value >= 5) {
					plainAlert("The Basestar is damaged: ");
					damageBasestar(j);
				} else {
					addAlert("Miss.");
				}
				z.destroyer = -1;
				return 0;
			}
		}
	}
	DRRE = /Pegasus CIC vs\. (Basestar.*)$/.exec(roll);
	if(DRRE !== null) {
		let basestar = DRRE[1];
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(value >= 7) {
					plainAlert("The Basestar is damaged twice.");
					damageBasestar(j);
					if(z.basestars[j][0] !== 0) {
						damageBasestar(j);
					}
				} else if(value >= 4) {
					plainAlert("The Basestar is damaged.");
					damageBasestar(j);
				} else {
					damagePegasus();
				}
				z.destroyer = -1;
				return 0;
			}
		}
	}
	DRRE = /^(.*) vs\. (Basestar.*)$/.exec(roll);
	if(DRRE !== null) {
		let basestar = DRRE[2];
		let pilot = DRRE[1];
		let viper = true;
		if(pilot === "Assault Raptor") {
			viper = false;
		} else if(z.daybreak) {
			for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === pilot) {
					viper = false;
					break;
				}
			}
		}
		if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3])) {
			let sector = 0;
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(basestarName(j) === basestar) {
					sector = z.basestars[j][0];
					break;
				}
			}
			if(z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
				viper = false;
			}
		}
		let BSRE = /Sector (\d)/.exec(basestar);
		let sector = parseInt(BSRE[1]);
		for(let j = 0; !(j >= z.basestars.length); j++) {
			if(basestarName(j) === basestar) {
				if(value >= 8 || (value === 7 && !viper) || (value === 6 && !viper && z.vBrutality)) {
					plainAlert("The Basestar is damaged: ");
					damageBasestar(j);
				} else {
					addAlert("Miss.");
				}
				z.destroyer = -1;
				let pilotNum = getPlayerNum(pilot);
				if(pilotNum !== -1){
					let BScount = 0;
					let raiderCount = 0;
					for(let k = 0; !(k >= z.basestars.length); k++){
						if(z.basestars[k][0] === sector){
							BScount++;
							break;
						}
					}
					for(let k = 0; !(k >= z.raiders.length); k++){
						if(z.raiders[k] === sector){
							raiderCount++;
							break;
						}
					}
					if(BScount === 0){
						removeOption(pilotNum,"Attack a Basestar");
					}
					if(raiderCount === 0){
						removeOption(pilotNum,"Attack a Raider");
					}
				}
				return 0;
			}
		}
	}
	DRRE = /vs\. Viper Mk II \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let scar = roll.slice(0, 4) === "Scar";
		raiderShot(scar);
		let sector = parseInt(DRRE[1]);
		if(value >= 5) {
			for(let j = 0; !(j >= z.vipersII.length); j++) {
				if(z.vipersII[j] === sector) {
					if(characterPresent("Racetrack") && versionAtLeast([2, 1, 3]) && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
						if(value >= 7 || (value === 6 && z.vBrutality)) {
							z.vipersII[j] = -2;
							plainAlert("Viper Mk II Destroyed.");
						} else {
							addAlert("Miss.");
						}
					} else if(value >= 8) {
						z.vipersII[j] = -2;
						plainAlert("Viper Mk II Destroyed.");
					} else {
						z.vipersII[j] = -1;
						plainAlert("Viper Mk II Damaged.");
					}
					break;
				}
			}
		} else {
			addAlert("Miss.");
		}
		resetActivatingSector();
		return 0;
	}
	DRRE = /vs\. Viper Mk VII \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		raiderShot();
		if(value >= 6) {
			for(let j = 0; !(j >= z.vipersVII.length); j++) {
				if(z.vipersVII[j] === sector) {
					if(characterPresent("Racetrack") && z.playerLocations[getPlayerNum("Racetrack")] === "Sector " + sector) {
						if(value >= 7 || (value === 6 && z.vBrutality)) {
							z.vipersVII[j] = -2;
							plainAlert("Viper Mk VII Destroyed.");
						} else {
							addAlert("Miss.");
						}
					} else if(value >= 8) {
						z.vipersVII[j] = -2;
						plainAlert("Viper Mk VII Destroyed.");
					} else {
						z.vipersVII[j] = -1;
						plainAlert("Viper Mk VII Damaged.");
					}
					break;
				}
			}
		} else {
			addAlert("Miss.");
		}
		resetActivatingSector();
		return 0;
	}
	DRRE = /vs\. Assault Raptor \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		let scar = roll.slice(0, 4) === "Scar";
		raiderShot(scar);
		if(value >= 7 || (z.vBrutality && value === 6)) {
			for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === sector) {
					z.assaultRaptors[j] = -2;
					plainAlert("Assault Raptor Destroyed.");
					break;
				}
			}
		} else {
			addAlert("Miss.");
		}
		resetActivatingSector();
		return 0;
	}
	if(roll === "Raider vs. Galactica" || roll === "Scar vs. Galactica") {
		if(value >= 8) {
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
			} else {
				damageGalactica();
			}
		} else {
			addAlert("Miss.");
		}
		raiderShot(roll === "Scar vs. Galactica");
		if(z.dieRollQueue.length === 0) {
			resetActivatingSector();
		}
		return 0;
	}
	if(roll === "Basestar vs. Galactica") {
		if(value >= 4) {
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
			} else {
				damageGalactica();
			}
		} else {
			plainAlert("The Basestar misses.");
		}
		return 0;
	}
	DRRE = /(Raider|Scar) vs\. (.*)$/.exec(roll);
	if(DRRE !== null) {
		let pilot = DRRE[2];
		let scar = roll.slice(0, 4) === "Scar";
		raiderShot(scar);
		let racetrack = characterPresent("Racetrack") && z.playerLocations[getPlayerNum("Racetrack")] === z.playerLocations[getPlayerNum(pilot)] && versionAtLeast([2, 1, 3]);
		for(let j = 0; !(j >= z.vipersII.length); j++) {
			if(z.vipersII[j] === pilot && (value >= 7 || (value === 6 && (!racetrack || z.vBrutality)) || (value === 5 && !racetrack))) {
				if(value >= 8 || (pilot === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) || racetrack) {
					boldAlert(pilot + "'s Viper Mk II destroyed; they are sent to Sickbay.");
					z.vipersII[j] = -2;
				} else {
					boldAlert(pilot + "'s Viper Mk II damaged; they are sent to Sickbay.");
					z.vipersII[j] = -1;
				}
				movePlayer(getPlayerNum(pilot), "Sickbay");
				resetActivatingSector();
				return 0;
			}
		}
		for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
			if(z.vipersVII[j] === pilot && (value >= 7 || (value === 6 && (!racetrack || z.vBrutality)) )) {
				if(value >= 8 || (pilot === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) || racetrack) {
					boldAlert(pilot + "'s Viper Mk VII destroyed; they are sent to Sickbay.");
					z.vipersVII[j] = -2;
				} else {
					boldAlert(pilot + "'s Viper Mk VII damaged; they are sent to Sickbay.");
					z.vipersVII[j] = -1;
				}
				movePlayer(getPlayerNum(pilot), "Sickbay");
				resetActivatingSector();
				return 0;
			}
		}
		for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
			if(z.assaultRaptors[j] === pilot && (value >= 7 || (value === 6 && z.vBrutality))) {
				boldAlert(pilot + "'s Assault Raptor destroyed; they are sent to Sickbay.");
				movePlayer(getPlayerNum(pilot), "Sickbay");
				z.assaultRaptors[j] = -2;
				resetActivatingSector();
				return 0;
			}
		}
		addAlert("Miss.");
		resetActivatingSector();
		return 0;
	}
	DRRE = /^(.*) vs\. Occupation Force \((.*)\)$/.exec(roll);
	if(DRRE !== null) {
		if(4 >= value) {
			plainAlert("No Effect.");
		} else {
			switch (DRRE[2]) {
				case "Occupation Authority":
					for(let j = 0; !(j >= 4); j++) {
						if(z.OFs[j] === 1) {
							z.OFs[j] = 0;
							plainAlert("Destroyed an Occupation Force on the Occupation Authority.");
							break;
						}
					}
					break;
				case "Breeder's Canyon":
					for(let j = 0; !(j >= 4); j++) {
						if(z.OFs[j] === 2) {
							z.OFs[j] = 0;
							plainAlert("Destroyed an Occupation Force on Breeder's Canyon.");
							break;
						}
					}
					break;
				case "Shipyard":
					for(let j = 0; !(j >= 4); j++) {
						if(z.OFs[j] === 3) {
							z.OFs[j] = 0;
							plainAlert("Destroyed an Occupation Force on the Shipyard.");
							break;
						}
					}
					break;
			}
		}
		return 0;
	}
	DRRE = /Best of the Best \(Sector (\d)/.exec(roll);
	if(DRRE !== null) {
		let sector = parseInt(DRRE[1]);
		if(value > 8) {
			value = 8;
		} else if(0 >= value) {
			value = 1;
		}
		let c = 0;
		for(let j = 0; !(j >= z.raiders.length) && value > c; j++) {
			if(z.raiders[j] === sector) {
				z.raiders[j] = 0;
				c++;
			}
		}
		let s = "s";
		if(c === 1){
			s = "";
		}
		if(z.scarCAC && z.scar === sector && value >= 7 && value > c){
			plainAlert("Scar destroyed.");
			z.scarCAC = false;
			z.scar = -1;
			z.raiders.push(0);
			if(z.galacticaReturned){
				z.oldCrisisDiscards.push(83);
			} else {
				z.crisisDiscards.push(83);
			}
		}
		
		if(z.scarCAC && z.scar === sector && value >= 7){
			/* RULES: who makes this call? */
			plainAlert((c-1)+" Raiders destroyed; " + z.players[z.turn] + " must decide whether the last raider destroyed is Scar or a regular raider.");
			addOption(z.turn, "Destroy Scar", undefined, true);
			addOption(z.turn, "Destroy Raider(s)", "Best of the Best", true);
			for(let j = 0; !(j>=z.raiders.length); j++){
				if(z.raiders[j] === 0){
					z.raiders[j] = sector;
					break;
				}
			}
			if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
				z.heavyCasualties = 0;
				plainAlert("BYC assumes the destroyed Raiders were prioritized to be those just placed; if not, you can fix this in the deep menus.");
			}
		} else {
		
			plainAlert("Destroyed " + c + " Raider"+s+".");
			if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
				plainAlert(
					"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
				z.dogfightCAC = false;
				if(z.galacticaReturned){
					z.oldCrisisDiscards.push(76);
				} else {
					z.crisisDiscards.push(76);
				}
			}
			if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
				z.heavyCasualties-=c;
				if(0 > z.heavyCasualties){
					z.heavyCasualties = 0;
				}
				let left = 0;
				for(let j = 0; !(j>=z.raiders.length); j++){
					if(z.raiders[j] === 6){
						left++;
					}
				}	
				if(left > z.heavyCasualties){
					plainAlert("BYC assumes that the Raiders just placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
				}	
			}
		}
		return 0;
	}
	DRRE = /Ruined Reputation vs\. (.*)$/.exec(roll);
	if(DRRE !== null) {
		let target = DRRE[1];
		let targetNum = getPlayerNum(target);
		if(value > 4) {
			plainAlert("No Effect.");
		} else {
			if(isOnNewCaprica(targetNum)) {
				boldAlert(target + " is sent to Detention.");
				movePlayer(targetNum, "Detention");
			} else {
				boldAlert(target + " is sent to the Brig.");
				movePlayer(targetNum, "Brig");
			}
		}
		return 0;
	}
	DRRE = /^Armory/.exec(roll);
	if(DRRE !== null) {
		if(value >= 7) {
			processGoodDieRoll(roll);
		} else {
			plainAlert("No Effect.");
		}
		return 0;
	}
	DRRE = /^Send a Message/.exec(roll);
	if(DRRE !== null) {
		if(value >= 7) {
			processGoodDieRoll(roll);
		} else {
			plainAlert("No Effect.");
		}
		return 0;
	}
	DRRE = /^Civilian Self Defense/.exec(roll);
	if(DRRE !== null) {
		if(value >= 3) {
			plainAlert("No Effect");
		} else {
			processBadDieRoll(roll);
		}
		if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
			plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
		}
		return;
	}
	DRRE = /^Encourage Mutiny/.exec(roll);
	if(DRRE !== null) {
		if(value >= 3) {
			processGoodDieRoll(roll);
		} else {
			processBadDieRoll(roll);
		}
		if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
			plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
		}
		return;
	}
	switch (roll) {
		case "Basestar Bridge: Jump/Pursuit Tracks":
		case "Scout for Fuel":
			if(value >= 4) {
				processGoodDieRoll(roll);
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "FTL Control (Blue -3)":
		case "FTL Control (Blue -1)":
			if(value >= 7) {
				processGoodDieRoll(roll);
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Test the Limits":
		case "Send Survey Team":
		case "A Cylon Ally":
		case "Execution List":
			if(value >= 6) {
				plainAlert("No Effect");
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Peaceful Resistance":
		case "Analyze Enemy Fighter":
		case "Bomb Threat":
		case "Crippled Raider":
		case "Informing the Public":
		case "Keep Tabs on Visitor":
		case "Scouting for Fuel":
		case "An Ambitious Operation":
		case "Defending a Prisoner":
		case "Cylon Genocide":
		case "Set a Trap":
		case "Religious Turmoil":
		case "Starvation in Dogsville - Top Option":
		case "Starvation in Dogsville - Bottom Option":
		case "Rescue Detainees":
		case "Inexperienced Leader (Crashdown)":
		case "Troublemaker (Hot Dog)":
		case "Mood Swings (Cally)":
		case "Unpopular Decisions (Helo)":
			if(value >= 5) {
				plainAlert("No Effect");
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Controversial Speech":
		case "Cylon Refinery":
			if(value >= 6) {
				processGoodDieRoll(roll);
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Food Hoarding in the Fleet":
		case "Release Cylon Mugshots":
		case "Presidential Detention":
		case "Amputee":
			if(value >= 4) {
				plainAlert("No Effect");
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "The Passage":
		case "Galactica Falling Apart":
		case "One Last Cocktail":
		case "Requisition for Demetrius":
			if(value >= 7) {
				plainAlert("No Effect");
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Authorization of Brutal Force":
			if(value >= 3) {
				plainAlert("No Effect");
				if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
					plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
				}
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Tylium Planet":
		case "Icy Moon":
			if(value >= 3) {
				processGoodDieRoll(roll);
			} else {
				processBadDieRoll(roll);
			}
			break;
		case "Major Victory":
			if(value >= 5) {
				processGoodDieRoll(roll);
			} else {
				plainAlert("No Effect.");
			}
			break;
		case "Inspirational Speech":
		case "Food Rationing":
			if(value >= 6) {
				processGoodDieRoll(roll);
			} else {
				plainAlert("No Effect");
				if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
					plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
				}
			}
			break;
		case "Human Fleet":
			if(value >= 5) {
				damageGalactica();
			} else {
				plainAlert("No Effect");
			}
			break;
		case "CFB Basestar Placement": {
			let sector = 0;
			if(value >= 7) {
				sector = -1;
			} else if(value >= 5) {
				sector = -2;
			} else if(value === 4) {
				sector = -6;
			} else if(value === 3) {
				sector = -3;
			} else if(value === 2) {
				sector = -5;
			} else if(value === 1) {
				sector = -4;
			}
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(z.basestars[j][0] === 0) {
					z.basestars[j][0] = sector;
					t.value += "Basestar placed in CFB Sector " + (-sector) + ".\r\n";
					advancePursuit();
					break;
				}
			}
			break;
		}
		case "CFB Raider Placement": {
			let sector = 0;
			if(value >= 7) {
				sector = -1;
			} else if(value >= 5) {
				sector = -2;
			} else if(value === 4) {
				sector = -6;
			} else if(value === 3) {
				sector = -3;
			} else if(value === 2) {
				sector = -5;
			} else if(value === 1) {
				sector = -4;
			}
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiders[j] === 0) {
					z.raiders[j] = sector;
					t.value += "Raider placed in CFB Sector " + (-sector) + ".\r\n";
					advancePursuit();
					break;
				}
			}
			break;
		}
		case "CFB Heavy Raider Placement": {
			let sector = 0;
			if(value >= 7) {
				sector = -1;
			} else if(value >= 5) {
				sector = -2;
			} else if(value === 4) {
				sector = -6;
			} else if(value === 3) {
				sector = -3;
			} else if(value === 2) {
				sector = -5;
			} else if(value === 1) {
				sector = -4;
			}
			for(let j = 0; !(j >= z.heavies.length); j++) {
				if(z.heavies[j] === 0) {
					z.heavies[j] = sector;
					t.value += "Heavy Raider placed in CFB Sector " + (-sector) + ".\r\n";
					advancePursuit();
					break;
				}
			}
			break;
		}
		default:
			plainAlert("Error: no outcome associated with die roll.");
	}
}

function processBottom() {
	if(z.currentCrisis === null) {
		return null;
	}
	let done = true;
	let name = d.crisisNames[z.currentCrisis];
	switch (name) {
		case "Build Cylon Detector": {
			let deeAdmiral = (z.players[z.admiral] === "Dee");
			if(decreaseMorale()) {
				done = promptDiscards(z.admiral, 2);
			} else if(deeAdmiral) {
				done = false;
				plainAlert("Once Dee's execution is fully resolved, the new Admiral must discard 2 skill cards."); /*DEE*/
			} else {
				done = false;
				promptDiscards(z.admiral, 2, true);
			}
			break;
		}
		case "Declare Martial Law":
			if(decreasePopulation()) {
				done = promptDiscards(z.admiral, 2);
			} else {
				done = false;
				promptDiscards(z.admiral, 2, true);
			}
			break;
		case "Food Shortage":
			decreaseFood();
			if(z.president === z.turn) {
				done = promptDiscards(z.turn, 5);
			} else if(z.revealedCylons[z.turn] === 1) {
				done = promptDiscards(z.president, 2);
			} else if(promptDiscards(z.president, 2)) {
				done = promptDiscards(z.turn, 3);
			} else {
				done = false;
				promptDiscards(z.turn, 3, true);
			}
			break;
		case "Requested Resignation":
			if(z.president === z.admiral) {
				plainAlert("Dictator " + z.players[z.admiral] + " may move to the Brig, if it is their will.");
				addOption(z.president, "Move a player to the Brig", "Requested Resignation", false);
			} else {
				boldAlert("President " + z.players[z.president] + " may give the President title to Admiral " + z.players[z.admiral] +
				", or move to the Brig.");
				addOption(z.president, "Move the President title", "Requested Resignation", true);
				addOption(z.president, "Move a player to the Brig", "Requested Resignation", true);
				done = false;
			}
			break;
		case "Rescue Caprica Survivors":
		case "Sleep Deprivation":
		case "Hidden Explosives":
		case "Medal of Distinction":
		case "Demanded Surrender":
		case "Establish Sanitation":
			done = decreaseMorale();
			break;
		case "Rescue Mission (B/*)":
		case "Rescue Mission (R/*)":
			decreaseFuel();
			destroyRaptor();
			break;
		case "Rescue the Fleet":
			done = decreaseMorale();
			placeBasestar(1);
			placeRaiders(1, 3);
			placeCivilians(4, 3);
			break;
		case "Riots (B/*)":
		case "Riots (L/-)":
			done = decreasePopulation();
			decreaseFuel();
			break;
		case "Water Shortage (B/-)":
		case "Water Shortage (B/*)":
		case "Water Shortage (R/*)":
		case "The Circle":
		case "Truth and Reconciliation":
			if(z.president === z.turn) {
				done = promptDiscards(z.turn, 5);
			} else if(z.revealedCylons[z.turn] === 1) {
				done = promptDiscards(z.president, 2);
			} else if(promptDiscards(z.president, 2)) {
				done = promptDiscards(z.turn, 3);
			} else {
				done = false;
				promptDiscards(z.turn, 3, true);
			}
			break;
		case "A Verdict of Guilty":
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				done = false;
				addOption(z.turn, "Damage Pegasus", 2, true);
				addOption(z.turn, "Damage Galactica", 2, true);
				boldAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica twice.");
			} else {
				if(damageGalactica()) {
					done = damageGalactica();
				} else {
					done = false;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 1) {
							addOption(j, "Damage Galactica", undefined, false);
						}
					}
					plainAlert("Once the damage is fully resolved, damage Galactica again.");
				}
			}
			break;
		case "Assassination Plot":
			executePlayer(z.admiral);
			break;
		case "Civilian Ship Nuked":
			done = destroyPileCivilian(2);
			break;
		case "Food Hoarding in the Fleet":
		case "Pressure the Supply Ships":
			decreaseFood();
			decreaseFood();
			break;
		case "Suspicious Election Results":
			if(promptRandomDiscards(z.admiral, 1)) {
				dealSkillCard(z.admiral, 5);
			} else {
				done = false;
				addOption(z.admiral, "Draw 1 Treachery", undefined, true);
				plainAlert("After discarding, Admiral " + z.players[z.admiral] + " must draw 1 Treachery card.");
			}
			break;
		case "Ambushed by the Press":
			if (z.players[z.president] === "Romo"){
				done = promptDiscards(z.president,z.skillCardHands[z.president].length);
			} else {
				done = discardEntireHand(z.president);
			}
			break;
		case "Appoint Head of Security":
		case "Unwelcome Faces":
			if(decreaseMorale()) {
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				} else {
					done = damageGalactica();
				}
			} else {
				plainAlert("After fully resolving Dee's execution, damage Galactica."); /*DEE*/
			}
			break;
		case "Controversial Manuscript":
			increaseMorale();
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				done = false;
				addOption(z.turn, "Damage Pegasus", 2, true);
				addOption(z.turn, "Damage Galactica", 2, true);
				boldAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica twice.");
			} else {
				if(damageGalactica()) {
					done = damageGalactica();
				} else {
					done = false;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 1) {
							addOption(z.turn, "Damage Galactica", undefined, false);
						}
					}
					plainAlert("Once the damage is fully resolved, damage Galactica again.");
				}
			}
			break;
		case "Detente":
			done = false;
			if(activateBasestars()) {
				if(activateRaiders()) {
					done = activateHeavies();
				} else {
					optionForAll("Activate Heavy Raiders");
					plainAlert("Once the Raider Activation is resolved, Activate Heavy Raiders.");
				}
			} else {
				optionForAll("Activate Raiders");
				optionForAll("Activate Heavy Raiders");
				plainAlert("Once the Basestar Activation is resolved, Activate Raiders, then Activate Heavy Raiders.");
			}
			break;
		case "Interrogation":
		case "A Cylon Ally":
			if(z.turn === z.admiral) {
				done = promptDiscards(z.admiral, 5);
			} else if(z.revealedCylons[z.turn] === 1) {
				done = promptDiscards(z.admiral, 2);
			} else {
				if(promptDiscards(z.admiral, 2)) {
					done = promptDiscards(z.turn, 3);
				} else {
					done = false;
					promptDiscards(z.turn, 3, true);
				}
			}
			break;
		case "Labor Dispute":
			decreaseFuel();
			decreaseJump();
			break;
		case "Raiders Inbound":
			if(z.cag === z.admiral) {
				done = promptDiscards(z.cag, 6);
			} else if(promptDiscards(z.cag, 3)) {
				done = promptDiscards(z.admiral, 3);
			} else {
				done = false;
				promptDiscards(z.admiral, 3, true);
			}
			break;
		case "Return to Duty":
			done = activateBasestars();
			break;
		case "Review Camera Footage":
			if(z.turn === z.cag) {
				done = promptDiscards(z.cag, 5);
			} else if(z.revealedCylons[z.turn] === 1) {
				done = promptDiscards(z.cag, 2);
			} else if(promptDiscards(z.cag, 2)) {
				done = promptDiscards(z.turn, 3);
			} else {
				done = false;
				promptDiscards(z.turn, 3, true);
			}
			break;
		case "Tracked by Radiation":
			decreaseFuel();
			break;
		case "Training a Rookie": {
			/* TODO: streamline? */
			let count = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves() + mannedVipersList().length + unmannedVipersList().length;
			if(count > 2) {
				count = 2;
			}
			if(count === 0) {
				plainAlert("There are no vipers to damage.");
			} else {
				boldAlert("CAG " + z.players[z.cag] + " must damage 2 Vipers.");
				addOption(z.cag, "Damage a Viper", ["Training a Rookie", count], true);
			}
			break;
		}
		case "Widespread Starvation":
			decreaseFood();
			done = decreasePopulation();
			break;
		case "Abandon Galactica":
			decreaseFood();
			dealSkillCard(z.admiral, 5);
			dealSkillCard(z.admiral, 5);
			break;
		case "An Ambitious Operation":
			addAlert("Roll a die.  If 4 or lower, -1 Fuel.");
			done = false;
			SPTokenBad("An Ambitious Operation", z.turn);
			break;
		case "Dangerous Plots":
			if(decreaseMorale()) {
				if(z.revealedCylons[z.turn] === 0) {
					done = promptDiscards(z.turn, 3);
				}
			} else if(z.players[z.turn] !== "Dee") {
				done = false;
				promptDiscards(z.turn, 3, true);
			}
			break;
		case "Dishonest Tactics":
			decreaseFuel();
			if(me !== z.president) {
				addAlert("President " + z.players[z.president] + " draws 2 Quorum cards.");
			}
			dealQuorumCard();
			dealQuorumCard();
			break;
		case "Question Procedure":
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				done = false;
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				plainAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				promptDiscards(z.president, 3, true);
			} else {
				if(damageGalactica()) {
					done = promptDiscards(z.president, 3);
				} else {
					done = false;
					promptDiscards(z.president, 3, true);
				}
			}
			break;
		case "Requisition for Demetrius": {
			/* RULES: if the Admiral is brigged by drawing the Mutiny, who gets the Treachery? */
			let target = z.admiral;
			dealMutiny(z.admiral, false);
			if(target === "Lee" && !noDrawback(target) && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
				plainAlert("Once Lee discards for his Moral Dilemma, he must draw 2 Treachery.");
				addOption(target, "Draw 2 Treachery", undefined, true);
				done = false;
			} else if(target === "Tom" && !z.vBrutality) {
				plainAlert("Once Tom resolves his Necessary Steps, he must draw 2 Treachery.");
				addOption(target, "Draw 2 Treachery", undefined, true);
				done = false;
			} else {
				dealSkillCard(target, 5);
				dealSkillCard(target, 5);
			}
			break;
		}
		case "Starvation in Dogsville":
			addAlert("Roll a die.  If 4 or lower, -2 Food.");
			SPTokenBad("Starvation in Dogsville - Bottom Option", z.turn);
			done = false;
			break;
		case "'Demand Peace' Manifesto":
			if(z.vBrutality && versionAtLeast([1, 2, 4, 2])) {
				z.nukes -= 2;
				boldAlert("Admiral " + z.players[z.admiral] + " discards 2 Nuke tokens.");
				discardEntireHand(z.admiral);
			} else {
				/* Athena cannot use For Love on a Super Crisis */
				discardEntireHand(z.president,true);
				if(z.admiral !== z.president) {
					discardEntireHand(z.admiral,true);
				}
			}
			break;
		case "Psychological Warfare": {
			if(!z.vBrutality) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						dealSkillCard(k, 5);
						dealSkillCard(k, 5);
					}
				}
				let destinyText = "The Destiny deck is discarded:\r\n";
				while(z.destiny.length > 0) {
					let card = z.destiny.pop();
					z.skillCardDiscards[cardColorID(card)].push(card);
					destinyText += cardText(card) + "\r\n";
				}
				refreshSkillDecks();
				plainAlert(destinyText);
				for(let j = 0; z.skillCardDecks[5].length > 0 && !(j >= 6); j++) {
					z.destiny.push(z.skillCardDecks[5].pop());
					if(z.skillCardDecks[5].length === 0) {
						z.skillCardDecks[5] = shuffle(z.skillCardDiscards[5]);
						z.skillCardDiscards[5] = [];
					}
				}
				if(z.destiny.length === 0) {
					buildDestiny();
					t.value += "There were no " + colorText("brown", "Treachery") + " cards available, so a fresh " + z.destiny.length +
						"-card Destiny deck was built.\r\n";
				} else {
					plainAlert("Destiny now consists of " + z.destiny.length + " Treachery cards.");
				}
			} else {
				decreaseFuel();
				decreaseJump();
			}
			break;
		}
		case "Fighting Blind":
			executePlayer(z.cag);
			done = false;
			break;
		case "Attack on the Power Plant":
			done = decreasePopulation();
			increaseMorale();
			break;
		case "Execution List":
		case "NCP Graduation":
			done = decreasePopulation();
			break;
		case "Keeping Hera Hidden": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && !z.playerLocations[j] !== "Detention") {
						plainAlert(z.players[j] + " is the only Human on New Caprica not already in Detention, and is automatically detained.");
						movePlayer(j, "Detention");
					}
				}
			} else {
				boldAlert("President " + z.players[z.president] + " must send a Human on New Caprica to Detention.");
				addOption(z.president, "Move a player to Detention", undefined, true);
				done = false;
			}
			break;
		}
		case "Marine Reinforcements": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && !z.playerLocations[j] !== "Detention") {
						plainAlert(z.players[j] + " is the only Human on New Caprica not already in Detention, and is automatically detained.");
						movePlayer(j, "Detention");
					}
				}
			} else {
				boldAlert("Admiral " + z.players[z.admiral] + " must send a Human on New Caprica to Detention.");
				addOption(z.admiral, "Move a player to Detention", undefined, true);
				done = false;
			}
			break;
		}
		default:
			error("ERROR: No Bottom effect found.");
	}
	if(isSuperCrisis(z.currentCrisis)) {
		z.superCrisisDiscards.push(z.currentCrisis);
	}
}

function validBrigTarget() {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Stranded on Caprica" && z.playerLocations[j] !==
			"Detention") {
			return true;
		}
	}
	return false;
}

function needsOfTheFleet() {
	if(versionAtLeast([2,2,25])){
		for(let j = 0; !(j>=z.numPlayers); j++){
			if(z.players[j] !== "Seelix" && isPilot(j) && isOnGalactica(j) && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Sickbay"){
				return true;
			}
		}
		return false;
	} else {
		let count = damagedVipersII() + damagedVipersVII();
		for(let j = 0; !(j>=z.damagedLocations.length); j++){
			let loc = z.damagedLocations[j];
			if(loc !== "Food" && loc !== "Fuel" && (!z.pegasusDestroyed || 
													!(loc === "Pegasus CIC" || loc === "Airlock" || loc === "Main Batteries" || loc === "Engine Room"))){
				count++;
			}
		}
		let raiders = z.raiders.length - raidersAway();
		if(z.scarCAC){
			raiders++;
		}
		return count > raiders;
	}
}

function validSickbayTarget(except) {
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(j !== except && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Brig" && z.playerLocations[j] !== "Stranded on Caprica" && z.playerLocations[
				j] !== "Detention" && z.playerLocations[j] !== "Sickbay" && z.playerLocations[j] !== "Medical Center") {
			return true;
		}
	}
	return false;
} /* RULES: Iron Will ordering if execution involved. */
function processTop() {
	if(z.currentCrisis === null) {
		return null;
	}
	let done = true;
	switch (d.crisisNames[z.currentCrisis]) {
		case "Build Cylon Detector":
		case "Abandon Galactica":
			if(z.nukes > 0) {
				z.nukes--;
				boldAlert("The Admiral discards a Nuke Token.");
			} else {
				error("Error: you have no nukes!");
			}
			break;
		case "Declare Martial Law":
			if(decreaseMorale()) {
				movePresident(z.admiral);
			} else {
				/*DEE*/
				done = false;
				plainAlert("Once Dee's execution is fully resolved, move the President title to the Admiral.");
			}
			break;
		case "Food Shortage":
		case "Widespread Starvation":
			decreaseFood();
			decreaseFood();
			break;
		case "Requested Resignation":
			if(z.president === z.admiral) {
				done = promptDiscards(z.president, 4);
			} else {
				done = promptDiscards(z.president, 2);
				if(done) {
					done = promptDiscards(z.admiral, 2);
				} else {
					promptDiscards(z.admiral, 2, true);
				}
			}
			break;
		case "Rescue Caprica Survivors":
			decreaseFuel();
			decreaseFood();
			increasePopulation();
			break;
		case "Rescue Mission (B/*)":
		case "Rescue Mission (R/*)":
			if(decreaseMorale()) {
				if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Sickbay") {
					plainAlert(z.players[z.turn] + " is already in Sickbay.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Medical Center");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
				} else {
					movePlayer(z.turn, "Sickbay");
				}
			} else {
				if(z.players[z.turn] !== "Dee") {
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
					} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
						plainAlert("Helo is Stranded, and is not sent to Sickbay.");
					} else if(z.playerLocations[z.turn] === "Sickbay") {
						plainAlert(z.players[z.turn] + " is already in Sickbay.");
					} else if(isOnNewCaprica(z.turn)) {
						plainAlert("Damn, Apollo!");
						movePlayer(z.turn, "Medical Center");
					} else if(z.playerLocations[z.turn] === "Brig") {
						plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
					} else {
						movePlayer(z.turn, "Sickbay");
					}
				} else {
					done = false; /*DEE*/
					plainAlert("If Dee was Human, her new character must immediately move to Sickbay.");
				}
			}
			break;
		case "Rescue the Fleet":
			done = decreasePopulation();
			done = decreasePopulation() && done;
			break;
		case "Riots (B/*)":
		case "Riots (L/-)":
			decreaseFood();
			done = decreaseMorale();
			break;
		case "Sleep Deprivation":
			recallAllVipers();
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is Stranded, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Sickbay") {
				plainAlert(z.players[z.turn] + " is already in Sickbay.");
			} else if(isOnNewCaprica(z.turn)) {
				plainAlert("Damn, Apollo!");
				movePlayer(z.turn, "Medical Center");
			} else if(z.playerLocations[z.turn] === "Brig") {
				plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
			} else {
				movePlayer(z.turn, "Sickbay");
			}
			break;
		case "Water Shortage (B/-)":
		case "Water Shortage (B/*)":
		case "Water Shortage (R/*)":
			decreaseFood();
			break;
		case "A Verdict of Guilty":
			if(z.revealedCylons[z.turn] === 0) {
				let oldAdmiral = z.admiral;
				executePlayer(z.turn);
				done = false;
				plainAlert("After the execution is fully resolved, the Admiral must discard 3 skill cards.");
				if(z.turn !== oldAdmiral) {
					promptDiscards(z.admiral, 3, true);
				}
			} else {
				done = promptDiscards(z.admiral, 3);
			}
			break;
		case "Assassination Plot":
			if(z.admiral === z.turn) {
				if(promptDiscards(z.turn, 6)) {
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
				} else {
					done = false;
					addOption(z.turn, "Draw 6 Treachery", undefined, true);
					plainAlert("After discarding, " + z.players[z.turn] + " must draw 6 Treachery.");
				}
			} else if(z.revealedCylons[z.turn] === 1) {
				if(promptDiscards(z.admiral, 3)) {
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
				} else if(z.skillCardDecks[5].length >= 6 && z.daybreak) {
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					plainAlert("After Admiral " + z.players[z.admiral] + " discards, they must draw 3 Treachery cards.");
					addOption(z.admiral, "Draw 3 Treachery", undefined, true);
					done = false;
				} else {
					addOption(z.admiral, "Draw 3 Treachery", undefined, true);
					addOption(z.turn, "Draw 3 Treachery", undefined, true);
					plainAlert("After the Admiral discards, the Admiral and " + z.players[z.turn] + " must each draw 3 Treachery cards.");
					done = false;
				}
			} else {
				if(promptDiscards(z.admiral, 3)) {
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.admiral, 5);
					if(promptDiscards(z.turn, 3)) {
						dealSkillCard(z.turn, 5);
						dealSkillCard(z.turn, 5);
						dealSkillCard(z.turn, 5);
					} else {
						plainAlert("After " + z.players[z.turn] + " discards, they must draw 3 Treachery cards.");
						addOption(z.turn, "Draw 3 Treachery", undefined, true);
						done = false;
					}
				} else {
					promptDiscards(z.turn, 3, true);
					addOption(z.turn, "Draw 3 Treachery", undefined, true);
					addOption(z.admiral, "Draw 3 Treachery", undefined, true);
					plainAlert("After they discard, " + z.players[z.admiral] + " and " + z.players[z.turn] + " must each draw 3 Treachery cards.");
					done = false;
				}
			}
			break;
		case "Civilian Ship Nuked": {
			destroyPileCivilian(1);
			let numDrawers = 0;
			plainAlert("Each player discards 1 skill card and draws 1 Treachery card.");
			for(let j = 0; !(j >= z.numPlayers); j++) {
				let k = (z.turn + j) % z.numPlayers;
				if(z.revealedCylons[k] === 0) {
					if(z.players[k] !== "Romo" && z.possibleColors[5] === 1 && z.dradisBait[k]) {
						numDrawers++;
					}
					promptDiscards(k, 1, true);
				}
			}
			let athena = 0;
			if(z.forLove) {
				athena++;
			}
			if(z.numPlayers + athena > z.skillCardDecks[5].length || !z.daybreak || numDrawers > z.mutinyDeck.length - z.buriedMutinies) {
				plainAlert("The order of discards and Treachery draws may matter here.");
			}
			/* TODO: make this harder to be skipped over, but preserve CL's option to decline */
			optionForAll("Draw 1 Treachery");
			done = false;
			break;
		}
		case "Food Hoarding in the Fleet":
			decreaseMorale();
			done = false;
			addAlert("Roll a die.  If 3 or lower, draw and destroy a civilian ship.");
			SPTokenBad("Food Hoarding in the Fleet", z.turn);
			break;
		case "Pressure the Supply Ships":
			increaseFood();
			if(decreaseMorale()) {
				if(promptDiscards(z.admiral, 2)) {
					dealSkillCard(z.admiral, 5);
					dealSkillCard(z.admiral, 5);
				} else {
					plainAlert("After Admiral " + z.players[z.admiral] + " discards, they must draw 2 Treachery cards.");
					addOption(z.admiral, "Draw 2 Treachery", undefined, true);
					done = false;
				}
			} else {
				/*DEE*/
				plainAlert("After Dee's execution is fully resolved, the Admiral must discard 2 skill cards and draw 2 Treachery cards.");
				done = false;
			}
			break;
		case "Suspicious Election Results":
			passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
			break;
		case "Ambushed by the Press":
		case "Controversial Manuscript":
		case "Question Procedure":
		case "NCP Graduation":
			done = decreaseMorale();
			break;
		case "Appoint Head of Security":
			recallAllVipers();
			done = promptRandomDiscards(z.admiral, 2);
			break;
		case "Detente":
			recallAllVipers();
			done = advancePursuit();
			break;
		case "Hidden Explosives":
			destroyRaptor();
			if(z.revealedCylons[z.turn] === 1) {
				plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
				plainAlert("Helo is Stranded, and is not sent to Sickbay.");
			} else if(z.playerLocations[z.turn] === "Sickbay") {
				plainAlert(z.players[z.turn] + " is already in Sickbay.");
			} else if(isOnNewCaprica(z.turn)) {
				plainAlert("Damn, Apollo!");
				movePlayer(z.turn, "Medical Center");
			} else if(z.playerLocations[z.turn] === "Brig") {
				plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
			} else {
				movePlayer(z.turn, "Sickbay");
			}
			break;
		case "Interrogation":
			boldAlert("Admiral " + z.players[z.admiral] +
			" must choose another player to send to Sickbay."); /* RULES: can I interrogate someone who's already in Sickbay? */
			addOption(z.admiral, "Move a player to Sickbay", "Interrogation", true);
			break;
		case "Labor Dispute":
			done = decreaseMorale();
			done = decreaseMorale() && done;
			break;
		case "Medal of Distinction":
			increaseMorale();
			done = false;
			if(z.civilianPile.length === 0) {
				done = activateRaiders();
			} else {
				if(z.CFB) {
					boldAlert("CAG " + z.players[z.cag] + " must place 2 civilian ships by usual CAG rules.");
					addOption(z.cag, "Place a Civilian on the board", 2, true);
					addOption(z.cag, "Activate Raiders", undefined, true);
					plainAlert("Then, activate Raiders.");
				} else {
					boldAlert("Admiral " + z.players[z.admiral] + " must place 2 civilian ships in any space sector(s).");
					addOption(z.admiral, "Place a Civilian on the board", "Medal of Distinction", true);
					addOption(z.admiral, "Activate Raiders", undefined, true);
					plainAlert("Then, activate Raiders.");
				}
				done = false;
			}
			break;
		case "Raiders Inbound":
			done = decreasePopulation();
			if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
				done = false;
				addOption(z.turn, "Damage Pegasus", undefined, true);
				addOption(z.turn, "Damage Galactica", undefined, true);
				boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
			} else if(!done) {
				plainAlert("After Hot Dog resolves his Memento, damage Galactica.");
				addOption(getPlayerNum("Hot Dog"), "Damage Galactica", undefined, true);
			} else {
				done = damageGalactica();
			}
			break;
		case "Return to Duty": {
			let anyPilots = false;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isPilot(j) && isOnGalactica(j) && z.playerLocations[j] !== "Brig") {
					anyPilots = true;
					if(z.players[j] === "Seelix" && needsOfTheFleet()){
						plainAlert("Seelix is needed on Galactica and cannot launch.");
						continue;
					}
					if(vipersIIReserves() > 0) {
						addOption(j, "Launch in a Viper Mk II in Sector 5", undefined, false);
						addOption(j, "Launch in a Viper Mk II in Sector 6", undefined, false);
					}
					if(z.CFB && vipersVIIReserves() > 0) {
						addOption(j, "Launch in a Viper Mk VII in Sector 5", undefined, false);
						addOption(j, "Launch in a Viper Mk VII in Sector 6", undefined, false);
					}
					if(z.daybreak && vipersIIReserves() > 0) {
						addOption(j, "Launch in an Assault Raptor in Sector 5", undefined, false);
						addOption(j, "Launch in an Assault Raptor in Sector 6", undefined, false);
					}
					if(isUnmannedInSpace() && (vipersIIReserves() === 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0)) {
						addOption(j, "Recall an unmanned Viper", "Launch", false);
					}
				}
			}
			if(anyPilots) {
				boldAlert("Any character on Galactica with Piloting in their skill set may immediately launch themselves in a Viper.");
				plainAlert("Then, Launch Raiders.");
				optionForAll("Launch Raiders");
				done = false;
				break;
			} else {
				plainAlert("There are no pilots eligible to launch.");
				done = launchRaiders();
			}
			break;
		}
		case "Review Camera Footage":
			done = false;
			if(vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) {
				if(vipersIIReserves() === 0) {
					plainAlert("There are no vipers in the Reserves to damage.");
				} else if(vipersIIReserves() === 1) {
					plainAlert("1 Viper Mk II damaged in the Reserves.");
				} else {
					plainAlert("2 Vipers Mk II damaged in the Reserves.");
				}
				let count = 0;
				for(let j = 0; !(j >= z.vipersII.length) && 2 > count; j++) {
					if(z.vipersII[j] === 0) {
						z.vipersII[j] = -1;
						count++;
					}
				}
				if(advancePursuit()) {
					plainAlert("CAG " + z.players[z.cag] + " may activate an unmanned Viper.");
				} else {
					plainAlert("After civilian placement, CAG " + z.players[z.cag] + " may activate an unmanned Viper.");
				}
				addOption(z.cag, "Activate an unmanned Viper", 1, false); /* TODO: other streamlines? */
			} else {
				let count = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves();
				if(count > 2) {
					count = 2;
				}
				boldAlert(z.players[z.turn] + ", as current player, must damage 2 Vipers in the Reserves (if able).");
				if(count > 0) {
					addOption(z.turn, "Damage a Viper", ["Review Camera Footage", count], true);
				}
				optionForAll("Advance the Pursuit Track");
				plainAlert("Then, advance the Pursuit Track by 1.");
				plainAlert("Then, CAG " + z.players[z.cag] + " may activate an unmanned Viper.");
				addOption(z.cag, "Activate an unmanned Viper", 1, false);
				done = false;
			}
			break;
		case "The Circle":
			boldAlert("President " + z.players[z.president] + " must choose another player to receive the President title or execute " + z.players[z.turn] +
				".");
			addOption(z.president, "Move the President title", "The Circle", true);
			addOption(z.president, "Execute a player", "The Circle", true);
			done = false;
			break;
		case "Tracked by Radiation":
			placeBasestar(1);
			placeRaiders(1, 3);
			placeCivilians(4, 2);
			break;
		case "Training a Rookie":
			/* RULES: who activates the viper? */ if(isUnmannedInSpace() || vipersIIReserves() > 0 || vipersVIIReserves() > 0 || assaultRaptorsReserves() > 0) {
				boldAlert("CAG " + z.players[z.cag] + " must now activate an unmanned Viper, then activate Raiders.");
				addOption(z.cag, "Activate an unmanned Viper", 1, true);
				plainAlert("Then, Activate Raiders.");
				addOption(z.cag, "Activate Raiders", undefined, true);
				done = false;
			} else {
				plainAlert("There are no unmanned vipers to activate.");
				done = activateRaiders();
			}
			break;
		case "Truth and Reconciliation":
			done = false;
			if(decreaseMorale()) {
				if(validBrigTarget()) {
					boldAlert("President " + z.players[z.president] + " must choose a character to send to the Brig.");
					addOption(z.president, "Move a player to the Brig", undefined, true);
				} else {
					plainAlert("No players can be sent to the Brig at this time.");
					done = true;
				}
			} else {
				/*DEE*/
				plainAlert("After Dee's execution is fully resolved, the President must choose a character to send to the Brig.");
			}
			break;
		case "Unwelcome Faces":
			/* RULES: TODO: what if the discards send the Admiral to the Brig due to For Love or Deceitful? */
			if(z.players[z.admiral] === "Romo"){
				promptDiscards(z.admiral,z.skillCardHands[z.admiral].length);
				if(validBrigTarget()){
					addOption(z.admiral, "Move a player to the Brig", undefined, true);
					plainAlert("Admiral " + z.players[z.admiral] + " must then choose a character to send to the Brig.");
				}
				done = false;
			} else if(discardEntireHand(z.admiral)){
				if(validBrigTarget()) {
					done = false;
					addOption(z.admiral, "Move a player to the Brig", undefined, true);
					boldAlert("Admiral " + z.players[z.admiral] + " must choose a character to send to the Brig.");
				} else {
					plainAlert("No players can be sent to the Brig at this time.");
				}
			} else {
				done = false;
				/* TODO: this could stall if the Admiral is brigged by the discards */
				if(validBrigTarget()){
					addOption(z.admiral, "Move a player to the Brig", undefined, true);
					plainAlert("Admiral " + z.players[z.admiral] + " must then choose a character to send to the Brig.");
				}
			}
			break;
		case "An Ambitious Operation": {
			decreaseFuel();
			let validTargets = false;
			for(let j = 0; !(j >= z.numPlayers) && !validTargets; j++) {
				validTargets = (z.revealedCylons[j] === 0 || isTheCylonLeader(j)) && (z.miracles[j] === 0 || (z.players[j] === "Gaius" && z.miracles[j] !==
					3));
			}
			if(validTargets) {
				boldAlert("Admiral " + z.players[z.admiral] + " must now choose another player to gain 1 Miracle Token.");
				done = false;
				addOption(z.admiral, "Choose a player to gain a Miracle Token from An Ambitious Operation", undefined, true);
			} else {
				plainAlert("There are no players who can gain a Miracle Token.");
			}
			break;
		}
		case "Dangerous Plots":
			if(characterPresent("Tom") && (!z.vBrutality || z.players[z.admiral] !== "Tom")) {
				done = false;
				dealMutiny(z.admiral, false);
				plainAlert("Once Necessary Steps is resolved, deal a Mutiny to President " + z.players[z.president] + ".");
				addOption(getPlayerNum("Tom"), "Deal a Mutiny card", "Dangerous Plots", true);
			} else {
				dealMutiny(z.admiral, false);
				dealMutiny(z.president, false);
				done = (z.admiral !== "Lee") && (z.president !== "Lee");
			}
			break;
		case "Dishonest Tactics":
			if(decreaseMorale()) {
				if(someoneInBrig()) {
					boldAlert("President " + z.players[z.president] + " may move a player from the Brig to Command.");
					addOption(z.president, "Move a player out of the Brig", "Dishonest Tactics", false);
					done = false;
				}
			} else {
				/*DEE*/
				plainAlert("After Dee's execution is fully resolved, the President may move a player from the Brig to Command.");
				done = false;
			}
			break;
		case "Requisition for Demetrius":
			decreaseFood();
			addAlert("Roll a die.  If 6 or lower, shuffle 2 Treachery cards into Destiny.");
			SPTokenBad("Requisition for Demetrius", z.turn);
			done = false;
			break;
		case "Starvation in Dogsville":
			addAlert("Roll a die.  If 4 or lower, -1 Population, -1 Food.");
			SPTokenBad("Starvation in Dogsville - Top Option", z.turn);
			done = false;
			break;
		case "'Demand Peace' Manifesto":
			if(decreaseMorale()) {
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
					done = false;
					boldAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica twice.");
					addOption(z.turn, "Damage Pegasus", 2, true);
					addOption(z.turn, "Damage Galactica", 2, true);
				} else {
					if(damageGalactica()) {
						done = damageGalactica();
					} else {
						done = false;
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.revealedCylons[j] === 1) {
								addOption(j, "Damage Galactica", undefined, false);
							}
						}
						plainAlert("Once the damage is fully resolved, damage Galactica again.");
					}
				}
			} else {
				/*DEE*/
				plainAlert("After Dee's execution is fully resolved, damage Galactica twice.");
				done = false;
			}
			break;
		case "Psychological Warfare":
			if(z.vBrutality) {
				done = decreaseMorale();
				done = decreaseMorale() && done;
			} else {
				done = false;
				if(decreaseMorale()) {
					let numDrawers = 0;
					boldAlert("Each player discards 2 skill cards and draws 2 Treachery cards.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0 && z.skillCardHands[j].length > 0) {
							addOption(j, "Discard a Skill Card", 2, true);
							if(z.possibleColors[j][5] === 1 && z.dradisBait[j]) {
								numDrawers++;
							}
						}
					}
					if(z.forLove) {
						plainAlert("Athena may not use For Love to prevent discards from a Super Crisis.");
					}
					if(characterPresent("Romo")) {
						plainAlert("Romo's Deceitful ability does not apply to Super Crises.");
					}
					if(2 * z.numPlayers > z.skillCardDecks[5].length || !z.daybreak || numDrawers > z.mutinyDeck.length - z.buriedMutinies) {
						plainAlert("The order of discards and Treachery draws may matter here.");
					}
					optionForAll("Draw 2 Treachery");
				} else {
					/*DEE*/
					plainAlert("After fully resolving Dee's execution, each player must discard 2 skill cards and draw 2 Treachery cards.");
				}
			}
			break;
		case "Fighting Blind":
			if(centurionReserves() >= 2) {
				boardGalactica();
				boardGalactica();
				boldAlert("Two Centurions board Galactica.");
			} else if(centurionReserves() === 1) {
				boardGalactica();
				boldAlert("One Centurion boards Galactica.");
				plainAlert("All " + z.centurions.length + " Centurions are now on board Galactica.");
			} else {
				plainAlert("All Centurions are now on board Galactica; no effect.");
			}
			break;
		case "A Cylon Ally":
			if(isOnNewCaprica(z.turn)) {
				if((z.galacticaAway || z.preparedCivilians.length === 0) && z.lockedCivilians.length === 0) {
					plainAlert("No ships can be prepared or evacuated.");
				} else {
					/* RULES: who makes this choice? */
					if((z.galacticaAway || z.preparedCivilians.length === 0)){
						prepareCivilian();
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must now prepare or evacuate a Civilian.");
						if(z.lockedCivilians.length > 0) {
							addOption(z.turn, "Prepare a Civilian", undefined, true);
						}
						addOption(z.turn, "Evacuate a Civilian", undefined, true);
						done = false;
					}
				}
				if(z.playerLocations[z.turn] === "Detention") {
					plainAlert(z.players[z.turn] + " is already in Detention; no die roll necessary.");
				} else {
					addAlert("Roll a die; on a 5 or less, send " + z.players[z.turn] + " to Detention.");
					SPTokenBad("A Cylon Ally", z.turn);
					done = false;
				}
			} else {
				error("ERROR: you cannot pick this option");
			}
			break;
		case "Attack on the Power Plant":
			if(decreaseMorale()) {
				boldAlert("Each Human player draws 2 skill cards.");
			} else {
				/*DEE*/
				plainAlert("After fully resolving Dee's execution, each Human player must draw 2 skill cards.");
			}
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.revealedCylons[j] === 0) {
					addOption(j, "Draw 2 Skill Cards", undefined, true);
				}
			}
			break;
		case "Demanded Surrender": {
			let validTargets = 0;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
					validTargets++;
				}
			}
			if(validTargets === 0) {
				plainAlert("There are no Humans on New Caprica; no effect.");
			} else if(validTargets === 1) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(isOnNewCaprica(j) && z.revealedCylons[j] === 0 && z.playerLocations[j] !== "Detention") {
						plainAlert(z.players[j] + " is the only Human on New Caprica not already in Detention, and is automatically detained.");
						movePlayer(j, "Detention");
					}
				}
			} else {
				boldAlert("President " + z.players[z.president] + " must send a Human on New Caprica to Detention.");
				addOption(z.president, "Move a player to Detention", undefined, true);
				done = false;
			}
			break;
		}
		case "Establish Sanitation":
			z.establishSanitation = true;
			plainAlert("The Prepare for Jump step of this turn will be skipped.");
			break;
		case "Execution List":
			addAlert("Roll a die; on a 5 or less, President " + z.players[z.president] + " is Executed.");
			SPTokenBad("Execution List", z.turn);
			done = false;
			break;
		case "Keeping Hera Hidden":
			shuffleTreachery();
			break;
		case "Marine Reinforcements": {
			let spaces = [0, 0, 0];
			for(let j = 0; !(j >= z.OFs.length); j++) {
				if(z.OFs[j] > 0) {
					spaces[z.OFs[j] - 1] = 1;
				}
			}
			let numSpaces = spaces[0] + spaces[1] + spaces[2];
			if(numSpaces === 0 || numSpaces === 1) {
				for(let j = 0; !(j >= z.OFs.length); j++) {
					if(z.OFs[j] > 0) {
						z.OFs[j] = 0;
						boldAlert("Destroyed an Occupation Force.");
						break;
					}
				}
				if(z.turn === z.admiral) {
					done = promptDiscards(z.admiral, 5);
				} else if(z.revealedCylons[z.turn] === 1) {
					done = promptDiscards(z.admiral, 2);
				} else {
					if(promptDiscards(z.admiral, 2)) {
						done = promptDiscards(z.turn, 3);
					} else {
						done = false;
						promptDiscards(z.turn, 3, true);
					}
				}
			} else {
				boldAlert(z.players[z.turn] + ", as current player, must destroy an Occupation Force.");
				if(z.admiral === z.turn) {
					promptDiscards(z.admiral, 5, true);
				} else if(z.revealedCylons[z.turn] === 1) {
					promptDiscards(z.admiral, 2, true);
				} else {
					promptDiscards(z.admiral, 2, true);
					promptDiscards(z.turn, 3, true);
				}
				done = false;
				addOption(z.turn, "Destroy an Occupation Force", undefined, true);
			}
			break;
		}
		default:
			error("Error: No Top Outcome Found.");
	}
	if(isSuperCrisis(z.currentCrisis)) {
		z.superCrisisDiscards.push(z.currentCrisis);
	}
} /* TODO: check all the numbers are right */
function processSkillCheckOutcome(fakeAutoPass) {
	removeFromAll("[Human Delusion] Play a card into the skill check");
	let result = "";
	let autoPass = fakeAutoPass || z.autoPass;
	z.autoPass = false;
	let autoFail = fakeAutoPass !== undefined && !autoPass;
	if(autoPass) {
		result = "PASS";
	} else if(autoFail) {
		result = "FAIL";
	}
	if(z.currentSkillCheck === null) {
		return null;
	}
	let name = "";
	if(!Number.isInteger(z.currentSkillCheck)) {
		name = z.currentSkillCheck;
	} else {
		name = d.crisisNames[z.currentSkillCheck];
	}
	let done = true;
	let tally = 0;
	if(!autoPass && !autoFail) {
		let sct = skillCheckTally(true);
		result = sct[1];
		tally = sct[2];
		if(z.secondChance) {
			let goal = 1000;
			switch (z.currentSkillCheck) {
				case "Airlock":
					goal = 16;
					break;
				case "Brig":
				case "Admiral's Quarters":
				case "Resistance HQ":
					goal = 11;
					break;
				case "Detention":
					goal = 13;
					break;
				default:
					goal = d.difficulty[z.currentSkillCheck] + 4;
			}
			if(tally >= goal && (z.revealedCylons[z.turn] === 0 || isTheCylonLeader(z.turn)) && (!z.vBrutality || z.players[z.turn] !== "D'Anna") && 
					(z.miracles[z.turn] === 0 || (z.players[z.turn] === "Gaius" && z.miracles[z.turn] !== 3))) {
				z.miracles[z.turn]++;
				addAlert(z.players[z.turn] + " gains a Miracle Token from A Second Chance.");
				t.value += bold(z.players[z.turn] + " gains a Miracle Token from " + colorText("purple", "A Second Chance")) + ".\r\n";
				z.secondChance = false;
			}
		}
		if(0 >= tally && z.ironWill) {
			let deadDee = z.graveyard.includes("Dee");
			for(let j = 0; !(j >= z.numPlayers) && !deadDee; j++) {
				if(z.revealedCylons[j] === 1 && z.players[j] === "Dee") {
					deadDee = true;
				}
			}
			if(deadDee && z.morale === 2) {
				plainAlert("Unless Dee died due to this this Iron Will, you must decrease Morale by 1 now.");
				optionForAll("Decrease a resource", "Iron Will");
			} else if(!decreaseMorale()) {
				plainAlert("After fully resolving Dee's execution, process the skill check outcome again.");
				mainMenu();
				return;
			}
		}
	}
	z.processedOutcome = true;
	if(isMission(z.currentSkillCheck)) {
		switch (z.currentSkillCheck) {
			case 203:
				if(result === "PASS") {
					addAlert("Attack on the Colony: PASS");
					if(z.basestars.length > 0 && z.basestars[0][0] > 0) {
						while(z.basestars[0].length > 1) {
							z.basestarDamage.push(z.basestars[0].pop());
						}
						z.basestars[0] = [0];
						shuffle(z.basestarDamage);
					}
					if(z.basestars.length > 1 && z.basestars[1][0] > 0) {
						while(z.basestars[1].length > 1) {
							z.basestarDamage.push(z.basestars[1].pop());
						}
						z.basestars[1] = [0];
						shuffle(z.basestarDamage);
					}
					/* TODO: new CFB rules (cannot remove from CFB unless both on CFB) */
					let numCFB = 0;
					if(z.CFB) {
						/* RULES: does it remove basestars from the CFB? */
						if(z.basestars.length > 0 && 0 > z.basestars[0][0]) {
							numCFB++;
						}
						if(z.basestars.length > 1 && 0 > z.basestars[1][0]) {
							numCFB++;
						}
					}
					if(numCFB === 2){
						if(z.basestars[1][0] === z.basestars[0][0]){
							z.basestars = [z.basestars[0][0]];
							boldAlert("Removed one basestar on CFB Sector "+(-z.basestars[0][0])+" from the game.");
						} else {
							plainAlert(z.players[z.turn] + " must remove a basestar on the CFB from the game.");
							addOption(z.turn,"[Attack on the Colony] Remove a basestar from the game",undefined,true);
							done = false;
						}
					} else if(numCFB === 1){
						if(z.basestars.length === 1){
							boldAlert("Removed the basestar on the CFB from the game.");
							z.basestars = [];
						} else {
							if(z.basestars[0][0] === 0){
								z.basestars.shift();
							} else {
								z.basestars.pop();
							}
							boldAlert("Removed the basestar that is not on the CFB from the game.");
						}	
					} else {
						if(z.basestars.length === 0){
							plainAlert("No effect.");
						} else {
							boldAlert("Removed all Basestars from the game board.\nRemoved 1 Basestar from the game.");
							z.basestars.pop();
						}
						
					}
				} else {
					addAlert("Attack on the Colony: FAIL");
					placeBasestar(1);
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
						plainAlert(z.players[z.turn] + ", as current player, must choose whether to damage Pegasus or Galactica.");
						addOption(z.turn, "Damage Pegasus", undefined, true);
						addOption(z.turn, "Damage Galactica", undefined, true);
						done = false;
					} else {
						done = damageGalactica();
					}
				}
				break;
			case 204:
				if(result === "PASS") {
					addAlert("Cylon Civil War: PASS");
					z.rebelBasestar = 1;
					boldAlert("The Rebel Basestar is now in play, with Human Allegiance.");
				} else {
					addAlert("Cylon Civil War: FAIL");
					z.rebelBasestar = -1;
					boldAlert("The Rebel Basestar is now in play, with Cylon Allegiance.");
				}
				break;
			case 205:
				if(result === "PASS") {
					addAlert("Destroy the Hub: PASS");
					z.hubDestroyed = true;
					addAlert("Hub Destroyed!");
					t.value += bold("Hub Destroyed: Cylon Locations overlay flipped.") + "\r\n";
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.playerLocations[j] === "Resurrection Ship") {
							movePlayer(j, "Hub Destroyed");
						}
					}
				} else {
					addAlert("Destroy the Hub: FAIL");
					done = decreasePopulation();
					recallAllVipers();
					if(assaultRaptorsReserves() > 0 || (z.CFB && vipersVIIReserves() > 0)) {
						let count = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves() + mannedVipersList().length + unmannedVipersList()
							.length;
						if(count > 2) {
							count = 2;
						}
						plainAlert(z.players[z.turn] + ", as current player, must damage 2 Vipers.");
						addOption(z.turn, "Damage a Viper", ["Destroy the Hub", count], true);
						done = false;
					} else {
						let damaged = 0;
						for(let j = 0; !(j >= z.vipersII.length) && !(damaged >= 2); j++) {
							if(z.vipersII[j] === 0) {
								z.vipersII[j] = -1;
								damaged++;
							}
						}
						boldAlert("Two Vipers Mk II damaged.");
					}
				}
				break;
			case 206:
				if(result === "PASS") {
					addAlert("Digging up the Past: PASS");
					z.destinationDiscards.push(35);
					processDestination();
					done = false;
				} else {
					addAlert("Digging up the Past: FAIL");
					shuffleTreachery();
				}
				break;
			case 207:
				if(result === "PASS") {
					addAlert("Needs of the People: PASS");
					if(z.vBrutality && versionAtLeast([1, 2, 4, 6])) {
						increaseFuel();
					} else {
						increaseFood();
					}
					increaseFood();
					let damageCount = 0;
					for(let j = 0; !(j >= z.damagedLocations.length); j++) {
						if(z.damagedLocations[j] !== "Food" && z.damagedLocations[j] !== "Fuel") {
							if(z.pegasus && z.pegasusDestroyed && onPegasus(z.damagedLocations[j])) {
								continue;
							}
							damageCount++;
						}
					}
					if(damageCount === 0) {
						plainAlert("There are no damaged locations to repair.");
					} else if(damageCount === 1) {
						for(let j = 0; !(j >= z.damagedLocations.length); j++) {
							if(z.damagedLocations[j] !== "Food" && z.damagedLocations[j] !== "Fuel") {
								if(z.pegasus && z.pegasusDestroyed && onPegasus(z.damagedLocations[j])) {
									continue;
								}
								let damage = z.damagedLocations.splice(j, 1)[0];
								boldAlert(damage + " repaired.");
								if(z.pegasus && onPegasus(damage) && !z.vAltDamage) {
									z.pegasusDamage.push(damage);
									shuffle(z.pegasusDamage);
								} else {
									z.damage.push(damage);
									shuffle(z.damage);
								}
								break;
							}
						}
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must repair a location.");
						addOption(z.turn, "Repair a location", undefined, true);
						done = false;
					}
				} else {
					addAlert("Needs of the People: FAIL");
					decreaseFood();
					addAlert("All Humans receive a Treachery.");
					dealSkillCardToEveryone(z.turn, 5, false);
				}
				break;
			case 208:
				if(result === "PASS") {
					addAlert("Rescue Hera: PASS");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0 && z.miracles[j] === 0 && (!z.vBrutality || z.miracles[j] !== "D'Anna")) {
							boldAlert(z.players[j] + " gains a Miracle Token.");
							z.miracles[j] = 1;
						}
					}
					if(z.assist !== undefined && z.assistMiracle === 0) {
						boldAlert(z.assist + " gains a Miracle Token.");
						z.assistMiracle = 1;
					}
				} else {
					addAlert("Rescue Hera: FAIL");
					done = decreaseMorale();
					destroyRaptor();
				}
				break;
			case 209:
				if(result === "PASS") {
					addAlert("The Red Stripes: PASS");
					for(let j = 0; !(j >= z.heavies.length); j++) {
						z.centurions[j] = 0;
						if(z.heavies[j] > 0) {
							z.heavies[j] = 0;
						}
					}
					let CFBremoved = false;
					if(z.CFB) {
						/* RULES: does it remove heavies from the CFB? */
						for(let j = 0; !(j >= z.heavies.length); j++) {
							if(0 > z.heavies[j]) {
								plainAlert("Removed a Heavy Raider from Sector " + (-z.heavies[j]) + " of the CFB.");
								CFBremoved = true;
								z.heavies[j] = 0;
							}
						}
					}
					addAlert("Removed all Heavy Raiders and Centurions from the game board.\nRemoved 2 Heavy Raiders and 2 Centurions from the game.");
					t.value += bold("All Heavy Raiders and Centurions removed from the board.") + "\r\n";
					t.value += bold("Two Heavy Raiders and Centurions removed from the game.") + "\r\n";
					if(z.heavies.length === 4) {
						z.heavies = [0, 0];
						z.centurions = [0, 0];
					} else {
						z.heavies = [];
						z.centurions = [];
					}
					if(CFBremoved) {
						done = false;
						plainAlert(
							"All Heavy Raiders were also removed from the CFB.  If the current player does not want to remove those Heavies from the game, they should be returned to the CFB now."
							);
						addOption(z.turn, "Place a Heavy Raider on the Cylon Fleet Board", undefined, false);
					}
				} else {
					addAlert("The Red Stripes: FAIL");
					placeHeavy(1);
					if(boardGalactica()) {
						boldAlert("A Centurion boards Galactica.");
					} else {
						t.value += "All Centurions are already on Galatica: no effect.\r\n";
					}
				}
				break;
			case 210:
				if(result === "PASS") {
					addAlert("The Search for Home: PASS");
					z.destinationDiscards.push(36);
					processDestination();
					done = false;
				} else {
					addAlert("The Search for Home: FAIL");
					decreaseFuel();
				}
				break;
		}
		if(z.stim !== null && z.revealedCylons[z.turn] === 0 && z.playerLocations[z.turn] === z.stim && z.numPlayers + z.boxedPlayers.length > 1) {
			if(!z.xo && z.SoEPlayer === -1) {
				boldAlert("Kat is a Stim Junkie.");
				movePlayer(z.turn, "Sickbay");
			} else {
				plainAlert("If it is the end of Kat's Action Step, move her to Sickbay now due to her Stim Junkie drawback.");
				optionForAll("Move a player to Sickbay", "Stim Junkie");
			}
		}
		if(characterPresent("Cain") && z.vBrutality && versionAtLeast([2,1,9]) && z.players[z.turn] === "Cain" && anyUndamagedBasestars()){
			if(!z.xo && z.SoEPlayer === -1) {
				boldAlert("Cain is Bent on Revenge.");
				dealMutiny(z.turn);
			} else {
				plainAlert("If it is the end of Cain's Action Step, she must now draw a Mutiny due to her Bent on Revenge drawback.");
				addOption(me,"Draw a Mutiny card","Bent on Revenge",true);
			}
		}
		if(z.expertPilot && (isInSpace(z.turn) || !z.vBrutality || !versionAtLeast([1, 2, 4, 2])) && z.players[z.turn] === "Starbuck" && z.turn !== z.theSympatheticCylon) {
			plainAlert("Remember that Starbuck still may take an Expert Pilot action this turn.");
			addOption(z.turn,"Expert Pilot",undefined,false);
		}
	} else if(result === "PASS") {
		/* TODO: make sure everything shows up in alerts */
		addAlert("The result of the " + name + " skill check is: PASS.");
		t.value += bold("The result of the " + name + " skill check is: " + colorText("green", "PASS")) + ".\r\n";
		if(z.changeOfPlans) {
			/* TODO: add warning if a deck may reshuffle from the draws.  Also applies to Support the People, Attack on the Power Plant, Dissent among Cylons.  Also weird consult the oracle interactions.*/
			addAlert("Every Human must draw 2 skill cards.");
			done = false;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.revealedCylons[j] === 0) {
					addOption(j, "Draw 2 Skill Cards", undefined, true);
				}
			}
		} else if(z.criticalMission && !versionAtLeast([2,1,13])) {
			increaseJump();
		} else if(z.engineRoom && z.vBrutalityPlus && Number.isInteger(z.currentSkillCheck) && (z.currentSkillCheck > 172 || 160 > z.currentSkillCheck) ){
			increaseJump();
		} else {
			switch (z.currentSkillCheck) {
				case "Brig":
					if(z.thisTarget === null) {
						plainAlert("No Effect");
					} else if(z.revealedCylons[z.thisTarget] === 1) {
						plainAlert("You cannot use the Brig to infiltrate.");
					} else {
						boldAlert(z.players[z.thisTarget] + " may move to any location on Galactica.");
						addOption(z.thisTarget, "Move a player out of the Brig", "Escape", true);
						done = false;
					}
					break;
				case "Administration":
					if(z.thisTarget !== null && z.revealedCylons[z.thisTarget] === 0 && z.thisTarget !== z.theSympatheticCylon && !isTheCylonLeader(z.thisTarget) && 
						z.thisTarget !== z.president) {
						movePresident(z.thisTarget);
					} else {
						plainAlert("No Effect.");
					}
					break;
				case "Admiral's Quarters":
					if(z.thisTarget === null) {
						plainAlert("It seems they found a loophole: you can't brig a dead guy!");
					} else if(z.revealedCylons[z.thisTarget] === 1) {
						plainAlert(z.players[z.turn] + " is a revealed Cylon, and cannot be sent to the Brig.");
					} else if(!autoPass && characterPresent("Cain") && tally >= 10 && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
						boldAlert("Cain may use her Intolerant ability to execute " + z.players[z.thisTarget] + ".");
						addOption(getPlayerNum("Cain"), "Execute a player", ["Intolerant", z.thisTarget], true);
						plainAlert("If she does not, they are sent to the Brig instead.");
						addOption(getPlayerNum("Cain"), "Move a player to the Brig", ["Intolerant", z.thisTarget], true);
						done = false;
					} else if(z.playerLocations[z.thisTarget] === "Stranded on Caprica") {
						plainAlert("Helo cannot be brigged while he is Stranded.");
					} else if(isOnNewCaprica(z.thisTarget)) {
						movePlayer(z.thisTarget, "Detention");
					} else {
						movePlayer(z.thisTarget, "Brig");
					}
					break;
				case "Airlock":
					if(z.thisTarget === null) {
						plainAlert("What is dead may never die.");
					} else if(z.revealedCylons[z.thisTarget] === 1) {
						plainAlert(z.players[z.turn] + " is a revealed Cylon, and cannot be Airlocked.");
					} else {
						executePlayer(z.thisTarget);
						done = false;
					}
					break;
				case "Detention":
					if(z.thisTarget === null) {
						plainAlert("No Effect");
					} else if(z.revealedCylons[z.thisTarget] === 1) {
						plainAlert("You cannot use Detention to infiltrate.");
					} else {
						boldAlert(z.players[z.thisTarget] + " may move to any location on New Caprica.");
						addOption(z.thisTarget, "Move a player out of Detention", "Escape", true);
						done = false;
					}
					break;
				case "Resistance HQ":
					if(z.thisTarget === null) {
						plainAlert("Error: this shouldn't have happened.");
					} else {
						executePlayer(z.thisTarget);
						done = false;
					}
					break;
				case 0:
				case 1:
				case 6:
				case 9:
				case 11:
				case 12:
				case 14:
				case 15:
				case 17:
				case 18:
				case 26:
				case 30:
				case 31:
				case 33:
				case 34:
				case 36:
				case 38:
				case 39:
				case 46:
				case 51:
				case 52:
				case 56:
				case 58:
				case 60:
				case 61:
				case 62:
				case 68:
				case 69:
				case 71:
				case 75:
				case 81:
				case 88:
				case 89:
				case 90:
				case 93:
				case 98:
				case 100:
				case 101:
				case 102:
				case 104:
				case 112:
				case 114:
				case 122:
				case 126:
				case 127:
				case 130:
				case 137:
				case 141:
				case 142:
				case 145:
				case 146:
				case 148:
				case 150:
				case 151:
				case 154:
				case 157:
				case 160:
				case 161:
				case 163:
				case 169:
				case 171:
				case 172:
				case 174:
				case 176:
				case 177:
				case 178:
				case 179:
				case 180:
				case 186:
				case 187:
				case 192:
				case 194:
				case 196:
				case 198:
					plainAlert("No Effect.");
					break;
				case 3:
					/* Analyze Enemy Fighter */ if(z.raptors !== 4 && !z.galacticaAway) {
						boldAlert("1 Raptor Repaired.");
						z.raptors++;
						if(z.raptors === 1){
							plainAlert("There is now 1 intact Raptor.");
						} else {
							plainAlert("There are now " + z.raptors + " intact Raptors.");
						}
					} else {
						plainAlert("There are no destroyed Raptors to repair.");
					}
					break;
				case 8:					/* Colonial Day */
				case 105:				/* In the Ring */
				case 107:				/* Joe's Bar */
				case 190:				/* Labor Union Strike */ 
					increaseMorale();
					break;
				case 10:				/* Cripped Raider */
				case 37:				/* Network Computers */
				case 94:				/* Consult the Prisoner */
				case 110:				/* Mysterious Guide */
				case 121:				/* The Passage */
				case 144:				/* Hybrid in Panic */ 
					increaseJump();
					done = z.jumpTrack !== 5;
					break;
				case 23:				/* Forced Water Mining */
				case 50:				/* Scouting for Water */
				case 86:				/* The Black Market */ 
					increaseFood();
					break;
				case 24: {
					/* Fulfiller of Prophecy */ let card = dealSkillCard(z.turn, 0);
					if(me === z.turn){
						addAlert("You drew " + cardText(card) + ".");
					} else {
						addAlert(z.players[z.turn]+" draws a Politics card.");
					}
					break;
				}
				case 25:
					/* Guilt by Collusion */ 
					boldAlert(z.players[z.turn] + ", as current player, may choose a character to move to the Brig.");
					addOption(z.turn, "Move a player to the Brig", undefined, false);
					done = false;
					break;
				case 28:				/* Informing the Public */
				case 57:				/* Terrorist Investigations */
				case 74:				/* Code Blue */ 
					if(z.detectorSabotage) {
						plainAlert("Loyalty cards may not be inspected due to Detector Sabotage; no effect.");
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to any player.");
						addOption(z.turn, "Inspect a random Loyalty card of another player", undefined, true);
						done = false;
					}
					break;
				case 32:
					/* Legendary Discovery */ z.destinationDiscards.push(34);
					processDestination();
					done = false;
					break;
				case 35:
					/* Mandatory Testing */ if(z.president === z.turn) {
						plainAlert("The President may not look at their own loyalty cards: no effect.");
					} else if(isTheCylonLeader(z.turn) || (z.turn === z.theSympatheticCylon && z.loyaltyHands[z.turn].length === 1) || z.loyaltyHands[z.turn]
						.length === 0) {
						plainAlert(z.players[z.turn] + " has no Loyalty cards: no effect.");
					} else if(z.detectorSabotage) {
						plainAlert("Loyalty cards may not be inspected due to Detector Sabotage; no effect.");
					} else {
						boldAlert("President " + z.players[z.president] + " must look at a random loyalty card belonging to " + z.players[z.turn] + ".");
						addOption(z.president, "Inspect a random Loyalty card of another player", "Mandatory Testing", true);
						done = false;
					}
					break;
				case 49:
					/* Scouting for Fuel */ increaseFuel();
					break;
				case 78:
					/* Medical Breakthrough */ boldAlert("Each Human Player draws 1 skill card.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0) {
							addOption(j, "Draw 1 Skill Card", "Medical Breakthrough", true);
						}
					}
					done = false;
					break;
				case 80:
					/*Reunite the Fleet */ increasePopulation();
					break;
				case 82:
					/*Sabotage Investigated */ decreaseFood();
					break;
				case 84:
					/*Standoff with Pegasus */ if(someoneInBrig()) {
						boldAlert(z.players[z.turn] + ", as current player, may move a character from the Brig to any other Galactica location.");
						addOption(z.turn, "Move a player out of the Brig", undefined, false);
						done = false;
					} else {
						plainAlert("No one is in the Brig: No Effect.");
					}
					break;
				case 96:
					/* Cylon Genocide */ boldAlert("All Cylon ships on the main game board are destroyed.");
					for(let j = 0; !(j >= z.raiders.length); j++) {
						if(z.raiders[j] > 0) {
							z.raiders[j] = 0;
						}
					}
					if(Number.isInteger(z.heavyCasualties)){
						z.heavyCasualties = 0;
					}
					for(let j = 0; !(j >= z.heavies.length); j++) {
						if(z.heavies[j] > 0) {
							z.heavies[j] = 0;
						}
					}
					for(let j = 0; !(j >= z.basestars.length); j++) {
						if(z.basestars[j][0] > 0) {
							done = (!z.theGuardians || z.morale !== 3 || !characterPresent("Dee") || noDrawback(getPlayerNum("Dee"))) && done;
							destroyBasestar(j);
						}
					}
					if(z.scarCAC) {
						plainAlert("Scar requires a die roll to kill, and is not destroyed.");
					}
					if(z.dogfightCAC && !z.scarCAC) {
						plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					} /* RULES: Does Cylon Genocide destroy Scar? */
					break;
				case 99:
					/* Familiar Face */ boldAlert("Admiral " + z.players[z.admiral] + " may choose a character to send to the Brig.");
					addOption(z.admiral, "Move a player to the Brig", undefined, false);
					done = false;
					break;
				case 111:
					/* Mysterious Message */ boldAlert(z.players[z.turn] + ", as current player, may search the Destiny deck and choose 2 cards to discard.");
					addOption(z.turn, "Process the Pass effect from Mysterious Message", undefined, false);
					done = false;
					break;
				case 117: {
					/* Set a Trap */
					let spaces = [0, 0, 0, 0];
					for(let j = 0; !(j >= z.centurions.length); j++) {
						if(z.centurions[j] > 0) {
							spaces[z.centurions[j] - 1] = 1;
						}
					}
					let numSpaces = spaces[0] + spaces[1] + spaces[2] + spaces[3];
					if(numSpaces === 0) {
						plainAlert("There are no Centurions on Galactica: No Effect");
						t.value += "There are no Centurions on Galactica: No Effect.\r\n";
					} else if(numSpaces === 1) {
						for(let j = 0; !(j >= z.centurions.length); j++) {
							if(z.centurions[j] > 0) {
								z.centurions[j] = 0;
								break;
							}
						}
						if(z.vBrutality && characterPresent("Karl") && !noDrawback(getPlayerNum("Karl"))) {
							t.value += "Karl's Conflicted triggers.\r\n";
							promptAllyDiscards(getPlayerNum("Karl"), 2);
						}
						boldAlert("Destroyed a Centurion on the Boarding Party Track.");
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must destroy a Centurion on Galactica.");
						addOption(z.turn, "Destroy a Centurion", "Set a Trap", true);
						done = false;
					}
					break;
				}
				case 118:
					/* Strange Beacon */ boldAlert(z.players[z.turn] +
						", as current player, must choose a space area on the main game board and remove all Cylon Ships in that sector.");
					addOption(z.turn, "Process the Pass effect from Strange Beacon", undefined, true);
					done = false;
					break;
				case 119:
					/* Temple of the Five */ boldAlert(z.players[z.turn] + " may draw 2 Skill Cards.");
					addOption(z.turn, "Draw 2 Skill Cards", undefined, false);
					done = false;
					break;
				case 134:
					/* Consult the Hybrid */ dealMutiny(z.turn, false);
					boldAlert(z.players[z.turn] + " must now draw 2 Skill Cards (they may be from outside of their skill set).");
					addOption(z.turn, "Draw 2 Skill Cards (any color)", 1, true);
					done = false;
					break;
				case 138:	/* Earth in Ruins */
				case 139:	/* Enemy of my Enemy */ 
					done = decreaseMorale();
					break;
				case 152:
					/* Reactor Critical */ dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
					break;
				case 153:
					/* Rebuild Trust */ if(someoneInBrig()) {
						boldAlert("Each character in the Brig may move to any location on Galactica.");
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.playerLocations[j] === "Brig") {
								addOption(j, "Move a player out of the Brig", "Escape", false);
							}
						}
						done = false;
					} else {
						plainAlert("Nobody is in the Brig; no effect.");
					}
					break;
				case 162:
					/* Fleet Mobilization */ if(activateBasestars()) {
						done = launchRaiders();
					} else {
						plainAlert("Once Basestars have finished activating, Launch Raiders.");
						optionForAll("Launch Raiders");
						done = false;
					}
					break;
				case 166:
					/* Footage Transmitted */ dealSkillCardToEveryone(z.turn, 5, true);
					break;
				case 181:	/* Decode Cylon Maps */
				case 195:	/* Organize the Pilots */
				case 199:	/* Recover Launch Keys */ 
					if((z.galacticaAway || z.preparedCivilians.length === 0) && 
						z.lockedCivilians.length === 0) {
						plainAlert("No ships can be prepared or evacuated; no effect.");
					} else {
						
						if((z.galacticaAway || z.preparedCivilians.length === 0)){
							prepareCivilian();
						} else {
							boldAlert(z.players[z.turn] + ", as current player, must now prepare or evacuate a Civilian.");
							if(z.lockedCivilians.length > 0) {
								addOption(z.turn, "Prepare a Civilian", undefined, true);
							}
							addOption(z.turn, "Evacuate a Civilian", undefined, true);
							done = false;
						}
					}
					break;
				case 183:
					/* Dissent Among Cylons */ boldAlert("Every Human player may now draw 2 skill cards.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0) {
							addOption(j, "Draw 2 Skill Cards", undefined, false);
						}
					}
					done = false;
					break;
				case 188:
					/* Intra-Atmos Entry */ 
					if((z.galacticaAway || z.preparedCivilians.length === 0) && z.lockedCivilians.length === 0) {
						if(z.galacticaReturned) {
							plainAlert("Galactica has returned, and no ships remain on New Caprica; no effect.");
						} else {
							increaseJump();
						}
					} else if(z.galacticaAway) {
						prepareCivilian();
						increaseJump();
					} else if(z.preparedCivilians.length === 0){
						prepareCivilian();
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must now prepare or evacuate a Civilian.");
						if(z.lockedCivilians.length > 0) {
							addOption(z.turn, "Prepare a Civilian", undefined, true);
						}
						addOption(z.turn, "Evacuate a Civilian", undefined, true);
						done = false;
					}
					break;
				case 197: {
					/* Prepare for a Fight */
					let spaces = [0, 0, 0];
					for(let j = 0; !(j >= z.OFs.length); j++) {
						if(z.OFs[j] > 0) {
							spaces[z.OFs[j] - 1] = 1;
						}
					}
					let numSpaces = spaces[0] + spaces[1] + spaces[2];
					if(numSpaces === 0) {
						plainAlert("There are no Occupation Forces on New Caprica: No Effect");
					} else if(numSpaces === 1) {
						for(let j = 0; !(j >= z.OFs.length); j++) {
							if(z.OFs[j] > 0) {
								z.OFs[j] = 0;
								break;
							}
						}
						boldAlert("Destroyed an Occupation Force.");
					} else {
						boldAlert(z.players[z.turn] + ", as current player, must destroy an Occupation Force.");
						addOption(z.turn, "Destroy an Occupation Force", undefined, true);
						done = false;
					}
					break;
				}
				case 200:	/* Rescue Detainees */
				case 202:	/* Second Thoughts */ 
					if(someoneInDetention()) {
						boldAlert(z.players[z.turn] + ", as current player, may move a character from Detention to any other New Caprica location.");
						addOption(z.turn, "Move a player out of Detention", undefined, false);
						done = false;
					} else {
						plainAlert("No one is in Detention: No Effect.");
					}
					break;
				case 201:
					/* Resistance Bombing */ boldAlert("Admiral " + z.players[z.admiral] +
						" must now choose whether to lose a Morale to either execute a revealed Cylon or destroy 2 Occupation Forces.");
					addOption(z.admiral, "[Resistance Bombing] Decrease Morale", undefined, true);
					addOption(z.admiral, "[Resistance Bombing] Do not decrease Morale", undefined, true);
					done = false;
					break;
				default:
					error("ERROR: No Pass Effect Found");
					break;
			}
		}
		if(isSuperCrisis(z.currentSkillCheck)) {
			z.superCrisisDiscards.push(z.currentSkillCheck);
		}
	} else if(result === "PARTIAL") {
		addAlert("The result of the " + name + " skill check is: PARTIAL.");
		t.value += bold("The result of the " + name + " skill check is: " + colorText("orange", "PARTIAL")) + ".\r\n";
		switch (z.currentSkillCheck) {
			case 18:	/* Elections Loom */
			case 69:	/* Witch Hunt */ 
				done = decreaseMorale();
				break;
			case 26:	/* Hangar Accident */
			case 39:	/* Prisoner Revolt */
			case 58:	/* The Olympic Carrier */ 
				done = decreasePopulation();
				break;
			case 33:	/* Loss of a Friend */
			case 144:
				/* Hybrid in Panic */ if(z.revealedCylons[z.turn] === 0) {
					done = promptDiscards(z.turn, 2);
				} else {
					addAlert("The current player is a Cylon: no effect.");
					t.value += z.players[z.turn] + " is a Cylon; no effect.\r\n";
				}
				break;
			case 35:
			case 57:
			case 78:
			case 183:
			case 188:
			case 191:
			case 201:
				plainAlert("No Effect.");
				break;
			case 46:	/* Resistance */
			case 169:	/* The Farm */ 
				decreaseFood();
				break;
			case 71:	/* An Offer of Peace */
			case 145:	/* Incitement to Mutiny */ 
				shuffleTreachery();
				break;
			case 81:	/* Review Galactica's Log */ 
				done = promptDiscards(z.admiral, 3);
				break;
			case 142:
				/* Give in to Despair */ decreaseFood();
				dealSkillCard(z.turn, 5);
				dealSkillCard(z.turn, 5);
				dealSkillCard(z.turn, 5);
				break;
			case 161:
				/*Cylon Intruders */ if(boardGalactica()) {
					boldAlert("A Centurion boards Galactica.");
				} else {
					t.value += "All Centurions are already on Galatica: no effect.\r\n";
				}
				break;
			case 166:
				/*Footage Transmitted */ for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						dealSkillCard(k, 5);
						dealSkillCard(k, 5);
					}
				}
				break;
			case 176:
				/* Betrayed From Within */ if(z.revealedCylons[z.turn] === 1) {
					/* RULES: can a revealed cylon ignore treachery draws from crises? */
					dealSkillCard(z.turn, 5);
					dealSkillCard(z.turn, 5);
				} else {
					if(promptRandomDiscards(z.turn, 2)) {
						dealSkillCard(z.turn, 5);
						dealSkillCard(z.turn, 5);
					} else {
						done = false;
						plainAlert("After they discard, " + z.players[z.turn] + " must draw 2 Treachery.");
						addOption(z.turn, "Draw 2 Treachery", undefined, true);
					}
				}
				break;
			default:
				error("ERROR: No Partial Result Found");
		}
		if(isSuperCrisis(z.currentSkillCheck)) {
			z.superCrisisDiscards.push(z.currentSkillCheck);
		}
	} else if(result === "PREVENTED FAIL") {
		if(name === "Airlock" || name === "Brig" || name === "Admiral's Quarters" || name === "Administration" || name === "Detention" || name ===
			"Resistance HQ") {
			addAlert("The result of the " + name + " skill check is: FAIL.\nIron Will applies, but there's no Fail effect to prevent.");
			t.value += bold("The result of the " + name + " skill check is: " + colorText("red", "FAIL")) + ".\r\n";
			t.value += colorText("green", "Iron Will") + " applies, but there is no Fail effect to prevent.\r\n";
		} else {
			addAlert("The " + name + " skill check failed, but the Fail effect was prevented by Iron Will.");
			t.value += bold("Fail effect of the " + name + " skill check is prevented by " + colorText("green", "Iron Will")) + ".\r\n";
		}
		if(isSuperCrisis(z.currentSkillCheck)) {
			z.superCrisisDiscards.push(z.currentSkillCheck);
		}
	} else if(result === "FAIL") {
		addAlert("The result of the " + name + " skill check is: FAIL.");
		t.value += bold("The result of the " + name + " skill check is: " + colorText("red", "FAIL")) + ".\r\n";
		switch (z.currentSkillCheck) {
			case "Admiral's Quarters":
			case "Administration":
			case "Brig":
			case "Airlock":
			case "Detention":
			case "Resistance HQ":
				plainAlert("No Effect.");
				break;
			case 0:
				/* A Traitor Accused */ if(validBrigTarget()) {
					boldAlert(z.players[z.turn] + " must choose a character to send to the Brig.");
					addOption(z.turn, "Move a player to the Brig", undefined, true);
					done = false;
				} else {
					plainAlert("No players may be moved to the Brig at this time.");
				}
				break;
			case 1: /* Admiral Grilled */ {
				let deeAdmiral = (z.players[z.admiral] === "Dee");
				if(decreaseMorale()) {
					done = promptDiscards(z.admiral, 2);
				} else {
					if(!deeAdmiral) {
						promptDiscards(z.admiral, 2, false);
					} else {
						/*DEE*/
						plainAlert("After Dee's execution is resolved, the new Admiral must discard 2 skill cards.");
					}
					done = false;
				}
				break;
			}
			case 3:		/* Analyze Enemy Fighter */
			case 10:	/* Crippled Raider */
			case 24:	/* Fulfiller of Prophecy */
			case 61:	/* Unidentified Ship */ 
				done = decreasePopulation();
				break;
			case 6:
				/* Bomb Threat */ if(decreaseMorale()) {
					done = destroyPileCivilian(1);
				} else {
					plainAlert("After Dee's execution is resolved, draw and destroy a Civilian ship.");
					optionForAll("Draw and destroy a Civilian", undefined, true);
				}
				break;
			case 8:		/* Colonial Day */
			case 28:	/* Informing the Public */
			case 138:	/* Earth in Ruins */
			case 142:	/* Give In To Despair */
			case 153:	/* Rebuild Trust */ 
				done = decreaseMorale();
				done = decreaseMorale() && done;
				break;
			case 9:
				/* Crash Landing */ boldAlert("Admiral " + z.players[z.admiral] + " may spend 1 Fuel.  If they do not, -1 Morale, and " + z.players[z.turn] +
					" is sent to Sickbay.");
				addOption(z.admiral, "Decrease a resource", "Crash Landing", true);
				done = false;
				break;
			case 11:
				/* Cylon Accusation */ if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded; no effect.");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is already in the Brig; no effect.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Detention");
				} else {
					movePlayer(z.turn, "Brig");
				}
				break;
			case 12:
				/* Cylon Screenings */ done = decreaseMorale();
				if(z.turn === z.president && z.turn === z.admiral) {
					addAlert(z.players[z.turn] + " is already the Dictator, and may not look at their own Loyalty cards.");
					t.value += colorText("purple", "Dictator ") + z.players[z.turn] + " may not inspect their own Loyalty cards.\r\n";
				} else if(z.detectorSabotage) {
					plainAlert("Loyalty cards may not be inspected due to Detector Sabotage; no effect.");
				} else if(z.turn === z.president) {
					addAlert(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to the Admiral.");
					t.value += bold(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to " + colorText("green",
						"Admiral ") + z.players[z.admiral]) + ".\r\n";
					addOption(z.turn, "Inspect a random Loyalty card of another player", "Cylon Screenings", true);
					done = false;
				} else if(z.turn === z.admiral) {
					addAlert(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to the President.");
					t.value += bold(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to " + colorText("orange",
						"President ") + z.players[z.president]) + ".\r\n";
					addOption(z.turn, "Inspect a random Loyalty card of another player", "Cylon Screenings", true);
					done = false;
				} else if(z.admiral === z.president) {
					addAlert(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to the Dictator.");
					t.value += bold(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to " + colorText("purple",
						"Dictator ") + z.players[z.admiral]) + ".\r\n";
					addOption(z.turn, "Inspect a random Loyalty card of another player", "Cylon Screenings", true);
					done = false;
				} else {
					addAlert(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to the Admiral or the President.");
					t.value += bold(z.players[z.turn] + ", as current player, must look at 1 random Loyalty card belonging to " + colorText("green",
						"Admiral ") + z.players[z.admiral] + " or " + colorText("orange", "President ") + z.players[z.president]) + ".\r\n";
					addOption(z.turn, "Inspect a random Loyalty card of another player", "Cylon Screenings", true);
					done = false;
				}
				break;
			case 14:
				/* Cylon Tracking Device */ destroyRaptor();
				placeBasestar(1);
				placeCivilians(4, 2);
				break;
			case 15:
				/* Cylon Virus */ for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.playerLocations[j] === "FTL Control") {
						movePlayer(j, "Sickbay");
					}
				}
				if(boardGalactica()) {
					boldAlert("A Centurion boards Galactica.");
				} else {
					t.value += "All Centurions are already on board Galactica.\r\n";
				}
				break;
			case 17:
				/* Detector Sabotage */ z.detectorSabotage = true;
				boldAlert("Detector Sabotage failed: Loyalty cards may no longer be inspected.");
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.playerLocations[j] === "Research Lab") {
						movePlayer(j, "Sickbay");
					}
				}
				break;
			case 18: /* Elections Loom */ {
				let deePresident = (z.players[z.president] === "Dee");
				if(decreaseMorale()) {
					done = promptDiscards(z.president, 4);
				} else {
					done = false;
					if(deePresident) {
						/*DEE*/
						plainAlert("After Dee's execution is resolved, the new President must discard 4 skill cards.");
					} else {
						promptDiscards(z.president, 4, false);
					}
				}
				break;
			}
			case 23:
				/* Forced Water Mining */ if(decreasePopulation()) {
					done = decreaseMorale();
				} else {
					if(z.morale === 3 && characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && z.preventative !== "Morale") {
						decreaseMorale();
					} else {
						plainAlert("After Hot Dog resolves his Memento, lose 1 Morale.");
						optionForAll("Decrease a resource", "Forced Water Mining", true);
					}
				}
				break;
			case 58:	/* The Olympic Carrier */
			case 126:	/* Unexplained Deaths */
			case 179:	/* Contact Informant */
			case 201:	/* Resistance Bombing */ 
				if(decreaseMorale()) {
					done = decreasePopulation();
				} else {
					if((!z.daybreak && !z.vAllCharacters) || z.graveyard.includes("Hot Dog") || (z.players.includes("Hot Dog") && !characterPresent(
						"Hot Dog"))) {
						decreasePopulation();
					} else {
						plainAlert("After Dee's execution is fully resolved, lose 1 Population.");
						optionForAll("Decrease a resource", "The Olympic Carrier", true);
					}
				}
				break;
			case 25:	/* Guilt by Collusion */
			case 35:	/* Mandatory Testing */
			case 57:	/* Terrorist Investigations */
			case 98:	/* Divisive Behavior */
			case 157:	/* Secret Meetings */
			case 183:	/* Dissent Among Cylons */
			case 194:	/* NCP Recruitment */
			case 196:	/* Playing with Emotions */
			case 200:	/* Rescue Detainees */
			case 202:	/* Second Thoughts */ 
				done = decreaseMorale();
				break;
			case 26:
				/* Hangar Accident */ 
				done = decreasePopulation();
				if((vipersIIReserves() === 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) || z.galacticaAway) {
					plainAlert("There are no Vipers in the Reserves to damage.");
				} else if(vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) {
					let c = 0;
					for(let j = 0; !(j >= z.vipersII.length) && !(c >= 2); j++) {
						if(z.vipersII[j] === 0) {
							z.vipersII[j] = -1;
							c++;
						}
					}
					plainAlert("Damaged " + c + " Vipers Mk II in the Reserves.");
				} else if(vipersIIReserves() === 0 && assaultRaptorsReserves() === 0) {
					let c = 0;
					for(let j = 0; !(j >= z.vipersVII.length) && !(c >= 2); j++) {
						if(z.vipersVII[j] === 0) {
							z.vipersVII[j] = -1;
							c++;
						}
					}
					plainAlert("Damaged " + c + " Vipers Mk VII in the Reserves.");
				} else if(vipersIIReserves() === 0 && vipersVIIReserves() === 0) {
					let c = 0;
					for(let j = 0; !(j >= z.assaultRaptors.length) && !(c >= 2); j++) {
						if(z.assaultRaptors[j] === 0) {
							z.assaultRaptors[j] = -2;
							c++;
						}
					}
					plainAlert("Destroyed " + c + " Assault Raptors in the Reserves.");
				} else {
					done = false;
					let count = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves();
					if(count > 2) {
						count = 2;
					}
					addOption(z.turn, "Damage a Viper", ["Hangar Accident", count], true);
					boldAlert(z.players[z.turn] + ", as current player, must damage 2 Vipers in the Reserves.");
				}
				break;
			case 30:
				/* Jump Computer Failure */ done = decreasePopulation();
				decreaseJump();
				break;
			case 31:
				/* Keep Tabs on Visitor */ addAlert("Roll a die.  If 4 or lower, -2 Population.");
				SPTokenBad("Keep Tabs on Visitor", z.turn);
				done = false;
				break;
			case 32:
				/* Legendary Discovery */ decreaseFood();
				destroyRaptor();
				break;
			case 33:	/* Loss of a Friend */
			case 180: 	/* Contact Raptor */ {
				let currentDee = (z.players[z.turn] === "Dee");
				if(decreaseMorale()) {
					if(z.revealedCylons[z.turn] === 0) {
						done = promptDiscards(z.turn, 2);
					}
				} else if(currentDee) {
					plainAlert("Dee has already been executed, and cannot discard more cards.");
					done = false;
				} else if(z.revealedCylons[z.turn] === 0) {
					promptDiscards(z.turn, 2, false);
					done = false;
				} else {
					done = false;
				}
				break;
			}
			case 34:
				/* Low Supplies */ done = decreaseMorale();
				if(6 > z.food) {
					done = decreaseMorale() && done;
				}
				break;
			case 36:
				/* Missing G4 Explosives */ decreaseFood();
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.playerLocations[j] === "Armory") {
						movePlayer(j, "Brig");
					}
				}
				break;
			case 37:
				/* Network Computers */ decreasePopulation();
				if(boardGalactica()) {
					boldAlert("A Centurion boards Galactica.");
				} else {
					t.value += "All Centurions are already on board Galactica.\r\n";
				}
				break;
			case 38:	/* Prison Labor */
			case 148:	/* One Last Cocktail */ 
				done = decreaseMorale();
				decreaseFood();
				break;
			case 39:
				/* Prisoner Revolt */ decreasePopulation();
				boldAlert("President " + z.players[z.president] + " must choose another player to receive the President title.");
				addOption(z.president, "Move the President title", undefined, true);
				done = false;
				break;
			case 46:
				/* Resistance */ 
				decreaseFood();
				decreaseFuel();
				break;
			case 49:	/* Scouting for Fuel */
			case 50:	/* Scouting for Water */
			case 192:	/* Meet Liaison Officer */ 
				decreaseFuel();
				destroyRaptor();
				break;
			case 51:
				/* Security Breach */ done = decreaseMorale();
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.playerLocations[j] === "Command") {
						movePlayer(j, "Sickbay");
					}
				}
				if(!done) {
					/*DEE*/
					if(!z.pegasus || z.pegasusDestroyed) {
						plainAlert("If the player who played Dee returns as Tigh or Cain, they are immediately moved to Sickbay.");
					} else {
						plainAlert(
							"If the player who played Dee returns as Tigh, they are immediately moved to Sickbay.  If they return as Cain, they must immediately move (for free) to Sickbay or Pegasus CIC."
							);
					}
				}
				break;
			case 52:	/* Send Survey Team */
			case 93:	/* Centurion Assault */ 
				if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Sickbay") {
					plainAlert(z.players[z.turn] + " is already in Sickbay.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Medical Center");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
				} else {
					movePlayer(z.turn, "Sickbay");
				}
				destroyRaptor();
				break;
			case 56:	/* Terrorist Bomber */
			case 105:	/* In the Ring */
			case 137:	/* Domestic Dispute */ 
				done = decreaseMorale();
				if(done || z.players[z.turn] !== "Dee") {
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
					} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
						plainAlert("Helo is Stranded, and is not sent to Sickbay.");
					} else if(z.playerLocations[z.turn] === "Sickbay") {
						plainAlert(z.players[z.turn] + " is already in Sickbay.");
					} else if(isOnNewCaprica(z.turn)) {
						plainAlert("Damn, Apollo!");
						movePlayer(z.turn, "Medical Center");
					} else if(z.playerLocations[z.turn] === "Brig") {
						plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
					} else {
						movePlayer(z.turn, "Sickbay");
					}
				} else {
					/*DEE*/
					plainAlert("If Dee was Human, her new character will be immediately moved to Sickbay.");
				}
				break;
			case 60:
				/* Unexpected Reunion */ 
				if(decreaseMorale()) {
					if(z.revealedCylons[z.turn] === 0) {
						if(z.players[z.turn] === "Romo"){
							done = promptDiscards(z.turn,z.skillCardHands[z.turn].length);
						} else {
							done = discardEntireHand(z.turn);
						}
					}
				} else if(z.players[z.turn] !== "Dee") {
					done = false;
					if(z.skillCardHands[z.turn].length > 0){
						if(z.players[z.turn] === "Romo"){
							plainAlert("After Dee's execution is fully resolved, Romo must discard all but one of their skill cards.");
							if(z.forLove && z.skillCardHands[z.turn].length > 1){
								plainAlert("Additionally, Athena could Love him to save him another card.");
							}
						} else if(z.forLove && z.players[z.turn] !== "Athena" ){			
							plainAlert("After Dee's execution is fully resolved, the current player must discard their entire hand of skill cards.  If Athena does not Love you, make sure you discard your cards randomly.");
						} else {
							plainAlert("After Dee's execution is fully resolved, the current player must randomly discard their entire hand of skill cards.");
						}
					}
				} else {
					done = false;
					if(z.forLove){
						plainAlert("If Athena loves Dee here, note that Dee's new character must still discard their last card afterwards; you'll probably need to use the deep menus to do so.");
					}
				} 
				break;
			case 62:
				/* Water Sabotaged */ decreaseFood();
				decreaseFood();
				break;
			case 68: {
				/* Weapon Malfunction */
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.playerLocations[j] === "Weapons Control") {
						movePlayer(j, "Sickbay");
					}
				}
				let vipersCount = 0;
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(!Number.isInteger(z.vipersII[j]) || z.vipersII[j] > 0) {
						vipersCount++;
					}
				}
				for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
					if(!Number.isInteger(z.vipersVII[j]) || z.vipersVII[j] > 0) {
						vipersCount++;
					}
				}
				for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
					if(!Number.isInteger(z.assaultRaptors[j]) || z.assaultRaptors[j] > 0) {
						vipersCount++;
					}
				}
				if(vipersCount === 0 || z.galacticaAway) {
					plainAlert("There are no Vipers in space to damage.");
				} else if(vipersCount > 2) {
					done = false;
					addOption(z.turn, "Damage a Viper", ["Weapons Malfunction", 2], true);
					boldAlert(z.players[z.turn] + ", as current player, must now damage 2 Vipers in space.");
				} else {
					if(vipersCount === 1) {
						boldAlert("The only Viper in space is damaged.");
					} else {
						boldAlert("Both Vipers in space are damaged.");
					}
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(!Number.isInteger(z.vipersII[j])) {
							movePlayer(getPlayerNum(z.vipersII[j]), "Sickbay");
							z.vipersII[j] = -1;
						} else if(z.vipersII[j] > 0) {
							z.vipersII[j] = -1;
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(!Number.isInteger(z.vipersVII[j])) {
							movePlayer(getPlayerNum(z.vipersVII[j]), "Sickbay");
							z.vipersVII[j] = -1;
						} else if(z.vipersVII[j] > 0) {
							z.vipersVII[j] = -1;
						}
					}
					for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
						if(!Number.isInteger(z.assaultRaptors[j])) {
							movePlayer(getPlayerNum(z.assaultRaptors[j]), "Sickbay");
							z.assaultRaptors[j] = -2;
						} else if(z.assaultRaptors[j] > 0) {
							z.assaultRaptors[j] = -2;
						}
					}
				}
				break;
			}
			case 69:
				/* Witch Hunt */ done = decreaseMorale();
				if(validSickbayTarget()) {
					boldAlert("Now, " + z.players[z.turn] + " must choose a character and move them to Sickbay.");
					addOption(z.turn, "Move a player to Sickbay");
					done = false;
				} else {
					plainAlert("No players may be moved to Sickbay at this time.");
				}
				break;
			case 71:
				/* An Offer of Peace */ if(decreaseMorale()) {
					shuffleTreachery();
				} else {
					done = false;
					if(characterPresent("Cavil") || (z.vBrutality && characterPresent("D'Anna"))) {
						/*DEE*/
						plainAlert("Once Dee's execution is fully resolved, shuffle 2 Treachery into Destiny.");
					} else {
						shuffleTreachery();
					}
				}
				break;
			case 74:	/* Code Blue */
			case 104:	/* Hidden Identity */
			case 107:	/* Joe's Bar */ 
				if(decreaseMorale()) {
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to the Brig.");
					} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
						plainAlert("Helo is Stranded, and is not sent to the Brig.");
					} else if(z.playerLocations[z.turn] === "Brig") {
						plainAlert(z.players[z.turn] + " is already in the Brig.");
					} else if(isOnNewCaprica(z.turn)) {
						plainAlert("Damn, Apollo!");
						movePlayer(z.turn, "Detention");
					} else {
						movePlayer(z.turn, "Brig");
					}
				} else {
					done = false; /*DEE*/
					plainAlert("Once Dee's execution is fully resolved, move the current player to the Brig.");
				}
				break;
			case 75:
				/* Defending a Prisoner */ done = false; /* RULES: weird cases involving multiple states of emergency and a cylon leader */
				if(decreaseMorale()) {
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert("A Cylon player cannot be executed by this crisis.");
						done = true;
					} else if(z.executedCurrentPlayer && z.exodus) {
						plainAlert("You can't execute the current player again.");
						done = true;
					} else {
						addAlert("Roll a die. On a 4 or less, " + z.players[z.turn] + " is executed.");
						SPTokenBad("Defending a Prisoner", z.turn);
					}
				} else {
					/* RULES: Is Dee's player still the current player here? */
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert("A Cylon player cannot be executed by this crisis.");
						done = true;
					} else if(z.executedCurrentPlayer && z.exodus) {
						plainAlert("You can't execute the current player again.");
						done = true;
					} else {
						plainAlert("Once Dee's execution is completely resolved, roll a die.  On a 4 or less, the current player is executed.");
						z.dieRollQueue.push("Defending a Prisoner");
					}
				}
				break;
			case 78:	/* Medical Breakthrough */
			case 80:	/* Reunite the Fleet */
			case 89: {	/* Unsettling Stories */
				decreaseMorale();
				plainAlert("Each player discards 1 skill card and draws 1 Treachery card.");
				let numDrawers = 0;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.revealedCylons[k] === 0) {
						if(z.players[k] !== "Romo" && z.possibleColors[k][5] === 1 && z.dradisBait[k]) {
							numDrawers++;
						}
						promptDiscards(k, 1, true);
					}
				}
				let athena = 0;
				if(z.forLove) {
					athena++;
				}
				if(z.numPlayers + athena > z.skillCardDecks[5].length || !z.daybreak || numDrawers > z.mutinyDeck.length - z.buriedMutinies) {
					plainAlert("The order of discards and Treachery draws may matter here.");
				}
				optionForAll("Draw 1 Treachery");
				done = false;
				break;
			}
			case 81: /* Review Galactica's Log */ {
				let deeAdmiral = (z.players[z.admiral] === "Dee");
				if(decreaseMorale()) {
					done = promptDiscards(z.admiral, 5);
				} else if(deeAdmiral) {
					/*DEE*/
					done = false;
					plainAlert("After Dee's execution is fully resolved, the new Admiral must discard 5 skill cards.");
				} else {
					done = false;
					promptDiscards(z.admiral, 5, false);
				}
				break;
			}
			case 82:
				/* Sabotage Investigated */ decreaseFuel();
				decreaseFood();
				done = decreaseMorale();
				break;
			case 84:
				/* Standoff with Pegasus */ done = decreasePopulation();
				if(!done && characterPresent("Dee") && !noDrawback(getPlayerNum("Dee")) && z.morale === 3 && z.preventative !== "Morale") {
					/*DEE*/
					plainAlert("Once Hot Dog resolves his Memento, decrease Morale by 1 and damage 1 Viper in space.");
				} else if(decreaseMorale()) {
					let vipersCount = 0;
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(!Number.isInteger(z.vipersII[j]) || z.vipersII[j] > 0) {
							vipersCount++;
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(!Number.isInteger(z.vipersVII[j]) || z.vipersVII[j] > 0) {
							vipersCount++;
						}
					}
					for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
						if(!Number.isInteger(z.assaultRaptors[j]) || z.assaultRaptors[j] > 0) {
							vipersCount++;
						}
					}
					if(vipersCount === 0 || z.galacticaAway) {
						plainAlert("There are no Vipers in space to damage.");
					} else if(vipersCount > 1) {
						done = false;
						addOption(z.turn, "Damage a Viper", ["Standoff with Pegasus", 1], true);
						boldAlert(z.players[z.turn] + ", as current player, must now damage 1 Viper in space.");
					} else {
						boldAlert("The only Viper in space is damaged.");
						for(let j = 0; !(j >= z.vipersII.length); j++) {
							if(!Number.isInteger(z.vipersII[j])) {
								movePlayer(getPlayerNum(z.vipersII[j]), "Sickbay");
								z.vipersII[j] = -1;
							} else if(z.vipersII[j] > 0) {
								z.vipersII[j] = -1;
							}
						}
						for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
							if(!Number.isInteger(z.vipersVII[j])) {
								movePlayer(getPlayerNum(z.vipersVII[j]), "Sickbay");
								z.vipersVII[j] = -1;
							} else if(z.vipersVII[j] > 0) {
								z.vipersVII[j] = -1;
							}
						}
						for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
							if(!Number.isInteger(z.assaultRaptors[j])) {
								movePlayer(getPlayerNum(z.assaultRaptors[j]), "Sickbay");
								z.assaultRaptors[j] = -2;
							} else if(z.assaultRaptors[j] > 0) {
								z.assaultRaptors[j] = -2;
							}
						}
					}
				} else {
					/*DEE*/
					done = false;
					plainAlert("Once Dee's execution is fully resolved, the current player must damage 1 Viper in space (if able).");
				}
				break;
			case 86:
				/* The Black Market */ decreaseFood();
				decreaseFood();
				done = decreaseMorale();
				break;
			case 88:
				/* Training Snafu */ /* TODO: more automatic cases */ 
				if(vipersIIReserves() + damagedVipersII() + destroyedVipersII() === z.vipersII.length && !z.CFB && !z.daybreak && !z.galacticaAway) {
					let c = 0;
					for(let j = 0; !(j >= z.vipersII.length) && !(c >= 3); j++) {
						if(z.vipersII[j] === 0) {
							z.vipersII[j] = -1;
							c++;
						}
					}
					if(c === 0){
						plainAlert("All Vipers are damaged or destroyed; no effect.");
					} else if (c === 1){
						boldAlert("The last Viper in the reserves is damaged.");
					} else {
						boldAlert(c+" Vipers in the Reserves are damaged.");
					}
				} else if(z.galacticaAway) {
					plainAlert("Damn, Apollo!  You cannot damage any Vipers as you jumped to New Caprica in the meantime.");
				} else {
					let count = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves() + mannedVipersList().length + unmannedVipersList().length;
					if(count > 3) {
						count = 3;
					}
					addOption(z.turn, "Damage a Viper", ["Training Snafu", count], true);
					done = false;
					boldAlert(z.players[z.turn] + " must damage 3 Vipers in the Reserves or in space.");
				}
				break;
			case 90:
				/* Airlock Leak */ if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Sickbay") {
					plainAlert(z.players[z.turn] + " is already in Sickbay.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Medical Center");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
				} else {
					movePlayer(z.turn, "Sickbay");
				}
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				} else if(!z.galacticaAway) {
					done = damageGalactica();
				} else {
					plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
				}
				break;
			case 94:
				/* Consult the Prisoner */ if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to the Brig.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded, and is not sent to the Brig.");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is already in the Brig.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Detention");
				} else {
					movePlayer(z.turn, "Brig");
				}
				done = false;
				plainAlert("Each human player must discard 1 skill card.");
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(z.revealedCylons[k] === 0) {
						promptDiscards(k, 1, true);
					}
				}
				break;
			case 96:
				/* Cylon Genocide */ done = false;
				if(decreaseMorale()) {
					if(activateBasestars()) {
						if(launchRaiders()) {
							done = activateHeavies();
						} else {
							optionForAll("Activate Heavy Raiders");
							plainAlert("Once the Launch Raiders icon is processed, activate Heavy Raiders.");
						}
					} else {
						optionForAll("Launch Raiders");
						optionForAll("Activate Heavy Raiders");
						plainAlert("Once the Activate Basestars icon is processed, Launch Raiders, then activate Heavy Raiders.");
					}
				} else {
					plainAlert("Once Dee's execution is fully resolved, Activate Basestars, Launch Raiders, then Activate Heavy Raiders.");
					optionForAll("Activate Basestars");
					optionForAll("Launch Raiders");
					optionForAll("Activate Heavy Raiders");
				}
				break;
			case 99: /* Familiar Face */ {
				let deeAdmiral = (z.players[z.admiral] === "Dee");
				if(decreaseMorale()) {
					if (z.players[z.admiral] === "Romo"){
						done = promptDiscards(z.admiral,z.skillCardHands[z.admiral].length);
					} else {
						done = discardEntireHand(z.admiral);
					}
				} else if(deeAdmiral) {
					done = false; /*DEE*/
					plainAlert("After Dee's execution is fully resolved, the new Admiral must discard their hand of skill cards.");
					if(z.forLove){
						plainAlert("Athena could Love them, if they do not Love Dee; if they are not loved, they should discard them randomly.");
					} else {
						plainAlert("Discard them randomly using the deep menus.");
					}
				} else {
					done = false;
					if(z.players[z.admiral] === "Romo"){
						plainAlert("After Dee's execution is fully resolved, Admiral Romo must discard all but one of his skill cards.");
						promptDiscards(z.admiral,z.skillCardHands[z.turn],true);
					} else if(z.forLove){
						plainAlert("After Dee's execution is fully resolved, the Admiral must discard their hand of skill cards.  If Athena does not love them, they should discard those cards randomly.");
					} else {
						plainAlert("After Dee's execution is fully resolved, the Admiral must randomly discard their hand of skill cards.");
					}
				}
				break;
			}
			case 100:
				/* Guilty Conscience */ if(z.revealedCylons[z.turn] === 0) {
					done = promptRandomDiscards(z.turn, 3);
				} else {
					plainAlert(z.players[z.turn] + " is a Cylon; no effect.");
				}
				break;
			case 101:
				/* Haunted by the Past */ if(z.forLove) {
					boldAlert("All Human players must discard a random skill card.");
					plainAlert("Athena can Love someone.");
					if(characterPresent("Romo")) {
						plainAlert("Romo is Deceitful, and does not need to discard.");
					}
					done = false;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(z.revealedCylons[j] === 0 && z.players[j] !== "Romo") {
							if(z.players[j] === "Athena") {
								addOption(me, "Discard a random Skill Card", 1, true);
							} else {
								z.randomLove[j] = true;
							}
						}
					}
				} else {
					addAlert("All players discard a random skill card.");
					for(let i = 0; !(i >= z.numPlayers); i++) {
						let j = (z.turn + i) % z.numPlayers;
						if(z.skillCardHands[j].length === 0) {
							plainAlert(z.players[j] + " has no skill cards to discard.");
						} else if(z.revealedCylons[j] === 1) {
							plainAlert("As a Cylon, " + z.players[j] + " can ignore the random discard.");
						} else if(z.players[j] === "Romo") {
							plainAlert(strikethrough("Romo") + " Nur-Ab-Sal ignores the discard as he is the Atlantean god of deceit.");
						} else {
							let discard = discardRandomSkillCard(j);
							addAlert(z.players[j] + " discards " + cardText(discard) + " randomly.");
						}
					}
				}
				break;
			case 102:
				/* Hera Rescued */ done = decreaseMorale();
				done = decreaseMorale() && done;
				destroyRaptor();
				break;
			case 110:
				/* Mysterious Guide */ decreaseFuel();
				if(z.revealedCylons[z.turn] === 0) {
					if (z.players[z.turn] === "Romo"){
						done = promptDiscards(z.turn,z.skillCardHands[z.turn].length);
					} else {
						done = discardEntireHand(z.turn);
					}
				}
				break;
			case 111:
				/* Mysterious Message */ if(launchRaiders()) {
					done = activateBasestars();
				} else {
					done = false;
					optionForAll("Activate Basestars");
					plainAlert("Once the Launch Raiders icon is fully resolved, Activate Basestars.");
				}
				break;
			case 112:	/* Power Failure */
			case 118:	/* Strange Beacon */
			case 119:	/* Temple of the Five */ 
				decreaseJump();
				break;
			case 114:
				/* Raptor Malfunction */ destroyRaptor();
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					plainAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				} else if(!z.galacticaAway) {
					done = damageGalactica();
				} else {
					plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
				}
				break;
			case 117:
				/* Set a Trap */ if(boardGalactica()) {
					plainAlert("A Centurion boards Galactica.");
				} else {
					t.value += "All Centurions are already on board Galactica.\r\n";
				}
				if(z.revealedCylons[z.turn] === 1) {
					plainAlert(z.players[z.turn] + " is a Cylon, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
					plainAlert("Helo is Stranded, and is not sent to Sickbay.");
				} else if(z.playerLocations[z.turn] === "Sickbay") {
					plainAlert(z.players[z.turn] + " is already in Sickbay.");
				} else if(isOnNewCaprica(z.turn)) {
					plainAlert("Damn, Apollo!");
					movePlayer(z.turn, "Medical Center");
				} else if(z.playerLocations[z.turn] === "Brig") {
					plainAlert(z.players[z.turn] + " is in the Brig, and is not sent to Sickbay.");
				} else {
					movePlayer(z.turn, "Sickbay");
				}
				break;
			case 121:
				/* The Passage */ /* RULES: the passage */ done = destroyPileCivilian(2);
				break;
			case 122:
				/* Threat of a Super Nova */ done = decreasePopulation();
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					plainAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				} else if(!done) {
					plainAlert("Once Hot Dog resolves his Memento, damage Galactica.");
					addOption(getPlayerNum("Hot Dog"), "Damage Galactica", undefined, true);
				} else if(!z.galacticaAway) {
					done = damageGalactica();
				} else {
					plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
				}
				break;
			case 127:
				/* Unfair Bias */ if(z.revealedCylons[z.turn] === 0) {
					if (z.players[z.turn] === "Romo"){
						done = promptDiscards(z.turn,z.skillCardHands[z.turn].length);
					} else {
						done = discardEntireHand(z.turn);
					}
				}
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					plainAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica.");
				} else if(!z.galacticaAway) {
					done = damageGalactica() && done;
				} else {
					plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
				}
				break;
			case 130:
				/* A Desperate Pact */ if(decreaseMorale()) {
					passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
				} else {
					done = false; /*DEE*/
					plainAlert(
						"After Dee's execution is fully resolved, pass the Presidency to the highest player on the succession list, apart from the then-President."
						);
				}
				break;
			case 134:
				/* Consult the Hybrid */ decreaseFood();
				shuffleTreachery();
				break;
			case 139:
				/* Enemy of my Enemy */ done = decreaseMorale();
				done = decreaseMorale() && done;
				if(done) {
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
						done = false;
						addOption(z.turn, "Damage Pegasus", undefined, true);
						addOption(z.turn, "Damage Galactica", undefined, true);
						boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
					} else if(!z.galacticaAway) {
						done = damageGalactica();
					} else {
						plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
					}
				} else {
					/*DEE*/
					plainAlert("After Dee's execution is fully resolved, damage Galactica.");
				}
				break;
			case 141:
				/* Galactica Falling Apart */ if(decreaseMorale()) {
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
						done = false;
						addOption(z.turn, "Damage Pegasus", undefined, true);
						addOption(z.turn, "Damage Galactica", undefined, true);
						boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
					} else if(!z.galacticaAway) {
						done = damageGalactica();
					} else {
						plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
					}
				} else {
					/*DEE*/
					plainAlert("After Dee's execution is fully resolved, damage Galactica.");
				}
				break;
			case 144:	/* Hybrid in Panic */
			case 152:	/* Reactor Critical */ 
				decreaseFuel();
				break;
			case 145:
				/* Incitement to Mutiny */ shuffleTreachery();
				shuffleTreachery();
				break;
			case 146:
				/* Insubordinate Crew */ if(decreaseMorale()) {
					if(characterPresent("Tom")) {
						let foundOne = -1;
						let foundTwo = false;
						for(let k = 0; !(k >= z.numPlayers); k++) {
							let j = (k + z.turn) % z.numPlayers;
							if(z.revealedCylons[j] === 0 && z.mutinies[j].length === 0) {
								if(foundOne === -1) {
									dealMutiny(j, false);
									if(!z.vBrutality || z.players[j] !== "Tom") {
										foundOne = j;
									}
								} else {
									foundTwo = true;
									break;
								}
							}
						}
						done = foundOne === -1;
						if(foundTwo) {
							plainAlert("After Tom resolves his Necessary Steps for " + z.players[foundOne] +
								", he must deal a Mutiny and handle Necessary Steps for the remaining Humans who do not already have a Mutiny.");
							addOption(getPlayerNum("Tom"), "Deal a Mutiny card", "Insubordinate Crew", true);
						}
					} else {
						for(let k = 0; !(k >= z.numPlayers); k++) {
							let j = (k + z.turn) % z.numPlayers;
							if(z.revealedCylons[j] === 0 && z.mutinies[j].length === 0) {
								done = dealMutiny(j, false) && done;
							}
						}
					}
				} else {
					done = false; /*DEE*/
					plainAlert("After Dee's execution is fully resolved, deal a Mutiny to every player who does not already have one.");
				}
				break;
			case 150:
				/* Quorum in Uproar */ if(z.quorumHand.length === 0) {
					plainAlert("The President has no Quorums to discard.");
				} else {
					for(let j = 0; !(j >= 2) && z.quorumHand.length > 0; j++) {
						let rando = Math.floor((z.seed * z.quorumHand.length)/ mLCG);
						updateSeed();
						let quo = z.quorumHand.splice(rando, 1)[0];
						z.quorumDiscards.push(quo);
						plainAlert("The President discards " + d.quorumNames[quo] + " randomly.");
					}
				}
				done = promptRandomDiscards(z.president, 2);
				break;
			case 151:
				/* Rallying Support */ done = decreasePopulation();
				if(!done && z.players[z.turn] === "Hot Dog") {
					plainAlert("Once Hot Dog resolves his Memento, he must draw a Mutiny card and a Treachery card.");
					addOption(z.turn, "Draw a Mutiny card", undefined, true);
					addOption(z.turn, "Draw 1 Treachery", undefined, true);
				} else if(z.revealedCylons[z.turn] === 0) {
					dealMutiny(z.turn, false);
				}
				done = done && !characterPresent("Tom") && (z.players[z.turn] !== "Lee" || noDrawback(z.turn));
				if(z.players[z.turn] === "Tom" && !z.vBrutality) {
					plainAlert("Once Tom finishes his Necessary Steps, he must draw a Treachery.");
					addOption(z.turn, "Draw 1 Treachery", undefined, true);
				} else if(z.players[z.turn] === "Lee" && !noDrawback(z.turn) && (!z.vBrutality || !versionAtLeast([2, 0, 1]))) {
					addOption(z.turn, "Draw 1 Treachery", undefined, true);
					plainAlert("Once Lee resolves his Moral Dilemma, he must draw a Treachery.");
				} else {
					dealSkillCard(z.turn, 5);
				}
				break;
			case 154:
				/* Religious Turmoil */ done = false;
				if(decreaseMorale()) {
					plainAlert("Each human player must discard 1 skill card.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						let k = (z.turn + j) % z.numPlayers;
						if(z.revealedCylons[k] === 0) {
							promptDiscards(k, 1, true);
						}
					}
				} else {
					plainAlert("Once Dee's execution is fully resolved, each player must discard a skill card.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						let k = (z.turn + j) % z.numPlayers;
						if(z.revealedCylons[k] === 0) {
							promptDiscards(k, 1, true);
						}
					}
				}
				break;
			case 160: {
				/* Bomb on Colonial One */
				done = decreaseMorale();
				done = decreaseMorale() && done; /* TODO: if Dee is executed during this, while there are Allies on Colonial One... */
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(onColonialOne(z.playerLocations[j])) {
						movePlayer(j, "Sickbay");
					}
				}
				boldAlert("Colonial One destroyed!");
				z.colonialOneDestroyed = true;
				let killedAllies = 0;
				for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
					if(onColonialOne(d.allyLocations[z.allies[j][0]])) {
						killedAllies++;
					}
				}
				if(!done && killedAllies > 0) {
					plainAlert("There are Allies on Colonial One.  Once Dee's execution is fully resolved, replace those Allies.");
					optionForAll("[Bomb on Colonial One] Draw new Allies", undefined, true);
				} else {
					for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
						if(onColonialOne(d.allyLocations[z.allies[j][0]])) {
							plainAlert("The " + d.allyNames[z.allies[j][0]] + " Ally is hit, and is removed from the game.");
							let trauma = z.allies[j][1];
							if(trauma !== null){
								z.traumaPile.push(trauma);
							}
							shuffle(z.traumaPile);
							z.allies.splice(j, 1);
							j--;
						}
					}
					for(let j = killedAllies; j > 0; j--) {
						let newAlly = allyPop();
						if(newAlly === -1) {
							plainAlert("Ally deck exhausted; it does not reshuffle.");
						} else {
							z.cylonAllyQueue.push(newAlly);
						}
					}
					if(z.preCrossroads && z.cylonAllyQueue.length > 0) {
						done = resolveCylonAllyQueue();
					}
				}
				break;
			}
			case 161:
				/* Cylon Intruders */ if(centurionReserves() >= 2) {
					boardGalactica();
					boardGalactica();
					boldAlert("Two Centurions board Galactica.");
				} else if(centurionReserves() === 1) {
					boardGalactica();
					boldAlert("One Centurion boards Galactica.");
					plainAlert("All " + z.centurions.length + " Centurions are now on board Galactica.");
				} else {
					plainAlert("All Centurions are now on board Galactica; no effect.");
				}
				if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && !z.galacticaAway) {
					done = false;
					addOption(z.turn, "Damage Pegasus", undefined, true);
					addOption(z.turn, "Damage Galactica", undefined, true);
					boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
				} else if(!z.galacticaAway) {
					done = damageGalactica();
				} else {
					plainAlert("Damn, Apollo!  You cannot damage Galactica while she is away.");
				}
				z.superCrisisDiscards.push(161);
				break;
			case 162:
				/* Fleet Mobilization */ done = false;
				if(decreaseMorale()) {
					if(activateBasestars()) {
						if(activateRaiders()) {
							if(activateHeavies()) {
								done = launchRaiders();
							} else {
								plainAlert("Once the Heavy activation is resolved, Launch Raiders.");
								optionForAll("Launch Raiders");
							}
						} else {
							plainAlert("Once the Raider activation is resolved, Activate Heavies, then Launch Raiders.");
							optionForAll("Activate Heavy Raiders");
							optionForAll("Launch Raiders");
						}
					} else {
						optionForAll("Activate Raiders");
						optionForAll("Activate Heavy Raiders");
						optionForAll("Launch Raiders");
						plainAlert("Once the Basestar activation is resolved, Activate Raiders, Activate Heavies, then Launch Raiders.");
					}
				} else {
					plainAlert("Once Dee's execution is fully resolved, Activate Basestars, Activate Raiders, Activate Heavies, then Launch Raiders.");
					optionForAll("Activate Basestars");
					optionForAll("Activate Raiders");
					optionForAll("Activate Heavy Raiders");
					optionForAll("Launch Raiders");
				}
				z.superCrisisDiscards.push(162);
				break;
			case 163:
				/* Inbound Nukes */ decreaseFuel();
				decreaseFood();
				done = decreasePopulation();
				z.superCrisisDiscards.push(163);
				break;
			case 166:
				/* Footage Transmitted */ for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (j + z.turn) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						dealSkillCard(k, 5);
						dealSkillCard(k, 5);
						if(z.superCrisisDeck.length === 0) {
							plainAlert("Super Crisis Deck entirely depleted.");
						} else {
							t.value += z.players[k] + " draws a Super Crisis.\r\n";
							z.superCrisisHands[k].push(z.superCrisisDeck.pop());
							if(z.superCrisisDeck.length === 0) {
								t.value += "Super Crisis deck reshuffled.\r\n";
								z.superCrisisDeck = shuffle(z.superCrisisDiscards);
								z.superCrisisDiscards = [];
							}
						}
					}
				}
				z.superCrisisDiscards.push(166);
				break;
			case 169:
				/* The Farm */ decreaseFood();
				done = decreasePopulation();
				z.theFarm = true;
				boldAlert("Human Players may no longer use their OPG abilities.");
				if(!z.daybreak){
					for(let j = 0; !(j>=z.numPlayers); j++){
						if(!isTheCylonLeader(j)){
							z.miracles[j] = 0;
						}
					}
				}
				break;
			case 171:
				/* Fire All Missiles */ done = destroyPileCivilian(2);
				z.superCrisisDiscards.push(171);
				break;
			case 172:
				/* Human Prisoner */ boldAlert(z.players[z.crisisPlayer] +
					" must now choose a Human player, take all of their skill cards, then move them to Sickbay.");
				addOption(z.crisisPlayer, "Process the Fail effect from Human Prisoner", undefined, true);
				done = false;
				z.superCrisisDiscards.push(172);
				break;
			case 174:	/* Arrests at Night */
			case 186:	/* Held for Questioning */
			case 197:	/* Prepare for a Fight */ 
				done = decreaseMorale();
				if(done && isOnNewCaprica(z.turn) && z.revealedCylons[z.turn] === 0) {
					movePlayer(z.turn, "Detention");
				} else if(!done) {
					if(z.players[z.turn] !== "Dee") {
						movePlayer(z.turn, "Detention");
					} else if(z.galacticaAway) {
						/*DEE*/
						plainAlert("If Dee was Human, her new character must immediately move to Detention.");
					}
				}
				break;
			case 176:
				/* Betrayed from Within */ if(z.revealedCylons[z.turn] === 0) {
					done = false;
					executePlayer(z.turn);
				}
				break;
			case 177:
				/* Brutal Treatment */ done = decreaseMorale();
				if(done && isOnNewCaprica(z.turn) && z.revealedCylons[z.turn] === 0) {
					movePlayer(z.turn, "Medical Center");
				} else if(!done) {
					if(z.players[z.turn] !== "Dee") {
						movePlayer(z.turn, "Medical Center");
					} else if(z.galacticaAway) {
						/*DEE*/
						plainAlert("If Dee was Human, her new character must immediately move to the Medical Center.");
					}
				}
				break;
			case 178:
				/* Centurion Ambush */ done = decreasePopulation();
				if(isOnNewCaprica(z.turn) && z.revealedCylons[z.turn] === 0) {
					movePlayer(z.turn, "Medical Center");
				}
				break;
			case 181:
				/* Decode Cylon Maps */ done = decreaseMorale();
				for(let j = 0; !(j >= 4); j++) {
					if(z.OFs[j] === 0) {
						z.OFs[j] = 1;
						boldAlert("Placed an Occupation Force on the Occupation Authority.");
						break;
					}
				}
				break;
			case 187:
				/* Hiding Underground */ 
				decreaseFood();
				break;
			case 188:
				/* Intra-Atmos Entry */ decreaseFuel();
				if(z.galacticaReturned) {
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
						done = false;
						addOption(z.turn, "Damage Pegasus", undefined, true);
						addOption(z.turn, "Damage Galactica", undefined, true);
						boldAlert(z.players[z.turn] + ", as current player, must now damage Pegasus or Galactica.");
					} else {
						done = damageGalactica();
					}
				}
				break;
			case 190:
				/* Labor Union Strike */ decreaseFood();
				if(isOnNewCaprica(z.turn) && z.revealedCylons[z.turn] === 0) {
					movePlayer(z.turn, "Detention");
				}
				break;
			case 195:
				/* Organize the Pilots */ done = destroyNCCivilian();
				break;
			case 198:
				/* Prepare the Civilians */ decreaseFood();
				for(let j = 0; !(j >= 4); j++) {
					if(z.OFs[j] === 0) {
						z.OFs[j] = 1;
						boldAlert("Placed an Occupation Force on the Occupation Authority.");
						break;
					}
				}
				break;
			case 199:
				/* Recover Launch Keys */ done = decreasePopulation();
				if(isOnNewCaprica(z.turn) && z.revealedCylons[z.turn] === 0) {
					movePlayer(z.turn, "Detention");
				}
				break;
			default:
				error("ERROR: No Fail Result Found");
		}
	}
	if(z.vBrutalityPlus){
		z.engineRoom = false;
	}
	if((done && z.commandAuthorityPause && characterPresent("Adama") && z.miracles[getPlayerNum("Adama")] === 1 && !isMission(z.currentSkillCheck) && !
			isSuperCrisis(z.currentSkillCheck) && !z.theFarm) || (done && z.commandAuthorityPause && z.assist === "Adama" && z.assistMiracle === 1 && !
			isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck) && !z.theFarm) || (done && z.commandAuthorityPause && actsOfFaith("Adama") &&
			!isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck))) {
		plainAlert(
			"Someone has requested a pause for Adama to consider using his Command Authority ability.  Please wait for Adama to use or pass on the ability " +
			"before proceeding.");
	} else if(done && (!characterPresent("Adama") || z.miracles[getPlayerNum("Adama")] === 0 || isMission(z.currentSkillCheck) || isSuperCrisis(z
			.currentSkillCheck) || z.theFarm) && (z.assist !== "Adama" || z.assistMiracle === 0 || isMission(z.currentSkillCheck) || isSuperCrisis(z
			.currentSkillCheck) || z.theFarm) && (!characterPresent("Gaius") || !z.vBrutality || 2 > z.miracles[getPlayerNum("Gaius")] || !actsOfFaith(
			"Adama") || isMission(z.currentSkillCheck) || isSuperCrisis(z.currentSkillCheck) || z.theFarm)) {
		addAlert("Discarding cards from the skill check.");
		clearSkillCheck();
	}
}

function SoEToken() {
	let qre = new RegExp('\\[q' + bl + '="BYC: State of Emergency"\\]((?!(\\[q' + bl + '=|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	t.value = t.value.replace(qre, "");
	let text = "[q" + bl + '="BYC: State of Emergency"]' + bold(size(colorText("green", "State of Emergency"), 14)) + "\r\n";
	text += "Every player, in order, may move or take an action.\r\n\r\n";
	for(let j = z.SoEPlayer; !(j >= z.SoEPlayer + z.numPlayers); j++) {
		let interruptPlayer = j % z.numPlayers;
		text += z.players[interruptPlayer] + " - ";
		if(z.playerLocations[interruptPlayer] === "Stranded on Caprica") {
			text += "(Stranded)";
		} else if((interruptPlayer + 1 + z.numPlayers) % z.numPlayers === z.SoEActor && !z.SoEDone) {} else if((interruptPlayer + 2 + z.numPlayers) % z
			.numPlayers === z.SoEActor && !z.SoEDone && z.playerLocations[(interruptPlayer + 1 + z.numPlayers) % z.numPlayers] === "Stranded on Caprica"
			) {} else if((interruptPlayer >= z.SoEPlayer && z.SoEActor > interruptPlayer) || (z.SoEPlayer > z.SoEActor && z.SoEActor > interruptPlayer) || (
				interruptPlayer >= z.SoEPlayer && z.SoEPlayer > z.SoEActor)) {
			text += "Done";
		}
		text += "\r\n";
	}
	text += "[/" + "q]\r\n";
	t.value += text;
}

function DEToken() {
	z.deToken = true; /* TODO: make sure this works */
	let qre = new RegExp('\\[q' + bl + '="BYC: Declare Emergency"\\]((?!(\\[q' + bl + '=|\\[/q\\]))[\\s\\S])*\\[/q\\]', "g");
	t.value = t.value.replace(qre, "");
	let text = "[q" + bl + '="BYC: Declare Emergency"]' + bold(size(colorText("green", "Declare Emergency"), 14)) + "\r\n";
	for(let i = z.turn; !(i >= z.turn + z.numPlayers); i++) {
		let interruptPlayer = i % z.numPlayers;
		text += z.players[interruptPlayer] + " (" + z.skillCardHands[interruptPlayer].length + ") - ";
		if(z.revealedCylons[interruptPlayer] === 1) {
			text += "PASS: Cylon";
		} else if(z.des[interruptPlayer] === 0) {
			text += "Pass";
		} else if(z.des[interruptPlayer] !== null) {
			text += colorText("green", z.des[interruptPlayer] + " - Declare Emergency");
		} else if(z.skillCardHands[interruptPlayer].length === 0) {
			text += "PASS: No Cards";
		} else if(z.possibleColors[interruptPlayer][1] === 0) {
			text += "PASS: No Leadership";
		}
		text += "\r\n";
	}
	text += "[/" + "q]\r\n";
	t.value += text;
}

function shouldDE() {
	if(z.currentSkillCheck === null) {
		return false;
	}
	let goal = z.thisDifficulty;
	if(z.currentSkillCheck === "Airlock" && z.playerLocations[z.thisTarget] === "Brig") {
		goal -= 4;
	}
	let sct = skillCheckTally(true);
	let tally = sct[2];
	if(tally === goal - 1 || tally === goal - 2) {
		if(!z.ironWill || (z.thisPartial > 0 && tally > z.thisPartial) || z.daybreak) {
			return true;
		}
		switch (z.currentSkillCheck) {
			case 0:
			case 1:
			case 6:
			case 9:
			case 11:
			case 12:
			case 14:
			case 15:
			case 17:
			case 18:
			case 26:
			case 30:
			case 31:
			case 33:
			case 34:
			case 36:
			case 38:
			case 39:
			case 46:
			case 51:
			case 52:
			case 56:
			case 58:
			case 60:
			case 61:
			case 62:
			case 68:
			case 69:
			case 71:
			case 75:
			case 81:
			case 88:
			case 89:
			case 90:
			case 93:
			case 98:
			case 100:
			case 101:
			case 102:
			case 104:
			case 112:
			case 114:
			case 122:
			case 126:
			case 127:
			case 130:
			case 137:
			case 141:
			case 142:
			case 145:
			case 146:
			case 148:
			case 150:
			case 151:
			case 154:
			case 157:
			case 160:
			case 161:
			case 163:
			case 169:
			case 171:
			case 172:
			case 174:
			case 176:
			case 177:
			case 178:
			case 179:
			case 180:
			case 186:
			case 187:
			case 192:
			case 194:
			case 196:
			case 198:
				return false;
			default:
				return true;
		}
	}
	if(z.ironWill && (tally === goal - 5 || tally === goal - 6) && (z.thisPartial === 0 || z.thisPartial > tally)) {
		if(!Number.isInteger(z.currentSkillCheck)) {
			return false;
		}
		return true;
	}
	return false;
} /* TODO: activation symbols!*/
function postSeed() {
	let re = new RegExp(/(\[c\])?\[size=(1|0)\]\[color=#(F4F4FF|FFFFFF)\](New|BYC) seed: (\S+)\[\/color\]\[\/size\](\[\/c\])?/, "g");
	let seed2 = re.exec(t.value);
	if(seed2 !== null) {
		seed2 = seed2[5];
		seed2 = window.atob(seed2.replace(/-/g, ""));
	}
	if(seed2 !== seed) {
		addAlert("Possible double-post prevented; you should probably run BYC again to make sure your play processed correctly.");
		t.value += bold(colorText("red", "Possible double-post prevented; you should run BYC again to make sure your play processed correctly.")) + "\r\n";
		return;
	}
	let banner = "";
	if(meBoxed === -1) {
		banner = z.banners[me];
	} else {
		banner = z.boxedPlayers[meBoxed][4];
	}
	let bannerRegExp = new RegExp("\\[ima" + bl + "geid=" + banner + " medium\\]", "g");
	let dumbRe = new RegExp('\\[co' + 'lor=red\\]\\[b' + "\\]This post did not process properly\\.  Please try again\\.\\[/" + "b\\]\\[/co" + "lor\\]", "g");
	let clearRegExp = new RegExp("(\\[clear\\])+", "g");
	let splitted = window.btoa(JSON.stringify(z)).match(/.{1,20}/g);
	let text0 = "";
	while(splitted.length > 0) {
		text0 += splitted.shift() + "-";
	}
	t.value = "[ima" + bl + "geid=" + banner + " medium]" + clear() + code(size(invisible("BYC seed: " + text0), 1)) + clear() + t.value.replace(bannerRegExp, "")
		.replace(re, "").replace(dumbRe, "").replace(clearRegExp, clear());
	if(arguments.length === 0) {
		clearSpoilers();
	}
	clearQuotes();
	try{
		let evt = new Event('input', {
			bubbles: true,
			cancelable: true,
		});

		t.dispatchEvent(evt);
	} catch(err){}
}

function textGameState(images) {
	let report = '[q' + bl + '="BYC: Game State"]' + size(bold(italics("Turn " + z.round + "." + (z.turn + 1) + ": " + titleList(z.turn) + z.players[z.turn] +
		" is the Current Player.")), 14) + "\r\n\r\n";
	if(images) {
		let distanceReport = "";
		switch (z.destination) {
			case "Kobol":
				distanceReport = imageO(3770859);
				break;
			case "New Caprica":
				distanceReport = imageO(3770862);
				break;
			case "Ionian Nebula":
				distanceReport = imageO(3770860);
				break;
			case "Earth":
				distanceReport = imageO(3770861);
				break;
			case "Ionian Earth":
				distanceReport = imageO(3781696);
				break;
		}
		if(z.destinationDiscards.length !== 1) {
			distanceReport += "\r\n" + bold(size(z.distance, 10));
		}
		for(let j = 0; !(j >= z.destinationDiscards.length); j++) {
			if(z.destinationDiscards[j] === 34) {
				distanceReport += "\r\n" + imageO(3771014);
			} else if(z.destinationDiscards[j] === 35) {
				distanceReport += "\r\n" + imageO(3771019);
			} else if(z.destinationDiscards[j] === 36) {
				distanceReport += "\r\n" + imageO(3771018);
			} else {
				switch (getDistance(z.destinationDiscards[j])) {
					case 0:
						distanceReport += "\r\n" + imageO(3771009);
						break;
					case 1:
						distanceReport += "\r\n" + imageO(3771010);
						break;
					case 2:
						distanceReport += "\r\n" + imageO(3771011);
						break;
					case 3:
						distanceReport += "\r\n" + imageO(3771012);
						break;
				}
			}
		}
		report += floatleft(center(distanceReport));
	}
	let fuelImage = imageO(3770535);
	let foodImage = imageO(3770531);
	for(let j = 0; images && !(j >= z.damagedLocations.length); j++) {
		if(z.damagedLocations[j] === "Fuel") {
			fuelImage = imageO(3770865);
		}
		if(z.damagedLocations[j] === "Food") {
			foodImage = imageO(3770866);
		}
	}
	if(images) {
		let resourcesReport = fuelImage + "\r\n";
		if(z.fuel > 4) {
			resourcesReport += bold(size(z.fuel, 10));
		} else {
			resourcesReport += bold(colorText("red", size(z.fuel, 10)));
		}
		resourcesReport += "\r\n" + foodImage + "\r\n";
		if(z.food > 4) {
			resourcesReport += bold(size(z.food, 10));
		} else {
			resourcesReport += bold(colorText("red", size(z.food, 10)));
		}
		resourcesReport += "\r\n" + imageO(3770532) + "\r\n";
		if(z.morale > 5) {
			resourcesReport += bold(size(z.morale, 10));
		} else {
			resourcesReport += bold(colorText("red", size(z.morale, 10)));
		}
		resourcesReport += "\r\n" + imageO(3770533) + "\r\n";
		if(z.population > 6) {
			resourcesReport += bold(size(z.population, 10));
		} else {
			resourcesReport += bold(colorText("red", size(z.population, 10)));
		}
		report += floatleft(center(resourcesReport));
	}
	if(images) {
		let leftReport = IIImage() + "\r\n" + size(bold(colorText("teal", "x" + vipersIIReserves())), 8);
		if(z.CFB && vipersVIIReserves() > 0) {
			leftReport += "\r\n" + VIIImage() + "\r\n" + size(bold(colorText("teal", "x" + vipersVIIReserves())), 8);
		}
		let rightReport = raptorImage() + "\r\n";
		if(z.raptors > 0) {
			rightReport += size(bold(colorText("teal", "x" + z.raptors)), 8);
		} else {
			rightReport += size(bold(colorText("red", "x" + z.raptors)), 8);
		}
		if(z.daybreak && assaultRaptorsReserves() > 0) {
			rightReport += "\r\n" + ARImage() + "\r\n" + size(bold(colorText("teal", "x" + assaultRaptorsReserves())), 8);
		}
		let viperReport = center(imageO(3771662) + "\r\n" + floatleft(center(leftReport)) + floatleft(center(rightReport)));
		if(damagedVipersII() > 0 || damagedVipersVII() > 0) {
			let damageReport = "";
			if(damagedVipersII() > 0) {
				damageReport += floatleft(center(IIImage() + "\r\n" + size(bold(colorText("orange", "x" + damagedVipersII())), 8)));
			}
			if(damagedVipersVII() > 0) {
				damageReport += floatleft(center(VIIImage() + "\r\n" + size(bold(colorText("orange", "x" + damagedVipersVII())), 8)));
			}
			viperReport += clear() + center(imageO(3770578) + "\r\n" + damageReport);
		}
		report += floatleft(viperReport);
		let expansionReport =
		""; /*	if(z.pegasus && !z.pegasusDestroyed){			expansionReport = imageO(3770547)+"\r\n"+imageO(3788480)+"\r\n"+pegasusImage()+"\r\n"+imageO(3788480)+"\r\n";		} */
		if(z.preCrossroads) {
			expansionReport += imageO(3771686) + "\r\n";
			for(let j = 0; !(j >= z.allies.length); j++) {
				expansionReport += allyImage(z.allies[j][0]);
			}
			expansionReport += clear();
		}
		if((z.destination === "Earth" || z.destination === "Ionian Earth") && z.activeMission !== null) {
			/* TODO: Missions on board image */
			expansionReport += imageO(3771738) + "\r\n" + bold(d.crisisNames[z.activeMission]);
			if(z.activeMission === 206) {
				if(z.destinationDiscards.length === 0 || (z.destinationDiscards[z.destinationDiscards.length - 1] !== 35 && !(z.destinationDiscards.length >
						1 && z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z.destinationDiscards[z.destinationDiscards.length - 2] ===
						35))) {
					if(z.currentSkillCheck === 206){
						expansionReport += "\r\n" + bold("(in progress)");
					} else {
						expansionReport += "\r\n" + bold(colorText("red", "(failed)"));
					}
				} else {
					expansionReport += "\r\n" + bold(colorText("green", "(passed)"));
				}
			} else if(z.activeMission === 210) {
				if(z.destinationDiscards.length === 0 || (z.destinationDiscards[z.destinationDiscards.length - 1] !== 36 && !(z.destinationDiscards.length >
						1 && z.destinationDiscards[z.destinationDiscards.length - 1] === 34 && z.destinationDiscards[z.destinationDiscards.length - 2] ===
						36))) {
					if(z.currentSkillCheck === 210){
						expansionReport += "\r\n" + bold("(in progress)");
					} else {
						expansionReport += "\r\n" + bold(colorText("red", "(failed)"));
					}
				} else {
					expansionReport += "\r\n" + bold(colorText("green", "(passed)"));
				}
			}
		} /*	if(z.galacticaAway || z.galacticaReturned){			expansionReport += floatleft(floatleft(center(size(bold("Locked"),8)+"\r\n"+imageO(3767295)+"\r\n"+size(bold(z.lockedCivilians.length),8))) +										 floatleft(center(size(bold("Prepared"),8)+"\r\n"+imageO(3767295)+"\r\n"+size(bold(z.preparedCivilians.length),8))))+clear();			if(4 > OFReserves()){				let OAReport = size(bold("OA\r\n"),8);				let c = 0;				for(let j = 0; !(j>=4); j++){					if(z.OFs[j] === 1){						c++;					}				}				if(c > 0){					OAReport += imageO(3780589);				}				if(c > 1){					OAReport += "\r\n"+size(bold(colorText("red","x"+c)),8);				}				let BCReport = size(bold("BC\r\n"),8);				c = 0;				for(let j = 0; !(j>=4); j++){					if(z.OFs[j] === 2){						c++;					}				}				if(c > 0){					BCReport += imageO(3780589);				}				if(c > 1){					BCReport += "\r\n"+size(bold(colorText("red","x"+c)),8);				}				let SYReport = size(bold("SY\r\n"),8);				c = 0;				for(let j = 0; !(j>=4); j++){					if(z.OFs[j] === 3){						c++;					}				}				if(c > 0){					SYReport += imageO(3780589);				}				if(c > 1){					SYReport += "\r\n"+size(bold(colorText("red","x"+c)),8);				}				expansionReport+=floatleft(floatleft(OAReport)+floatleft(BCReport)+floatleft(SYReport));			}		} 		if(expansionReport !== ""){			report+=floatleft(center(expansionReport));		} */
		if(z.destroyedCivilians.length > 0 || z.graveyard.length > 0 || z.pegasusDestroyed) {
			let deadCivReport = imageO(3771660);
			if(z.pegasusDestroyed) {
				deadCivReport += "\r\n" + imageO(3771787);
			}
			let pop1 = 0;
			let pop2 = 0;
			let decoy = 0;
			for(let j = 0; !(j >= z.destroyedCivilians.length); j++) {
				if(z.destroyedCivilians[j] === "1 Pop") {
					pop1++;
				} else if(z.destroyedCivilians[j] === "2 Pop") {
					pop2++;
				} else if(z.destroyedCivilians[j] === "Decoy") {
					decoy++;
				} else if(z.destroyedCivilians[j] === "Pop/Fuel") {
					deadCivReport += "\r\n" + imageO(3769949);
				} else if(z.destroyedCivilians[j] === "Pop/Morale") {
					deadCivReport += "\r\n" + imageO(3769951);
				}
			}
			if(pop2 === 1) {
				deadCivReport += "\r\n" + imageO(3769944);
			} else if(pop2 > 1) {
				deadCivReport += "\r\n" + imageO(3769944) + "\r\n" + size(bold("x" + pop2), 8);
			}
			if(pop1 === 1) {
				deadCivReport += "\r\n" + imageO(3769943);
			} else if(pop1 > 1) {
				deadCivReport += "\r\n" + imageO(3769943) + "\r\n" + size(bold("x" + pop1), 8);
			}
			if(decoy === 1) {
				deadCivReport += "\r\n" + imageO(3769946);
			} else if(decoy > 1) {
				deadCivReport += "\r\n" + imageO(3769946) + "\r\n" + size(bold("x" + decoy), 8);
			}
			for(let j = 0; !(j >= z.graveyard.length); j++) {
				deadCivReport += "\r\n" + characterImage(z.graveyard[j]);
			}
			if(z.colonialOneDestroyed) {
				deadCivReport += "\r\n" + size(bold("Colonial One"), 8);
			}
			if(destroyedVipersII() > 0) {
				deadCivReport += "\r\n" + IIImage();
				if(destroyedVipersII() > 1) {
					deadCivReport += "\r\n" + size(bold(colorText("red", "x" + destroyedVipersII())), 8);
				}
			}
			if(destroyedVipersVII() > 0) {
				deadCivReport += "\r\n" + VIIImage();
				if(destroyedVipersVII() > 1) {
					deadCivReport += "\r\n" + size(bold(colorText("red", "x" + destroyedVipersVII())), 8);
				}
			}
			if(destroyedAssaultRaptors() > 0) {
				deadCivReport += "\r\n" + ARImage();
				if(destroyedAssaultRaptors() > 1) {
					deadCivReport += "\r\n" + size(bold(colorText("red", "x" + destroyedAssaultRaptors())), 8);
				}
			}
			if(2 > z.basestars.length) {
				deadCivReport += "\r\n" + basestarImage();
				if(z.basestars.length === 0) {
					deadCivReport += "\r\n" + size(bold(colorText("red", "x2")), 8);
				}
			}
			if(z.heavies.length === 2) {
				deadCivReport += "\r\n" + imageO(4526293);
			}
			if(z.heavies.length === 0) {
				deadCivReport += "\r\n" + imageO(4526293) + "\r\n" + imageO(4526293);
			}
			if(deadCivReport.length > 0 && expansionReport.length > 0) {
				report += floatleft(center(expansionReport + "\r\n" + deadCivReport));
			} else {
				report += floatleft(center(deadCivReport));
			}
		} else if(expansionReport.length > 0) {
			report += floatleft(center(expansionReport));
		}
		report += clear();
	}
	report += "[h" + bl + "r]";
	let locationCount = 0;
	let demetrius = false;
	let rebel = false;
	if(z.galacticaAway || z.galacticaReturned) {
		report += floatleft(newCapricaImage());
		locationCount++;
	} else if(!z.colonialOneDestroyed) {
		report += floatleft(colonialOneImage());
		locationCount++;
	}
	if(z.pegasus && !z.pegasusDestroyed) {
		report += floatleft(pegasusImage());
		locationCount++;
	}
	if((z.destination === "Earth" || z.destination === "Ionian Earth") && (!z.vBrutality || !versionAtLeast([1, 2, 4, 6]))) {
		if(2 > locationCount) {
			report += floatleft(demetriusImage());
			locationCount++;
		} else {
			demetrius = true;
		}
	}
	if(z.rebelBasestar === 1 || z.rebelBasestar === -1) {
		if(2 > locationCount) {
			report += floatleft(rebelBasestarImage());
			locationCount++;
		} else {
			rebel = true;
		}
	}
	if(!z.galacticaAway) {
		report += floatleft(cylonImage());
	}
	report += clear();
	if(demetrius || rebel) {
		if(demetrius) {
			report += floatleft(demetriusImage());
		}
		if(rebel) {
			report += floatleft(rebelBasestarImage());
		}
		report += clear();
	}
	if(images) {
		report += "[h" + bl + "r]" + boardImage() + "[h" + bl + "r]";
	}
	if(images) {
		if(z.CFB) {
			report += CFBImage() + "[h" + bl + "r]";
		}
	}
	if(images) {
		report += floatleft(center(imageO(3770956) + "\r\n" + size(bold(colorText("orange", z.skillCardDecks[0].length)), 8)));
		report += floatleft(center(imageO(3770958) + "\r\n" + size(bold(colorText("green", z.skillCardDecks[1].length)), 8)));
		report += floatleft(center(imageO(3770959) + "\r\n" + size(bold(colorText("purple", z.skillCardDecks[2].length)), 8)));
		report += floatleft(center(imageO(3770960) + "\r\n" + size(bold(colorText("red", z.skillCardDecks[3].length)), 8)));
		report += floatleft(center(imageO(3770961) + "\r\n" + size(bold(colorText("blue", z.skillCardDecks[4].length)), 8)));
		if(z.pegasus || z.daybreak) {
			report += floatleft(center(imageO(3770964) + "\r\n" + size(bold(colorText("brown", z.skillCardDecks[5].length)), 8)));
		}
		report += floatleft(center(imageO(3770974) + "\r\n" + size(bold(z.destiny.length), 8)));
		if(z.galacticaAway || z.galacticaReturned) {
			report += floatleft(center(imageO(3770907) + "\r\n" + size(bold(z.crisisDeck.length), 8)));
		} else {
			report += floatleft(center(imageO(3770893) + "\r\n" + size(bold(z.crisisDeck.length), 8)));
		}
		report += floatleft(center(imageO(3770908) + "\r\n" + size(bold(z.destinationDeck.length), 8)));
		report += floatleft(center(imageO(3770911) + "\r\n" + size(bold(z.quorumDeck.length), 8)));
		if(z.daybreak) {
			report += floatleft(center(imageO(3770912) + "\r\n" + size(bold(z.mutinyDeck.length), 8)));
		}
		report += floatleft(center(imageO(3770909) + "\r\n" + size(bold(z.superCrisisDeck.length), 8)));
		if(z.preCrossroads) {
			if(z.destination === "Ionian Earth") {
				report += floatleft(center(imageO(3780568) + "\r\n" + size(bold(z.allyDeck.length), 8) + "\r\n" + imageO(3772016) + "\r\n" + size(bold(z
					.traumaPile.length), 8)));
			} else {
				report += floatleft(center(imageO(3780568) + "\r\n" + size(bold(z.allyDeck.length), 8)));
				report += floatleft(center(imageO(3772016) + "\r\n" + size(bold(z.traumaPile.length), 8)));
			}
		}
		if(z.destination === "Earth" || z.destination === "Ionian Earth") {
			report += floatleft(center(imageO(3770913) + "\r\n" + size(bold(z.missionDeck.length), 8)));
		}
		report += floatleft(center(imageO(3780575) + "\r\n" + size(bold(z.civilianPile.length), 8)));
		if(z.loyaltyDeck.length > 0) {
			report += floatleft(center(imageO(3931143) + "\r\n" + size(bold(z.loyaltyDeck.length), 8)));
		}
		report += clear();
	}
	if(images) {
		/*var turnReport = "";		for(let j = 0; !(j>=z.numPlayers); j++){			turnReport+="\r\n"+inv();			if(j===z.turn){				turnReport+=imageO(3772029);			} else {				turnReport+=vspacer();			}			turnReport+=inv();		}		report+=floatleft(center(turnReport.slice(2)));*/
		let titleReport = "";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			titleReport += "\r\n" + inv();
			let anything = false; /*if(j === z.turn){				titleReport+=imageO(3772029);				anything = true;			}*/
			if(j === z.admiral) {
				switch (z.nukes) {
					case 0:
						titleReport += imageO(3771992);
						break;
					case 1:
						titleReport += imageO(3773294);
						break;
					case 2:
						titleReport += imageO(3773295);
						break;
					case 3:
						titleReport += imageO(3773297);
						break;
				}
				anything = true;
			}
			if(j === z.president) {
				titleReport += imageO(3772009);
				anything = true;
			}
			if(z.CFB && j === z.cag) {
				titleReport += imageO(3772004);
				anything = true;
			}
			if(j === z.theSympathizer) {
				titleReport += imageO(3780566);
				anything = true;
			}
			if(j === z.theSympatheticCylon) {
				titleReport += imageO(3780567);
			}
			if(j === z.theMutineer) {
				titleReport += imageO(3772653);
				anything = true;
			} /*if((j === z.theCylonLeader || j === z.theSympatheticCylon) && z.revealedCylons[j] === 0){				titleReport += imageO(3772018);				anything = true;			}*/
			for(let k = 0; !(k >= z.quorumTitles[j].length); k++) {
				switch (z.quorumTitles[j][k]) {
					case 0:
						titleReport += imageO(3772691);
						anything = true;
						break;
					case 3:
						titleReport += imageO(3772690);
						anything = true;
						break;
					case 4:
						titleReport += imageO(3772688);
						anything = true;
						break;
					case 5:
						titleReport += imageO(3772689);
						anything = true;
						break;
					case 17:
						titleReport += imageO(3772693);
						anything = true;
						break;
					case 22:
						titleReport += imageO(3772694);
						anything = true;
				}
			}
			if(!anything) {
				titleReport += vspacer();
			}
			titleReport += inv();
		}
		if(z.assist !== undefined) {
			titleReport += "\r\n" + inv() + vspacer() + inv();
		}
		report += floatleft(center(titleReport.slice(2)));
		let skillsReport = "";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			skillsReport += "\r\n" + imageO(3772668) + bold(z.skillCardHands[j].length);
		}
		if(z.assist !== undefined) {
			skillsReport += "\r\n" + imageO(3772668) + bold(0);
		}
		report += floatleft(skillsReport.slice(2));
		let nameReport = "";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			nameReport += "\r\n" + inv() + nametag(j) + locationtag(j) + inv();
		}
		if(z.assist !== undefined) {
			nameReport += "\r\n" + inv() + nametag(1) + locationtag(1) + inv();
		}
		report += floatleft(center(nameReport.slice(2)));
		let miscReport = "";
		for(let j = 0; !(j >= z.numPlayers); j++) {
			miscReport += "\r\n";
			switch (z.miracles[j]) {
				case 0:
					miscReport += imageO(3772626);
					break;
				case 1:
					miscReport += imageO(3772024);
					break;
				case 2:
					miscReport += imageO(3772625);
					break;
				case 3:
					miscReport += imageO(3772627);
					break;
			}
			if(z.preCrossroads) {
				miscReport += inv() + imageO(3772016) + bold(z.antagonistic[j] + z.benevolent[j]);
			}
			if(z.loyaltyHands[j].length > 0) {
				if(isTheCylonLeader(j) || j === z.theSympatheticCylon) {
					miscReport += inv();
					if(z.daybreak || z.vNoAgendas) {
						if(z.loyaltyHands[j].length === 1) {
							miscReport += imageO(3772667);
						} else if(z.loyaltyHands[j].length > 1) {
							miscReport += imageO(3772667) + bold(z.loyaltyHands[j].length);
						}
					} else if(z.numPlayers + z.boxedPlayers.length === 5 || z.numPlayers + z.boxedPlayers.length === 7) {
						miscReport += imageO(3772664);
					} else {
						miscReport += imageO(3772665);
						if(z.loyaltyHands[j].length > 1) {
							miscReport += inv() + imageO(3772666);
							if(z.loyaltyHands[j].length > 2) {
								miscReport += bold((z.loyaltyHands[j].length - 1));
							}
						}
					}
				} else {
					miscReport += inv() + imageO(3772666);
					if(z.loyaltyHands[j].length > 1) {
						miscReport += bold(z.loyaltyHands[j].length);
					}
				}
			}
			if(Array.isArray(z.personalGoalsBrutality) && z.personalGoalsBrutality[j] !== null){
				miscReport += imageO(5306711);
			}
			if(z.president === j && z.quorumHand.length > 0) {
				miscReport += inv() + imageO(3772658);
				if(z.quorumHand.length > 1) {
					miscReport += bold(z.quorumHand.length);
				}
			}
			if(getPlayerNum("Billy") === j && z.billyHand.length > 0) {
				miscReport += inv() + imageO(3772658);
				if(z.billyHand.length > 1) {
					miscReport += bold(z.billyHand.length);
				}
			}
			if(z.daybreak && z.mutinies[j].length > 0) {
				miscReport += inv() + imageO(3772657);
				if(z.mutinies[j].length > 1) {
					miscReport += bold(z.mutinies[j].length);
				}
			}
			if(z.superCrisisHands[j].length > 0) {
				miscReport += inv() + imageO(3772659);
				if(z.superCrisisHands[j].length > 1) {
					miscReport += bold(z.superCrisisHands[j].length);
				}
			}
		}
		if(z.assist !== undefined) {
			miscReport += "\r\n";
			switch (z.assistMiracle) {
				case 0:
					miscReport += imageO(3772626);
					break;
				case 1:
					miscReport += imageO(3772024);
					break;
				case 2:
					miscReport += imageO(3772625);
					break;
				case 3:
					miscReport += imageO(3772627);
					break;
			}
			if(z.preCrossroads) {
				miscReport += inv() + imageO(3772016) + bold(0);
			}
			if(z.assistLoyalty.length > 0) {
				miscReport += inv() + imageO(3772666);
				if(z.assistLoyalty.length > 1) {
					miscReport += bold(z.assistLoyalty.length);
				}
			}
		}
		report += floatleft(miscReport.slice(2)) + clear();
		if(z.colonialOneDestroyed) {
			report += imageO(3771827);
		}
		if(z.hubDestroyed) {
			report += imageO(3771843);
		} /*if(z.rebelBasestar === 1){			report+=imageO(3771855)+imageO(3771857);		} else if (z.rebelBasestar === -1){			report+=imageO(3771855)+imageO(3771856);		}*/
		if(z.detectorSabotage) {
			report += imageO(3771829);
		}
		if(z.ambush) {
			report += imageO(3771826);
		}
		if(z.cylonSwarm) {
			report += imageO(3771828);
		}
		if(z.jammedAssault) {
			report += imageO(3771833);
		}
		if(z.thirtyThree) {
			report += imageO(3771838);
		}
		if(z.dogfightCAC) {
			report += imageO(3771830);
		}
		if(z.theGuardians) {
			report += imageO(3771837);
		}
		if(z.eventHorizon) {
			report += imageO(3771831);
		}
		if(z.hornetsNest) {
			report += imageO(3771832);
		}
		if(z.lockdown) {
			report += imageO(3771834);
		}
		if(z.luredIntoATrap) {
			report += imageO(3771835);
		}
		if(z.theFarm) {
			report += imageO(3771836);
		}
	}
	report += "[/" + "q]";
	t.value += report;
} /* TODO: add new player's banner at start of their turn? */
function imageO(id) {
	return "[ima" + bl + "geid=" + id + " original inline]";
}

function imageM(id) {
	return "[ima" + bl + "geid=" + id + " medium inline]";
}

function spacer() {
	return imageO(3767405);
}

function vspacer() {
	return imageO(3772031);
}

function basestarImage() {
	return imageO(3767272);
}

function raptorImage() {
	return imageO(3769937);
}

function raiderImage() {
	return imageO(3767269);
}

function heavyImage() {
	return imageO(3767270);
}

function scarImage() {
	return imageO(3768394);
}

function civilianImage() {
	return imageO(3767295);
}

function dieRollImage() {
	let r = "";
	switch (z.lastDieRollModifier) {
		case -3:
			r = imageO(3807729);
			break;
		case -2:
			r = imageO(3807730);
			break;
		case -1:
			r = imageO(3807731);
			break;
		case 1:
			r = imageO(3807732);
			break;
		case 2:
			r = imageO(3807733);
			break;
		case 3:
			r = imageO(3807734);
			break;
		case 4:
			r = imageO(3807735);
			break;
		case 5:
			r = imageO(3807736);
			break;
		case 0:
			break;
		default:
			r = "+" + z.lastDieRollModifier + "=";
	}
	if(z.lastDieRollModifier !== 0) {
		if(z.lastDieRollValue + z.lastDieRollModifier >= 8) {
			r += imageO(3789084);
		} else if(1 >= z.lastDieRollValue + z.lastDieRollModifier) {
			r += imageO(3789064);
		} else {
			switch (z.lastDieRollValue + z.lastDieRollModifier) {
				case 2:
					r += imageO(3789070);
					break;
				case 3:
					r += imageO(3789073);
					break;
				case 4:
					r += imageO(3789077);
					break;
				case 5:
					r += imageO(3789080);
					break;
				case 6:
					r += imageO(3789081);
					break;
				case 7:
					r += imageO(3789096);
					break;
			}
		}
	}
	switch (z.lastDieRollValue) {
		case 1:
			return imageO(3789064) + r;
		case 2:
			return imageO(3789070) + r;
		case 3:
			return imageO(3789073) + r;
		case 4:
			return imageO(3789077) + r;
		case 5:
			return imageO(3789080) + r;
		case 6:
			return imageO(3789081) + r;
		case 7:
			return imageO(3789096) + r;
		case 8:
			return imageO(3789084) + r;
		default:
			return r;
	}
}

function characterImage(chr) {
	switch (chr) {
		case "Adama":
			return imageO(4291475);
		case "Anders":
			return imageO(4291476);
		case "Apollo":
			return imageO(4291477);
		case "Athena":
			return imageO(4291478);
		case "Baltar":
			return imageO(4291479);
		case "Boomer":
			return imageO(4291480);
		case "Cain":
			return imageO(4291481);
		case "Cally":
			return imageO(4291482);
		case "Cavil":
			return imageO(4291483);
		case "Chief":
			return imageO(4291484);
		case "Cottle":
			return imageO(4291485);
		case "D'Anna":
			return imageO(4291486);
		case "Dee":
			return imageO(4291487);
		case "Doral":
			return imageO(4291488);
		case "Ellen":
			return imageO(4291489);
		case "Gaeta":
			return imageO(4291490);
		case "Gaius":
			return imageO(4291491);
		case "Helo":
			return imageO(4291492);
		case "Hoshi":
			return imageO(4291493);
		case "Hot Dog":
			return imageO(4291494);
		case "Karl":
			return imageO(4291495);
		case "Kat":
			return imageO(4291496);
		case "Lee":
			return imageO(4291497);
		case "Leoben":
			return imageO(4291498);
		case "Romo":
			return imageO(4291499);
		case "Roslin":
			return imageO(4291500);
		case "Simon":
			return imageO(4291501);
		case "Six":
			return imageO(4291502);
		case "Starbuck":
			return imageO(4291503);
		case "Tigh":
			return imageO(4291504);
		case "Tom":
			return imageO(4291505);
		case "Tory":
			return imageO(4291506);
		case "Zarek":
			return imageO(4291507);
		case "Billy":
			return imageO(4361003);
		case "Crashdown":
			return imageO(4361004);
		case "Shaw":
		case "Kendra":
			return imageO(4361005);
		case "Elosha":
			return imageO(4361006);
		case "Kelly":
			return imageO(4361007);
		case "Racetrack":
			return imageO(4361008);
		case "Seelix":
			return imageO(4361010);
		default:
			return imageO(4291474);
	}
}

function locationImage2(loc) {
	let allies = [];
	for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
		allies.push(d.allyNames[z.allies[j][0]]);
	}
	switch (loc) {
		case "Press Room":
			if(z.daybreak) {
				if(allies.includes("D'Anna") && allies.includes("Tory")) {
					return imageO(4293200);
				} else if(allies.includes("D'Anna")) {
					return imageO(4293199);
				} else if(allies.includes("Tory")) {
					return imageO(4293198);
				} else {
					return imageO(4293197);
				}
			} else {
				if(allies.includes("D'Anna") && allies.includes("Tory")) {
					return imageO(4293185);
				} else if(allies.includes("D'Anna")) {
					return imageO(4293184);
				} else if(allies.includes("Tory")) {
					return imageO(4293182);
				} else {
					return imageO(4293181);
				}
			}
			case "President's Office":
				if(z.daybreak) {
					if(allies.includes("Elosha") && allies.includes("Roslin")) {
						return imageO(4293205);
					} else if(allies.includes("Elosha")) {
						return imageO(4293202);
					} else if(allies.includes("Roslin")) {
						return imageO(4293204);
					} else {
						return imageO(4293201);
					}
				} else {
					if(allies.includes("Elosha") && allies.includes("Roslin")) {
						return imageO(4293189);
					} else if(allies.includes("Elosha")) {
						return imageO(4293188);
					} else if(allies.includes("Roslin")) {
						return imageO(4293187);
					} else {
						return imageO(4293186);
					}
				}
				case "Administration": {
					let numAllies = 0;
					if(allies.includes("Doral")) {
						numAllies++;
					}
					if(allies.includes("Billy")) {
						numAllies++;
					}
					if(allies.includes("Zarek")) {
						numAllies++;
					}
					if(z.daybreak) {
						if(numAllies === 3) {
							return imageO(4293212);
						} else if(numAllies === 2) {
							if(allies.includes("Billy")) {
								if(allies.includes("Doral")) {
									return imageO(4295690);
								} else {
									return imageO(4295691);
								}
							} else {
								return imageO(4295692);
							}
						} else if(allies.includes("Zarek")) {
							return imageO(4293210);
						} else if(allies.includes("Billy")) {
							return imageO(4293209);
						} else if(allies.includes("Doral")) {
							return imageO(4293208);
						} else {
							return imageO(4293207);
						}
					} else {
						if(numAllies === 3) {
							return imageO(4293196);
						} else if(numAllies === 2) {
							if(allies.includes("Billy")) {
								if(allies.includes("Doral")) {
									return imageO(4295687);
								} else {
									return imageO(4295688);
								}
							} else {
								return imageO(4295689);
							}
						} else if(allies.includes("Zarek")) {
							return imageO(4293194);
						} else if(allies.includes("Billy")) {
							return imageO(4293193);
						} else if(allies.includes("Doral")) {
							return imageO(4293191);
						} else {
							return imageO(4293190);
						}
					}
				}
				case "Weapons Control": {
					let numAllies = 0;
					if(allies.includes("Shaw") || allies.includes("Kendra")) {
						numAllies++;
					}
					if(allies.includes("Racetrack")) {
						numAllies++;
					}
					if(allies.includes("Hot Dog")) {
						numAllies++;
					}
					if(allies.includes("Helo")) {
						numAllies++;
					}
					if(z.damagedLocations.includes("Weapons Control")) {
						if(numAllies === 3) {
							return imageO(4293233);
						} else if(numAllies === 2) {
							return imageO(4293231);
						} else if(allies.includes("Helo")) {
							return imageO(4293229);
						} else if(allies.includes("Hot Dog")) {
							return imageO(4293228);
						} else if(allies.includes("Racetrack")) {
							return imageO(4293227);
						} else if(allies.includes("Shaw") || allies.includes("Kendra")) {
							return imageO(4293226);
						} else {
							return imageO(4291554);
						}
					} else {
						if(numAllies === 3) {
							return imageO(4293232);
						} else if(numAllies === 2) {
							if(allies.includes("Helo")) {
								if(allies.includes("Hot Dog")) {
									return imageO(4295693);
								} else if(allies.includes("Racetrack")) {
									return imageO(4295694);
								} else {
									return imageO(4295699);
								}
							} else if(allies.includes("Hot Dog")) {
								if(allies.includes("Racetrack")) {
									return imageO(4295695);
								} else {
									return imageO(4295697);
								}
							} else {
								return imageO(4295698);
							}
						} else if(allies.includes("Helo")) {
							return imageO(4293225);
						} else if(allies.includes("Hot Dog")) {
							return imageO(4293224);
						} else if(allies.includes("Racetrack")) {
							return imageO(4293223);
						} else if(allies.includes("Shaw") || allies.includes("Kendra")) {
							return imageO(4293221);
						} else {
							return imageO(4291525);
						}
					}
				}
				case "Communications": {
					let numAllies = 0;
					if(allies.includes("Leoben")) {
						numAllies++;
					}
					if(allies.includes("Hoshi")) {
						numAllies++;
					}
					if(allies.includes("Dee")) {
						numAllies++;
					}
					if(numAllies === 3) {
						return imageO(4293248);
					} else if(numAllies === 2) {
						if(allies.includes("Leoben")) {
							if(allies.includes("Hoshi")) {
								return imageO(4295700);
							} else {
								return imageO(4295703);
							}
						} else {
							return imageO(4295705);
						}
					} else if(allies.includes("Dee")) {
						return imageO(4293246);
					} else if(allies.includes("Hoshi")) {
						return imageO(4293245);
					} else if(allies.includes("Leoben")) {
						return imageO(4293244);
					} else {
						return imageO(4293243);
					}
				}
				case "Research Lab":
					if(allies.includes("Baltar") && allies.includes("Cavil")) {
						return imageO(4293255);
					} else if(allies.includes("Baltar")) {
						return imageO(4293254);
					} else if(allies.includes("Cavil")) {
						return imageO(4293253);
					} else {
						return imageO(4293252);
					}
					case "Sickbay":
						if(allies.includes("Cottle") && allies.includes("Simon") && z.sickbayTrauma !== undefined) {
							return imageO(4293273);
						} else if(allies.includes("Cottle") && z.sickbayTrauma !== undefined) {
							return imageO(4293272);
						} else if(allies.includes("Simon") && z.sickbayTrauma !== undefined) {
							return imageO(4293271);
						} else if(allies.includes("Cottle") && allies.includes("Simon")) {
							return imageO(6674248);
						} else if(allies.includes("Cottle") ) {
							return imageO(6674249);
						} else if(allies.includes("Simon") ) {
							return imageO(6674251);
						}else if(z.preCrossroads && z.sickbayTrauma !== undefined) {
							return imageO(4293028);
						} else {
							return imageO(4291524);
						}
						case "FTL Control":
							if(allies.includes("Gaeta")) {
								if(z.damagedLocations.includes("FTL Control")) {
									return imageO(4293277);
								} else {
									return imageO(4293276);
								}
							} else {
								if(z.damagedLocations.includes("FTL Control")) {
									return imageO(4291546);
								} else {
									return imageO(4291527);
								}
							}
							case "Armory": {
								let numAllies = 0;
								if(allies.includes("Seelix")) {
									numAllies++;
								}
								if(allies.includes("Crashdown")) {
									numAllies++;
								}
								if(allies.includes("Boomer")) {
									numAllies++;
								}
								if(allies.includes("Anders")) {
									numAllies++;
								}
								if(z.damagedLocations.includes("Armory")) {
									if(numAllies === 3) {
										return imageO(4293298);
									} else if(numAllies === 2) {
										return imageO(4293296);
									} else if(allies.includes("Anders")) {
										return imageO(4293294);
									} else if(allies.includes("Boomer")) {
										return imageO(4293292);
									} else if(allies.includes("Crashdown")) {
										return imageO(4293291);
									} else if(allies.includes("Seelix")) {
										return imageO(4293290);
									} else {
										return imageO(4291541);
									}
								} else {
									if(numAllies === 3) {
										return imageO(4293297);
									} else if(numAllies === 2) {
										return imageO(4293295);
									} else if(allies.includes("Anders")) {
										return imageO(4293289);
									} else if(allies.includes("Boomer")) {
										return imageO(4293288);
									} else if(allies.includes("Crashdown")) {
										return imageO(4293287);
									} else if(allies.includes("Seelix")) {
										return imageO(4293286);
									} else {
										return imageO(4291532);
									}
								}
							}
							case "Command": {
								let numAllies = 0;
								if(allies.includes("Cain")) {
									numAllies++;
								}
								if(allies.includes("Tigh")) {
									numAllies++;
								}
								if(allies.includes("Kelly")) {
									numAllies++;
								}
								if(z.damagedLocations.includes("Command")) {
									if(numAllies === 3) {
										return imageO(4293653);
									} else if(numAllies === 2) {
										return imageO(4293655);
									} else if(allies.includes("Cain")) {
										return imageO(4293656);
									} else if(allies.includes("Kelly")) {
										return imageO(4293657);
									} else if(allies.includes("Tigh")) {
										return imageO(4293658);
									} else {
										return imageO(4291544);
									}
								} else {
									if(numAllies === 3) {
										return imageO(4293652);
									} else if(numAllies === 2) {
										if(allies.includes("Kelly")) {
											if(allies.includes("Cain")) {
												return imageO(4295706);
											} else {
												return imageO(4295707);
											}
										} else {
											return imageO(4295708);
										}
									} else if(allies.includes("Cain")) {
										return imageO(4293660);
									} else if(allies.includes("Kelly")) {
										return imageO(4293661);
									} else if(allies.includes("Tigh")) {
										return imageO(4293663);
									} else {
										return imageO(4291535);
									}
								}
							}
							case "Admiral's Quarters":
								if(z.damagedLocations.includes("Admiral's Quarters")) {
									if(allies.includes("Ellen") && allies.includes("Adama")) {
										return imageO(4293670);
									} else if(allies.includes("Ellen")) {
										return imageO(4293681);
									} else if(allies.includes("Adama")) {
										return imageO(4293683);
									} else {
										return imageO(4291539);
									}
								} else {
									if(allies.includes("Ellen") && allies.includes("Adama")) {
										return imageO(4293684);
									} else if(allies.includes("Ellen")) {
										return imageO(4293685);
									} else if(allies.includes("Adama")) {
										return imageO(4293687);
									} else {
										return imageO(4291536);
									}
								}
								case "Hangar Deck": {
									let numAllies = 0;
									if(allies.includes("Apollo")) {
										numAllies++;
									}
									if(allies.includes("Cally")) {
										numAllies++;
									}
									if(allies.includes("Chief")) {
										numAllies++;
									}
									if(allies.includes("Kat")) {
										numAllies++;
									}
									if(allies.includes("Starbuck")) {
										numAllies++;
									}
									if(z.damagedLocations.includes("Hangar Deck")) {
										if(numAllies === 3) {
											return imageO(4293705);
										} else if(numAllies === 2) {
											return imageO(4293706);
										} else if(allies.includes("Apollo")) {
											return imageO(4293707);
										} else if(allies.includes("Cally")) {
											return imageO(4293709);
										} else if(allies.includes("Chief")) {
											return imageO(4293710);
										} else if(allies.includes("Kat")) {
											return imageO(4293711);
										} else if(allies.includes("Starbuck")) {
											return imageO(4293713);
										} else {
											return imageO(4293057);
										}
									} else {
										if(numAllies === 3) {
											return imageO(4293703);
										} else if(numAllies === 2) {
											if(allies.includes("Chief")) {
												if(allies.includes("Cally")) {
													return imageO(4295710);
												} else if(allies.includes("Starbuck")) {
													return imageO(4295711);
												} else if(allies.includes("Kat")) {
													return imageO(4295714);
												} else {
													return imageO(4295718);
												}
											} else if(allies.includes("Cally")) {
												if(allies.includes("Starbuck")) {
													return imageO(4295712);
												} else if(allies.includes("Kat")) {
													return imageO(4295713);
												} else {
													return imageO(4295719);
												}
											} else if(allies.includes("Kat")) {
												if(allies.includes("Starbuck")) {
													return imageO(4295715);
												} else {
													return imageO(4295717);
												}
											} else {
												return imageO(4295716);
											}
										} else if(allies.includes("Apollo")) {
											return imageO(4293714);
										} else if(allies.includes("Cally")) {
											return imageO(4293715);
										} else if(allies.includes("Chief")) {
											return imageO(4293716);
										} else if(allies.includes("Kat")) {
											return imageO(4339913);
										} else if(allies.includes("Starbuck")) {
											return imageO(4293718);
										} else {
											return imageO(4293056);
										}
									}
								}
								case "Brig":
									if(allies.includes("Romo") && allies.includes("Six") && z.brigTrauma !== undefined) {
										return imageO(4293723);
									} else if(allies.includes("Romo")  && z.brigTrauma !== undefined) {
										return imageO(4293724);
									} else if(allies.includes("Six")  && z.brigTrauma !== undefined) {
										return imageO(4293725);
									} else if(allies.includes("Romo") && allies.includes("Six")) {
										return imageO(6674258);
									} else if(allies.includes("Romo")) {
										return imageO(6674256);
									} else if(allies.includes("Six")) {
										return imageO(6674252);
									}else if(z.preCrossroads && z.brigTrauma !== undefined) {
										return imageO(4293058);
									} else {
										return imageO(4293059);
									}
	}
	return "";
}

function locationImage(loc) {
	let numPresent = 0;
	let lastChar = "";
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.playerLocations[j] === loc) {
			numPresent++;
			lastChar = z.players[j];
		}
		if(loc === "Caprica" && z.playerLocations[j] === "Stranded on Caprica") {
			numPresent++;
			lastChar = z.players[j];
		}
	}
	if(numPresent === 1) {
		return characterImage(lastChar);
	} else if(numPresent === 0) {
		switch (loc) {
			case "Weapons Control":
				return imageO(4291512);
			case "Communications":
				return imageO(4291514);
			case "Research Lab":
				return imageO(4291516);
			case "Sickbay":
				return imageO(4291518);
			case "FTL Control":
				return imageO(4291521);
			case "Armory":
				return imageO(4291523);
			case "Command":
				return imageO(4291528);
			case "Admiral's Quarters":
				return imageO(4901377);
			case "Hangar Deck":
				return imageO(4291531);
			case "Brig":
				return imageO(4291533);
			case "Pegasus CIC":
				return imageO(4291558);
			case "Airlock":
				return imageO(4291560);
			case "Main Batteries":
				return imageO(4291562);
			case "Engine Room":
				return imageO(4291564);
			case "Quorum Chamber":
				return imageO(4291571);
			case "Press Room":
				if(z.daybreak) {
					return imageO(4291575);
				} else {
					return imageO(4291598);
				}
				case "President's Office":
					if(z.daybreak) {
						return imageO(4291592);
					} else {
						return imageO(4291600);
					}
					case "Administration":
						if(z.daybreak) {
							return imageO(4291594);
						} else {
							return imageO(4291602);
						}
						case "Bridge":
							return imageO(4291607);
						case "Tactical Plot":
							return imageO(4291609);
						case "Captain's Cabin":
							return imageO(4291611);
						case "Hybrid Tank":
							return imageO(4291616);
						case "Datastream":
							return imageO(4291618);
						case "Raider Bay":
							return imageO(4291620);
						case "Basestar Bridge":
							return imageO(4291627);
						case "Caprica":
							return imageO(4291633);
						case "Cylon Fleet":
							return imageO(4291635);
						case "Human Fleet":
							return imageO(4291641);
						case "Resurrection Ship":
							if(z.pegasus || z.daybreak) {
								return imageO(4291653);
							} else {
								return imageO(4291644);
							}
							case "Hub Destroyed":
								return imageO(4291666);
							case "Medical Center":
								return imageO(4291669);
							case "Resistance HQ":
								return imageO(4291671);
							case "Detention":
								return imageO(4291675);
							case "Occupation Authority":
								return imageO(4291677);
							case "Breeder's Canyon":
								return imageO(4291679);
							case "Shipyard":
								return imageO(4291681);
							default:
								return imageO(4291474);
		}
	} else {
		switch (numPresent) {
			case 2:
				return imageO(4294211);
			case 3:
				return imageO(4294212);
			case 4:
				return imageO(4294213);
			case 5:
				return imageO(4294214);
			case 6:
				return imageO(4294215);
			default:
				return imageO(4294216);
		}
	}
}

function galacticaImage() {
	let galactica = imageO(4901304) + "\r\n";
	galactica += imageO(4291511) + locationImage("Weapons Control") + imageO(4291513) + locationImage("Communications") + imageO(4291515) + locationImage(
		"Research Lab") + imageO(4291517) + locationImage("Sickbay") + imageO(4291519) + "\r\n";
	galactica += imageO(4291520) + locationImage("FTL Control") + locationImage2("Weapons Control") + locationImage2("Communications") + locationImage2(
		"Research Lab") + locationImage("Armory") + locationImage2("Sickbay") + "\r\n";
	galactica += locationImage2("FTL Control") + locationImage("Command") + imageO(4291526) + locationImage("Admiral's Quarters") + imageO(4901378) +
		locationImage("Hangar Deck") + locationImage2("Armory") + locationImage("Brig") + imageO(4291534) + "\r\n";
	galactica += locationImage2("Command") + locationImage2("Admiral's Quarters") + locationImage2("Hangar Deck") + locationImage2("Brig") + "\r\n";
	galactica += imageO(4901297);
	return galactica;
} /* TODO: these for crashdown*/
function IIImage() {
	if(arguments.length === 0) {
		return imageO(3767266);
	} else {
		switch (arguments[0]) {
			case "Anders":
				return imageO(3768185);
			case "Apollo":
				return imageO(3768190);
			case "Athena":
				return imageO(3768258);
			case "Boomer":
				return imageO(3768261);
			case "Helo":
				return imageO(3768266);
			case "Hot Dog":
				return imageO(3768272);
			case "Karl":
				return imageO(3768273);
			case "Kat":
				return imageO(3768278);
			case "Lee":
				return imageO(3768279);
			case "Starbuck":
				return imageO(3768283);
			case "Racetrack":
				return imageO(4361045);
			case "Seelix":
				return imageO(4361044);
		}
	}
}

function VIIImage() {
	if(arguments.length === 0) {
		return imageO(3767267);
	} else {
		switch (arguments[0]) {
			case "Anders":
				return imageO(3768295);
			case "Apollo":
				return imageO(3768296);
			case "Athena":
				return imageO(3768309);
			case "Boomer":
				return imageO(3768314);
			case "Helo":
				return imageO(3768316);
			case "Hot Dog":
				return imageO(3768321);
			case "Karl":
				return imageO(3768322);
			case "Kat":
				return imageO(3768327);
			case "Lee":
				return imageO(3768328);
			case "Starbuck":
				return imageO(3768334);
			case "Racetrack":
				return imageO(4361043);
			case "Seelix":
				return imageO(4361042);
		}
	}
}

function ARImage() {
	if(arguments.length === 0) {
		return imageO(3767268);
	} else {
		switch (arguments[0]) {
			case "Anders":
				return imageO(3768348);
			case "Apollo":
				return imageO(3768359);
			case "Athena":
				return imageO(3768361);
			case "Boomer":
				return imageO(3768366);
			case "Helo":
				return imageO(3768367);
			case "Hot Dog":
				return imageO(3768371);
			case "Karl":
				return imageO(3768373);
			case "Kat":
				return imageO(3768374);
			case "Lee":
				return imageO(3768377);
			case "Starbuck":
				return imageO(3768380);
			case "Racetrack":
				return imageO(4361041);
			case "Seelix":
				return imageO(4361040);
		}
	}
}

function damageImage(dam) {
	if(z.destination === "Ionian Nebula" || z.destination === "Ionian Earth") {
		switch (dam) {
			case "Critical Hit":
				return imageO(3767281);
			case "Structural Damage":
				return imageO(3767282);
			case "Weapons Disabled":
				return imageO(3767284);
			case "Hangar Disabled":
				return imageO(3767285);
			case "Collateral Damage":
				return imageO(3767286);
			case "Damage to Personnel":
				return imageO(3767287);
		}
	} else {
		switch (dam) {
			case "Critical Hit":
				return imageO(3767274);
			case "Structural Damage":
				return imageO(3767278);
			case "Weapons Disabled":
				return imageO(3767277);
			case "Hangar Disabled":
				return imageO(3767275);
		}
	}
}

function pursuitImage() {
	switch (z.pursuitTrack) {
		case 0:
			return imageO(3769875);
		case 1:
			return imageO(3769890);
		case 2:
			return imageO(3769893);
		case 3:
			return imageO(3769894);
	}
}

function jumpImage() {
	if(z.galacticaReturned) {
		return imageO(3788208);
	}
	switch (z.jumpTrack) {
		case 0:
			return imageO(3769911);
		case 1:
			return imageO(3769912);
		case 2:
			return imageO(3769914);
		case 3:
			return imageO(3769915);
		case 4:
			return imageO(3769916);
		default:
			return imageO(3769918);
	}
}

function pegasusImage() {
	if(z.pegasusDestroyed) {
		return imageO(3771680);
	}
	let cic = false;
	let airlock = false;
	let mb = false;
	let er = false;
	for(let j = 0; !(j >= z.damagedLocations.length); j++) {
		switch (z.damagedLocations[j]) {
			case "Pegasus CIC":
				cic = true;
				break;
			case "Airlock":
				airlock = true;
				break;
			case "Main Batteries":
				mb = true;
				break;
			case "Engine Room":
				er = true;
				break;
		}
	}
	let pegasus = imageO(4291555) + "\r\n";
	pegasus += locationImage("Pegasus CIC") + imageO(4291559) + locationImage("Airlock") + imageO(4291561) + locationImage("Main Batteries") + imageO(4291563) +
		locationImage("Engine Room") + "\r\n";
	if(cic) {
		pegasus += imageO(4291553);
	} else {
		pegasus += imageO(4291565);
	}
	if(airlock) {
		pegasus += imageO(4291540);
	} else {
		pegasus += imageO(4291566);
	}
	if(mb) {
		pegasus += imageO(4291552);
	} else {
		pegasus += imageO(4291567);
	}
	if(er) {
		pegasus += imageO(4291545);
	} else {
		pegasus += imageO(4291568);
	}
	return pegasus; /*	if(z.pegasusDestroyed){		return imageO(3771680);	}	let pegasusDamage = ["0","0","0","0"];	for(let j = 0; !(j>=z.damagedLocations.length); j++){		switch(z.damagedLocations[j]){			case "Pegasus CIC":				pegasusDamage[0] = "1";				break;			case "Airlock":				pegasusDamage[1] = "1";				break;			case "Main Batteries":				pegasusDamage[2] = "1";				break;			case "Engine Room":				pegasusDamage[3] = "1";				break;		}	}	switch(pegasusDamage[0]+pegasusDamage[1]+pegasusDamage[2]+pegasusDamage[3]){		case "0000":			return imageO(3769986);		case "0001":			return imageO(3770004);		case "0010":			return imageO(3770007);		case "0011":			return imageO(3770020);		case "0100":			return imageO(3770021);		case "0101":			return imageO(3770023);		case "0110":			return imageO(3770024);		case "0111":			return imageO(3770025);		case "1000":			return imageO(3770026);		case "1001":			return imageO(3770027);		case "1010":			return imageO(3770029);		case "1011":			return imageO(3770030);		case "1100":			return imageO(3770031);		case "1101":			return imageO(3770033);		case "1110":			return imageO(3770034);	}*/
}

function colonialOneImage() {
	/* TODO: Colonial One Destroyed image */
	let c1 = "";
	if(z.daybreak) {
		c1 += imageO(4291570) + locationImage("Quorum Chamber") + imageO(4291573) + locationImage("Press Room") + imageO(4291576) + locationImage(
			"President's Office") + imageO(4291593) + locationImage("Administration") + imageO(4291595) + "\r\n";
		c1 += locationImage2("Press Room") + locationImage2("President's Office") + locationImage2("Administration");
	} else {
		c1 += imageO(4291597) + locationImage("Press Room") + imageO(4291599) + locationImage("President's Office") + imageO(4291601) + locationImage(
			"Administration") + imageO(4291603) + "\r\n";
		c1 += locationImage2("Press Room") + locationImage2("President's Office") + locationImage2("Administration");
	}
	return c1;
}

function demetriusImage() {
	let demetrius = imageO(4291605) + "\r\n";
	demetrius += imageO(4291606) + locationImage("Bridge") + imageO(4291608) + locationImage("Tactical Plot") + imageO(4291610) + locationImage(
		"Captain's Cabin") + imageO(4291612) + "\r\n";
	demetrius += imageO(4291613);
	return demetrius;
}

function rebelBasestarImage() {
	let rebel = "";
	if(z.rebelBasestar === -1) {
		rebel += imageO(4291614);
	} else {
		rebel += imageO(4291623);
	}
	rebel += "\r\n" + imageO(4291615) + locationImage("Hybrid Tank") + imageO(4291617) + locationImage("Datastream") + imageO(4291619) + locationImage(
		"Raider Bay") + imageO(4291624) + "\r\n";
	rebel += imageO(4291622);
	return rebel;
}

function basestarBridgeImage() {
	let bb = imageO(4291625) + "\r\n";
	bb += imageO(4291626) + locationImage("Basestar Bridge") + imageO(4291628) + "\r\n";
	bb += imageO(4291629);
	return bb;
}

function newCapricaImage() {
	let nc = imageO(4901303) + "\r\n";
	nc += imageO(4291668) + locationImage("Medical Center") + imageO(4291670) + locationImage("Resistance HQ") + imageO(4291672) + "\r\n";
	nc += imageO(4291673) + "\r\n";
	nc += imageO(4291674) + locationImage("Detention") + imageO(4291676) + locationImage("Occupation Authority") + imageO(4291678) + locationImage(
		"Breeder's Canyon") + imageO(4291680) + locationImage("Shipyard") + imageO(4291682);
	switch (z.preparedCivilians.length) {
		case 12:
			nc += imageO(4292489);
			break;
		case 11:
			nc += imageO(4292487);
			break;
		case 10:
			nc += imageO(4292479);
			break;
		case 9:
			nc += imageO(4292476);
			break;
		case 8:
			nc += imageO(4292475);
			break;
		case 7:
			nc += imageO(4292474);
			break;
		case 6:
			nc += imageO(4292473);
			break;
		case 5:
			nc += imageO(4292472);
			break;
		case 4:
			nc += imageO(4292471);
			break;
		case 3:
			nc += imageO(4292467);
			break;
		case 2:
			nc += imageO(4292465);
			break;
		case 1:
			nc += imageO(4292430);
			break;
		default:
			nc += imageO(4291683);
			break;
	}
	nc += imageO(4291684) + "\r\n";
	let c = 0;
	for(let j = 0; !(j >= 4); j++) {
		if(z.OFs[j] === 1) {
			c++;
		}
	}
	switch (c) {
		case 4:
			nc += imageO(4292530);
			break;
		case 3:
			nc += imageO(4292529);
			break;
		case 2:
			nc += imageO(4292528);
			break;
		case 1:
			nc += imageO(4291690);
			break;
		default:
			nc += imageO(4291685);
			break;
	}
	c = 0;
	for(let j = 0; !(j >= 4); j++) {
		if(z.OFs[j] === 2) {
			c++;
		}
	}
	switch (c) {
		case 4:
			nc += imageO(4292525);
			break;
		case 3:
			nc += imageO(4292524);
			break;
		case 2:
			nc += imageO(4292520);
			break;
		case 1:
			nc += imageO(4291691);
			break;
		default:
			nc += imageO(4291686);
			break;
	}
	c = 0;
	for(let j = 0; !(j >= 4); j++) {
		if(z.OFs[j] === 3) {
			c++;
		}
	}
	switch (c) {
		case 4:
			nc += imageO(4292533);
			break;
		case 3:
			nc += imageO(4292532);
			break;
		case 2:
			nc += imageO(4292531);
			break;
		case 1:
			nc += imageO(4291692);
			break;
		default:
			nc += imageO(4291687);
			break;
	}
	switch (z.lockedCivilians.length) {
		case 12:
			nc += imageO(4292514);
			break;
		case 11:
			nc += imageO(4292512);
			break;
		case 10:
			nc += imageO(4292511);
			break;
		case 9:
			nc += imageO(4292510);
			break;
		case 8:
			nc += imageO(4292509);
			break;
		case 7:
			nc += imageO(4292508);
			break;
		case 6:
			nc += imageO(4292506);
			break;
		case 5:
			nc += imageO(4292505);
			break;
		case 4:
			nc += imageO(4292504);
			break;
		case 3:
			nc += imageO(4292502);
			break;
		case 2:
			nc += imageO(4292501);
			break;
		case 1:
			nc += imageO(4292493);
			break;
		default:
			nc += imageO(4291688);
			break;
	}
	return nc;
}

function cylonImage() {
	let cylon = imageO(4901299);
	if(z.pegasus || z.daybreak) {
		cylon += imageO(4901300);
	} else {
		cylon += imageO(4901302);
	}
	cylon += "\r\n" + imageO(4291632) + locationImage("Caprica") + imageO(4291634) + locationImage("Cylon Fleet") + imageO(4291636) + locationImage(
		"Human Fleet") + imageO(4291642);
	if(z.pegasus || z.daybreak) {
		cylon += imageO(4291652);
		if(z.hubDestroyed) {
			cylon += locationImage("Hub Destroyed") + imageO(4291665);
		} else {
			cylon += locationImage("Resurrection Ship") + imageO(4291654) + imageO(4291658);
		}
	} else {
		cylon += imageO(4291643) + locationImage("Resurrection Ship") + imageO(4291645) + imageO(4291659);
	}
	cylon += "\r\n" + imageO(4291650);
	if(z.pegasus || z.daybreak) {
		cylon += imageO(4291656);
	} else {
		cylon += imageO(4291647);
	}
	return cylon;
}

function allyImage(ally) {
	switch (d.allyNames[ally]) {
		case "D'Anna":
			return floatleft(center(bold(size(imageO(3771433) + "\r\nPress\r\nRoom", 7))));
		case "Tory":
			return floatleft(center(bold(size(imageO(3771436) + "\r\nPress\r\nRoom", 7))));
		case "Elosha":
			return floatleft(center(bold(size(imageO(3771434) + "\r\nPres.\r\nOffice", 7))));
		case "Roslin":
			return floatleft(center(bold(size(imageO(3771435) + "\r\nPres.\r\nOffice", 7))));
		case "Adama":
			return floatleft(center(bold(size(imageO(3771485) + "\r\nAQ", 7))));
		case "Anders":
			return floatleft(center(bold(size(imageO(3771486) + "\r\nArmory", 7))));
		case "Apollo":
			return floatleft(center(bold(size(imageO(3771487) + "\r\nHangar\r\nDeck", 7))));
		case "Baltar":
			return floatleft(center(bold(size(imageO(3771488) + "\r\nLab", 7))));
		case "Billy":
			return floatleft(center(bold(size(imageO(3771489) + "\r\nAdmin", 7))));
		case "Boomer":
			return floatleft(center(bold(size(imageO(3771490) + "\r\nArmory", 7))));
		case "Cain":
			return floatleft(center(bold(size(imageO(3771492) + "\r\nCmd.", 7))));
		case "Cally":
			return floatleft(center(bold(size(imageO(3771493) + "\r\nHangar\r\nDeck", 7))));
		case "Cavil":
			return floatleft(center(bold(size(imageO(3771495) + "\r\nLab", 7))));
		case "Chief":
			return floatleft(center(bold(size(imageO(3771496) + "\r\nHangar\r\nDeck", 7))));
		case "Cottle":
			return floatleft(center(bold(size(imageO(3771497) + "\r\nSickbay", 7))));
		case "Crashdown":
			return floatleft(center(bold(size(imageO(3771498) + "\r\nArmory", 7))));
		case "Dee":
			return floatleft(center(bold(size(imageO(3771499) + "\r\nComms", 7))));
		case "Doral":
			return floatleft(center(bold(size(imageO(3771501) + "\r\nAdmin", 7))));
		case "Ellen":
			return floatleft(center(bold(size(imageO(3771504) + "\r\nAQ", 7))));
		case "Gaeta":
			return floatleft(center(bold(size(imageO(3771505) + "\r\nFTL", 7))));
		case "Helo":
			return floatleft(center(bold(size(imageO(3771508) + "\r\nWpns.\r\nControl", 7))));
		case "Hoshi":
			return floatleft(center(bold(size(imageO(3771509) + "\r\nComms", 7))));
		case "Hot Dog":
			return floatleft(center(bold(size(imageO(3771510) + "\r\nWpns.\r\nControl", 7))));
		case "Kat":
			return floatleft(center(bold(size(imageO(3771512) + "\r\nHangar\r\nDeck", 7))));
		case "Kelly":
			return floatleft(center(bold(size(imageO(3771513) + "\r\nCmd.", 7))));
		case "Shaw":
		case "Kendra":
			return floatleft(center(bold(size(imageO(3771515) + "\r\nWpns.\r\nControl", 7))));
		case "Leoben":
			return floatleft(center(bold(size(imageO(3771516) + "\r\nComms", 7))));
		case "Romo":
			return floatleft(center(bold(size(imageO(3771517) + "\r\nBrig", 7))));
		case "Seelix":
			return floatleft(center(bold(size(imageO(3771519) + "\r\nArmory", 7))));
		case "Simon":
			return floatleft(center(bold(size(imageO(3771521) + "\r\nSickbay", 7))));
		case "Six":
			return floatleft(center(bold(size(imageO(3771523) + "\r\nBrig", 7))));
		case "Starbuck":
			return floatleft(center(bold(size(imageO(3771524) + "\r\nHangar\r\nDeck", 7))));
		case "Tigh":
			return floatleft(center(bold(size(imageO(3771525) + "\r\nCmd.", 7))));
		case "Zarek":
			return floatleft(center(bold(size(imageO(3771526) + "\r\nAdmin", 7))));
		case "Racetrack":
			return floatleft(center(bold(size(imageO(3771531) + "\r\nWpns.\r\nControl", 7))));
	}
	return "";
}

function CFBImage() {
	let anything = false;
	let sectorReports = [imageO(3771886), imageO(3771887), imageO(3771888), imageO(3771889), imageO(3771890), imageO(3771891)];
	for(let i = 1; !(i > 6); i++) {
		sectorReports[i - 1] += "\r\n";
		let cylonReport = "";
		let humanReport = "";
		if(z.basestars.length > 0 && z.basestars[0][0] === -i) {
			cylonReport += "\r\n" + basestarImage();
			anything = true;
		}
		if(z.basestars.length > 1 && z.basestars[1][0] === -i) {
			humanReport += "\r\n" + basestarImage();
			anything = true;
		}
		let raiderCount = 0;
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] === -i) {
				raiderCount++;
			}
		}
		if(raiderCount > 0) {
			anything = true;
			cylonReport += "\r\n" + raiderImage();
			if(raiderCount > 1) {
				cylonReport += "\r\n" + colorText("red", bold(size("x" + raiderCount, 8)));
			}
		}
		let heavyCount = 0;
		for(let j = 0; !(j >= z.heavies.length); j++) {
			if(z.heavies[j] === -i) {
				heavyCount++;
			}
		}
		if(heavyCount > 0) {
			anything = true;
			humanReport += "\r\n" + heavyImage();
			if(heavyCount > 1) {
				humanReport += "\r\n" + colorText("red", bold(size("x" + heavyCount, 8)));
			}
		}
		if(cylonReport !== "" && humanReport !== "") {
			sectorReports[i - 1] += floatleft(center(cylonReport.slice(2))) + floatright(center(humanReport.slice(2)));
		} else if(cylonReport === "" && humanReport !== "") {
			sectorReports[i - 1] += "\r\n" + humanReport.slice(2);
		} else if(cylonReport !== "" && humanReport === "") {
			sectorReports[i - 1] += "\r\n" + cylonReport.slice(2);
		}
		if(i === 4) {
			sectorReports[3] = center(pursuitImage() + "\r\n\r\n" + sectorReports[3]);
		} else if(i === 1) {
			sectorReports[0] = center("\r\n" + imageO(3770116) + "\r\n\r\n\r\n" + sectorReports[0]);
		} else {
			sectorReports[i - 1] = center(sectorReports[i - 1]);
		}
	}
	for(let j = 0; !(j >= z.numPlayers) && !anything && !z.galacticaAway; j++) {
		anything = z.revealedCylons[j] === 1;
	}
	if(anything) {
		return floatleft(sectorReports[0]) + floatleft(floatleft(sectorReports[1]) + floatright(sectorReports[2]) + clear() + "\r\n" + center(
			basestarBridgeImage()) + floatleft(sectorReports[5]) + floatright(sectorReports[4])) + floatleft(sectorReports[3]) + clear();
	} else {
		return floatleft(center(imageO(3770116) + "\r\n" + pursuitImage() + "\r\n" + bold("The CFB is empty."))) + clear();
	}
} /* TODO: Sabotage warning in Pegasus games */
function locationtag(player) {
	let loc = "";
	if(z.assist !== undefined && player === 1) {
		loc = "Stranded on Caprica";
	} else {
		loc = z.playerLocations[player];
	}
	switch (loc) {
		case "Administration":
			return imageO(3772318);
		case "Admiral's Quarters":
			return imageO(3772799);
		case "Airlock":
			return imageO(3772319);
		case "Armory":
			return imageO(3772320);
		case "Basestar Bridge":
			return imageO(3772321);
		case "Bridge":
			return imageO(3772324);
		case "Brig":
			return imageO(4644597);
		case "Caprica":
			return imageO(3772326);
		case "Captain's Cabin":
			return imageO(3772328);
		case "Command":
			return imageO(3772329);
		case "Communications":
			return imageO(3772330);
		case "Cylon Fleet":
			return imageO(3772332);
		case "Detention":
			return imageO(4644608);
		case "Engine Room":
			return imageO(3772337);
		case "FTL Control":
			return imageO(3772338);
		case "Hangar Deck":
			return imageO(3772339);
		case "Hub Destroyed":
			return imageO(4644607);
		case "Human Fleet":
			return imageO(3772344);
		case "Main Batteries":
			return imageO(3772348);
		case "Pegasus CIC":
			return imageO(3772354);
		case "President's Office":
			return imageO(3772355);
		case "Press Room":
			return imageO(3772356);
		case "Quorum Chamber":
			return imageO(3772357);
		case "Research Lab":
			return imageO(3772360);
		case "Resurrection Ship":
			if(z.pegasus || z.daybreak) {
				return imageO(4644596);
			} else {
				return imageO(3772364);
			}
			case "Sector 1":
				return imageO(3772365);
			case "Sector 2":
				return imageO(3772366);
			case "Sector 3":
				return imageO(3772367);
			case "Sector 4":
				return imageO(3772368);
			case "Sector 5":
				return imageO(3772369);
			case "Sector 6":
				return imageO(3772370);
			case "Sickbay":
				return imageO(4644595);
			case "Stranded on Caprica":
				return imageO(3772375);
			case "Tactical Plot":
				return imageO(3772377);
			case "Weapons Control":
				return imageO(3772379);
			case "Breeder's Canyon":
				if(z.revealedCylons[player] === 0) {
					return imageO(3772322);
				} else {
					return imageO(3772323);
				}
				case "Datastream":
					if(z.revealedCylons[player] === 0) {
						return imageO(3772333);
					} else {
						return imageO(3772334);
					}
					case "Hybrid Tank":
						if(z.revealedCylons[player] === 0) {
							return imageO(3772346);
						} else {
							return imageO(3772347);
						}
						case "Medical Center":
							if(z.revealedCylons[player] === 0) {
								return imageO(4644606);
							} else {
								return imageO(4644605);
							}
							case "Occupation Authority":
								if(z.revealedCylons[player] === 0) {
									return imageO(3772352);
								} else {
									return imageO(3772353);
								}
								case "Raider Bay":
									if(z.revealedCylons[player] === 0) {
										return imageO(3772358);
									} else {
										return imageO(3772359);
									}
									case "Resistance HQ":
										if(z.revealedCylons[player] === 0) {
											return imageO(3772361);
										} else {
											return imageO(3772362);
										}
										case "Shipyard":
											if(z.revealedCylons[player] === 0) {
												return imageO(3772371);
											} else {
												return imageO(3772372);
											}
	}
	return z.playerLocations[player];
}

function nametag(player) {
	let name = "";
	if(z.assist !== undefined && player === 1) {
		name = z.assist;
	} else {
		name = z.players[player];
	}
	if(player !== z.turn) {
		switch (name) {
			case "Adama":
				return imageO(3772200);
			case "Anders":
				return imageO(3772202);
			case "Apollo":
				return imageO(3772204);
			case "Athena":
				return imageO(3772207);
			case "Baltar":
				return imageO(3772209);
			case "Boomer":
				return imageO(3772214);
			case "Cain":
				return imageO(3772216);
			case "Cally":
				return imageO(3772217);
			case "Cavil":
				return imageO(3772220);
			case "Chief":
				return imageO(3772222);
			case "Cottle":
				return imageO(3772228);
			case "D'Anna":
				return imageO(3772231);
			case "Dee":
				return imageO(3772233);
			case "Doral":
				return imageO(3772235);
			case "Ellen":
				return imageO(3772237);
			case "Gaeta":
				return imageO(3772251);
			case "Gaius":
				return imageO(3772253);
			case "Helo":
				return imageO(3772254);
			case "Hoshi":
				return imageO(3772257);
			case "Hot Dog":
				return imageO(3772260);
			case "Karl":
				return imageO(3772262);
			case "Kat":
				return imageO(3772264);
			case "Lee":
				return imageO(3772266);
			case "Leoben":
				return imageO(3772268);
			case "Romo":
				return imageO(3772270);
			case "Roslin":
				return imageO(3772272);
			case "Simon":
				return imageO(3772274);
			case "Six":
				return imageO(3772297);
			case "Starbuck":
				return imageO(3772299);
			case "Tigh":
				return imageO(3772301);
			case "Tom":
				return imageO(3772304);
			case "Tory":
				return imageO(3772306);
			case "Zarek":
				return imageO(3772311);
			case "Billy":
				return imageO(4361009);
			case "Crashdown":
				return imageO(4361012);
			case "Elosha":
				return imageO(4361014);
			case "Kelly":
				return imageO(4361015);
			case "Shaw":
			case "Kendra":
				return imageO(4708202);
			case "Seelix":
				return imageO(4361024);
			case "Racetrack":
				return imageO(4361026);
		}
	} else {
		switch (name) {
			case "Adama":
				return imageO(3772201);
			case "Anders":
				return imageO(3772203);
			case "Apollo":
				return imageO(3772205);
			case "Athena":
				return imageO(3772208);
			case "Baltar":
				return imageO(3772210);
			case "Boomer":
				return imageO(3772215);
			case "Cain":
				return imageO(3772218);
			case "Cally":
				return imageO(3772219);
			case "Cavil":
				return imageO(3772221);
			case "Chief":
				return imageO(3772224);
			case "Cottle":
				return imageO(3772229);
			case "D'Anna":
				return imageO(3772232);
			case "Dee":
				return imageO(3772234);
			case "Doral":
				return imageO(3772236);
			case "Ellen":
				return imageO(3772239);
			case "Gaeta":
				return imageO(3772252);
			case "Gaius":
				return imageO(3772255);
			case "Helo":
				return imageO(3772256);
			case "Hoshi":
				return imageO(3772258);
			case "Hot Dog":
				return imageO(3772261);
			case "Karl":
				return imageO(3772263);
			case "Kat":
				return imageO(3772265);
			case "Lee":
				return imageO(3772267);
			case "Leoben":
				return imageO(3772269);
			case "Romo":
				return imageO(3772271);
			case "Roslin":
				return imageO(3772273);
			case "Simon":
				return imageO(3772275);
			case "Six":
				return imageO(3772298);
			case "Starbuck":
				return imageO(3772300);
			case "Tigh":
				return imageO(3772302);
			case "Tom":
				return imageO(3772305);
			case "Tory":
				return imageO(3772307);
			case "Zarek":
				return imageO(3772314);
			case "Billy":
				return imageO(4361011);
			case "Crashdown":
				return imageO(4361014);
			case "Elosha":
				return imageO(4361028);
			case "Kelly":
				return imageO(4361016);
			case "Shaw":
			case "Kendra":
				return imageO(4708206);
			case "Seelix":
				return imageO(4361025);
			case "Racetrack":
				return imageO(4361027);
		}
	}
	return z.players[player];
}

function boardImage() {
	let sectorReports = [imageO(3771863), imageO(3771864), imageO(3771865), imageO(3771866), imageO(3771867), imageO(3771868)];
	for(let i = 1; !(i > 6); i++) {
		/* restore spacer if necessary */
		sectorReports[i - 1] += "\r\n"; /* do we want this? */
		let cylonReport = "";
		if(z.basestars.length > 0 && z.basestars[0][0] === i) {
			cylonReport += "\r\n" + basestarImage();
			if(z.basestars[0].length > 1) {
				cylonReport += "\r\n";
				for(let j = 1; !(j >= z.basestars[0].length); j++) {
					cylonReport += damageImage(z.basestars[0][j]);
				}
			}
		}
		if(z.basestars.length > 1 && z.basestars[1][0] === i) {
			cylonReport += "\r\n" + basestarImage();
			if(z.basestars[1].length > 1) {
				cylonReport += "\r\n";
				for(let j = 1; !(j >= z.basestars[1].length); j++) {
					cylonReport += damageImage(z.basestars[1][j]);
				}
			}
		}
		if(z.scar === i) {
			cylonReport += "\r\n" + scarImage();
		}
		let raiderCount = 0;
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] === i) {
				raiderCount++;
			}
		}
		if(raiderCount > 0) {
			cylonReport += "\r\n" + raiderImage();
			if(raiderCount > 1) {
				cylonReport += "\r\n" + colorText("red", bold(size("x" + raiderCount, 8)));
			}
		}
		let heavyCount = 0;
		for(let j = 0; !(j >= z.heavies.length); j++) {
			if(z.heavies[j] === i) {
				heavyCount++;
			}
		}
		if(heavyCount > 0) {
			cylonReport += "\r\n" + heavyImage();
			if(heavyCount > 1) {
				cylonReport += "\r\n" + colorText("red", bold(size("x" + heavyCount, 8)));
			}
		}
		let humanReport = "";
		if(z.spaceCivilians[i - 1].length > 0) {
			humanReport += "\r\n" + civilianImage();
			for(let j = 0; !(j >= z.spaceCivilians[i - 1].length); j++) {
				if(j % 4 === 0) {
					humanReport += "\r\n[b" + "][si" + "ze=8]";
				}
				humanReport += z.spaceCivilians[i - 1][j][0];
				if(j % 4 === 3 || j === z.spaceCivilians[i - 1].length - 1) {
					humanReport += "[/si" + "ze][/" + "b]";
				}
			}
		}
		let viperIICount = 0;
		for(let j = 0; !(j >= z.vipersII.length); j++) {
			if(z.vipersII[j] === i) {
				viperIICount++;
			}
		}
		if(viperIICount > 0) {
			humanReport += "\r\n" + IIImage();
			if(viperIICount > 1) {
				humanReport += "\r\n" + colorText("teal", bold(size("x" + viperIICount, 8)));
			}
		}
		if(z.CFB) {
			let viperVIICount = 0;
			for(let j = 0; !(j >= z.vipersVII.length); j++) {
				if(z.vipersVII[j] === i) {
					viperVIICount++;
				}
			}
			if(viperVIICount > 0) {
				humanReport += "\r\n" + VIIImage();
				if(viperVIICount > 1) {
					humanReport += "\r\n" + colorText("teal", bold(size("x" + viperVIICount, 8)));
				}
			}
		}
		if(z.daybreak) {
			let ARCount = 0;
			for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
				if(z.assaultRaptors[j] === i) {
					ARCount++;
				}
			}
			if(ARCount > 0) {
				humanReport += "\r\n" + ARImage();
				if(ARCount > 1) {
					humanReport += "\r\n" + colorText("teal", bold(size("x" + ARCount, 8)));
				}
			}
		}
		for(let j = 0; !(j >= z.numPlayers); j++) {
			if(z.playerLocations[j] === "Sector " + i) {
				for(let k = 0; !(k >= z.vipersII.length); k++) {
					if(z.vipersII[k] === z.players[j]) {
						humanReport += "\r\n" + IIImage(z.players[j]);
					}
				}
				for(let k = 0; z.CFB && !(k >= z.vipersVII.length); k++) {
					if(z.vipersVII[k] === z.players[j]) {
						humanReport += "\r\n" + VIIImage(z.players[j]);
					}
				}
				for(let k = 0; z.daybreak && !(k >= z.assaultRaptors.length); k++) {
					if(z.assaultRaptors[k] === z.players[j]) {
						humanReport += "\r\n" + ARImage(z.players[j]);
					}
				}
			}
		}
		if(cylonReport !== "" && humanReport !== "") {
			sectorReports[i - 1] += "\r\n" + floatleft(center(cylonReport.slice(2))) + floatright(center(humanReport.slice(2)));
		} else if(cylonReport === "" && humanReport !== "") {
			sectorReports[i - 1] += "\r\n" + humanReport.slice(2);
		} else if(cylonReport !== "" && humanReport === "") {
			sectorReports[i - 1] += "\r\n" + cylonReport.slice(2);
		}
		if(i === 1) {
			sectorReports[0] = center(jumpImage() + "\r\n\r\n" + sectorReports[0]);
		} else if(i === 4) {
			let centurionReport = "";
			if(z.centurions.length === centurionReserves()) {
				centurionReport = imageO(3770838);
			} else {
				for(let j = 1; !(j > 5); j++) {
					let c = 0;
					for(let k = 0; !(k >= z.centurions.length); k++) {
						if(z.centurions[k] === j) {
							c++;
						}
					}
					switch (j) {
						case 1:
							switch (c) {
								case 0:
									centurionReport += imageO(3770811);
									break;
								case 1:
									centurionReport += imageO(3770812);
									break;
								case 2:
									centurionReport += imageO(3770813);
									break;
								case 3:
									centurionReport += imageO(3770814);
									break;
								case 4:
									centurionReport += imageO(3770815);
									break;
							}
							break;
						case 2:
							switch (c) {
								case 0:
									centurionReport += imageO(3770822);
									break;
								case 1:
									centurionReport += imageO(3770823);
									break;
								case 2:
									centurionReport += imageO(3770824);
									break;
								case 3:
									centurionReport += imageO(3770825);
									break;
								case 4:
									centurionReport += imageO(3770826);
									break;
							}
							break;
						case 3:
							switch (c) {
								case 0:
									centurionReport += imageO(3770827);
									break;
								case 1:
									centurionReport += imageO(3770828);
									break;
								case 2:
									centurionReport += imageO(3770829);
									break;
								case 3:
									centurionReport += imageO(3770830);
									break;
								case 4:
									centurionReport += imageO(3770831);
									break;
							}
							break;
						case 4:
							switch (c) {
								case 0:
									centurionReport += imageO(3770832);
									break;
								case 1:
									centurionReport += imageO(3770833);
									break;
								case 2:
									centurionReport += imageO(3770834);
									break;
								case 3:
									centurionReport += imageO(3770835);
									break;
								case 4:
									centurionReport += imageO(3770836);
									break;
							}
							break;
					}
				}
				centurionReport += imageO(3770837);
			}
			sectorReports[3] = center(centurionReport + "\r\n" + sectorReports[3]);
		} else {
			sectorReports[i - 1] = center(sectorReports[i - 1]);
		}
	}
	return floatleft(sectorReports[0]) + floatleft(floatleft(sectorReports[1]) + floatright(sectorReports[2]) + clear() + galacticaImage() + "\r\n" + floatleft(
		sectorReports[5]) + floatright(sectorReports[4])) + floatleft(sectorReports[3]) + clear();
}

function startThatTurn(){
	let newPlayerLoc = z.playerLocations[z.turn];
	let newPlayer = z.players[z.turn];
	if(z.round === z.andersBenchRound && z.players[z.turn] === "Anders" && !noDrawback(z.turn) && !z
		.vBrutality) {
		addAlert("Anders Starts on the Bench.");
		t.value += "Anders Starts on the Bench, and does not draw skill cards this turn.\r\n";
		z.drawSkills = false;
		z.phase = 1;
	} else if(!hasVariableDraw(z.turn) && (((z.players[z.turn] !== "Ellen" || z.miracles[z.turn] === 0 || z
			.theFarm) && (z.players[z.turn] !== "Gaius" || !actsOfFaith("Ellen"))) || ((z.turn === z.admiral ||
			z.playerLocations[z.turn] === "Brig") && z.turn === z.president)) && z.assist === undefined && (z
			.players[z.turn] !== "Billy" || !versionAtLeast([2, 1, 6]) || z.miracles[z.turn] === 0 || z.theFarm) &&
		(z.players[z.turn] !== "Gaius" || !actsOfFaith("Billy") || !versionAtLeast([2, 1, 6]))) {
		for(let i = 0; !(i >= 6); i++) {
			for(let j = d.skillDraws[i ][getCharacter(z.players[z.turn])]; j > 0; j--) {
				dealSkillCard(z.turn, i);
			}
		}
		z.drawSkills = false;
		z.phase = 1;
		addAlert("Dealt " + newPlayer + " their skill cards for the turn.");
		if(z.players[z.turn] === "Billy" && (!versionAtLeast([2,1,9]) || versionAtLeast([2,1,13]) || z.turn !== z.president)) {
			dealQuorumCard(true);
		}
		if(z.heloReturnRound > z.round && z.players[z.turn] === "Helo") {
			z.phase = 3;
		}
	} else if(newPlayerLoc === "Hub Destroyed") {
		t.value += newPlayer +
			" is starting their turn on Hub Destroyed, and draws no skill cards during their Receive Skills step.\r\n";
		if(z.superCrisisHands[z.turn].length > 0) {
			t.value += newPlayer + " discards all Super Crises in hand:\r\n";
			z.superCrisisHands[z.turn].sort();
			for(let i = 0; !(i >= z.superCrisisHands[z.turn].length); i++) {
				t.value += d.crisisNames[z.superCrisisHands[z.turn][i ]] + "\r\n";
			}
			z.superCrisisDiscards = z.superCrisisDiscards.concat(z.superCrisisHands[z.turn]);
			z.superCrisisHands[z.turn] = [];
		}
		if(newPlayer === "D'Anna" && z.vBrutality) {
			t.value +=
				"D'Anna uses her Investigative Journalism ability to look at the top card of the Crisis deck.  She must now draw 1 skill card (it may come from outside her skill set).\r\n";
			if(me === z.turn) {
				addAlert("The top crisis of the deck is " + d.crisisNames[z.crisisDeck[z.crisisDeck.length - 1]] +
					".");
			}
			if(z.crisisDeck.length === 1) {
				let crisis = z.crisisDeck.pop();
				plainAlert("Crisis deck reshuffles.");
				z.crisisDeck = shuffle(z.crisisDiscards);
				z.crisisDeck.push(crisis);
				z.crisisDiscards = [];
			}
			z.secretMessages[z.turn] += "\nInvestigative Journalism, Turn " + z.round + "." + (z.turn + 1) + ": " +
				d.crisisNames[z.crisisDeck[z.crisisDeck.length - 1]];
			addOption(z.turn, "Draw 1 Skill Card (any color)", "Investigative Journalism Hub", true);
		} else {
			z.phase = 1;
		}
		z.drawSkills = false;
	} else if(newPlayer === "D'Anna" && z.vBrutality) {
		t.value +=
			"D'Anna uses her Investigative Journalism ability to look at the top card of the Crisis deck.  She must now draw 1 skill card (it may come from outside her skill set), then take her normal Receive Skills step.\r\n";
		if(me === z.turn) {
			addAlert("The top crisis of the deck is " + d.crisisNames[z.crisisDeck[z.crisisDeck.length - 1]] + ".");
		}
		if(z.crisisDeck.length === 1) {
			let crisis = z.crisisDeck.pop();
			plainAlert("Crisis deck reshuffles.");
			z.crisisDeck = shuffle(z.crisisDiscards);
			z.crisisDeck.push(crisis);
			z.crisisDiscards = [];
		}
		z.secretMessages[z.turn] += "\nInvestigative Journalism, Turn " + z.round + "." + (z.turn + 1) + ": " + d
			.crisisNames[z.crisisDeck[z.crisisDeck.length - 1]];
		addOption(z.turn, "Draw 1 Skill Card (any color)", "Investigative Journalism", true);
		z.drawSkills = false;
	} else if(z.players[z.turn] === "Athena" && !noDrawback(z.turn) && (newPlayerLoc === "Brig" || newPlayerLoc ===
			"Sickbay" || newPlayerLoc === "Medical Center" || newPlayerLoc === "Detention" || newPlayerLoc ===
			"Resurrection Ship")) {
		t.value += "Athena is Grieving, and draws no skill cards during her Receive Skills step.\r\n";
		z.drawSkills = false;
		z.phase = 1;
	} else if(z.playerLocations[z.turn] === "Sickbay") {
		t.value += z.players[z.turn] +
			" is starting their turn in Sickbay, and only draws 1 skill card during their Receive Skills step.\r\n";
		if(z.players[z.turn] === "Billy" && z.turn !== z.theSympatheticCylon && versionAtLeast([2,1,9]) && (versionAtLeast([2,1,13]) ||z.turn !== z.president)){
			dealQuorumCard(true);
		}
	} else if(z.playerLocations[z.turn] === "Medical Center") {
		t.value += z.players[z.turn] +
			" is starting their turn in the Medical Center, and only draws 1 skill card during their Receive Skills step.\r\n";
	} else if((z.pegasus || z.daybreak) && z.playerLocations[z.turn] === "Resurrection Ship") {
		t.value += z.players[z.turn] +
			" is starting their turn on the Resurrection Ship, and only draws 1 skill card during their Receive Skills step.\r\n";
	} else if(newPlayer === "Karl" && !isOnGalactica(z.turn) && z.revealedCylons[z.turn] === 0 && !z.vBrutality && !
		noDrawback(z.turn)) {
		t.value +=
			"Due to his Family Commitments, Karl draws only 4 skill cards during his Receive Skills step.\r\n";
	} else if(newPlayer === "Anders" && z.round === z.andersBenchRound && z.players[z.turn] === "Anders" && !
		noDrawback(z.turn) && z.vBrutality) {
		t.value += "Anders Starts on the Bench, and draws only 2 skill cards this turn.\r\n";
	} else if(newPlayer === "Ellen" && z.revealedCylons[z.turn] == 0 && z.turn !== z.theSympatheticCylon) {
		t.value += "If Ellen is not using her Manipulative ability, she may now draw her skill cards.\r\n";
	} else if(newPlayer === "Gaius" && (actsOfFaith("Ellen") || actsOfFaith("Billy"))) {
		if(actsOfFaith("Ellen") && !actsOfFaith("Billy")) {
			t.value += "If Gaius is not using Ellen's Manipulative ability, he may now draw his skill cards.\r\n";
		} else if(actsOfFaith("Billy") && !actsOfFaith("Ellen")) {
			t.value +=
				"If Gaius is not using Billy's Moment of Heroism ability, he may now draw his skill cards.\r\n";
		} else {
			t.value +=
				"If Gaius is not using either Ellen's OPG or Billy's OPG, he may now draw his skill cards.\r\n";
		}
	} else if(newPlayer === "Billy" && versionAtLeast([2, 1, 6]) && z.turn !== z.theSympatheticCylon && z.revealedCylons[z.turn] === 0) {
		t.value +=
			"If Billy is not using his Moment of Heroism ability, he may now draw his skill cards and Quorum card.\r\n";
	} else if(newPlayer === "Doral" && z.revealedCylons[z.turn] === 0) {
		t.value += "Doral is infiltrating, and will draw 2 extra skill cards this turn.\r\n";
	} else if((isCylonLeader(newPlayer) || z.turn === z.theSympatheticCylon) && z.revealedCylons[z.turn] === 0) {
		t.value += newPlayer + " is infiltrating, and will draw an extra skill card this turn.\r\n";
	} else if(z.revealedCylons[z.turn] === 1 && !isCylonLeader(newPlayer) && z.noSympathizer) {
		t.value += newPlayer + " must now draw their 3 skill cards.\r\n";
	} else if(z.revealedCylons[z.turn] === 1 && !isCylonLeader(newPlayer)) {
		t.value += newPlayer + " must now draw their 2 skill cards.\r\n";
	} else {
		t.value += newPlayer + " has a variable draw.\r\n";
	}
	if(newPlayer === "Starbuck" && isInSpace(z.turn) && (!z.vBrutality || !versionAtLeast([1, 2, 4, 2]))) {
		t.value += "Starbuck may take an extra action this turn, due to her Expert Pilot ability.\r\n";
		z.expertPilot = true;
	}
	if(newPlayer === "Starbuck" && z.vBrutality && versionAtLeast([1, 2, 4, 2])) {
		z.expertPilot = true;
	}
	if(newPlayer === "Kat" && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && newPlayerLoc !==
		"Brig" && newPlayerLoc !== "Sickbay" && !onNewCaprica(newPlayerLoc) && !noDrawback(z.turn)) {
		z.stim = newPlayerLoc;
		t.value += bold("Kat is a Stim Junkie:") + " if Kat is still in " + newPlayerLoc +
			" at the end of her Action Step, she will be moved to Sickbay.\r\n";
	}
	if(newPlayer === "Kat" && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && newPlayerLoc !==
		"Detention" && newPlayerLoc !== "Medical Center" && onNewCaprica(newPlayerLoc) && !noDrawback(z.turn)) {
		z.stim = newPlayerLoc;
		t.value += bold("Kat is a Stim Junkie:") + " if Kat is still in " + newPlayerLoc +
			" at the end of her Action Step, she will be moved to the Medical Center.\r\n";
	}
	if(newPlayer === "Cain" && z.revealedCylons[z.turn] === 0 && anyUndamagedBasestars() && z.vBrutality && versionAtLeast([2,1,9])){
		t.value += bold("Cain is Bent on Revenge:") + " if there are still any undamaged Basestars at the end of her Action step,"
				+ " she will draw a Mutiny.\r\n";
	}
	if(newPlayer === "Romo" && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && !noDrawback(z
			.turn)) {
		/* TODO: change this up based on number of skill cards he has? */
		if(otherPlayerInLocation(z.turn, z.playerLocations[z.turn])) {
			t.value += bold("Romo is a Kleptomaniac") +
				"; if he does not move to an empty space by the end of his Movement step, he must discard 2 skill cards; if he cannot, he is moved to the Brig at the end of his turn.\r\n";
		} else {
			t.value +=
				"Romo is a Kleptomaniac; if he moves to a space with another player, he must discard 2 skill cards; if he cannot, he is moved to the Brig at the end of his turn.\r\n";
		}
	}
	for(let i = 0; z.preCrossroads && !(i >= z.allies.length); i++) {
		if(z.playerLocations[z.turn] === d.allyLocations[z.allies[i ][0]]) {
			t.value += newPlayer +
				" is on the same location as an Ally, and will meet an Ally if they do not move this turn.\r\n";
			break;
		}
	}
}


function allyPop() {
	if(z.allyDeck.length === 0) {
		return -1;
	}
	let newAlly = z.allyDeck.pop();
	let newAllyName = d.allyNames[newAlly];
	let altName = "Nur-Ab-Sal";
	if(newAllyName === "Apollo") {
		altName = "Lee";
	} else if(newAllyName === "Helo") {
		altName = "Karl";
	} else if(newAllyName === "Zarek") {
		altName = "Tom";
	} else if(newAllyName === "Baltar") {
		altName = "Gaius";
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(newAllyName === z.players[j] || altName === z.players[j]) {
			return allyPop();
		}
	}
	for(let j = 0; !(j >= z.graveyard.length); j++) {
		if(newAllyName === z.graveyard[j] || altName === z.graveyard[j]) {
			return allyPop();
		}
	}
	if(z.colonialOneDestroyed && onColonialOne(d.allyLocations[newAlly])) {
		return allyPop();
	}
	return newAlly;
}

function gameSetup() {
	z.gameSetup = true;
	z.mutineer = false;
	z.cylonLeader = false;
	z.sympathizer = false;
	z.sympatheticCylon = false;
	z.noSympathizer = false;
	z.seed = Math.floor(Math.random() * mLCG);

	confirmify("Use Pegasus expansion?", () => {
		z.pegasus = false;
		exodusPrompt();
	}, () => {
		z.pegasus = true;
		exodusPrompt();
	}, "YES", "NO");
}

function exodusPrompt() {
	confirmify("Use Exodus expansion?", () => {
		z.exodus = false;
		daybreakPrompt();
	}, () => {
		z.exodus = true;
		daybreakPrompt();
	}, "YES", "NO");
}

function daybreakPrompt() {
	confirmify("Use Daybreak expansion?", () => {
		z.daybreak = false;
		if(z.exodus) {
			CFBPrompt();
		} else {
			numPlayersPrompt();
		}
	}, () => {
		z.daybreak = true;
		if(z.exodus) {
			CFBPrompt();
		} else {
			numPlayersPrompt();
		}
	}, "YES", "NO");
}

function CFBPrompt() {
	confirmify("Use Cylon Fleet Board?", () => {
		z.CFB = false;
		finalFivesPrompt();
	}, () => {
		z.CFB = true;
		finalFivesPrompt();
	}, "YES", "NO");
}

function finalFivesPrompt() {
	confirmify("Use Final Fives?", () => {
		z.finalFives = false;
		personalGoalsPrompt();
	}, () => {
		z.finalFives = true;
		personalGoalsPrompt();
	}, "YES", "NO");
}

function personalGoalsPrompt() {
	confirmify("Use Personal Goals?", () => {
		z.personalGoals = false;
		numPlayersPrompt();
	}, () => {
		z.personalGoals = true;
		numPlayersPrompt();
	}, "YES", "NO");
}

function clearBackground() {
	hideElement(alertifyBackground);
}

function isMobile() {
	try {
		document.createEvent("TouchEvent");
		return true;
	} catch (e) {
		return false;
	}
}
mobile = isMobile();

function numPlayersPrompt() {
	let maxPlayers = 6;
	if(z.daybreak || z.pegasus) {
		maxPlayers++;
	}
	promptNum("How many players? (1-" + maxPlayers + ")", (a) => 1 > a || a > maxPlayers, clearBackground, (prompted) => {
		z.numPlayers = prompted;
		if(z.numPlayers > 3 && z.numPlayers !== 7 && (z.pegasus || z.daybreak)) {
			confirmify("Use Cylon Leader?", () => {
				z.cylonLeader = false;
				if(z.numPlayers === 4 || z.numPlayers === 6) {
					if(z.daybreak) {
						mutineerPrompt();
					} else if(z.pegasus) {
						confirmify("Use Sympathetic Cylon?", () => {
							z.sympatheticCylon = false;
							sympathizerPrompt();
						}, () => {
							z.sympatheticCylon = true;
							objectivePrompt();
						}, "YES", "NO");
					}
				} else {
					objectivePrompt();
				}
			}, () => {
				z.cylonLeader = true;
				if(z.numPlayers === 5 && z.daybreak) {
					mutineerPrompt();
				} else {
					objectivePrompt();
				}
			}, "YES", "NO");
		} else if(z.numPlayers === 7) {
			z.cylonLeader = true;
			if(z.daybreak){
				mutineerPrompt();
			} else {
				objectivePrompt();
			}
		} else if(z.numPlayers === 4 || z.numPlayers === 6) {
			sympathizerPrompt();
		} else {
			objectivePrompt();
		}
	});
}

function mutineerPrompt() {
	confirmify("Use Mutineer?", ()=>{
		addAlert("Using Official No Sympathizer Variant.");
		z.noSympathizer = true;
		objectivePrompt();
	},()=>{
		addAlert("Using a Mutineer.");
		z.mutineer = true;
		objectivePrompt();
	},"YES","NO");
}

function sympathizerPrompt() {
	confirmify("Use Sympathizer?", () => {
		z.sympathizer = false;
		addAlert("Using Official No Sympathizer Variant.");
		z.noSympathizer = true;
		objectivePrompt();
	}, () => {
		z.sympathizer = true;
		objectivePrompt();
	}, "YES", "NO");
}

function objectivePrompt() {
	if(!z.pegasus && !z.exodus && !z.daybreak) {
		z.destination = "Kobol";
		addAlert("Objective is Kobol.");
		variantsPrompt();
	} else {
		let options = ["Kobol"];
		if(z.pegasus) {
			options.push("New Caprica");
		}
		if(z.exodus) {
			options.push("Ionian Nebula");
		}
		if(z.daybreak) {
			options.push("Earth");
		}
		let promptText = "For which Objective is the fleet bound? (1-" + options.length + ")";
		for(let i = 0; !(i >= options.length); i++) {
			promptText += "\n" + (i + 1) + ": " + options[i ];
		}
		promptNum(promptText, (a) => 1 > a || a > options.length, clearBackground, (prompted) => {
			z.destination = options[prompted - 1];
			addAlert("Objective is " + z.destination + ".");
			variantsPrompt();
		});
	}
}

function variantsPrompt() {
	let variants = [];
	z.pegasusIC = z.pegasus;
	if(!z.pegasus) {
		variants.push("Use Pegasus IC");
	}
	z.quorumHandLimit = 17;
	if(!z.pegasus && !z.exodus && !z.daybreak) {
		variants.push("10-card Quorum Hand Limit");
	} else {
		z.quorumHandLimit = 10;
	}
	z.vExodusMinusCFB = false;
	if(z.exodus && !z.CFB) {
		variants.push("Exodus Minus CFB Variant");
	}
	z.vSoloCylonHandicap = false;
	if(z.exodus && z.numPlayers > 2) {
		variants.push("Solo Cylon Handicap (Original)");
	}
	z.vSoloCylonBrutality = false;
	if(z.exodus && z.numPlayers > 2) {
		variants.push("Solo Cylon Handicap (Brutality)");
	}
	if(z.exodus && z.daybreak && z.destination === "Ionian Nebula") {
		variants.push("Ionian Earth");
	}
	z.vAltTrauma = false;
	if(z.destination === "Ionian Nebula") {
		variants.push("Alternative Trauma Token Drawing");
	}
	z.vAltDamage = false;
	if(z.pegasus) {
		variants.push("Random Pegasus Damage");
	}
	z.vHandoff = false;
	if(!z.pegasus && !z.daybreak) {
		variants.push("Automatic Loyalty Handoff");
	}
	z.vNoCain = false;
	if(z.pegasus || z.exodus) {
		variants.push("Ban Cain");
	}
	z.vCain = false;
	if(z.pegasus || z.exodus) {
		variants.push("Truly Blind Jump");
	}
	z.vAllCharacters = false;
	variants.push("Characters From All Expansions");
	z.vPandemic = false;
	if(!z.CFB) {
		variants.push("Stack the CACs");
	}
	z.vBalancedMotives = false;
	if(z.cylonLeader) {
		variants.push("Balanced Motives");
	}
	z.vDisasterDeferred = false;
	if(z.destination === "Ionian Nebula") {
		variants.push("Disaster Deferred");
	}
	z.vBrutality = false;
	variants.push("Brutality");
	z.vBrutalityPlus = false;
	if(z.pegasus && (!z.personalGoals || z.daybreak)){
		variants.push("Brutality Plus");
	}
	
	z.vPersonalGoalsMovement = false;
	if(z.personalGoals) {
		variants.push("Personal Goals as Movement");
	}
	z.vNoBoxing = false;
	if(z.destination === "Ionian Nebula"){
		variants.push("No Boxing");
	}
	z.vMegaVoyage = false;
	variants.push("Mega Voyage");
	z.vAllClasses = false;
	variants.push("No Character Class Restrictions");
	z.vNoRandom = false;
	variants.push("No Turn Order Randomization");
	if(z.cylonLeader && !z.daybreak){
		z.vNoAgendas = false;
		variants.push("Motives Minus Daybreak");
	}
	z.v20 = false;
	if((z.numPlayers === 5 && !z.cylonLeader) || (z.numPlayers === 6 && z.noSympathizer)){
		variants.push("20 Loyalty Cards");
	}
	z.vInfiltration = false;
	if(z.noSympathizer){
		variants.push("Infiltration Variant");
	}
	if(z.destination === "Ionian Nebula"){
		variants.push("European Trauma");
	}
	let usedVariants = [];
	for(let j = 0; !(j >= variants.length); j++) {
		usedVariants.push(false);
	}
	let anyVariants = false;
	if(variants.length > 0) {
		let variantPrompt = function() {
			let promptText = "You may toggle variants here.  Once you're done, press Cancel to proceed.";
			for(let j = 0; !(j >= variants.length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(usedVariants[j]) {
					promptText += "[ON] ";
				} else {
					promptText += "[OFF] ";
				}
				promptText += variants[j];
			}
			promptNum(promptText, (a) => 1 > a || a > variants.length, () => {
				for(let j = 0; !(j >= variants.length); j++) {
					if(usedVariants[j]) {
						anyVariants = true;
						switch (variants[j]) {
							case "Use Pegasus IC":
								z.pegasusIC = true;
								break;
							case "10-card Quorum Hand Limit":
								z.quorumHandLimit = 10;
								break;
							case "Exodus Minus CFB Variant":
								z.vExodusMinusCFB = true;
								break;
							case "Solo Cylon Handicap (Original)":
								z.vSoloCylonHandicap = true;
								break;
							case "Solo Cylon Handicap (Brutality)":
								z.vSoloCylonBrutality = true;
								break;
							case "Ionian Earth":
								z.destination = "Ionian Earth";
								break;
							case "Alternative Trauma Token Drawing":
								z.vAltTrauma = true;
								break;
							case "Random Pegasus Damage":
								z.vAltDamage = true;
								break;
							case "Automatic Loyalty Handoff":
								z.vHandoff = true;
								break;
							case "Ban Cain":
								z.vNoCain = true;
								break;
							case "Truly Blind Jump":
								z.vCain = true;
								break;
							case "Characters From All Expansions":
								z.vAllCharacters = true;
								break;
							case "Stack the CACs":
								z.vPandemic = true;
								break;
							case "Balanced Motives":
								z.vBalancedMotives = true;
								break;
							case "Disaster Deferred":
								z.vDisasterDeferred = true;
								break;
							case "Brutality":
								z.vBrutality = true;
								break;
							case "Brutality Plus":
								z.vBrutalityPlus = true;
								break;
							case "Personal Goals as Movement":
								z.vPersonalGoalsMovement = true;
								break;
							case "No Boxing":
								z.vNoBoxing = true;
								break;
							case "Mega Voyage":
								z.vMegaVoyage = true;
								break;
							case "No Character Class Restrictions":
								z.vAllClasses = true;
								break;
							case "Motives Minus Daybreak":
								z.vNoAgendas = true;
								break;
							case "20 Loyalty Cards":
								z.v20 = true;
								break;
							case "Infiltration Variant":
								z.vInfiltration = true;
								z.noSympathizer = false;
								break;
							case "No Turn Order Randomization":
								z.vNoRandom = true;
								break;
							case "European Trauma":
								z.vEuropeanTrauma = true;
								break;
						}
					}
				}
				if(z.vMegaVoyage){
					promptSeed(anyVariants,variants,usedVariants);
				} else {
					promptUsernames(anyVariants, variants, usedVariants, 1);
				}
			}, (prompted) => {
				usedVariants[prompted - 1] = !usedVariants[prompted - 1];
				variantPrompt();
			});
		};
		variantPrompt();
	} else {
		promptUsernames(anyVariants, variants, usedVariants, 1);
	}
}

function promptSeed(anyVariants, variants, usedVariants){
	promptString("Enter the seed from the previous game in this series.  If this is the first game in this series, press Cancel.",
		()=>{
			z.megaVoyageSeed = null;
			promptUsernames(anyVariants,variants,usedVariants,1);
		},(prompted)=>{
			if(prompted === ""){
				z.megaVoyageSeed = null;
			} else {
				prompted = window.atob(prompted.replace(/-/g, ""));
				z.megaVoyageSeed = JSON.parse(prompted);
			}
			promptUsernames(anyVariants,variants,usedVariants,1);
		});
}

function promptUsernames(anyVariants, variants, usedVariants, j) {
	if(j === 1) {
		z.usernames = [];
	}
	if(j > z.numPlayers) {
		if(!z.vNoRandom){
			shuffle(z.usernames);
		}
		finishSetup(anyVariants, variants, usedVariants);
	} else {
		let st = "Enter the BGG username of a player (" + j + "/" + z.numPlayers + ").";
		if(!z.vNoRandom){
			st+="\nTurn order will be randomized before character selection.";
		}
		promptString(st,
			clearBackground, (prompted) => {
				z.usernames.push(prompted);
				promptUsernames(anyVariants, variants, usedVariants, j + 1);
			});
	}
}

function finishSetup(anyVariants, variants, usedVariants) {
	t.value = t.value + bold(size("[thread"+"=1848115]By Your Command Setup["+"/thread]", 14)) + "\r\n\r\n";
	if(z.vBrutality) {
		if(z.exodus) {
			let index = variants.indexOf("Solo Cylon Handicap (Brutality)");
			usedVariants[index] = true;
			z.vSoloCylonBrutality = true;
			index = variants.indexOf("Solo Cylon Handicap (Original)");
			usedVariants[index] = false;
			z.vSoloCylonHandicap = false;
		}
		let index = variants.indexOf("Ban Cain");
		usedVariants[index] = false;
		z.vNoCain = false;
		index = variants.indexOf("Truly Blind Jump");
		usedVariants[index] = false;
		z.vCain = false;
		if(z.destination === "Ionian Nebula" || z.destination === "Ionian Earth") {
			index = variants.indexOf("Exodus Minus CFB Variant");
			usedVariants[index] = false;
			z.vExodusMinusCFB = false;
		}
	}
	if(z.v20 && z.vInfiltration){
		let index = variants.indexOf("Infiltration Variant");
		usedVariants[index] = false;
		z.vInfiltration = false;
	}
	if(!z.vBrutality){
		let index = variants.indexOf("Brutality Plus");
		usedVariants[index] = false;
		z.vBrutalityPlus = false;
	}
	if(z.vPandemic && z.exodus && z.destination !== "Ionian Nebula" && z.destination !== "Ionian Earth") {
		let index = variants.indexOf("Exodus Minus CFB Variant");
		usedVariants[index] = false;
		z.vExodusMinusCFB = false;
	}
	if(z.vPersonalGoalsMovement && z.vBrutalityPlus){
		let index = variants.indexOf("Personal Goals as Movement");
		usedVariants[index] = false;
		z.vPersonalGoalsMovement = false;
	}
	if(z.vMegaVoyage){
		z.vCaprica = true;
		if(!z.CFB && z.megaVoyageSeed !== null){
			let index = variants.indexOf("Stack the CACs");
			usedVariants[index] = false;
			z.vPandemic = false;
		}
	}
	if(!z.daybreak && z.vBalancedMotives && !z.vNoAgendas){
		z.vBalancedMotives = false;
	}
	if(z.v20 && z.exodus){
		let index = variants.indexOf("Solo Cylon Handicap (Brutality)");
		usedVariants[index] = false;
		z.vSoloCylonBrutality = false;
		index = variants.indexOf("Solo Cylon Handicap (Original)");
		usedVariants[index] = false;
		z.vSoloCylonHandicap = false;
	}
	t.value += bold("Game Options:");
	t.value += "\r\n" + z.numPlayers + " Player";
	if(z.numPlayers > 1) {
		t.value += "s";
	}
	if(z.pegasus) {
		t.value += "\r\nPegasus";
	}
	if(z.exodus) {
		t.value += "\r\nExodus";
	}
	if(z.daybreak) {
		t.value += "\r\nDaybreak";
	}
	if(!z.pegasus && !z.exodus && !z.daybreak) {
		t.value += "\r\nBase Game";
	}
	if(z.CFB) {
		t.value += "\r\nCylon Fleet Board";
	}
	if(z.personalGoals) {
		t.value += "\r\nPersonal Goals";
	}
	if(z.finalFives) {
		t.value += "\r\nFinal Fives";
	}
	if(z.noSympathizer) {
		t.value += "\r\nNo Sympathizer Variant";
	}
	if(z.sympathizer) {
		t.value += "\r\nSympathizer";
	}
	if(z.sympatheticCylon) {
		t.value += "\r\nSympathetic Cylon";
	}
	if(z.cylonLeader) {
		t.value += "\r\nCylon Leader";
	}
	if(z.mutineer) {
		t.value += "\r\nMutineer";
	}
	if(anyVariants) {
		t.value += "\r\n\r\n" + bold("[article" + "=26973211]Unofficial Variants[/" + "article]:");
		for(let j = 0; !(j >= variants.length); j++) {
			if(usedVariants[j]) {
				t.value += "\r\n" + variants[j];
			}
		}
	}
	t.value += "\r\n\r\n" + bold("Objective: ") + z.destination + "\r\n\r\n";
	t.value += bold("Players") + " (in randomized turn order)";
	for(let j = 0; !(j >= z.numPlayers); j++) {
		t.value += "\r\n" + (j + 1) + ": [us" + "er=" + z.usernames[j] + "]" + z.usernames[j] + "[/" + "user]";
	}
	if(z.usernames[z.numPlayers-1].toLowerCase() === "vorpalgens"){
		t.value += " (no surprise there)";
	}
	if(z.megaVoyageSeed !== null && z.megaVoyageSeed !== undefined){
		t.value += "\r\n\r\n"+bold("Mega Voyage Effects:");
		if(z.megaVoyageSeed.colonialOneDestroyed){
			t.value += "\r\nColonial One Destroyed";
			t.value += "\r\nBomb on Colonial One removed from game";
			z.colonialOneDestroyed = true;
			
		}
		if(z.megaVoyageSeed.pegasusDestroyed){
			t.value += "\r\nPegasus Destroyed";
			z.pegasusDestroyed = true;
		}
		if(z.megaVoyageSeed.graveyard.length > 0){
			t.value += italics("\r\nMemorial Wall:");
			for(let j = 0; !(j>=z.megaVoyageSeed.graveyard.length); j++){
				t.value += "\r\n"+z.megaVoyageSeed.graveyard[j];
			}
			z.graveyard = z.megaVoyageSeed.graveyard;
		}
		
		if(z.megaVoyageSeed.galacticaAway || z.megaVoyageSeed.galacticaReturned){
			if(z.destination === "New Caprica"){
				let temp = z.megaVoyageSeed.crisisDiscards;
				z.megaVoyageSeed.crisisDiscards = z.megaVoyageSeed.oldCrisisDiscards;
				z.megaVoyageSeed.oldCrisisDiscards = temp;
			} else {
				z.megaVoyageSeed.crisisDiscards = z.megaVoyageSeed.oldCrisisDiscards;
			}
		}
		/* Thirty-Three reshuffled */
		if(z.megaVoyageSeed.ambush) {
			z.megaVoyageSeed.crisisDiscards.push(2);
		}
		if(z.megaVoyageSeed.cylonSwarm) {
			z.megaVoyageSeed.crisisDiscards.push(13);
		}
		if(z.megaVoyageSeed.jammedAssault) {
			z.megaVoyageSeed.crisisDiscards.push(29);
		}
		if(z.megaVoyageSeed.dogfightCAC) {
			z.megaVoyageSeed.crisisDiscards.push(76);
		}
		if(z.megaVoyageSeed.scarCAC) {
			z.megaVoyageSeed.crisisDiscards.push(83);
		}
		if(z.megaVoyageSeed.theGuardians) {
			z.megaVoyageSeed.crisisDiscards.push(87);
		}
		if(z.megaVoyageSeed.eventHorizon) {
			z.megaVoyageSeed.crisisDiscards.push(140);
		}
		if(z.megaVoyageSeed.hornetsNest) {
			z.megaVoyageSeed.crisisDiscards.push(143);
		}
		if(z.megaVoyageSeed.lockdown) {
			z.megaVoyageSeed.crisisDiscards.push(147);
		}
		if(z.megaVoyageSeed.detectorSabotage){
			z.megaVoyageSeed.crisisDiscards.push(17);
		}
		/* Legendary Discovery */
		if(z.megaVoyageSeed.destinationDiscards.includes(34)){
			z.megaVoyageSeed.crisisDiscards.push(32);
		}
		if(z.megaVoyageSeed.luredIntoATrap) {
			z.megaVoyageSeed.superCrisisDiscards.push(167);
		}
		if(z.megaVoyageSeed.theFarm){
			z.megaVoyageSeed.superCrisisDiscards.push(169);
		}
		if(z.megaVoyageSeed.currentCrisis !== null && !isSuperCrisis(z.megaVoyageSeed.currentCrisis) && !isMission(z.megaVoyageSeed.currentCrisis)) {
			if(isSuperCrisis(z.megaVoyageSeed.currentCrisis)){
				z.megaVoyageSeed.superCrisisDiscards.push(z.megaVoyageSeed.currentCrisis);
			} else if(!isMission(z.megaVoyageSeed.currentCrisis)){
				z.megaVoyageSeed.crisisDiscards.push(z.megaVoyageSeed.currentCrisis);
			}
		}
		shuffle(z.megaVoyageSeed.crisisDiscards);
		t.value += italics("\r\nCrisis Discards:");
		for(let j = 0; !(j>=z.megaVoyageSeed.crisisDiscards.length); j++){
			let crisis = z.megaVoyageSeed.crisisDiscards[j];
			if((z.CFB && d.CAC[crisis] === 1) || (!z.CFB && d.cagChooses[crisis] === 1) || (!z.pegasus && crisis >= 70 && 90 > crisis) || 
			   (!z.exodus && crisis >= 90 && 130 > crisis) || (!z.pegasus && crisis >= 130)){

				z.megaVoyageSeed.crisisDiscards.splice(j,1);
				j--;
			} else {
				t.value += "\r\n"+d.crisisNames[crisis];
			}
		}
		z.crisisDiscards = z.megaVoyageSeed.crisisDiscards;
		t.value += italics("\r\nSuper Crisis Discards:");
		shuffle(z.megaVoyageSeed.superCrisisDiscards);
		let any = false;
		for(let j = 0; !(j>=z.megaVoyageSeed.superCrisisDiscards.length); j++){
			let crisis = z.megaVoyageSeed.superCrisisDiscards[j];
			if((z.CFB && d.CAC[crisis] === 1) || (!z.CFB && d.cagChooses[crisis] === 1) || (!z.pegasus && crisis >= 165 && 170 > crisis) || 
			   (!z.exodus && crisis >= 170) ){

				z.megaVoyageSeed.superCrisisDiscards.splice(j,1);
				j--;
			} else {
				any = true;
				t.value += "\r\n"+d.crisisNames[crisis];
			}
		}
		if(!any){
			t.value += "\r\n(none)";
		}
		z.superCrisisDiscards = z.megaVoyageSeed.superCrisisDiscards;
		
		if(z.megaVoyageSeed.hasOwnProperty("oldCrisisDiscards") && z.destination === "New Caprica"){
			z.oldCrisisDiscards = z.megaVoyageSeed.oldCrisisDiscards;
			shuffle(z.oldCrisisDiscards);
			if(z.oldCrisisDiscards.length > 0){
				t.value += italics("\r\nNew Caprica Crisis Discards:");
				for(let j = 0; !(j>=z.oldCrisisDiscards.length); j++){
					t.value += "\r\n"+d.crisisNames(z.oldCrisisDiscards[j]);
				}
			}
		}	
		delete z.megaVoyageSeed;
	}
	t.value += "\r\n\r\n";
	t.value += bold(z.usernames[0] + " is up first for character selection.") + " They should quote this post to proceed.\n\nIf you run into any issues during the game, no matter how small, please GeekMail [us"+"er=Grafin]Zoe T[/us"+"er].\n\nRemember to add your game to the [ur"+"l=https"+"://boardgamegeek.com/wiki/page/BSG_PBF]BSG PBF Wiki[/"+"url]!";
	z.players = [];
	z.banners = [];
	z.playerLocations = [];
	z.possibleColors = [];
	let splitted = window.btoa(JSON.stringify(z)).match(/.{1,20}/g);
	let text = "";
	while(splitted.length > 0) {
		text += splitted.shift() + "-";
	}
	let re = new RegExp("(\\[c\\])?\\[size=(1|0)\\]\\[color=#(F4F4FF|FFFFFF)\\](New|BYC) seed: \\S+\\[/color\\]\\[/size\\](\\[/c\\])?", "g");
	t.value = t.value.replace(re, "") + code(size(invisible("BYC seed: " + text), 1));
	try{
		let evt = new Event('input', {
			bubbles: true,
			cancelable: true,
		});
		t.dispatchEvent(evt);
	} catch(err){}
	clearBackground();
}

function characterClass(name) {
	switch (name) {
		case "Adama":
		case "Tigh":
		case "Helo":
		case "Cain":
		case "Gaeta":
		case "Hoshi":
		case "Tom":
		case "Shaw":
		case "Kelly":
			return "Military Leader";
		case "Roslin":
		case "Baltar":
		case "Zarek":
		case "Ellen":
		case "Tory":
		case "Romo":
		case "Lee":
		case "Billy":
		case "Elosha":
			return "Political Leader";
		case "Apollo":
		case "Starbuck":
		case "Boomer":
		case "Kat":
		case "Anders":
		case "Hot Dog":
		case "Karl":
		case "Racetrack":
		case "Crashdown":
			return "Pilot";
		case "Chief":
		case "Dee":
		case "Cally":
		case "Cottle":
		case "Gaius":
		case "Seelix":
			return "Support";
		case "Cavil":
		case "Leoben":
		case "Six":
		case "Athena":
		case "D'Anna":
		case "Doral":
		case "Simon":
			return "Cylon Leader";
	}
	return "";
}

function hashString(str) {
	let hash = 0;
	for(let i = 0; !(i >= str.length); i++) {
		let chr = str.charCodeAt(i);
		hash = (Math.floor(hash / 32) - hash) + chr;
		hash = hash & hash;
	}
	return (hash & 7);
}

function supportChoices() {
	let options = [];
	if(!z.players.includes("Chief") && !z.graveyard.includes("Chief")) {
		options.push("Chief");
	}
	if(!z.players.includes("Dee") && (z.pegasus || (z.exodus && z.vAllCharacters)) && !z.graveyard.includes("Dee")) {
		options.push("Dee");
	}
	if(!z.players.includes("Cally") && (z.exodus || (z.pegasus && z.vAllCharacters)) && !z.graveyard.includes("Cally")) {
		options.push("Cally");
	}
	if(!z.players.includes("Cottle") && (z.daybreak || z.vAllCharacters) && !z.graveyard.includes("Cottle")) {
		options.push("Cottle");
	}
	if(!z.players.includes("Gaius") && !z.players.includes("Baltar") && z.daybreak && !z.graveyard.includes("Gaius") && !z.graveyard.includes("Baltar")) {
		options.push("Gaius");
	}
	if(!z.players.includes("Seelix") && z.vAllCharacters && !z.graveyard.includes("Seelix")){
		options.push("Seelix");
	}
	return options;
}

function militaryChoices(){
	let assist = z.numPlayers === 1 && z.players.length === 1;
	let options = [];
	if(!z.vNoCain && !z.players.includes("Cain") && (assist || z.pegasus || (z.exodus && z.vAllCharacters && !z.vBrutality)) && 
		(!z.vBrutality || z.daybreak || assist) && !z.graveyard.includes("Cain")) {
			
		options.push("Cain");
	}
	if(!z.players.includes("Adama") && !z.graveyard.includes("Adama")) {
		options.push("Adama");
	}
	if(!z.players.includes("Tigh") && !z.graveyard.includes("Tigh")) {
		options.push("Tigh");
	}
	if(!z.players.includes("Helo") && !z.players.includes("Karl") && !z.graveyard.includes("Helo") && !z.graveyard.includes("Karl")) {
		options.push("Helo");
	}
	if(!z.players.includes("Gaeta") && (z.exodus || z.vAllCharacters) && (!z.vBrutality || z.daybreak || z.numPlayers === 1 || assist) && !z.graveyard.includes("Gaeta")) {
		options.push("Gaeta");
	}
	if(!z.players.includes("Hoshi") && (z.daybreak || z.vAllCharacters) && !z.graveyard.includes("Hoshi")) {
		options.push("Hoshi");
	}
	if(!z.players.includes("Tom") && !z.players.includes("Zarek") && z.daybreak && !z.graveyard.includes("Tom") && !z.graveyard.includes("Zarek")) {
		options.push("Tom");
	}
	if(!z.players.includes("Shaw") && z.vAllCharacters && (!versionAtLeast([2,1,13]) || versionAtLeast([2,1,14]) || (z.daybreak && z.pegasus)) && !z.graveyard.includes("Shaw")) {
		options.push("Shaw");
	}
	return options;
}

function politicalChoices(){
	let assist = z.numPlayers === 1 && z.players.length === 1;
	let options = [];
	if(!z.players.includes("Roslin") && (z.numPlayers !== 1 || assist) && !z.graveyard.includes("Roslin")) {
		options.push("Roslin");
	}
	if(!z.players.includes("Baltar") && !z.players.includes("Gaius") && z.numPlayers !== 2 && !z.graveyard.includes("Baltar") && !z.graveyard.includes("Gaius")) {
		options.push("Baltar");
	}
	if(!z.players.includes("Lee") && !z.players.includes("Apollo") && (z.daybreak || (z.vAllCharacters && (z.vBrutality || z.numPlayers ===
			1 || assist))) && !z.graveyard.includes("Lee") && !z.graveyard.includes("Apollo")) {
		options.push("Lee");
	}
	if(!z.players.includes("Zarek") && !z.players.includes("Tom") && !z.graveyard.includes("Tom") && !z.graveyard.includes("Zarek")) {
		options.push("Zarek");
	}
	if(!z.players.includes("Romo") && (z.daybreak || z.vAllCharacters) && !z.graveyard.includes("Romo")) {
		options.push("Romo");
	}
	if(!z.players.includes("Tory") && (z.exodus || z.vAllCharacters) && !z.graveyard.includes("Tory")) {
		options.push("Tory");
	}
	if(!z.players.includes("Ellen") && (z.pegasus || (z.daybreak && z.vAllCharacters)) && !z.graveyard.includes("Ellen")) {
		options.push("Ellen");
	}
	if(!z.players.includes("Billy") && z.vAllCharacters && !z.graveyard.includes("Billy")) {
		options.push("Billy");
	}
	return options;
}

function pilotChoices(){
	let assist = z.numPlayers === 1 && z.players.length === 1;
	let options = [];
	if(!z.players.includes("Apollo") && !z.players.includes("Lee") && !z.graveyard.includes("Lee") && !z.graveyard.includes("Apollo")) {
		options.push("Apollo");
	}
	if(!z.players.includes("Starbuck") && !z.graveyard.includes("Starbuck")) {
		options.push("Starbuck");
	}
	if(!z.players.includes("Kat") && (z.pegasus || z.vAllCharacters) && !z.graveyard.includes("Kat")) {
		options.push("Kat");
	}
	if(!z.players.includes("Karl") && !z.players.includes("Helo") && (z.daybreak || z.vAllCharacters) && !z.graveyard.includes("Karl") && !z.graveyard.includes("Helo")) {
		options.push("Karl");
	}
	if(!z.players.includes("Boomer") && z.numPlayers !== 2 && (z.numPlayers !== 1 || assist) && !z.graveyard.includes("Boomer")) {
		options.push("Boomer");
	}
	if(!z.players.includes("Hot Dog") && (z.daybreak || z.vAllCharacters) && !z.graveyard.includes("Hot Dog")) {
		options.push("Hot Dog");
	}
	if(!z.players.includes("Anders") && (z.exodus || z.vAllCharacters) && !z.graveyard.includes("Anders")) {
		options.push("Anders");
	}
	if(!z.players.includes("Racetrack") && z.vAllCharacters && !z.graveyard.includes("Racetrack")) {
		options.push("Racetrack");
	}
	return options;
}

function cylonLeaderChoices(){
	let options = [];
	if(z.pegasus || z.vAllCharacters) {
		if(!z.graveyard.includes("Cavil")){
			options.push("Cavil");
		}
		if(!z.graveyard.includes("Leoben")){
			options.push("Leoben");
		}
		if(!z.graveyard.includes("Six")){
			options.push("Six");
		}
	}
	if(z.daybreak || z.vAllCharacters) {
		if(!z.graveyard.includes("Athena")){
			options.push("Athena");
		}
		if(!z.graveyard.includes("D'Anna")){
			options.push("D'Anna");
		}
		if(!z.graveyard.includes("Doral")){
			options.push("Doral");
		}
		if(!z.graveyard.includes("Simon")){
			options.push("Simon");
		}
	}
	return options;
}

function pickCharacter() {
	let numMilitary = 0;
	let numPolitical = 0;
	let numPilot = 0;
	let numSupport = 0;
	let canMilitary = true;
	let canPolitical = true;
	let canPilot = true;
	let canSupport = true;
	let cylonLeaderYet = false;
	let maxSupport = 1;
	if(z.graveyard.includes("Chief")){
		maxSupport--;
	}
	if(z.pegasus || (z.exodus && z.vAllCharacters)) {
		maxSupport++;
		if(z.graveyard.includes("Dee")){
			maxSupport--;
		}
	}
	if(z.exodus || (z.pegasus && z.vAllCharacters)) {
		maxSupport++;
		if(z.graveyard.includes("Cally")){
			maxSupport--;
		}
	}
	if(z.daybreak || z.vAllCharacters) {
		maxSupport++;
		if(z.graveyard.includes("Cottle")){
			maxSupport--;
		}
	}
	if(z.daybreak) {
		maxSupport++;
		if(z.graveyard.includes("Baltar") || z.graveyard.includes("Gaius")){
			maxSupport--;
		}
	}
	
	for(let j = 0; !(j >= z.players.length); j++) {
		switch (characterClass(z.players[j])) {
			case "Military Leader":
				numMilitary++;
				canMilitary = false;
				break;
			case "Political Leader":
				numPolitical++;
				canPolitical = false;
				break;
			case "Pilot":
				numPilot++;
				canPilot = false;
				break;
			case "Cylon Leader":
				cylonLeaderYet = true;
				break;
			case "Support":
				numSupport++;
				if(numSupport === maxSupport) {
					canSupport = false;
				}
				break;
		}
		if(z.daybreak && z.players[j] === "Baltar") {
			maxSupport--;
			if(numSupport === maxSupport) {
				canSupport = false;
			}
		}
		if(numMilitary === numPolitical && numPolitical === numPilot) {
			canMilitary = true;
			canPolitical = true;
			canPilot = true;
		}
	}
	if(z.numPlayers === 7 && z.players.length === 6 && !cylonLeaderYet) {
		canMilitary = false;
		canPolitical = false;
		canPilot = false;
		canSupport = false;
	}
	let assist = z.numPlayers === 1 && z.players.length === 1;
	if(assist) {
		canMilitary = true;
		canPolitical = true;
		canPilot = true;
		canSupport = true;
	}
	let promptText = "";
	if(!assist) {
		promptText = "Which character class would you like to play?";
	} else {
		promptText = "Which character class would you like the assist character to be?";
	}
	let choices = [];
	
	if(z.vAllClasses && !(z.numPlayers === 7 && z.players.length === 6 && !cylonLeaderYet)){
		if(militaryChoices().length > 0){
			canMilitary = true;
		}
		if(politicalChoices().length > 0){
			canPolitical = true;
		}
		if(pilotChoices().length > 0){
			canPilot = true;
		}
		if(supportChoices().length > 0){
			canSupport = true;
		}
	}
	
	if(canMilitary) {
		choices.push("Military Leader");
		promptText += "\n" + choices.length + ": Military Leader";
	}
	if(canPolitical) {
		choices.push("Political Leader");
		promptText += "\n" + choices.length + ": Political Leader";
	}
	if(canPilot) {
		choices.push("Pilot");
		promptText += "\n" + choices.length + ": Pilot";
	}
	if(canSupport) {
		choices.push("Support");
		promptText += "\n" + choices.length + ": Support";
	}
	if(z.cylonLeader && !cylonLeaderYet) {
		choices.push("Cylon Leader");
		promptText += "\n" + choices.length + ": Cylon Leader";
	}
	choices.push("Random Character");
	promptText += "\n" + choices.length +": Random Character";
	if(me === 0 && z.numPlayers > 1){
		choices.push("Reshuffle Turn Order");
		promptText += "\n" + choices.length +": Reshuffle Turn Order";
	}
	
	promptNum(promptText, (a) => 1 > a || a > choices.length, clearBackground, (choice) => {
		let options = [];
		let chosenClass = choices[choice - 1];
		
		let chooseCharacter = (prompted,chosenClass,howRandom) => {
			switch (chosenClass) {
				case "Military Leader":
					numMilitary++;
					canMilitary = false;
					break;
				case "Political Leader":
					numPolitical++;
					canPolitical = false;
					if(prompted === "Baltar" && z.daybreak && numSupport === maxSupport - 1) {
						canSupport = false;
					}
					break;
				case "Pilot":
					numPilot++;
					canPilot = false;
					break;
				case "Support":
					numSupport++;
					if(numSupport === maxSupport) {
						canSupport = false;
					}
					break;
				case "Cylon Leader":
					cylonLeaderYet = true;
					break;
			}
			if(z.noSympathizer && prompted === "Boomer" && z.numPlayers === 6) {
				addAlert(
					"Boomer may not typically be chosen in a 6-player game using the No Sympathizer variant; you may want to clear this with your fellow players."
					);
			}
			let resolution = function() {
				if(z.numPlayers === 1 && z.players.length === 1 && z.assist === undefined) {
					pickCharacter();
				} else if(z.players.length >= z.numPlayers) {
					if(z.cylonLeader && !cylonLeaderYet) {
						if(z.numPlayers === 5) {
							plainAlert("Nobody chose to play a Cylon Leader; setting up a regular 5-player game instead.");
							z.cylonLeader = false;
							z.mutineer = false;
						} else if(z.daybreak) {
							z.cylonLeader = false;
							confirmify("Nobody chose to play a Cylon leader.  Would you like to use a Mutineer instead?",()=>{
								addAlert("Using the No Sympathizer Variant.");
								t.value +=
									"Nobody chose to play a Cylon Leader; using the No Sympathizer Variant instead.\r\n\r\n";
								z.noSympathizer = true;
								gameSetup2();
							},()=>{
								addAlert("Using a Mutineer.");
								t.value += "Nobody chose to play a Cylon Leader; using a Mutineer instead.\r\n\r\n";
								z.mutineer = true;
								gameSetup2();
							},"YES","NO");
						} else {
							z.cylonLeader = false;
							confirmify("Nobody chose to play a Cylon Leader.  Would you like to use a Sympathetic Cylon instead?", () => {
								confirmify("Would you like to use a Sympathizer or the No Sympathizer Variant?", () => {
									addAlert("Using the No Sympathizer Variant.");
									t.value +=
										"Nobody chose to play a Cylon Leader; using the No Sympathizer Variant instead.\r\n\r\n";
									z.noSympathizer = true;
									gameSetup2();
								}, () => {
									addAlert("Using a Sympathizer.");
									t.value += "Nobody chose to play a Cylon Leader; using a Sympathizer instead.\r\n\r\n";
									z.sympathizer = true;
									gameSetup2();
								}, "Sympathizer", "No Sympathizer Variant");
							}, () => {
								addAlert("Using a Sympathetic Cylon.");
								t.value += "Nobody chose to play a Cylon Leader; using a Sympathetic Cylon instead.\r\n\r\n";
								z.sympatheticCylon = true;
								gameSetup2();
							}, "YES", "NO");
							return;
						}
					}
					gameSetup2();
				} else {
					if(z.vAllClasses && !(z.numPlayers === 7 && z.players.length === 6 && !cylonLeaderYet)){
						if(militaryChoices().length > 0){
							canMilitary = true;
						}
						if(politicalChoices().length > 0){
							canPolitical = true;
						}
						if(pilotChoices().length > 0){
							canPilot = true;
						}
						if(supportChoices().length > 0){
							canSupport = true;
						}
					}
					t.value += bold(z.usernames[z.players.length] + " is next up for character selection.") +
						" They may pick one of the following character classes:";
					if(canMilitary) {
						t.value += "\n" + colorText("green", "Military Leader");
					}
					if(canPolitical) {
						t.value += "\n" + colorText("orange", "Political Leader");
					}
					if(canPilot) {
						t.value += "\n" + colorText("red", "Pilot");
					}
					if(canSupport) {
						t.value += "\n" + colorText("blue", "Support");
					}
					if(z.cylonLeader && !cylonLeaderYet) {
						t.value += "\n" + colorText("magenta", "Cylon Leader");
					}
					saveAndQuit();
				}
			};
			if(assist) {
				z.assist = prompted;
				boldAlert("You chose " + prompted + " as your assist character.");
				resolution();
			} else {
				z.players.push(prompted);
				if(numMilitary === numPolitical && numPolitical === numPilot) {
					canMilitary = true;
					canPolitical = true;
					canPilot = true;
				}
				if(z.numPlayers === 7 && z.players.length === 6 && !cylonLeaderYet) {
					canMilitary = false;
					canPolitical = false;
					canPilot = false;
					canSupport = false;
				}
				addAlert("You chose to play " + prompted + ".");
				t.value += bold(z.usernames[z.players.length - 1] + " chooses to play " + prompted) + ".\r\n\r\n";
				if(howRandom === "Totally Random"){
					t.value += "They were chosen randomly from among all available characters.\r\n\r\n";
				} else if (howRandom === "Somewhat Random"){
					t.value += "They were chosen randomly from among the available characters of that class.\r\n\r\n";
				}
				let character = getCharacter(z.players[z.players.length - 1]);
				z.playerLocations.push(d.startingLocations[character]);
				if(prompted === "Roslin" && z.vBrutality && z.daybreak) {
					z.playerLocations[z.playerLocations.length - 1] = "Quorum Chamber";
				}
				if(prompted === "Tory" && z.vBrutality && z.daybreak) {
					z.playerLocations[z.playerLocations.length - 1] = "President's Office";
				}
				if(z.numPlayers === 1 && prompted === "Helo") {
					z.playerLocations[z.playerLocations.length - 1] = "Hangar Deck";
					plainAlert("Helo begins on the Hangar Deck in this variant.");
				}
				if(z.colonialOneDestroyed && (prompted === "Roslin" || prompted === "Zarek" || prompted === "Tory" || prompted === "Romo")){
					z.playerLocations[z.playerLocations.length - 1] = "Hangar Deck";
					plainAlert("Since Colonial One was destroyed, "+prompted+" starts on the Hangar Deck.");
				}
				if(isCylonLeader(prompted) && prompted !== "Athena") {
					z.banners.push(d.cylonBanners[character]);
				} else {
					z.banners.push(d.banners[character]);
				}
				z.possibleColors.push([0, 0, 0, 0, 0]);
				if(z.pegasus || z.daybreak) {
					z.possibleColors[z.players.length - 1].push(0);
				}
				if(z.players[z.players.length - 1] === "Apollo") {
					let numOptions = 2;
					if(z.daybreak) {
						numOptions += 2;
					}
					let promptText = "Where would you like to start? (1-" + numOptions +
						")\n1: Viper Mk II in Sector 5 \n2: Viper Mk II in Sector 6";
					if(z.daybreak) {
						promptText += "\n3: Assault Raptor in Sector 5\n4: Assault Raptor in Sector 6";
					}
					promptNum(promptText, (a) => 1 > a || a > numOptions, () => {
						boldAlert("Apollo starts in a Viper Mk II in Sector 5.");
						resolution();
					}, (prompted) => {
						if(prompted === 1) {
							boldAlert("Apollo starts in a Viper Mk II in Sector 5.");
						} else if(prompted === 2) {
							boldAlert("Apollo starts in a Viper Mk II in Sector 6.");
							z.playerLocations[z.playerLocations.length - 1] = "Sector 6";
						} else if(prompted === 3) {
							boldAlert("Apollo starts in an Assault Raptor in Sector 5.");
							z.playerLocations[z.playerLocations.length - 1] = "Sector 5 AR";
						} else if(prompted === 4) {
							z.playerLocations[z.playerLocations.length - 1] = "Sector 6 AR";
							boldAlert("Apollo starts in an Assault Raptor in Sector 6.");
						}
						resolution();
					});
				} else if(z.players[z.players.length - 1] === "Cain" && z.pegasus && !z.pegasusDestroyed) {
					confirmify("Do you want to start on Command or Pegasus CIC?", () => {
						boldAlert("Cain starts on Pegasus CIC.");
						z.playerLocations[z.playerLocations.length - 1] = "Pegasus CIC";
						resolution();
					}, () => {
						boldAlert("Cain starts on Command.");
						resolution();
					}, "Command", "Pegasus CIC");
				} else if(z.players[z.players.length - 1] === "Hoshi" && z.pegasus && z.vBrutality && !z.pegasusDestroyed) {
					confirmify("Do you want to start on Communications or Main Batteries?", () => {
						boldAlert("Hoshi starts on Main Batteries.");
						z.playerLocations[z.playerLocations.length - 1] = "Main Batteries";
						resolution();
					}, () => {
						boldAlert("Hoshi starts on Communications.");
						resolution();
					}, "Communications", "Main Batteries");
				} else if(z.players[z.players.length - 1] === "Shaw" && z.pegasus && !z.pegasusDestroyed) {
					confirmify("Do you want to start on Weapons Control or Main Batteries?", () => {
						boldAlert("Shaw starts on Main Batteries.");
						z.playerLocations[z.playerLocations.length - 1] = "Main Batteries";
						resolution();
					}, () => {
						boldAlert("Shaw starts on Weapons Control.");
						resolution();
					}, "Weapons Control", "Main Batteries");
				} else {
					resolution();
				}
			}
		};
		
		
		switch (chosenClass) {
			/* TODO: more options open up with assist characters as they just have their OPG and skill set */
			case "Military Leader":
				options = militaryChoices();
				break;
			case "Political Leader":
				options = politicalChoices();
				break;
			case "Pilot":
				options = pilotChoices();
				break;
			case "Support":
				options = supportChoices();
				break;
			case "Cylon Leader":
				options = cylonLeaderChoices();
				break;
			case "Random Character": {
				let choices = [];
				if(canMilitary){
					choices = choices.concat(militaryChoices());
				}
				if(canPolitical){
					choices = choices.concat(politicalChoices());
				}
				if(canPilot){
					choices = choices.concat(pilotChoices());
				}
				if(canSupport){
					choices = choices.concat(supportChoices());
				}
				if(z.cylonLeader && !cylonLeaderYet){
					choices = choices.concat(cylonLeaderChoices());
				}
				let rando = Math.floor(Math.random() * choices.length);
				let choice = choices[rando];
				if(militaryChoices().includes(choice)){
					chosenClass = "Military Leader";
				} else if(politicalChoices().includes(choice)){
					chosenClass = "Political Leader";
				} else if(pilotChoices().includes(choice)){
					chosenClass = "Pilot";
				} else if(supportChoices().includes(choice)){
					chosenClass = "Support";
				} else {
					chosenClass = "Cylon Leader";
				}
				chooseCharacter(choice,chosenClass,"Totally Random");
				return;
			}
			case "Reshuffle Turn Order":
				shuffle(z.usernames);
				boldAlert("Turn Order reshuffled.");
				t.value += bold("Players") + " (in randomized turn order)";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					t.value += "\r\n" + (j + 1) + ": [us" + "er=" + z.usernames[j] + "]" + z.usernames[j] + "[/" + "user]";
				}
				saveAndQuit();
				return;
		}
		let promptText = "Which character would you like to play? (1-" + options.length + ")";
		for(let j = 0; !(j >= options.length); j++) {
			promptText += "\n" + (j + 1) + ": " + options[j];
		}
		promptText += "\n"+(options.length+1)+": Random "+chosenClass;
		promptNum(promptText, (a) => 1 > a || a > options.length+1, pickCharacter, (charNum) => {
			if(charNum === options.length+1){
				let rando = Math.floor(Math.random() * options.length);
				let choice = options[rando];
				chooseCharacter(choice,chosenClass,"Somewhat Random");
			} else {
				chooseCharacter(options[charNum - 1],chosenClass);
			}
		});
	});
}

function saveAndQuit() {
	postSeed();
	if(t.value.slice(-4) !== ("[h" + bl + "r]")) {
		t.value += "[h" + bl + "r]";
	}
	clearBackground();
}

function gameSetup2() {
	z.version = BYCversion;
	z.BYCversion = BYCversion;
	z.billyHand = [];
	t.value += bold("Players:\r\n");
	for(let j = 0; !(j >= z.numPlayers); j++) {
		t.value += "[us" + "er=" + z.usernames[j] + "]" + z.usernames[j] + "[/" + "user] as " + bold(z.players[j]) + "\r\n";
	}
	t.value += "\r\n";
	z.reshuffledSeen = false;
	z.nukes = 2;
	if(z.numPlayers === 1) {
		z.nukes = 1;
	}
	z.population = 12;
	z.morale = 10;
	z.food = 8;
	z.fuel = 8;
	z.galacticaAway = false;
	z.galacticaReturned = false;
	z.preCrossroads = (z.destination === "Ionian Nebula" || z.destination === "Ionian Earth");
	if(!z.hasOwnProperty("colonialOneDestroyed")){
		z.colonialOneDestroyed = false;
	}
	if(!z.hasOwnProperty("pegasusDestroyed")){
		z.pegasusDestroyed = false;
	}
	z.hubDestroyed = false;
	z.detectorSabotage = false;
	z.rebelBasestar = 0;
	z.round = 1;
	z.turn = 0;
	z.phase = 0;
	z.emergencyAction = false;
	z.investigativeCommittee = false;
	z.restoreOrder = false;
	z.reckless = false;
	z.secondChance = false;
	z.president = -1;
	z.admiral = -1;
	z.cag = -1;
	z.currentCrisis = null;
	z.crisisPlayer = null;
	z.currentSkillCheck = null;
	z.thisDifficulty = null;
	z.thisPartial = null;
	z.thisConsequence = null;
	z.thisPolitics = null;
	z.thisLeadership = null;
	z.thisTactics = null;
	z.thisPiloting = null;
	z.thisEngineering = null;
	z.thisTreachery = null;
	z.thisTarget = null;
	z.destiny = [];
	z.interrupts = blankArrays(z.numPlayers);
	z.theMutineer = -1;
	z.theCylonLeader = -1;
	z.theSympathizer = -1;
	z.theSympatheticCylon = -1;
	z.jumpTrack = 0;
	z.distance = 0;
	z.contributingPlayer = 0;
	z.guts = false;
	z.juryRigged = false;
	z.supportThePeople = false;
	z.vanity = false;
	z.skillCheckRevealed = false;
	z.capricaCrisis = false;
	z.toDoJumpIcon = false;
	z.finishedCrisis = false;
	z.revealedCards = [];
	z.theFarm = false;
	z.sleeper = false;
	z.ambush = false;
	z.cylonSwarm = false;
	z.jammedAssault = false;
	z.thirtyThree = false;
	z.dogfightCAC = false;
	z.scarCAC = false;
	z.scar = -1;
	z.theGuardians = false;
	z.eventHorizon = false;
	z.hornetsNest = false;
	z.lockdown = false;
	z.luredIntoATrap = false;
	z.toDoRaiders = false;
	z.toDoHeavies = false;
	z.toDoLaunchRaiders = false;
	z.toDoBasestars = false;
	z.toDoCACSetup = false;
	z.toDoCACSpecial = false;
	z.damagePlayer = -1;
	z.blindDevotion = -1;
	z.damageHand = [];
	z.drawSkills = true;
	if(z.players[0] === "Anders") {
		z.drawSkills = false;
		z.phase = 1;
	} /* new for v0.2*/
	z.quorumPeek = [];
	z.quorumPeeker = -1;
	z.negotiation = false;
	z.secretMessages = [];
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.secretMessages.push("");
	}
	z.scout = -1;
	z.scoutingDestination = false;
	z.scoutingCrisis = false;
	z.scouted = [];
	z.redTape = false;
	z.ironWill = false;
	z.trustInstincts = false;
	z.protectTheFleet = false;
	z.establishNetwork = false;
	z.forceTheirHand = false;
	z.allHandsOnDeck = false;
	z.quickThinking = false;
	z.dogfight = false;
	z.installUpgrades = false;
	z.broadcastLocation = false;
	z.byYourCommand = false;
	z.specialDestiny = false;
	z.bait = false;
	z.dradisContact = false;
	z.personalVices = false;
	z.aBetterMachine = false;
	z.violentOutbursts = false;
	z.exploitWeakness = false;
	z.gameOver = false; /* new for v0.3 */
	if(!z.hasOwnProperty("graveyard")){
		z.graveyard = [];
	}
	z.cylonExecuted = -1;
	z.humanExecuted = -1;
	z.heloReturnRound = 2;
	z.noCylonDetector = false;
	z.andersBenchRound = 1;
	if(z.numPlayers + z.boxedPlayers.length === 1) {
		z.andersBenchRound = -1;
	}
	z.executedCurrentPlayer = false;
	z.boxedPlayers = [];
	z.preventative = null;
	z.engineRoom = false;
	z.eulogy = false;
	z.blindJump = false;
	z.fastLearner = [];
	z.manipulativeVictim = -1;
	z.manipulativeAdmiral = true;
	z.endGame = false;
	z.CLexecuted = false;
	z.mutualAnnihilation = false;
	z.establishSanitation = false;
	z.changeOfPlans = false;
	z.crisisOptions = blankArrays(z.numPlayers);
	z.context = blankArrays(z.numPlayers);
	z.mandatory = blankArrays(z.numPlayers);
	z.processedOutcome = false;
	z.mementoUsed = false;
	z.mementoCards = [];
	z.dradisBait = [];
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.dradisBait.push(true);
	}
	z.forLove = characterPresent("Athena");
	z.blindDevotionPause = false;
	z.humanDelusionPause = false;
	z.commandAuthorityPause = false;
	z.changeOfPlansPause = false;
	z.probationPause = false;
	z.modificationsPause = false;
	z.noOneGetsLeftBehindPause = false;
	z.xo = false;
	z.majorVictory = false;
	/* TODO: if Helo returns after an execution in a Pegasus game, he should be able to use his ECO ability.  Same with Seelix. */
	z.eco = z.players[0] === "Helo";
	z.avionicsExpert = z.players[0] === "Seelix";
	z.spToken = false;
	z.deToken = false;
	z.stim = null;
	z.quickFix = false;
	z.des = [];
	z.sps = [];
	z.dieRoller = 0;
	z.SoEPlayer = -1;
	if(z.forLove) {
		z.forLoveCOs = [];
		z.randomLove = [];
		z.allForLove = [];
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.sps.push(null);
		z.des.push(null);
		if(z.forLove) {
			z.forLoveCOs.push(null);
			z.randomLove.push(false);
			z.allForLove.push(false);
		}
	}
	z.FTLOperator = true;
	z.tank = [];
	for(let j = 0; !(j >= z.numPlayers); j++) {
		z.tank.push(false);
	}
	z.autoPass = false;
	if(z.CFB) {
		z.cagTitle = true;
	}
	z.dieRolls = [];
	for(let j = 0; !(j >= 250); j++) {
		let rando = Math.floor((z.seed * 8) / mLCG) + 1;
		updateSeed();
		z.dieRolls.push(rando);
	}
	z.contributionLabels = [];
	for(let i = 0; !(i >= z.numPlayers); i++) {
		z.contributionLabels.push("");
	}
	if(z.noSympathizer) {
		z.population -= 2;
		z.morale--;
		z.food--;
	}
	let numSkillDecks = 5;
	if(z.pegasus || z.daybreak) {
		numSkillDecks++;
	}
	z.skillCardDecks = blankArrays(numSkillDecks);
	for(let i = 0; !(i >= 5); i++) {
		for(let j = 0; !(j >= 21); j++) {
			z.skillCardDecks[i ].push(j + i * 35);
		}
		for(let j = 21; z.pegasus && !(j >= 26); j++) {
			z.skillCardDecks[i ].push(j + i * 35);
		}
		for(let j = 26; z.exodus && !z.vBrutality && !(j >= 30); j++) {
			z.skillCardDecks[i ].push(j + i * 35);
		}
		for(let j = 30; z.daybreak && !(j >= 35); j++) {
			z.skillCardDecks[i ].push(j + i * 35);
		}
		shuffle(z.skillCardDecks[i ]);
	}
	if(z.daybreak || z.pegasus) {
		for(let j = 0; !(j >= 26); j++) {
			z.skillCardDecks[5].push(j + 5 * 35);
		}
		shuffle(z.skillCardDecks[5]);
	}
	z.skillCardDiscards = blankArrays(numSkillDecks);
	buildDestiny();
	z.skillCardHands = blankArrays(z.numPlayers);
	z.skillCheckCards = blankArrays(z.numPlayers + 1);
	z.damage = ["Fuel", "Food", "FTL Control", "Weapons Control", "Command", "Admiral's Quarters", "Hangar Deck", "Armory"];
	shuffle(z.damage);
	z.damagedLocations = [];
	if(z.pegasus) {
		if(z.pegasusDestroyed){
			if(!z.vAltDamage){
				z.pegasusDamage = [];
			}
			z.damagedLocations = ["Pegasus CIC", "Airlock", "Main Batteries", "Engine Room"];
		} else if(!z.vAltDamage) {
			z.pegasusDamage = ["Pegasus CIC", "Airlock", "Main Batteries", "Engine Room"];
			shuffle(z.pegasusDamage);
		} else {
			z.damage = z.damage.concat(["Pegasus CIC", "Airlock", "Main Batteries", "Engine Room"]);
			shuffle(z.damage);
		}
	}
	z.basestarDamage = ["Structural Damage", "Weapons Disabled", "Hangar Disabled", "Critical Hit"];
	if(z.destination === "Ionian Nebula" || z.destination === "Ionian Earth") {
		z.basestarDamage.push("Damage to Personnel");
		z.basestarDamage.push("Collateral Damage");
	}
	shuffle(z.basestarDamage);
	z.miracles = [];
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.vBrutality && z.players[j] === "D'Anna") {
			z.miracles.push(0);
		} else {
			z.miracles.push(1);
		}
	}
	z.quorumDeck = [];
	z.quorumHand = [];
	for(let j = 0; !(j >= 17); j++) {
		z.quorumDeck.push(j);
	}
	for(let j = 17; z.pegasus && !(j >= 26); j++) {
		z.quorumDeck.push(j);
	}
	for(let j = 26; z.exodus && !(j >= 29) && !z.vBrutality; j++) {
		z.quorumDeck.push(j);
	}
	shuffle(z.quorumDeck);
	z.quorumHand.push(z.quorumDeck.pop());
	z.quorumDiscards = [];
	z.quorumTitles = blankArrays(z.numPlayers);
	z.superCrisisDeck = [];
	if(!z.hasOwnProperty("superCrisisDiscards")){
		z.superCrisisDiscards = [];
	}
	if(!z.colonialOneDestroyed && !z.superCrisisDiscards.includes(160)){
		z.superCrisisDeck.push(160);
	}
	for(let j = 161; !(j >= 165); j++) {
		if((j !== 164 || !z.CFB) && !z.superCrisisDiscards.includes(j)) {
			z.superCrisisDeck.push(j);
		}
	}
	for(let j = 165; z.pegasus && !(j >= 170); j++) {
		if((j !== 167 || !z.CFB) && !z.superCrisisDiscards.includes(j)) {
			z.superCrisisDeck.push(j);
		}
	}
	for(let j = 170; z.exodus && !(j >= 173) && !z.vBrutality; j++) {
		if((j !== 170 || z.CFB) && !z.superCrisisDiscards.includes(j)) {
			z.superCrisisDeck.push(j);
		}
	}
	shuffle(z.superCrisisDeck);
	
	z.superCrisisHands = blankArrays(z.numPlayers);
	let CACDeck = [];
	z.crisisDeck = [];
	if(!z.hasOwnProperty("crisisDiscards")){
		z.crisisDiscards = [];
	}
	for(let j = 0; !(j >= 70); j++) {
		if(z.crisisDiscards.includes(j)){
			continue;
		}
		if(d.CAC[j] === 0) {
			z.crisisDeck.push(j);
		} else {
			CACDeck.push(j);
		}
	}
	for(let j = 70; z.pegasus && !(j >= 90); j++) {
		if(z.crisisDiscards.includes(j)){
			continue;
		}
		if(d.CAC[j] === 0) {
			z.crisisDeck.push(j);
		} else {
			CACDeck.push(j);
		}
	}
	for(let j = 90; z.exodus && !z.vBrutality && !(j >= 130); j++) {
		if(z.crisisDiscards.includes(j)){
			continue;
		}
		if(d.cagChooses[j] === 0 || z.CFB) {
			z.crisisDeck.push(j);
		}
	}
	for(let j = 130; z.daybreak && !(j >= 160); j++) {
		if(z.crisisDiscards.includes(j)){
			continue;
		}
		if(d.CAC[j] === 0) {
			z.crisisDeck.push(j);
		} else {
			CACDeck.push(j);
		}
	}
	shuffle(z.crisisDeck);
	if((z.vExodusMinusCFB || (z.vPandemic && z.exodus)) && !z.vBrutality) {
		if(z.vMegaVoyage){
			let anyDiscardedExodus = false;
			for(let j = 0; !(j>=z.crisisDiscards.length); j++){
				if(z.crisisDiscards[j] >= 90 && 130 > z.crisisDiscards[j]){
					anyDiscardedExodus = true;
					break;
				}
			}
			if(!anyDiscardedExodus){
				z.crisisDiscards = z.crisisDeck.splice(0,34).concat(z.crisisDiscards);
			}
		} else {
			z.crisisDeck.splice(0, 34);
		}
	}
	if(!z.CFB) {
		shuffle(CACDeck);
		if(z.vPandemic) {
			let piles = [];
			while(CACDeck.length > 0) {
				piles.push([CACDeck.pop()]);
			}
			let j = 0;
			while(z.crisisDeck.length > 0) {
				piles[j].push(z.crisisDeck.pop());
				j = (j + 1) % piles.length;
			}
			shuffle(piles);
			let tempDeck = [];
			while(piles.length > 0) {
				tempDeck = tempDeck.concat(shuffle(piles.pop()));
			}
			while(tempDeck.length > 0) {
				let five = [];
				five.push(tempDeck.pop());
				five.push(tempDeck.pop());
				five.push(tempDeck.pop());
				five.push(tempDeck.pop());
				five.push(tempDeck.pop());
				shuffle(five);
				z.crisisDeck = z.crisisDeck.concat(five);
			}
			let r = Math.floor((z.seed * Math.floor(z.crisisDeck.length / 3.0)) / mLCG) + Math.floor(z.crisisDeck.length / 3.0);
			updateSeed();
			for(let j = 0; !(j >= r); j++) {
				z.crisisDeck.push(z.crisisDeck.shift());
			}
		} else {
			z.crisisDeck = z.crisisDeck.concat(CACDeck);
			shuffle(z.crisisDeck);
		}
	}
	
	if(z.destination === "Earth" || z.destination === "Ionian Earth") {
		z.missionDeck = [];
		z.missionDiscards = [];
		for(let j = 203; !(j >= 211); j++) {
			z.missionDeck.push(j);
		}
		shuffle(z.missionDeck);
		z.activeMission = null;
		z.scoutingMission = false;
	}
	z.destinationDeck = [];
	for(let j = 0; !(j >= 22); j++) {
		z.destinationDeck.push(j);
	}
	for(let j = 22; z.pegasus && !(j >= 27); j++) {
		if(j !== 25 || !z.CFB) {
			z.destinationDeck.push(j);
		}
	}
	for(let j = 27; z.exodus && !(j >= 34); j++) {
		z.destinationDeck.push(j);
	}
	shuffle(z.destinationDeck);
	z.destinationDiscards = [];
	if(z.daybreak) {
		z.mutinyDeck = [];
		for(let j = 0; !(j >= 22); j++) {
			z.mutinyDeck.push(j);
		}
		shuffle(z.mutinyDeck);
		z.buriedMutinies = 0;
		z.mutinies = blankArrays(z.numPlayers);
		z.mutinyDiscards = [];
	}
	if(z.preCrossroads) {
		z.traumaPile = [];
		if(!z.vDisasterDeferred) {
			z.traumaPile = [-1,-1];
		} else if (z.vEuropeanTrauma){
			z.traumaPile = [-1];
		}
		for(let j = 0; !(j >= 18); j++) {
			z.traumaPile.push(0);
			z.traumaPile.push(1);
		}
		shuffle(z.traumaPile);
		if(!z.vEuropeanTrauma){
			z.sickbayTrauma = z.traumaPile.pop();
		}
		z.brigTrauma = z.traumaPile.pop();
		z.benevolent = [];
		z.antagonistic = [];
		for(let j = 0; !(j >= z.numPlayers); j++) {
			z.benevolent.push(0);
			z.antagonistic.push(0);
			for(let l = 0; !(l >= 3); l++) {
				let drawnTrauma = z.traumaPile.pop();
				let foundDisasters = 0;
				while(drawnTrauma === -1) {
					foundDisasters++;
					drawnTrauma = z.traumaPile.pop();
				}
				for(let k = foundDisasters; k > 0; k--) {
					z.traumaPile.push(-1);
					shuffle(z.traumaPile);
				}
				if(drawnTrauma === 0) {
					z.antagonistic[j]++;
				} else if(drawnTrauma === 1) {
					z.benevolent[j]++;
				}
			}
		}
		z.allyDeck = [];
		for(let j = 0; !(j >= 35); j++) {
			z.allyDeck.push(j);
		}
		shuffle(z.allyDeck);
		z.allies = [];
		for(let j = 0; !(j >= 3); j++) {
			z.allies.push([allyPop(), z.traumaPile.pop()]);
		}
		z.metAlly = null;
		z.newAlly = null;
		z.cylonAllyQueue = [];
		z.ionianBattle = false;
		z.earlyCrossroads = false;
		z.midCrossroads = false;
		z.lateCrossroads = false;
		z.crossroadsPlayer = -1;
	}
	let cylonDeck = [11, 12, 13, 14];
	z.notCylonDeck = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	if(z.daybreak) {
		z.notCylonDeck.unshift(39);
	}
	if(z.pegasus) {
		z.notCylonDeck.unshift(16);
		cylonDeck.push(18);
	} else if(z.noSympathizer && characterPresent("Boomer") && characterPresent("Baltar") && !z.exodus && !z.daybreak && z.numPlayers === 6) {
		plainAlert("Stole Pegasus' extra \"You Are Not a Cylon\" card for use in this game.");
		z.notCylonDeck.push(16);
	}
	if(z.exodus) {
		cylonDeck.push(37);
		cylonDeck.push(38);
		z.notCylonDeck = z.notCylonDeck.concat([19, 20, 21, 22, 23]);
		if(z.finalFives) {
			z.notCylonDeck = z.notCylonDeck.concat([32, 33, 34, 35, 36]);
		}
		if(z.personalGoals) {
			if(z.vBrutalityPlus && (!z.vInfiltration || z.numPlayers !== 7 || z.destination !== "New Caprica")){
				let personalGoals = [24,25,26,27,28,29,30,31,67];
				shuffle(personalGoals);
				z.personalGoalsBrutality = [];
				for(let j = 0; !(j>=z.numPlayers); j++){
					if( isTheCylonLeader(j)){
						z.personalGoalsBrutality.push(null);
					} else {
						z.personalGoalsBrutality.push(personalGoals.pop());
					}
				}
			} else {
				z.notCylonDeck = z.notCylonDeck.concat([24, 25, 26, 27, 28, 29, 30, 31]);
			}
		}
	}
	shuffle(cylonDeck);
	if(z.exodus) {
		shuffle(z.notCylonDeck);
	}
	z.loyaltyDeck = [];
	if(z.v20){
		if(!z.exodus){
			z.notCylonDeck = z.notCylonDeck.concat([19, 20, 21, 22, 23]);
		}
		if(!z.pegasus && (z.exodus || characterPresent("Boomer") || characterPresent("Baltar"))){
			z.notCylonDeck.push(16);
		}
		if(!z.daybreak && (z.exodus || characterPresent("Boomer") || characterPresent("Baltar"))){
			z.notCylonDeck.push(39);
		}
		shuffle(z.notCylonDeck);
		for(let j = 0; !(j>=16); j++){
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		for(let j = 0; !(j>=4); j++){
			z.loyaltyDeck.push(cylonDeck.pop());
		}
		if(characterPresent("Boomer")){
			if(z.notCylonDeck.length > 0 ){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
			if(z.notCylonDeck.length > 0 ){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		}
		if(characterPresent("Baltar")){
			if(z.notCylonDeck.length > 0 ){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
			if(z.notCylonDeck.length > 0 ){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		}
	} else {
		if(z.numPlayers >= 3) {
			z.loyaltyDeck.push(cylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		if(z.numPlayers === 4 || z.numPlayers === 6) {
			if(z.sympathizer || z.sympatheticCylon) {
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			} else if(z.mutineer) {
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(40);
			} else if(z.noSympathizer) {
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			} else if(z.vInfiltration){
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(68);
			}
			if(z.numPlayers === 6) {
				z.loyaltyDeck.push(cylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		} else if(z.numPlayers === 5) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			if(z.mutineer && z.cylonLeader) {
				z.loyaltyDeck.push(40);
			} else if(!z.cylonLeader) {
				z.loyaltyDeck.push(cylonDeck.pop());
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		} else if(z.numPlayers === 7) {
			z.loyaltyDeck.push(cylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			if(z.vInfiltration){
				z.loyaltyDeck.push(68);
			} else {
				z.loyaltyDeck.push(z.notCylonDeck.pop());
				if(z.mutineer){
					z.loyaltyDeck.push(40);
				}
			}
		}
		if(z.exodus && z.numPlayers >= 2) {
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
		for(let i = 0; !(i >= z.numPlayers) && z.numPlayers >= 3; i++) {
			if(z.players[i ] === "Boomer" || z.players[i ] === "Baltar") {
				z.loyaltyDeck.push(z.notCylonDeck.pop());
			}
		}
		if(z.numPlayers === 1) {
			z.loyaltyDeck.push(cylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
			z.loyaltyDeck.push(z.notCylonDeck.pop());
		}
	}
	shuffle(z.loyaltyDeck);
	z.loyaltyHands = blankArrays(z.numPlayers);
	z.loyaltyDiscards = blankArrays(z.numPlayers);
	
	t.value += z.loyaltyDeck.length + " cards to start in the Loyalty Deck.\r\n";
	if(z.numPlayers === 1) {
		z.assistLoyalty = [];
		z.assistLoyalty.push(z.loyaltyDeck.pop());
		z.assistLoyalty.push(z.loyaltyDeck.pop());
		z.assistLoyalty.push(z.loyaltyDeck.pop());
		z.assistMiracle = 1;
	}
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(z.players[i ] === "Tom" && z.numPlayers + z.boxedPlayers.length > 1) {
			z.abusePower = [];
			if(z.vBrutality) {
				z.necessarySteps = [];
				t.value += "Tom's Disreputable Mutiny dealt.\r\n";
				z.mutinies[i ].push(z.mutinyDeck.pop());
			} else {
				z.necessarySteps = [i ];
				z.necessarySteps.push(z.mutinyDeck.pop());
				z.necessarySteps.push(z.mutinyDeck.pop());
				t.value += "Tom's Disreputable Mutinies dealt.\r\n";
				t.value += bold("Tom must place one of these mutinies on the bottom of the Mutiny deck.\r\n");
			}
		}
		if(!isCylonLeader(z.players[i ])) {
			if(z.numPlayers >= 3) {
				z.loyaltyHands[i ].push(z.loyaltyDeck.pop());
			}
		} else if(z.daybreak || z.vNoAgendas) {
			z.theCylonLeader = i;
			if(z.vBalancedMotives) {
				z.motiveDeck = [];
				for(let j = 0; !(j >= 7); j++) {
					z.motiveDeck.push(53 + j);
				}
				shuffle(z.motiveDeck);
				z.loyaltyHands[i ].push(z.motiveDeck.pop());
				let evilDeck = [];
				for(let j = 7; !(j >= 14); j++) {
					evilDeck.push(53 + j);
				}
				shuffle(evilDeck);
				z.loyaltyHands[i ].push(evilDeck.pop());
				while(evilDeck.length > 0) {
					z.motiveDeck.push(evilDeck.pop());
				}
				t.value += z.players[i ] + " is dealt one Human Motive and one Cylon Motive; the remaining Motives are shuffled together.\r\n";
			} else {
				z.motiveDeck = [];
				for(let j = 0; !(j >= 14); j++) {
					z.motiveDeck.push(53 + j);
				}
				shuffle(z.motiveDeck);
				t.value += "Initial Motives dealt.\r\n";
				z.loyaltyHands[i ].push(z.motiveDeck.pop());
				z.loyaltyHands[i ].push(z.motiveDeck.pop());
			}
			shuffle(z.motiveDeck);
			z.motiveDeck = z.motiveDeck.slice(0, 4);
		} else {
			z.theCylonLeader = i;
			let agendaDeck = [];
			let hostileOffset = 0;
			if(z.numPlayers === 5 || z.numPlayers === 7) {
				hostileOffset = 6;
				t.value += "Hostile Agenda dealt.\r\n";
			} else {
				t.value += "Sympathetic Agenda dealt.\r\n";
			}
			for(let j = 0; !(j >= 6); j++) {
				agendaDeck.push(41 + hostileOffset + j);
			}
			shuffle(agendaDeck);
			z.loyaltyHands[i ].push(agendaDeck.pop());
		}
		if(z.players[i ] === "Baltar" && z.numPlayers !== 1) {
			z.loyaltyHands[i ].push(z.loyaltyDeck.pop());
			t.value += "Baltar receives an extra Loyalty.\r\n";
		}
	}
	t.value += "Initial Loyalties dealt.  There are now " + z.loyaltyDeck.length + " cards remaining in the Loyalty Deck.\r\n";
	if(z.sympathizer) {
		z.loyaltyDeck.push(15);
		shuffle(z.loyaltyDeck);
		t.value += "Sympathizer card added; there are now " + z.loyaltyDeck.length + " cards in the Loyalty Deck.\r\n";
	} else if(z.sympatheticCylon) {
		z.loyaltyDeck.push(17);
		shuffle(z.loyaltyDeck);
		t.value += "Sympathetic Cylon card added; there are now " + z.loyaltyDeck.length + " cards in the Loyalty Deck.\r\n";
	}
	if(z.numPlayers === 2) {
		z.loyaltyDeck.push(z.notCylonDeck.pop());
		z.loyaltyDeck.push(z.notCylonDeck.pop());
		z.loyaltyDeck.push(cylonDeck.pop());
	}
	shuffle(z.loyaltyDeck);
	z.revealedCylons = [];
	for(let i = 0; !(i >= z.numPlayers); i++) {
		if(isCylonLeader(z.players[i ]) && z.players[i ] !== "Athena") {
			z.revealedCylons.push(1);
		} else {
			z.revealedCylons.push(0);
		}
	}
	z.vipersII = [5, 6, 0, 0, 0, 0];
	z.raiders = [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	z.heavies = [0, 0, 0, 0];
	z.basestars = [
		[1],
		[0]
	];
	z.centurions = [0, 0, 0, 0];
	if(!z.CFB) {
		z.vipersII.push(0);
		z.vipersII.push(0);
	} else {
		z.vipersVII = [-1, -1, -1, -1];
		z.pursuitTrack = 0;
		z.raiders.push(0);
		z.raiders.push(0);
		z.raiders.push(0);
		z.raiders.push(0);
	}
	z.raiderActivated = [];
	for(let j = 0; !(j >= z.raiders.length); j++) {
		z.raiderActivated.push(0);
	}
	z.activatingSector = 0;
	if(z.daybreak) {
		z.assaultRaptors = [0, -3, -3, -3];
	}
	if(characterPresent("Apollo")) {
		z.avp = [];
		if(z.playerLocations[getPlayerNum("Apollo")] === "Sector 5 AR") {
			z.assaultRaptors[0] = "Apollo";
			z.playerLocations[getPlayerNum("Apollo")] = "Sector 5";
		} else if(z.playerLocations[getPlayerNum("Apollo")] === "Sector 6 AR") {
			z.assaultRaptors[0] = "Apollo";
			z.playerLocations[getPlayerNum("Apollo")] = "Sector 6";
		} else {
			z.vipersII[2] = "Apollo";
		}
	}
	z.raptors = 4;
	z.civilianPile = ["Decoy", "Decoy", "Pop/Fuel", "Pop/Morale", "2 Pop", "2 Pop", "1 Pop", "1 Pop", "1 Pop", "1 Pop", "1 Pop", "1 Pop"];
	z.destroyedCivilians = [];
	z.lockedCivilians = [];
	z.preparedCivilians = [];
	shuffle(z.civilianPile);
	z.civilianLetters = ["C", "D", "E", "F", "G", "H", "I", "J", "K", "L"];
	z.spaceCivilians = blankArrays(6);
	z.spaceCivilians[3].push(["A", z.civilianPile.pop(), false]);
	z.spaceCivilians[3].push(["B", z.civilianPile.pop(), false]);
	passPresident(99);
	t.value += "Quorum dealt to the President.\r\n";
	passAdmiral(99);
	if(z.CFB) {
		passCAG(99);
	}
	t.value += "\r\n";
	z.gameSetup = false;
	if(z.mutineer) {
		let position = -1;
		for(let j = 0; z.theMutineer === -1 && !(j >= z.numPlayers); j++) {
			for(let k = 0; !(k >= z.loyaltyHands.length); k++) {
				if(z.loyaltyHands[j][k] === 40) {
					z.theMutineer = j;
					position = k;
					break;
				}
			}
		}
		if(z.theMutineer !== -1) {
			boldAlert(z.players[z.theMutineer] + " is the Mutineer.");
			z.loyaltyDiscards[z.theMutineer].push(z.loyaltyHands[z.theMutineer].splice(position, 1)[0]);
			t.value += z.players[z.theMutineer] + " draws another Loyalty card.\r\n";
			z.loyaltyHands[z.theMutineer].push(z.loyaltyDeck.pop());
			t.value += "There are now " + z.loyaltyDeck.length + " cards remaining in the Loyalty Deck.\r\n"; /* TODO: check this works right for Tom */
			dealMutiny(z.theMutineer, false);
			if(z.theMutineer === z.president) {
				z.secretMessages[z.theMutineer] += "\nThe President's Quorum is: " + d.quorumNames[z.quorumHand[0]] + ".";
				passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
				t.value += z.players[z.theMutineer] + " has been informed what their Quorum was before they passed it off.\r\n";
			}
			if(z.theMutineer === z.admiral) {
				passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
			}
			if(z.CFB && z.theMutineer === z.cag) {
				passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
			}
		}
	}
	textGameState(true);
	if(z.players[0] === "Starbuck" && z.vBrutality && versionAtLeast([1, 2, 4, 2])) {
		z.expertPilot = true;
	}
	if(z.players[0] === "Billy"){
		z.presidentialAide = true;
	}
	if(z.cylonLeader) {
		if(z.turn === z.theCylonLeader){
			if(z.vBrutality && z.players[z.turn] === "D'Anna") {
				t.value +=
					"D'Anns uses her Investigative Journalism ability to look at the top card of the Crisis deck.  She must draw 1 Skill Card (it may be from outside of her skill set), then draw 1 Skill Card from her Skill set.\r\n";
				z.secretMessages[z.turn] += "\nInvestigative Journalism, Turn " + z.round + "." + (z.turn + 1) + ": " + d.crisisNames[z.crisisDeck[z.crisisDeck
					.length - 1]];
				addOption(z.turn, "Draw 1 Skill Card (any color)", "Investigative Journalism", true);
				z.drawSkills = false;
			} else if(z.players[z.theCylonLeader] === "Athena" && z.theCylonLeader === 0) {
				t.value += "Athena should draw her starting hand of 3 skill cards once everyone else has drawn.\r\n";
			} else {
				t.value += z.players[z.theCylonLeader] + " should now draw 2 skill cards from within the colors and numbers in their skill set once everyone else has drawn.\r\n";
			}
		} else {
			if(z.vBrutality && z.players[z.theCylonLeader] === "D'Anna") {
				t.value += "D'Anna should draw her starting hand of 1 skill card.\r\n";
			} else if(z.players[z.theCylonLeader] === "Athena") {
				t.value += "Athena should draw their starting hand of 3 skill cards (as if it were her turn).\r\n";
			} else {
				t.value += z.players[z.theCylonLeader] + " should now draw 2 skill cards from within the colors and numbers in their skill set.\r\n";
			}
		}
	}
	if(z.theCylonLeader !== 0) {
		if(z.players[0] === "Anders" && z.numPlayers + z.boxedPlayers.length > 1) {
			t.value += "Anders Starts on the Bench, and does not draw skill cards at this time.\r\n";
		} else if(z.players[0] === "Baltar") {
			t.value += "Baltar should draw his starting hand of 4 skill cards once everyone else has drawn.\r\n";
		} else if(z.players[0] === "Billy") {
			t.value += "Billy should draw his starting hand of 4 skill cards and 1 Quorum card once everyone else has drawn.\r\n";
		} else {
			t.value += z.players[0] + " should draw their starting hand of 5 skill cards once everyone else has drawn.\r\n";
		}
	}
	t.value += "Everyone else should now draw 3 cards from within the colors and numbers in their skill set.\r\n";
	saveAndQuit();
}

function canAVP() {
	if(z.vBrutality) {
		if(versionAtLeast([2,3,5,2])){
			return characterPresent("Apollo") && onGalactica(z.playerLocations[getPlayerNum("Apollo")]) && z.playerLocations[getPlayerNum("Apollo")] !== "Brig" && 
			       z.playerLocations[getPlayerNum("Apollo")] !== "Sickbay";
		} else {
			return characterPresent("Apollo") && z.playerLocations[getPlayerNum("Apollo")] !== "Brig" && z.playerLocations[getPlayerNum("Apollo")] !== "Sickbay" &&
			!isInSpace(getPlayerNum("Apollo")) && !isOnNewCaprica(getPlayerNum("Apollo"));
		}
	}
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.players[j] === "Apollo" && onGalactica(z.playerLocations[j]) && z.playerLocations[j] !== "Brig" && j !== z.theSympatheticCylon) {
			return true;
		}
	}
	return false;
}

function canMoralCompass() {
	return (z.currentCrisis !== null && !isSuperCrisis(z.currentCrisis) && ((characterPresent("Helo") && z.miracles[getPlayerNum("Helo")] === 1) || (z
		.assist === "Helo" && z.assistMiracle === 1) || actsOfFaith("Helo")) && !z.theFarm);
}

function getHelo() {
	if(z.assist === "Helo") {
		return 0;
	} else if(characterPresent("Helo") && z.miracles[getPlayerNum("Helo")] === 1) {
		return getPlayerNum("Helo");
	} else if(characterPresent("Gaius")) {
		return getPlayerNum("Gaius");
	}
	return me;
}

function handReport() {
	let report = bold(titleList(me)) + bold(myPlayer) + ", your current hand is:\r\n";
	for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
		report += cardText(z.skillCardHands[me][j]);
		if(characterPresent("Athena") && z.forLoveCOs[me] == z.skillCardHands[me][j]) {
			report += " (to be discarded if Athena does not Love you)";
		}
		report += "\r\n";
	}
	let excessCards = z.skillCardHands[me].length - 10;
	if(myPlayer === "Chief" && z.revealedCylons[me] === 0 && !noDrawback(me)) {
		excessCards += 2;
	}
	if(excessCards > 0) {
		report += "You are over your hand limit by ";
		if(excessCards === 1) {
			report += bold("1 card");
		} else {
			report += bold(excessCards + " cards");
		}
		report += " and may need to discard at the end of the turn.\r\n";
	}
	report += "\r\n";
	if(z.superCrisisHands[me].length === 1) {
		report += bold("Your Super Crisis is:") + "\r\n" + d.crisisNames[z.superCrisisHands[me][0]] + "\r\n\r\n";
	} else if(z.superCrisisHands[me].length > 1) {
		report += bold("Your Super Crises are:") + "\r\n";
		for(let j = 0; !(j >= z.superCrisisHands[me].length); j++) {
			report += d.crisisNames[z.superCrisisHands[me][j]] + "\r\n";
		}
		report += "\r\n";
	}
	if(z.daybreak && z.mutinies[me].length > 0) {
		report += bold("Your Mutinies are") + ":\r\n";
		for(let j = 0; !(j >= z.mutinies[me].length); j++) {
			report += d.mutinyNames[z.mutinies[me][j]] + "\r\n";
		}
		if(z.mutinies[me].length === 3 || (z.mutinies[me].length === 2 && z.theMutineer !== me)) {
			report += bold("You must discard a Mutiny now.") + "\r\n";
		}
		report += "\r\n";
	}
	if(myPlayer === "Tom" && z.necessarySteps.length > 0) {
		report += bold("Necessary Steps for " + z.players[z.necessarySteps[0]] + ":\r\n");
		report += d.mutinyNames[z.necessarySteps[1]] + "\r\n";
		if(!z.vBrutality) {
			report += d.mutinyNames[z.necessarySteps[2]] + "\r\n";
			report += bold("Pick one to give to " + z.players[z.necessarySteps[0]] + "; bottom the other.\r\n\r\n");
		} else {
			report += bold("You may place it on the top or bottom of the deck.");
		}
	}
	if(me === z.president) {
		if(isMale(me)) {
			report += bold("Mr. ");
		} else {
			report += bold("Madam ");
		}
		report += bold("President, your Quorum hand is:\r\n");
		for(let j = 0; !(j >= z.quorumHand.length); j++) {
			report += d.quorumNames[z.quorumHand[j]] + "\r\n";
		}
		if(z.quorumHand.length > z.quorumHandLimit) {
			report += bold("You are over your Quorum hand limit by " + (z.quorumHand.length - z.quorumHandLimit) + " cards") +
				", and may need to discard at the end of the turn.\r\n";
		}
		report += "\r\n";
	} else if(z.players[me] === "Billy") {
		report += bold("Billy, your private Quorum hand is:\r\n");
		for(let j = 0; !(j >= z.billyHand.length); j++) {
			report += d.quorumNames[z.billyHand[j]] + "\r\n";
		}
		if(z.billyHand.length > 2) {
			report += bold("You are over your Quorum hand limit by " + (z.billyHand.length - 2) + " cards") +
				", and may need to discard and/or use Presidential Aide at the end of the turn.\r\n";
		}
	}
	if(me === z.admiral) {
		report += bold(colorText("green", "Admiral")) + ", you have " + z.nukes + " nuke token(s).\r\n\r\n";
	}
	if(!isTheCylonLeader(me) && me !== z.theSympatheticCylon) {
		report += bold("Your Loyalty hand is:\r\n");
	} else if(z.daybreak) {
		report += bold("Your Motive hand is:\r\n");
	} else {
		report += bold("Your Agenda is:\r\n");
	}
	for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
		report += d.loyaltyNames[z.loyaltyHands[me][j]] + "\r\n";
	}
	for(let j = 0; !(j >= z.loyaltyDiscards[me].length); j++) {
		if(z.loyaltyDiscards[me][j] === 40 || z.loyaltyDiscards[me][j] === 17 || z.loyaltyDiscards[me][j] === 15){
			report += d.loyaltyNames[z.loyaltyDiscards[me][j]] + " (revealed)\r\n";
		} else {
			report += strikethrough(d.loyaltyNames[z.loyaltyDiscards[me][j]]) + "\r\n";
		}
	}
	report += "\r\n";
	if(Array.isArray(z.personalGoalsBrutality) && !isTheCylonLeader(me)){
		if(z.personalGoalsBrutality[me] === null){
			report += "You have already revealed your Personal Goal.\r\n\r\n";
		} else {
			report += bold("Your Personal Goal is:\r\n");
			report += d.loyaltyNames[z.personalGoalsBrutality[me]] + "\r\n";
			report += "Note that the condition to reveal this Personal Goal is likely different than stated above due to Brutality tweaks.\r\n\r\n";
		}
	}
	if(z.daybreak) {
		if(z.miracles[me] === 1) {
			report += bold("You have 1 Miracle Token.") + "\r\n\r\n";
		} else {
			report += bold("You have " + z.miracles[me] + " Miracle Tokens.") + "\r\n\r\n";
		}
	} else {
		if(z.miracles[me] === 1) {
			report += bold("You still have your OPG ability.") + "\r\n\r\n";
		} else {
			report += bold("You have used your OPG ability.") + "\r\n\r\n";
		}
	}
	if(z.preCrossroads) {
		report += "You have " + colorText("blue", z.benevolent[me]) + " Benevolent Trauma.\r\n";
		report += "You have " + colorText("red", z.antagonistic[me]) + " Antagonistic Trauma.\r\n";
	}
	if(z.preCrossroads && z.earlyCrossroads) {
		report += bold("Your Crossroads card is:") + "\r\n" + z.crossroadsCards[me] + "\r\n";
	}
	if(z.damagePlayer === me && z.damageHand.length > 0) {
		report += "You have the following damage tokens in hand:\r\n";
		for(let i = 0; !(i >= z.damageHand.length); i++) {
			report += z.damageHand[i ] + "\r\n";
		}
		if(z.playerLocations[me] === "Basestar Bridge" || myPlayer === "Athena") {
			report += bold("Basestar Bridge: Please choose one to resolve then discard the other.") + "\r\n";
		} else {
			report += bold("Damage Reveal: Please choose two to resolve then discard the other three.") + "\r\n";
		}
	}
	if(z.secretMessages[me].length > 0) {
		report += "Your secret message is:\r\n" + z.secretMessages[me];
	}
	return report;
}

function resetActivatingSector() {
	/* TODO: pick when Scar activates? */
	if(z.activatingSector !== 0) {
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiderActivated[j] === 0 && z.raiders[j] === z.activatingSector) {
				activateSector();
				return;
			}
		}
		if(z.scar === z.activatingSector && 3 > z.scarActivated) {
			activateSector(true);
			return;
		}
	}
	let sectors = [false, false, false, false, false, false];
	for(let j = 0; !(j >= z.raiders.length); j++) {
		if(z.raiderActivated[j] === 0 && z.raiders[j] > 0) {
			sectors[z.raiders[j] - 1] = true;
		}
	}
	if(z.scar > 0 && 3 > z.scarActivated) {
		sectors[z.scar - 1] = true;
	}
	let multipleSectors = false;
	let lastSector = 0;
	for(let j = 0; !(j >= sectors.length); j++) {
		if(sectors[j]) {
			if(lastSector !== 0) {
				multipleSectors = true;
				break;
			}
			lastSector = j + 1;
		}
	}
	if(multipleSectors) {
		if(unmannedVipersList().length + mannedVipersList().length + spaceCiviliansList().length === 0) {
			plainAlert("Raiders in Sector " + lastSector + " activate.");
			z.activatingSector = lastSector;
			activateSector();
		} else {
			if(z.activatingSector !== 0) {
				plainAlert("Activations in Sector " + z.activatingSector + " complete; " + z.players[z.turn] + " must pick the next sector to activate.");
			} else {
				plainAlert(z.players[z.turn] + " must pick the next sector of Raiders to activate.");
			}
			addOption(z.turn, "Choose which sector of Raiders activates next", undefined, true);
		}
	} else if(lastSector === 0) {
		z.activatingSector = 0;
		plainAlert("Raider activation complete."); /* TODO: now prime the jump prep. */
	} else {
		plainAlert("Raiders in Sector " + lastSector + " activate.");
		z.activatingSector = lastSector;
		activateSector();
	}
}

function raiderShot(scar) {
	if(scar) {
		if(z.scarActivated === 0) {
			z.scarActivated = 2;
		} else {
			z.scarActivated = 4;
		}
		return;
	}
	for(let j = 0; !(j >= z.raiders.length); j++) {
		if(z.raiderActivated[j] === 0 && z.raiders[j] === z.activatingSector) {
			z.raiderActivated[j] = 2;
			break;
		}
	}
}

function numUndamagedVipers(){
	let count = 0;
	for(let j = 0; !(j>=z.vipersII.length); j++){
		if(!Number.isInteger(z.vipersII[j]) || z.vipersII[j] >= 0){
			count++;
		}
	}
	for(let j = 0; z.CFB && !(j>=z.vipersVII.length); j++){
		if(!Number.isInteger(z.vipersVII[j]) || z.vipersVII[j] >= 0){
			count++;
		}
	}
	for(let j = 0; z.daybreak && !(j>=z.assaultRaptors.length); j++){
		if(!Number.isInteger(z.assaultRaptors[j]) || z.assaultRaptors[j] >= 0){
			count++;
		}
	}
	return count;
}

function activateSector(pickedScar) {
	let numRaiders = 0;
	let firstActivation = true;
	for(let j = 0; !(j >= z.raiders.length); j++) {
		if(z.raiderActivated[j] === 0 && z.raiders[j] === z.activatingSector) {
			numRaiders++;
		}
		if(z.raiderActivated[j] === 2 && z.raiders[j] === z.activatingSector) {
			firstActivation = false;
		}
	}
	let scar = z.scar === z.activatingSector && 3 > z.scarActivated;
	if(z.scar === z.activatingSector && (z.scarActivated === 2 || z.scarActivated === 4)) {
		firstActivation = false;
	}
	if(scar && z.scarActivated === 2) {
		pickedScar = true;
	}
	let numPilots = 0;
	let lastPilot = "";
	let runInterference = false;
	for(let j = 0; !(j >= z.numPlayers); j++) {
		if(z.playerLocations[j] === "Sector " + z.activatingSector) {
			lastPilot = z.players[j];
			if(z.possibleColors[j][3] === 1 && z.pegasus) {
				runInterference = firstActivation;
			}
			numPilots++;
		}
	}
	let unmannedTypes = 0;
	let vipersII = false;
	for(let j = 0; !(j >= z.vipersII.length); j++) {
		if(z.vipersII[j] === z.activatingSector) {
			vipersII = true;
			unmannedTypes++;
			break;
		}
	}
	let vipersVII = false;
	for(let j = 0; !(j >= z.vipersII.length) && !vipersVII && z.CFB; j++) {
		if(z.vipersVII[j] === z.activatingSector) {
			vipersVII = true;
			unmannedTypes++;
		}
	}
	let assaultRaptors = false;
	for(let j = 0; !(j >= z.vipersII.length) && !assaultRaptors && z.daybreak; j++) {
		if(z.assaultRaptors[j] === z.activatingSector) {
			assaultRaptors = true;
			unmannedTypes++;
		}
	}
	if(!pickedScar && scar && numRaiders > 0 && arguments.length === 0 && (vipersII || vipersVII || assaultRaptors || numPilots > 0 || z.spaceCivilians[z
			.activatingSector - 1].length > 0)) {
		plainAlert(z.players[z.turn] + " must choose whether to activate Scar or a regular raider.");
		addOption(z.turn, "Activate Scar", undefined, true);
		addOption(z.turn, "Activate a regular Raider", undefined, true);
		return;
	}
	if(scar && numRaiders === 0) {
		pickedScar = true;
	}
	if(vipersII && !vipersVII && !assaultRaptors && !runInterference) {
		if(pickedScar) {
			plainAlert("Scar shoots at a Viper Mk II in Sector " + z.activatingSector + ".");
			z.dieRollQueue.push("Scar vs. Viper Mk II (Sector " + z.activatingSector + ")");
			z.dieRoller = z.turn;
		} else {
			plainAlert("Raider shoots at a Viper Mk II in Sector " + z.activatingSector + ".");
			z.dieRollQueue.push("Raider vs. Viper Mk II (Sector " + z.activatingSector + ")");
			z.dieRoller = z.turn;
		}
		return;
	}
	if(!vipersII && vipersVII && !assaultRaptors && !runInterference) {
		plainAlert("Raider shoots at a Viper Mk VII in Sector " + z.activatingSector + ".");
		z.dieRollQueue.push("Raider vs. Viper Mk VII (Sector " + z.activatingSector + ")");
		z.dieRoller = z.turn;
		return;
	}
	if(!vipersII && !vipersVII && assaultRaptors && !runInterference) {
		if(pickedScar) {
			plainAlert("Scar shoots at an Assault Raptor in Sector " + z.activatingSector + ".");
			z.dieRollQueue.push("Scar vs. Assault Raptor (Sector " + z.activatingSector + ")");
			z.dieRoller = z.turn;
		} else {
			plainAlert("Raider shoots at an Assault Raptor in Sector " + z.activatingSector + ".");
			z.dieRollQueue.push("Raider vs. Assault Raptor (Sector " + z.activatingSector + ")");
			z.dieRoller = z.turn;
		}
		return;
	}
	if(unmannedTypes > 1) {
		plainAlert("Raiders will attack an unmanned Viper in Sector " + z.activatingSector + ". " + z.players[z.turn] +
			" must choose which one will be attacked.");
		if(vipersII) {
			addOption(z.turn, "Attack an unmanned Viper Mk II", pickedScar, true);
		}
		if(vipersVII) {
			addOption(z.turn, "Attack an unmanned Viper Mk VII", pickedScar, true);
		}
		if(assaultRaptors) {
			addOption(z.turn, "Attack an unmanned Assault Raptor", pickedScar, true);
		}
		if(runInterference && (numRaiders > 2 || (scar && firstActivation && numRaiders > 0) || (scar && numRaiders > 1))) {
			plainAlert("You may want to pause for " + colorText("red", "Run Interference") + " first.");
		}
		return;
	}
	if(runInterference) {
		plainAlert("Raiders will attack a Viper in Sector " + z.activatingSector + ".");
		if(vipersII) {
			optionForAll("Attack an unmanned Viper Mk II", pickedScar, true);
		}
		if(vipersVII) {
			optionForAll("Attack an unmanned Viper Mk VII", pickedScar, true);
		}
		if(assaultRaptors) {
			optionForAll("Attack an unmanned Assault Raptor", pickedScar, true);
		}
		if(!vipersII && !vipersVII && !assaultRaptors) {
			optionForAll("Attack a piloted Viper", pickedScar);
			plainAlert("You may want to pause for " + colorText("red", "Run Interference") + " here.");
		}
		return;
	}
	if(numPilots > 1) {
		plainAlert("Raiders will attack a piloted Viper in Sector " + z.activatingSector + ". " + z.players[z.turn] +
			" must choose which one will be attacked.");
		addOption(z.turn, "Attack a piloted Viper", pickedScar, true);
		return;
	}
	if(numPilots === 1) {
		if(pickedScar) {
			plainAlert("Scar shoots at " + lastPilot + ".");
			z.dieRollQueue.push("Scar vs. " + lastPilot);
			z.dieRoller = z.turn;
		} else {
			plainAlert("Raider shoots at " + lastPilot + ".");
			z.dieRollQueue.push("Raider vs. " + lastPilot);
			z.dieRoller = z.turn;
		}
		return;
	}
	if(characterPresent("Hot Dog") && z.miracles[getPlayerNum("Hot Dog")] === 1 && !z.theFarm && z.spaceCivilians[z.activatingSector - 1].length > 0 &&
	   !(Number.isInteger(z.currentCrisis) && d.crisisNames[z.currentCrisis] === "Lured into a Trap") &&
	   !(Number.isInteger(z.currentSkillCheck) && d.crisisNames[z.currentSkillCheck] === "Fleet Mobilization") && numUndamagedVipers() > 0) {
		if(z.spaceCivilians[z.activatingSector - 1].length === 1) {
			plainAlert("Raiders will destroy the Civilian in Sector " + z.activatingSector + ".");
			optionForAll("Destroy a Civilian in space",["Raider", z.activatingSector],true);
			addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",["Raider", z.activatingSector],false);
		} else {
			plainAlert("Raiders will destroy a Civilian in Sector " + z.activatingSector + ".\n"+z.players[z.turn] + " must choose which one will be destroyed.");
			addOption(z.turn, "Destroy a Civilian in space", ["Raider", z.activatingSector], true);
			let anyInspected = false;
			for(let j = 0; !(j >= z.spaceCivilians[z.activatingSector - 1].length) && !anyInspected; j++) {
				anyInspected = z.spaceCivilians[z.activatingSector - 1][j][2];
			}
			if(!anyInspected){
				addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",["Raider", z.activatingSector],false);
			}
		}
		raiderShot(pickedScar);
		return;
	}
	if(z.spaceCivilians[z.activatingSector - 1].length === 1) {
		let civ = z.spaceCivilians[z.activatingSector - 1].pop();
		raiderShot(pickedScar);
		let done = destroyCivilian(civ[1]);
		let civiliansInSpace = 0;
		for(let j = 0; !(j >= 6); j++) {
			civiliansInSpace += z.spaceCivilians[j].length;
		}
		if(civiliansInSpace === 0) {
			z.reshuffledSeen = false;
		}
		if(done) {
			resetActivatingSector();
		} else {
			optionForAll("Resume Raider Activation");
		}
		return;
	}
	if(z.spaceCivilians[z.activatingSector - 1].length > 1) {
		let anyInspected = false;
		raiderShot(pickedScar);
		for(let j = 0; !(j >= z.spaceCivilians[z.activatingSector - 1].length) && !anyInspected; j++) {
			anyInspected = z.spaceCivilians[z.activatingSector - 1][j][2];
		}
		if(anyInspected) {
			plainAlert("Raiders will destroy a Civilian in Sector " + z.activatingSector + ". " + z.players[z.turn] +
				" must choose which one will be destroyed.");
			addOption(z.turn, "Destroy a Civilian in space", ["Raider", z.activatingSector], true);
		} else {
			let civ = z.spaceCivilians[z.activatingSector - 1].shift();
			let done = destroyCivilian(civ[1]);
			let civiliansInSpace = 0;
			for(let j = 0; !(j >= 6); j++) {
				civiliansInSpace += z.spaceCivilians[j].length;
			}
			if(civiliansInSpace === 0) {
				z.reshuffledSeen = false;
			}
			if(done) {
				resetActivatingSector();
			} else {
				optionForAll("Resume Raider Activation");
			}
		}
		return;
	}
	let nextSector = raiderTarget(z.activatingSector);
	if(nextSector !== z.activatingSector) {
		let numMoved = 0;
		for(let j = 0; !(j >= z.raiders.length); j++) {
			if(z.raiders[j] === z.activatingSector && z.raiderActivated[j] === 0) {
				numMoved++;
				z.raiders[j] = nextSector;
				z.raiderActivated[j] = 1;
			}
		}
		if(numMoved === 1) {
			plainAlert("1 Raider moves into Sector " + nextSector + ".");
		} else if(numMoved > 1) {
			plainAlert(numMoved + " Raiders move into Sector " + nextSector + ".");
		}
		if(z.scar === z.activatingSector && 3 > z.scarActivated) {
			plainAlert("Scar moves into Sector " + nextSector + ".");
			z.scar = nextSector;
			if(z.scarActivated === 0) {
				z.scarActivated = 1;
			} else {
				z.scarActivated = 3;
			}
		}
		resetActivatingSector();
		return;
	}
	plainAlert("The Raiders in Sector " + z.activatingSector + " shoot at Galactica.");
	if(z.scarActivated === 0 && z.scar === z.activatingSector) {
		if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && z.turn === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
				delete z.stratPlanPause;
				plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
				SPTokenBad("Scar vs. Galactica",z.turn);
		} else {
			z.dieRollQueue.push("Scar vs. Galactica");
			z.dieRoller = z.turn;
		}
	}
	if(3 > z.scarActivated && z.scar === z.activatingSector) {
		if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && z.turn === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
				delete z.stratPlanPause;
				plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
				SPTokenBad("Scar vs. Galactica",z.turn);
		} else {
			z.dieRollQueue.push("Scar vs. Galactica");
			z.dieRoller = z.turn;
		}
	}
	for(let j = 0; !(j >= numRaiders); j++) {
		if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && z.turn === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
				delete z.stratPlanPause;
				plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
				SPTokenBad("Raider vs. Galactica",z.turn);
		} else {
			z.dieRollQueue.push("Raider vs. Galactica");
			z.dieRoller = z.turn;
		}
	}
}
var menuPage = "Default";
var firstPage = true;
var reGlobal = new RegExp(/\[size=(1|0)\]\[color=#(F4F4FF|FFFFFF)\](New|BYC) seed: \S+\[\/color\]\[\/size\]/, "g");
var a2 = "ENDBYCC  [/size][/c] " + 
" [c][size=1] STARTBYCD";
if(t === undefined) {
	window.localStorage.setItem("bycUrgent", "out of context");
	alert("BYC only works while creating or editing a post on the BGG forums.");
	clearBackground();
} else {
	let foundOne = false;
	let foundTwo = false;
	var seed = null;
	for(let j = ts.length-1; j>=0; j--){
		let seedRE = reGlobal.exec(ts[j].value);
		if(seedRE !== null){
			if(foundOne){
				foundTwo = true;
				break;
			} else {
				seed = seedRE[0].slice(33,-15);
				t = ts[j];
				foundOne = true;
			}
		}
	}
	if(foundTwo){
		addAlert("You are quoting multiple BYC posts on this page; close all but one, or use the Legacy Editor, to continue.");
		seed = null;
		clearBackground();
	} else if(seed === null){
		window.localStorage.setItem("bycUrgent", "blank post");
		confirmify("Would you like to start a new game?", clearBackground, gameSetup, "YES", "NO");
		seed = null;
	}
	if(seed !== null) {
		seed = window.atob(seed.replace(/-/g, ""));
		z = JSON.parse(seed);
		if(!z.hasOwnProperty("quorumPeek")) {
			z.quorumPeek = [];
			z.quorumPeeker = -1;
			z.negotiation = false;
		}
		if(!z.hasOwnProperty("secretMessages")) {
			z.secretMessages = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.secretMessages.push("");
			}
			z.scout = -1;
			z.scoutingDestination = false;
			z.scoutingCrisis = false;
			z.scouted = [];
			z.redTape = false;
			z.ironWill = false;
			z.trustInstincts = false;
			z.protectTheFleet = false;
			z.establishNetwork = false;
			z.forceTheirHand = false;
			z.allHandsOnDeck = false;
			z.quickThinking = false;
			z.dogfight = false;
			z.installUpgrades = false;
			z.broadcastLocation = false;
			z.byYourCommand = false;
			z.specialDestiny = false;
			z.bait = false;
			z.dradisContact = false;
			z.personalVices = false;
			z.aBetterMachine = false;
			z.violentOutbursts = false;
			z.exploitWeakness = false;
			z.gameOver = false;
		}
		if(!z.hasOwnProperty("graveyard")) {
			z.graveyard = [];
			z.cylonExecuted = -1;
			z.humanExecuted = -1;
			z.heloReturnRound = 2;
			z.andersBenchRound = 1;
			z.noCylonDetector = false;
			z.executedCurrentPlayer = false;
		}
		if(!z.hasOwnProperty("boxedPlayers")) {
			z.boxedPlayers = [];
			z.preventative = null;
			z.engineRoom = false;
			z.eulogy = false;
			z.blindJump = false;
			z.fastLearner = [];
			z.manipulativeVictim = -1;
			z.manipulativeAdmiral = true;
			z.endGame = false;
			z.CLexecuted = false;
			z.mutualAnnihilation = false;
		}
		if(!z.hasOwnProperty("establishSanitation")) {
			z.establishSanitation = false;
		}
		if(!z.hasOwnProperty("changeOfPlans")) {
			z.changeOfPlans = false;
			z.crisisOptions = blankArrays(z.numPlayers);
			z.processedOutcome = false;
			z.mementoUsed = false;
			z.mementoCards = [];
			z.dradisBait = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.dradisBait.push(true);
			}
			z.forLove = characterPresent("Athena");
		}
		if(!z.hasOwnProperty("blindDevotionPause")) {
			z.blindDevotionPause = false;
			z.humanDelusionPause = false;
			z.commandAuthorityPause = false;
			z.changeOfPlansPause = false;
		}
		if(!z.hasOwnProperty("tank")) {
			z.tank = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.tank.push(false);
			}
		}
		if(!z.hasOwnProperty("probationPause")) {
			z.probationPause = false;
			z.xo = false;
		}
		if(!z.hasOwnProperty("dieRollQueue")) {
			z.dieRollQueue = [];
			z.dieRollModifier = 0;
			z.lastDieRoll = null;
			z.lastDieRollModifier = 0;
			z.lastDieRollValue = 0;
			z.majorVictory = false;
			for(let j = 0; !(j >= 6) && z.hasOwnProperty("spaceCivilians"); j++) {
				for(let k = 0; !(k >= z.spaceCivilians[j].length); k++) {
					if(z.spaceCivilians[j][k].length === 2) {
						z.spaceCivilians[j][k].push(false);
					}
				}
			}
			z.eco = z.players[z.turn] === "Helo" && characterPresent("Helo");
			z.avionicsExpert = z.players[z.turn] === "Seelix" && characterPresent("Seelix");
			z.sps = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.sps.push(null);
			}
			z.FTLOperator = true;
			z.autoPass = false;
			if(z.CFB) {
				z.cagTitle = true;
			}
		}
		if(!z.hasOwnProperty("spToken")) {
			z.spToken = false;
			z.stim = null;
			z.quickFix = false;
			z.des = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.des.push(null);
			}
			z.deToken = false;
			z.dieRolls = [];
			for(let j = 0; !(j >= 250); j++) {
				let rando = Math.floor((z.seed * 8)/mLCG) + 1;
				updateSeed();
				z.dieRolls.push(rando);
			}
		}
		if(!z.hasOwnProperty("modificationsPause")) {
			z.modificationsPause = false;
			z.noOneGetsLeftBehindPause = false;
		}
		if(!z.hasOwnProperty("context")) {
			z.context = blankArrays(z.numPlayers);
			z.promptStyle = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				z.promptStyle.push(1);
			}
			if(z.hasOwnProperty("raiders")) {
				z.raiderActivated = [];
				for(let j = 0; !(j >= z.raiders.length); j++) {
					z.raiderActivated.push(0);
				}
			}
			z.activatingSector = 0;
			z.scarActivated = 0;
			z.reshuffledSeen = false;
		}
		if(!z.hasOwnProperty("version")) {
			z.version = BYCversion;
			z.billyHand = [];
		}
		if(!z.hasOwnProperty("phase")) {
			z.phase = 1;
			z.emergencyAction = true;
		}
		if(!z.hasOwnProperty("mandatory")) {
			z.mandatory = blankArrays(z.numPlayers);
			z.buriedMutinies = 0;
		}
		if(!z.hasOwnProperty("BYCversion")) {
			z.BYCversion = BYCversion;
			if(characterPresent("Apollo") && !z.hasOwnProperty("avp")) {
				z.avp = [];
			}
		}
		if(!("seed" in z)){
			z.seed = Math.floor(Math.random() * mLCG);
		}
		if(!versionsAtLeast(BYCversion, z.BYCversion)) {
			let alertText = "You are using an out-of-date version of BYC!  Run BYC again to apply the update.\nYour version: ";
			for(let j = 0; !(j>=BYCversion.length); j++){
				alertText += BYCversion[j]+".";
			}
			addAlert(alertText);
			window.localStorage.setItem("bycUrgent", "outdated");
			clearBackground();
		} else {
			if(!versionsAtLeast(z.BYCversion, BYCversion)) {
				z.BYCversion = BYCversion;
			}
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.usernames[j].toLowerCase() === myUsername.toLowerCase()) {
					me = j;
				}
			}
			if(me === -1) {
				for(let j = 0; !(j >= z.boxedPlayers.length); j++) {
					if(myUsername === z.boxedPlayers[j][0]) {
						meBoxed = j;
					}
				}
				if(meBoxed === -1) {
					addAlert(
						"You are not recognized as a player in this game!\nProceed only if you believe this to be in error, or you are replacing a player who resigned or disappeared."
						);
					let promptText = "What player number are you? (1-" + (z.numPlayers + z.boxedPlayers.length) +
						")\nProceed only if you know you are a player in the game (e.g. your username was misspelled, or you are replacing a player who resigned or disappeared).";
					for(let j = 0; !(j >= z.numPlayers); j++) {
						promptText += "\n" + (j + 1) + ": " + z.players[j];
					}
					for(let j = 0; !(j >= z.boxedPlayers.length); j++) {
						promptText += "\n" + (j + 1 + z.numPlayers) + ": " + z.boxedPlayers[j][1] + " (boxed)";
					}
					promptNum(promptText, (a) => 1 > a || a > z.numPlayers + z.boxedPlayers.length, clearBackground, (prompted) => {
						me = prompted - 1;
						if(me >= z.numPlayers) {
							me = -1;
							meBoxed = prompted - 1 - z.numPlayers;
							myPlayer = z.boxedPlayers[meBoxed][1];
							myCharacter = getCharacter(myPlayer);
							mainMenu();
						} else if(z.gameSetup && me > z.players.length) {
							addAlert("It is not yet your turn to pick a character.");
							clearBackground();
						} else if(z.gameSetup && z.players.length > me) {
							addAlert("Please wait for character selection to conclude.");
							clearBackground();
						} else if(z.gameSetup) {
							pickCharacter();
						} else {
							myPlayer = z.players[me];
							myCharacter = getCharacter(myPlayer);
							t.value += colorText("red", bold("This post did not process properly.  Please try again."));
							mainMenu();
						}
					});
				} else {
					myPlayer = z.boxedPlayers[meBoxed][1];
					myCharacter = getCharacter(myPlayer);
					mainMenu();
				}
			} else {
				if(z.gameSetup) {
					if(me > z.players.length) {
						addAlert("It is not yet your turn to pick a character.");
						clearBackground();
					} else if(z.players.length > me) {
						addAlert("Please wait for character selection to conclude.");
						clearBackground();
					} else {
						pickCharacter();
					}
				} else {
					myPlayer = z.players[me];
					myCharacter = getCharacter(myPlayer);
					t.value += colorText("red", bold("This post did not process properly.  Please try again."));
					mainMenu();
				}
			}
		}
	}
}

function actsOfFaith(playerName) {
	return characterPresent(playerName) && z.miracles[getPlayerNum(playerName)] === 0 && characterPresent("Gaius") && z.miracles[getPlayerNum("Gaius")] >= 2 &&
		!z.theFarm && z.vBrutality;
}

function canPlayMovementCard() {
	if(me !== z.turn) {
		return false;
	}
	if(z.phase !== 1) {
		return false;
	}
	if(z.revealedCylons[me] === 1) {
		if(z.daybreak || !z.pegasus) {
			return false;
		}
		for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
			if(cardName(z.skillCardHands[me][j]) === "God's Plan") {
				return true;
			}
		}
		return false;
	}
	for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
		if(cardName(z.skillCardHands[me][j]) === "Preventative Policy" || cardName(z.skillCardHands[me][j]) === "Critical Situation") {
			return true;
		} /* RULES: can you use Full Throttle when Hornet's Nest is around? */
		if(cardName(z.skillCardHands[me][j]) === "Full Throttle" && isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z.gravityWell)) {
			return true;
		}
	}
	return false;
}

function couldBeUnrevealed(){
	if(z.v20){
		if(7 > z.distance || (z.distance === 7 && z.destination !== "New Caprica") || (10 > z.distance && (z.destination === "Earth" || z.destination === "Ionian Earth"))){
			let cylonCount = 0;
			for(let j = 0; !(j>=z.numPlayers); j++){
				if(z.revealedCylons[j] === 1){
					cylonCount++;
				}
			}
			return cylonCount !== 4;
		} else {
			if(z.exodus && z.graveyard.length > 0){
				let cylonCount = 0;
				for(let j = 0; !(j>=z.numPlayers); j++){
					if(z.revealedCylons[j] === 1){
						cylonCount++;
					}
				}
				return cylonCount !== 4;
			} else {
				for(let j = 0; !(j>=z.numPlayers); j++){
					if(z.revealedCylons[j] === 0 && cylonCards(j) > 0){
						return true;
					}
				}
				return false;
			}
		}
	} else {
		if(z.theCylonLeader >= 0 && z.revealedCylons[z.theCylonLeader] === 0){
			return true;
		}
		if(z.theSympatheticCylon >= 0 && z.revealedCylons[z.theSympatheticCylon] === 0){
			return true;
		}
		for(let j = 0; !(j>=z.numPlayers); j++){
			for(let k = 0; !(k>=z.loyaltyHands[j].length); k++){
				if(isCylonCard(z.loyaltyHands[j][k])){
					return true;
				}
			}
		}
		for(let j = 0; !(j>=z.loyaltyDeck.length); j++){
			if(isCylonCard(z.loyaltyDeck[j])){
				return true;
			}
		}
		return false;
	}
}

function canPlayActionCard() {
	let solo = (z.numPlayers + z.boxedPlayers.length === 1 || me === z.momentOfHeroism);
	if(z.revealedCylons[me] === 1) {
		if(z.daybreak || !z.pegasus) {
			return false;
		}
		for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
			if(cardName(z.skillCardHands[me][j]) === "Human Weakness" && (otherPlayerInLocation(me, "Brig") || otherPlayerInLocation(me, "Detention"))) {
				return true;
			}
		}
		return false;
	}
	for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
		let name = cardName(z.skillCardHands[me][j]);
		switch (name) {
			case "Consolidate Power":
			case "Negotiation":
			case "Popular Influence":
				return true;
			case "Unorthodox Plan":
				if(z.players[me] === "Shaw" && 3 >= z.skillCardHands[me].length) {
					continue;
				}
				if(!z.galacticaAway) {
					return true;
				}
				break;
			case "Executive Order":
				if(!z.xo) {
					return true;
				}
				break;
			case "Launch Scout":
				if(z.raptors > 0) {
					return true;
				}
				break;
			case "Maximum Firepower":
				if(isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z.gravityWell)) {
					return true;
				}
				break;
			case "Repair":
				if(z.players[me] === "Cottle" && !solo) {
					break;
				}
				for(let i = 0; !(i >= z.damagedLocations.length); i++) {
					if(z.playerLocations[me] === z.damagedLocations[i ]) {
						return true;
					}
				}
				if(z.playerLocations[me] === "Hangar Deck" && (damagedVipersII() > 0 || damagedVipersVII() > 0)) {
					return true;
				}
				break;
			case "Full Throttle":
				if(isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z.gravityWell)) {
					return true;
				}
				break;
			case "State of Emergency":
				return true;
			case "Scout for Fuel":
				if(z.raptors > 0) {
					return true;
				}
				break;
			case "Build Nuke":
				if(z.players[me] === "Cottle" && !solo) {
					break;
				}
				if(3 > z.nukes) {
					return true;
				}
				break;
			case "Combat Veteran":
				if(!z.hornetsNest && !z.galacticaAway) {
					return true;
				}
				break;
			case "Launch Reserves": {
				if(z.hornetsNest || z.galacticaAway) {
					break;
				}
				let anyone = false;
				for(let j = 0; !(j >= z.numPlayers) && !anyone; j++) {
					anyone = isInSpace(j);
				}
				if(!anyone) {
					break;
				}
				if(vipersIIReserves() === 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) {
					break;
				}
				return true;
			}
			case "Raptor Specialist":
				if((z.players[me] === "Cottle" && !solo)) {
					break;
				}
				if(unbuiltARs() === 0 && z.raptors === 4) {
					break;
				}
				return true;
			case "Test the Limits":
				if(3 > z.jumpTrack && !z.galacticaReturned && (z.players[me] !== "Cottle" || solo)) {
					return true;
				}
				break;
		}
	}
	return false;
}

function resolveKleptomania() {
	if(otherPlayerInLocation(me, z.playerLocations[me])) {
		boldAlert("Romo is a Kleptomaniac!");
		if(z.skillCardHands[z.turn].length > 2) {
			boldAlert("Romo must discard 2 skill cards.");
			if(z.forLove && z.forLoveCOs[z.turn] === null) {
				addOption(z.turn, "[Kleptomania] Discard a Skill Card", 1, true);
				addOption(z.turn, "[Kleptomania] Choose a Skill Card to discard if Athena does not Love you", undefined, true);
			} else {
				addOption(z.turn, "[Kleptomania] Discard a Skill Card", 2, true);
			}
		} else {
			if(isOnNewCaprica(z.turn)) {
				boldAlert("Romo will be moved to Detention at the end of his turn.");
			} else {
				boldAlert("Romo will be moved to the Brig at the end of his turn.");
			}
			z.klepto = true;
		}
	} else {
		plainAlert("Looks like Romo managed to extricate himself before his compulsions took over.");
	}
}

function endMovement() {
	let ally = false;
	for(let j = 0; z.preCrossroads && !(j >= z.allies.length) && !ally; j++) {
		ally = z.playerLocations[z.turn] === d.allyLocations[z.allies[j][0]];
	}
	if(ally) {
		boldAlert(z.players[z.turn] + " must meet an Ally on their current location.");
	}
	if(z.players[z.turn] === "Romo" && z.revealedCylons[z.turn] === 0 && !noDrawback(z.turn) && z.turn !== z.theSympatheticCylon) {
		if(otherPlayerInLocation(z.turn, z.playerLocations[z.turn])) {
			if(ally) {
				plainAlert("Romo may choose to resolve Kleptomania before or after meeting an Ally.");
				addOption(z.turn, "Resolve Kleptomania", undefined, true);
			} else {
				resolveKleptomania();
			}
		}
	}
	z.phase = 2;
}

function canAnyoneAction() {
	return z.AVPAction || z.avionicsExpertAction || z.phase === 2 || (!z.vBrutality && z.aggressiveTactics > 0) || z.criticalSituation || z.xo1 >= 0 || z.xo2 >= 0 || z.SoEActor >= 0 || z
		.athenaProblem;
}

function didAction() {
	removeOption(me, "Razor");
	if(z.players[me] === "Athena" && z.athenaProblem) {
		z.athenaProblem = false;
	} else if(z.players[me] === "Apollo" && z.AVPAction) {
		z.AVPAction = false;
	} else if(z.players[me] === "Seelix" && z.avionicsExpertAction){
		z.avionicsExpertAction = false;
		z.phase = 3;
	} else if(!z.vBrutality && z.aggressiveTactics > 0 && z.players[me] === "Cavil") {
		z.aggressiveTactics--;
		if(z.aggressiveTactics === 0) {
			z.phase = 2;
		}
	} else if(z.criticalSituation) {
		z.criticalSituation = false;
		z.phase = 2;
		if(z.players[z.turn] === "Romo" && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && !noDrawback(z.turn)) {
			addOption(z.turn, "I'm done with Critical Situation", undefined, true);
		}
	} else if(me === z.xo1) {
		if(z.revealedCylons[me] === 0) {
			z.xo2 = z.xo1;
		} else if(z.forwardThinker && characterPresent("Lee") && me !== getPlayerNum("Lee")) {
			let leeLocation = z.playerLocations[getPlayerNum("Lee")];
			if((!inSpace(leeLocation) && leeLocation !== "Sickbay" && leeLocation !== "Medical Center" && !z.damagedLocations.includes(leeLocation)) || z.vBrutality) {
				addOption(getPlayerNum("Lee"), "Forward Thinker", undefined, true);
				addOption(getPlayerNum("Lee"), "Pass on Forward Thinker", undefined, true);
			}
			z.forwardThinker = false;
		}
		z.xo1 = undefined;
	} else if(me === z.SoEActor && me === z.SoEPlayer) {
		z.SoEDone = false;
		z.SoEActor++;
		z.SoEActor %= z.numPlayers;
		if(z.players[z.SoEActor] === "Helo" && z.playerLocations[z.SoEActor] === "Stranded on Caprica") {
			z.SoEActor++;
			z.SoEActor %= z.numPlayers;
		}
		if(z.SoEActor === z.SoEPlayer) {
			z.SoEActor = -1;
		}
	} else if(me === z.xo2) {
		z.xo2 = undefined;
		if(z.forwardThinker && characterPresent("Lee") && me !== getPlayerNum("Lee")) {
			let leeLocation = z.playerLocations[getPlayerNum("Lee")];
			if((!inSpace(leeLocation) && leeLocation !== "Sickbay" && leeLocation !== "Medical Center" && !z.damagedLocations.includes(leeLocation)) || z.vBrutality) {
				addOption(getPlayerNum("Lee"), "Forward Thinker", undefined, true);
				addOption(getPlayerNum("Lee"), "Pass on Forward Thinker", undefined, true);
			}
			z.forwardThinker = false;
		}
	} else if(me === z.SoEActor) {
		let last = (z.SoEActor - 1 + z.numPlayers) % z.numPlayers;
		removeOption(last, "I'm done with my part of State of Emergency");
		z.SoEDone = false;
		z.SoEActor++;
		z.SoEActor %= z.numPlayers;
		if(z.players[z.SoEActor] === "Helo" && z.playerLocations[z.SoEActor] === "Stranded on Caprica") {
			z.SoEActor++;
			z.SoEActor %= z.numPlayers;
		}
		if(z.SoEActor === z.SoEPlayer) {
			z.SoEActor = -1;
		}
	} else if(z.phase === 2 && me === z.turn) {
		z.phase = 3;
	}
}

function canActivateLocation(player, location, roslin) {
	let solo = (z.numPlayers + z.boxedPlayers.length === 1 || player === z.momentOfHeroism);
	if(z.dieRollQueue.length > 0) {
		return false;
	}
	if(isLocationDamaged(location)) {
		return false;
	}
	if(inSpace(location)) {
		return false;
	}
	if(((location === "Administration" && !z.daybreak) || location === "Admiral's Quarters" || location === "Brig" || location === "Airlock" || location === "Resistance HQ" || location === "Detention") && z.currentSkillCheck !== null){
		return false;
	}
	if(location === "Hangar Deck" && z.players[player] === "Seelix" && needsOfTheFleet()){
		return false;
	}
	if(player === z.theSympathizer && location === "Cylon Fleet") {
		return false;
	}
	if(z.players[player] === "Shaw" && !solo && 3 > z.skillCardHands[player].length && location !== "Brig" && location !== "Detention" && z.revealedCylons[
			player] === 0 && player !== z.theSympatheticCylon) {
		return false;
	}
	if(z.players[player] === "Cain" && !z.vBrutality && !solo && (location === "Engine Room" || location === "FTL Control")) {
		return false;
	}
	if(z.players[player] === "Adama" && !z.vBrutality && !solo && location === "Admiral's Quarters") {
		return false;
	}
	if(z.players[player] === "Zarek" && otherPlayerInLocation(player, location) && location !== "Brig" && location !== "Detention" && !solo && z.revealedCylons[
			player] === 0 && player !== z.theSympatheticCylon) {
		return false;
	}
	if(z.players[player] === "Roslin" && z.revealedCylons[player] === 0 && player !== z.theSympatheticCylon && !solo && (!roslin || 2 > z.skillCardHands[player]
			.length)) {
		return false;
	}
	if(z.players[player] === "Six" && !solo && location === "Cylon Fleet" && (!roslin || z.skillCardHands[player].length === 0)) {
		return false;
	}
	if((z.playerLocations[player] === "Brig" || z.playerLocations[player] === "Detention" || z.revealedCylons[player] === 1) && location === "Hangar Deck") {
		return false;
	}
	if(z.revealedCylons[player] === 0 && location === "Hub Destroyed") {
		return false;
	}
	switch (location) {
		case "Bridge":
			return z.activeMission === null;
		case "Sickbay":
		case "Medical Center":
		case "Stranded on Caprica":
			return false;
		case "Engine Room":
			return (z.skillCardHands[player].length >= 2) && (!roslin || z.skillCardHands[player].length >= 4 || player !== "Roslin");
		case "Raider Bay":
		case "Datastream":
		case "Hybrid Tank":
			return z.miracles[player] > 0 || z.superCrisisHands[player].length > 0;
		case "Communications":
			return !z.jammedAssault && spaceCiviliansList().length > 0;
		case "Pegasus CIC":
			return (z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0);
		case "Quorum Chamber":
		case "Occupation Authority (Human)":
			return player === z.president;
		case "Armory":
			return !z.lockdown && z.centurions.length > centurionReserves();
		case "Hangar Deck":
			return isPilot(player);
		case "President's Office":
			return z.daybreak || z.president === player;
		case "Occupation Authority":
			return z.president === player || z.revealedCylons[player] === 1;
		case "FTL Control":
			return z.jumpTrack === 3 || z.jumpTrack == 4;
		case "Caprica":
			return z.currentCrisis == null;
		case "Breeder's Canyon":
			return z.revealedCylons[me] === 0 || z.currentCrisis === null;
		case "Breeder's Canyon (Cylon)":
			return z.currentCrisis === null;
		case "Brig":
		case "Detention":
			return z.playerLocations[player] === location;
		case "Research Lab":
			return !z.vBrutality || !versionAtLeast([1, 2, 4, 6]) || (z.destination !== "Earth" && z.destination !== "Ionian Earth") || !z.captainsCabin;
		default:
			return true;
	}
}

function mainMenu() {
	if(z.vBrutality) {
		d.presidentSuccession[getCharacter("Lee")] = 4;
		d.presidentSuccession[getCharacter("Zarek")] = 3;
		d.skillDraws[1][getCharacter("Lee")] = 2;
		d.skillDraws[3][getCharacter("Lee")] = 0;
		d.skillDraws[0][getCharacter("Tom")] = 1;
		d.skillDraws[2][getCharacter("Tom")] = 2;
		d.skillDraws[2][getCharacter("Karl")] = 1;
		d.skillDraws[3][getCharacter("Karl")] = 2;
		if(z.exodus){
			d.quorumNames[23] = "Establish Dogsville";
		}
	}
	if(versionAtLeast([2,1,13])){
		d.skillDraws[4][getCharacter("Shaw")] = 0;
		d.skillSets[0][getCharacter("Shaw")] = 1;
	}
	let solo = (z.numPlayers + z.boxedPlayers.length === 1 || me === z.momentOfHeroism);
	let myLocation = "Stranded on Caprica";
	let options = [];
	if(meBoxed !== -1) {
		options.push("Display Game State");
		let cylonInHand = false;
		for(let j = 0; !(j >= z.boxedPlayers[meBoxed][2].length); j++) {
			if(isCylonCard(z.boxedPlayers[meBoxed][2][j])) {
				cylonInHand = true;
				break;
			}
		}
		let cylonInDiscards = false;
		for(let j = 0; !(j >= z.boxedPlayers[meBoxed][3].length); j++) {
			if(isCylonCard(z.boxedPlayers[meBoxed][3][j])) {
				cylonInDiscards = true;
			}
			if(z.boxedPlayers[meBoxed][3][j] === 40) {
				options.push("Give the Mutineer card to a Human player after being boxed");
			}
		}
		if(cylonInHand && !cylonInDiscards) {
			options.push("Reveal a Cylon card after being boxed");
		}
	} else {
		myLocation = z.playerLocations[me];
		options.push("Show Hand Report");
		options.push("Display Game State");
		if(mobile) {
			options.push("Add text after your post (and quit)");
		}
		if(z.quorumDeck.length === 0 && z.quorumDiscards.length > 0) {
			options.push("Rebuild the empty Quorum Deck");
		}
		if(z.endGame) {
			options.push("End Game");
		} /* TODO: if you're the last person to pass on interrupts, automatically play in destiny */ /* TODO: closequote tag for easier cleanup */
		if(z.cylonExecuted === me) {
			options.push("Reveal a Cylon card after being executed");
		}
		if(z.humanExecuted === me) {
			options.push("Choose a new character after being executed");
		}
		let initialDraws = false;
		if(z.turn === 0 && z.round === 1 && z.skillCardDiscards[0].length === 0 && z.skillCardDiscards[1].length === 0 
						&& z.skillCardDiscards[2].length === 0 && z.skillCardDiscards[3].length === 0 && z.skillCardDiscards[4].length === 0 
						&& (z.skillCardDiscards.length === 5 || z.skillCardDiscards[5].length === 0)){
			for(let j = 1; !(j>=z.numPlayers) && !initialDraws; j++){
				if(z.skillCardHands[j].length === 0){
					initialDraws = true;
				}
			}
		}
		if(z.drawSkills && me === z.turn && !initialDraws) {
			if(myLocation === "Sickbay" || myLocation === "Medical Center" || ((z.daybreak || z.pegasus) && myLocation === "Resurrection Ship")) {
				options.push("Draw 1 Skill Card");
				if(z.players[me] === "Billy" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !versionAtLeast([2,1,9])) {
					options.push("Draw a Quorum Card");
				}
			} else {
				options.push("Receive Skills for this turn");
			}
			if(((myPlayer === "Ellen" && z.miracles[me] === 1) || (z.assist === "Ellen" && z.assistMiracle === 1) || (myPlayer === "Gaius" && actsOfFaith(
					"Ellen"))) && ((myLocation !== "Brig" && me !== z.admiral) || me !== z.president) && !z.theFarm) {
				options.push("Manipulative (OPG)");
			}
			if((z.players[me] === "Billy" && z.miracles[me] === 1 && !z.theFarm) || (z.players[me] === "Gaius" && actsOfFaith("Billy"))) {
				options.push("Moment of Heroism (OPG)");
			}
		}
		if(z.round === 1 && z.turn === 0 && me !== 0 && z.skillCardHands[me].length === 0 && z.currentCrisis === null && z.currentSkillCheck === null && z
			.skillCardDiscards[0].length === 0 && z.skillCardDiscards[1].length === 0 && z.skillCardDiscards[2].length === 0 && z.skillCardDiscards[3]
			.length === 0 && z.skillCardDiscards[4].length === 0 && (z.skillCardDiscards.length === 5 || z.skillCardDiscards[5].length === 0)) {
			options.push("Draw initial Skill Cards");
		}
		if(Array.isArray(z.allForLove) && z.allForLove[me] && z.skillCardHands[me].length > 1){
			options.push("Discard a Skill Card");
		}
		if(z.scout === me) {
			if(z.scoutingDestination) {
				options.push("Top scouted Destination");
				options.push("Bottom scouted Destination");
			} else if(z.scoutingCrisis) {
				options.push("Top scouted Crisis");
				options.push("Bottom scouted Crisis");
			} else if((z.destination === "Earth" || z.destination === "Ionian Earth") && z.scoutingMission) {
				options.push("Top scouted Mission");
				options.push("Bottom scouted Mission");
			}
		}
		if(z.damageHand.length > 0 && z.damagePlayer === me) {
			options.push("Process a damage token in your hand");
			let damageLeft = z.damage.length;
			if(z.pegasus && !z.vAltDamage && !z.pegasusDestroyed) {
				damageLeft += z.pegasusDamage.length;
			}
			if(z.playerLocations[me] !== "Basestar Bridge" && z.players[me] !== "Athena" && damageLeft === 0) {
				options.push("Discard the damage tokens in your hand");
			}
		}
		if(z.damagePlayer !== -1 && z.damage.length > 0 && (2 > z.damageHand.length || (5 > z.damageHand.length && z.playerLocations[z.damagePlayer] !==
				"Basestar Bridge" && z.players[z.damagePlayer] !== "Athena"))) {
			if(z.damagePlayer === me && (z.turn === me || !z.pegasus || z.vAltDamage || z.pegasusDestroyed)) {
				options.push("Draw a Galactica damage token to hand");
			} else if(z.turn === me) {
				options.push("Deal a Galactica damage token to the Cylon");
			}
		}
		if(z.damagePlayer !== -1 && z.turn === me && z.pegasus && !z.pegasusDestroyed && !z.vAltDamage && z.pegasusDamage.length > 0 && (2 > z.damageHand
				.length || (5 > z.damageHand.length && z.playerLocations[z.damagePlayer] !== "Basestar Bridge" && z.players[z.damagePlayer] !== "Athena"))) {
			if(z.damagePlayer === me) {
				options.push("Draw a Pegasus damage token to hand");
			} else {
				options.push("Deal a Pegasus damage token to the Cylon");
			}
		}
		if(myPlayer === "Tom" || z.assist === "Tom") {
			if(z.necessarySteps.length > 0) {
				options.push("Resolve Necessary Steps");
			} else if(z.abusePower.length === 4) {
				if(!mutinyPlayable(z.abusePower[0]) && !mutinyPlayable(z.abusePower[1]) && !mutinyPlayable(z.abusePower[2]) && !mutinyPlayable(z.abusePower[
					3])) {
					options.push("Reveal that all your Abuse Power (OPG) Mutinies are unplayable, then bottom them.");
				} else {
					options.push("Play a Mutiny from Abuse Power (OPG)");
				}
			} else if(z.abusePower.length > 0) {
				options.push("Bottom the remaining Mutinies from Abuse Power (OPG)");
			}
		}
		if(z.daybreak && (z.mutinies[me].length === 3 || (z.mutinies[me].length === 2 && me !== z.theMutineer)) && !hasOption(me, "Discard a Mutiny card")) {
			options.push("Discard a Mutiny card");
		}
		if(z.jumpTrack === 5 && !z.galacticaReturned) {
			if(((characterPresent("Karl") && z.miracles[getPlayerNum("Karl")] === 1) || (z.assist === "Karl" && z.assistMiracle === 1) || actsOfFaith(
				"Karl")) && !z.theFarm && (z.vBrutality || z.fuel > 0) && z.noOneGetsLeftBehindPause) {
				boldAlert("A pause has been requested for Karl's No One Gets Left Behind ability; please wait for his input before proceeding.");
				z.noOneGetsLeftBehindPause = false;
			}
			if(((myPlayer === "Karl" && z.miracles[me] === 1) || (z.assist === "Karl" && z.assistMiracle === 1) || (myPlayer === "Gaius" && actsOfFaith(
					"Karl"))) && !z.theFarm && (z.vBrutality || z.fuel > 0)) {
				options.push("No One Gets Left Behind (OPG)");
			}
			if(z.blindJump) {
				options.push("[Blind Jump] Reveal the top Destination");
			} else if((missionSpecialist() === "NONE" && z.admiral === me) || myPlayer === missionSpecialist()) {
				options.push("Choose a Destination");
			}
		}
		if(((characterPresent("Simon") && z.miracles[getPlayerNum("Simon")] === 1 && (!z.theFarm || z.revealedCylons[getPlayerNum("Simon")] === 1)) ||
				actsOfFaith("Simon")) && z.revealedCylons[z.turn] === 0 && (z.finishedCrisis || z.playerLocations[z.turn] === "Brig") && z.modificationsPause) {
			/* TODO: z.finishedCrisis should occur only after any die rolls have been resolved. */
			boldAlert("A pause has been requested for Simon's Modifications ability; please wait for Simon before proceeding.");
			z.modificationsPause = false;
		}
		if(z.destination === "New Caprica" && z.distance >= 7 && !z.galacticaAway && !z.galacticaReturned) {
			options.push("Set up the New Caprica Phase");
		}
		if(z.preCrossroads && z.cylonAllyQueue.length > 0 && z.revealedCylons[me] === 1 && (z.benevolent[me] + z.antagonistic[me] > 0)) {
			options.push("Place a Trauma token on the newly-revealed Ally");
		}
		if(z.preCrossroads && z.midCrossroads && me === z.crossroadsPlayer && z.crossroadsTrauma[me] === true) {
			options.push("Choose the Benevolent (top) option on your Crossroads card");
			options.push("Choose the Antagonistic (bottom) option on your Crossroads card");
		}
		if(z.preCrossroads && z.lateCrossroads && me === z.president) {
			options.push("Box a Human");
		}
		if(z.preCrossroads && z.midCrossroads && !z.lateCrossroads && z.humanExecuted === -1) {
			options.push("Move on from this Crossroads card");
		} 
		if((z.pegasus || z.daybreak || z.vHandoff) && (7 > z.distance) && z.revealedCylons[me] === 1 && !isCylonLeader(myPlayer) && (z.loyaltyHands[me].length >
				1 || (me !== z.theSympatheticCylon && z.loyaltyHands[me].length === 1))) {
			options.push("Pass your remaining Loyalty cards to a Human of your choice");
		}
		if(z.revealedCylons[me] === 1 && me === z.theMutineer) {
			options.push("Give the Mutineer card to a Human player");
		}
		if(z.revealedCylons[me] === 1 && !z.sympathizer && me === z.theSympathizer) {
			options.push("Give the Sympathizer card to a Human player");
		}
		if(z.mutineer && z.theMutineer === -1 && z.sleeper && z.turn === me) {
			options.push("Choose a Human player to draw an additional Loyalty");
		}
		if(z.distance >= 4 && !z.sleeper) {
			/* TODO: don't allow this if there are still choices remaining from the jump... */
			options.push("Trigger Sleeper Phase");
		}
		if(((z.distance >= 8 && z.destination === "Ionian Nebula") || (z.distance >= 10 && z.destination === "Ionian Earth")) && !z.ionianBattle) {
			options.push("Set up the Battle of the Ionian Nebula");
		}
		if(((z.distance >= 8 && z.destination === "Kobol") || (z.distance >= 10 && z.destination === "Earth")) && z.vSoloCylonBrutality && z.brutalityPenalty === undefined) {
			options.push("[Brutality] Reveal the Loyalty deck");
		}
		if(((z.distance >= 8 && z.destination === "Kobol") || (z.distance >= 10 && z.destination === "Earth")) && z.v20) {
			options.push("[20 Loyalty Cards] Check the number of Cylons");
		}
		if(z.distance >= 6 && Array.isArray(z.personalGoalsBrutality)){
			options.push("[Brutality] Discard Personal Goals and deal new Loyalty cards");
		}
		if(z.preCrossroads && z.ionianBattle && !z.earlyCrossroads) {
			/* TODO: cannot end turn while this is available */
			options.push("Start the Crossroads Phase");
		} /* TODO: change mind on crossroads card? */
		if(z.earlyCrossroads && z.crossroadsTrauma[me] === false) {
			options.push("Place a Trauma Token on my Crossroads card");
		}
		if(z.dieRollQueue.length > 0 && z.lastDieRoll === null && !z.spToken) {
			let alreadyPlayed = false;
			for(let j = 0; !(j>=z.sps.length); j++){
				if(z.sps[j] !== null && z.sps[j] > 0){
					alreadyPlayed = true;
					break;
				}
			}
			if(!alreadyPlayed){
				options.push("Ask for a Strategic Planning");
			}
		} /*	if(menuPage === "Skill Check" && (z.spToken || z.deToken) && z.revealedCylons[me] === 0 && z.skillCardHands[me].length > 0 ){			options.push("Play a Skill Card");		} */
		if(!z.processedOutcome && (z.skillCheckRevealed || z.autoPass) && skillCheckEffects().length === 0 && !isMission(z.currentCrisis) && !z.reckless && (z
				.thisConsequence === 0 || !consequenceTriggered()) && z.revealedCylons[me] === 0 && (z.autoPass || skillCheckTally(true)[1] == "PASS")) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Change of Plans";
			}
			if(canDE) {
				options.push("Change of Plans");
			}
		}
		if(z.deToken && z.des[me] === null && z.revealedCylons[me] === 0) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Declare Emergency";
			}
			for(let j = 0; !(j >= z.numPlayers) && canDE; j++) {
				if(z.des[j] !== null && z.des[j] > 0) {
					canDE = false;
					if(j !== me) {
						addAlert("If you would like to play a Declare Emergency of your own, rewind to before the previous Declare Emergency was played.");
					}
				}
			}
			if(canDE) {
				options.push("Play a Declare Emergency");
			}
			options.push("Pass on Declare Emergency");
		}
		if(z.dieRollQueue.length > 0 && z.lastDieRoll === null && z.revealedCylons[me] === 0 && (z.players[z.dieRoller] !== "Billy" || z.revealedCylons[
				getPlayerNum("Billy")] === 1 || getPlayerNum("Billy") === z.theSympatheticCylon || z.phase !== 3 || noDrawback(z.dieRoller))) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Strategic Planning";
			}
			for(let j = 0; !(j >= z.numPlayers) && canDE; j++) {
				if(z.sps[j] !== null && z.sps[j] > 0) {
					canDE = false;
					if(j !== me) {
						addAlert("If you would like to play a Strategic Planning of your own, rewind to before the previous Strategic Planning was played.");
					}
				}
			}
			if(canDE) {
				options.push("Play a Strategic Planning");
			}
			if(z.sps[me] === null && z.spToken) {
				options.push("Pass on Strategic Planning");
			}
		}
		if(z.lastDieRoll !== null && canCalc() && z.revealedCylons[me] === 0) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Calculations";
			}
			if((z.lastDieRollModifier + 10) % 2 === 1 && canDE) {
				addAlert("If you would like to play a Calculations of your own, rewind to before the previous Calculations was played.");
			} else if(canDE) {
				options.push("Play a Calculations");
			}
		}
		for(let j = 0; !(j>=z.numPlayers) && z.exodus && z.revealedCylons[me] === 0; j++){
			let DRRE = new RegExp(z.players[j] + " vs\. (Raider|Scar|Heavy Raider|Basestar)","g");
			if(z.dieRollQueue.length > 0 && DRRE.test(z.dieRollQueue[0])){
				for(let k = 0; !(k>=z.skillCardHands[me].length); k++){
					if(cardName(z.skillCardHands[me][k]) === "Best of the Best"){
						if(z.dieRollModifier === 2){
							addAlert("If you want to play Best of the Best, rewind to before the Strategic Planning was played.");
						} else if (z.dieRollModifier === 0){
							options.push("Best of the Best");
						}
						break;
					}
				}
				break;
			}
		}
		if(isInSpace(me) && z.pegasus && z.lastDieRoll === null && (z.activatingSector > 0 || hasOption(z.turn, "Choose which sector of Raiders activates next"))) {
			let mySector = parseInt(z.playerLocations[me].slice(7));
			let anything = Number.isInteger(z.scarActivated) && 2 >= z.scarActivated;
			for(let j = 0; !(j >= z.raiders.length) && !anything; j++) {
				anything = z.raiders[j] === mySector && z.raiderActivated[j] === 0;
			}
			if(anything) {
				for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
					if(cardName(z.skillCardHands[me][j]) === "Run Interference") {
						options.push("Play a Run Interference");
						break;
					}
				}
			}
		}
		if(z.revealedCylons[me] === 1 && !z.sabotage && z.treacheryDiscarded) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Sabotage";
			}
			if(canDE) {
				options.push("Play a Sabotage");
			}
		}
		let DRRE = /(Raider|Scar) vs\. (.*)$/.exec(z.lastDieRoll);
		if(DRRE !== null && DRRE[2] !== "Galactica" && z.revealedCylons[me] === 0) {
			let canDE = false;
			for(let j = 0; !(j >= z.skillCardHands[me].length) && !canDE; j++) {
				canDE = cardName(z.skillCardHands[me][j]) === "Evasive Maneuvers";
			}
			if(canDE) {
				options.push("Play an Evasive Maneuvers");
			}
		}
		if(z.dieRollQueue.length > 0 && z.lastDieRoll === null) {
			options.push("Roll a die for " + z.dieRollQueue[0]);
		}
		if(z.lastDieRoll !== null) {
			options.push("Process the outcome of the die roll");
		}
		options = options.concat(z.crisisOptions[me]);
		if(z.currentSkillCheck !== null) {
			if(checkNotStarted()) {
				if(interruptChoices().length > 0) {
					options.push("Play an interrupt for this skill check");
				}
				if(z.interrupts[me].length === 0 && z.revealedCylons[me] === 0) {
					options.push("Pass on interrupts for this skill check");
				} /* TODO: fix guts / tank bug!! (still present?) */
				if(!z.tank[me]) {
					options.push("TANK this skill check");
				}
				if(me === z.turn && duplicateInterrupts().length !== 0) {
					options.push("Return a duplicate interrupt to hand");
				}
				if(z.skillCheckCards[z.numPlayers].length !== 2 && z.destiny.length >= 1 && !z.guts && duplicateInterrupts().length === 0 && z.revealedCards
					.length === 0) {
					options.push("Play Destiny into skill check");
				} else if(duplicateInterrupts().length === 0){
					options.push("Display the skill check token");
				}
			} /* TODO: check if this is working properly. */ /* TODO: check if you can use this during the skill check */ /* TODO: really check this is cancelled properly by a play in */ /* TODO: check you can do this before the skill check starts... */
			if(!z.skillCheckRevealed && (!(z.contributingPlayer >= (me - z.turn - 1 + z.numPlayers) % z.numPlayers) || (z.contributingPlayer === 0 && (z.turn + 1) % z.numPlayers ===
					me))) {
				if(z.tank[me]) {
					options.push("Cancel your TANK order");
				} else if(!options.includes("TANK this skill check")) {
					options.push("TANK this skill check");
				}
			} else if(z.tank[me] && !z.skillCheckRevealed){
				let contributingMe = (me - z.turn - 1 + z.numPlayers);
				let good = true;
				for(let j = z.contributingPlayer - 1; j > contributingMe; j--){
					if(!autoPass(j)){
						good = false;
					}
				}
				if(good){
					options.push("Cancel your TANK order");
				}
				
			}
			if((z.skillCheckCards[z.numPlayers].length === 2 || (z.guts && duplicateInterrupts().length === 0)) && canIContribute() && !solo && z
				.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && ((myPlayer === "Cally" && myLocation !== "Brig" && myLocation !== "Detention" && z
					.skillCheckCards[me].length === 1 && !solo) || (z.players[me] === "Lee" && z.vBrutality && versionAtLeast([2, 0, 1]) && !versionAtLeast([2,1,13])) && !solo && z
					.skillCheckCards[me].length === 0 && z.skillCardHands[me].length > 0 && !Number.isInteger(z.currentSkillCheck))) {
				options.push("Play a card into the skill check (MANDATORY)");
			} else if((z.skillCheckCards[z.numPlayers].length === 2 || (z.guts && duplicateInterrupts().length === 0)) && canIContribute()) {
				options.push("Play a card into the skill check");
			} /* RULES: Cally's drawback in detention? */
			if((z.skillCheckCards[z.numPlayers].length === 2 || (z.guts && duplicateInterrupts().length === 0)) && canIContribute() && z.skillCheckCards[me]
				.length === 0 && (!z.vBrutality || !versionAtLeast([2, 0, 1]) || versionAtLeast([2,1,13]) || z.players[me] !== "Lee" || z.revealedCylons[me] === 1 || me === z
					.theSympatheticCylon || z.skillCardHands[me].length === 0 || Number.isInteger(z.currentSkillCheck) || solo)) {
				options.push("Pass on the skill check");
			}
			if(z.skillCheckCards[me].length > 0 && !z.investigativeCommittee && z.contributionLabels[me] === "") {
				options.push("Specify strength of your contribution to the skill check");
			}
			if(me === z.president && canUseProbation()) {
				options.push("Trigger Probation");
			}
			if(z.contributingPlayer === z.numPlayers && !z.skillCheckRevealed) {
				if(((((myPlayer === "Chief" && !z.vBrutality) || (myPlayer === "Tigh" && z.vBrutality)) && z.miracles[me] === 1) || (((z.assist === "Chief" && 
						!z.vBrutality) || (z.assist === "Tigh" && z.vBrutality)) && z.assistMiracle === 1) || (myPlayer === "Gaius" && actsOfFaith("Tigh"))) && 
					!isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck) && !z.theFarm) {
					options.push("Blind Devotion (OPG)");
				}
				options.push("Reveal cards from skill check");
			}
			if(((myPlayer === "Cottle" && z.miracles[me] === 1) || (myPlayer === "Gaius" && actsOfFaith("Cottle"))) && z.vBrutality && !z.theFarm && !isMission(z.currentSkillCheck) && 
			   !isSuperCrisis(z.currentSkillCheck)) {
				let can = false;
				for(let j = 0; !(j >= z.numPlayers) && !can; j++) {
					can = (j !== me && z.skillCheckCards[j].length > 0);
				}
				options.push("Quarantine (OPG)");
			}
			if((!isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck)) && 
				((myPlayer === "Adama" && z.processedOutcome && z.miracles[me] === 1 && !z.theFarm && !z.installUpgrades) || 
			    (z.assist === "Adama" && z.processedOutcome && z.assistMiracle === 1 && !z.theFarm && !z.installUpgrades) || 
				(myPlayer === "Gaius" && actsOfFaith("Adama") && !z.installUpgrades))) {
				options.push("Command Authority (OPG)");
			}
			if(myPlayer === "Adama" && z.processedOutcome && z.miracles[getPlayerNum("Adama")] === 1 && !z.theFarm && z.installUpgrades) {
				options.push("Process Install Upgrades");
			}
			if(((myPlayer === "Six" && z.miracles[me] === 1 && (!z.theFarm || z.revealedCylons[me] === 1))) && z.skillCheckRevealed && 
			   !isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck)) {
				options.push("Human Delusion (OPG)");
			}
			if(z.turn === me && myPlayer === "Cally" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && z.revealedCards.length > 0 && 
			   !z.quickFix && !z.processedOutcome && !isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck)) {
				options.push("Use Quick Fix");
			}
			if(skillCheckEffects().length > 0 && (z.turn === me || normalSkillCheckEffects())) {
				options.push("Activate Skill Check Effects");
			}
			if(skillCheckEffects().length === 0 && z.skillCheckRevealed && z.reckless && z.daybreak) {
				options.push("Resolve the Reckless");
			}
			if(skillCheckEffects().length === 0 && z.skillCheckRevealed && (!z.reckless || !z.daybreak) && z.thisConsequence === 1 && consequenceTriggered()) {
				options.push("Trigger Consequences");
			}
			if(z.autoPass || (!z.processedOutcome && z.skillCheckRevealed && skillCheckEffects().length === 0 && (!z.reckless || !z.daybreak) && (z
					.thisConsequence === 0 || !consequenceTriggered()))) {
				options.push("Process outcome of this skill check");
			}
			if(z.processedOutcome) {
				options.push("Clear skill check");
			}
		}
		if(menuPage === "Default") {
			if(Array.isArray(z.personalGoalsBrutality)){
				if(canRevealAcquirePower()) {
					options.push("Reveal Acquire Power (Personal Goal)");
				}
				if(canRevealDevastation()) {
					options.push("Reveal Devastation (Personal Goal)");
				}
				if(canRevealPoliticalIntrigue()) {
					options.push("Reveal Political Intrigue (Personal Goal)");
				}
				if(canRevealSacrifice()) {
					options.push("Reveal Sacrifice (Personal Goal)");
				}
				if(canRevealSelfDestruction()) {
					options.push("Reveal Self-Destruction (Personal Goal)");
				}
				if(canRevealSelfish()) {
					options.push("Reveal Selfish (Personal Goal)");
				}
				if(canRevealStandAndFight()) {
					options.push("Reveal Stand and Fight (Personal Goal)");
				}
				if(canRevealUseCaution()) {
					options.push("Reveal Use Caution (Personal Goal)");
				}
				if(canRevealInfiltration()) {
					options.push("Reveal Infiltration (Personal Goal)");
				}
			}
			if((z.daybreak || z.vNoAgendas) && isCylonLeader(myPlayer) && hasActuallyRevealableMotive()) {
				options.push("Reveal a Motive");
			}
			if(myPlayer === "Athena" && z.forLove && couldLove()) {
				options.push("For Love");
				options.push("Pass on For Love");
			}
			if(myPlayer === "Helo" && z.turn === me && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && z.lastDieRoll !== null && z.eco) {
				options.push("ECO Officer");
			}
			if(myPlayer === "Seelix" && z.turn === me && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && z.avionicsExpert && z.avionicsExpertAvailable
			   && z.playerLocations[me] === "Hangar Deck"){
				options.push("Avionics Expert");
			}
			if(myPlayer === "Gaeta" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !z.vBrutality && (z.lastDieRoll ===
					"FTL Control (Blue -1)" || z.lastDieRoll === "FTL Control (Blue -3)")) {
				options.push("FTL Operator");
			}
			let DRRE = /^(.*) vs\. Occupation Force \((.*)\)$/.exec(z.lastDieRoll);
			if(DRRE !== null && DRRE[1] === z.players[me] && (z.players[me] !== "Billy" || z.phase !== 3 || me === z.theSympatheticCylon || solo)) {
				let mf = false;
				for(let j = 0; !(j >= z.skillCardHands[me].length) && !mf; j++) {
					mf = cardName(z.skillCardHands[me][j]) === "Maximum Firepower";
				}
				if(mf) {
					options.push("Discard a Maximum Firepower to reroll the attack on the Occupation Force");
				}
			}
			if(myPlayer === "Racetrack" && me === z.dieRoller && !versionAtLeast([2, 1, 3]) && !z.expertRaptorPilot && (z.lastDieRoll === "Launch Scout" || z
					.lastDieRoll === "Scout for Fuel" || z.lastDieRoll === "Tylium Planet" || z.lastDieRoll === "Icy Moon")) {
				options.push("Expert Raptor Pilot");
			}
			let initialDraws = false;
			if(z.turn === 0 && z.round === 1 && z.skillCardDiscards[0].length === 0 && z.skillCardDiscards[1].length === 0 
							&& z.skillCardDiscards[2].length === 0 && z.skillCardDiscards[3].length === 0 && z.skillCardDiscards[4].length === 0 
							&& (z.skillCardDiscards.length === 5 || z.skillCardDiscards[5].length === 0)){
				for(let j = 1; !(j>=z.numPlayers) && !initialDraws; j++){
					if(z.skillCardHands[j].length === 0){
						initialDraws = true;
					}
				}
			}
			if(!initialDraws && myLocation !== "Stranded on Caprica" && myLocation !== "Brig" && myLocation !== "Detention" && ((me === z.turn && z.phase === 1) || (me === z
					.xo1 && !z.razor) || me === z.SoEActor)) {
				if(myPlayer === "D'Anna" && myLocation === "Resurrection Ship" && !hasOption(me, "Move") && !solo) {
					if(z.superCrisisHands[me].length > 0) {
						options.push("[Heretic] Discard a Super Crisis");
					} else if(z.vBrutality && z.skillCardHands[me].length >= 3) {
						options.push("[Heretic] Discard 3 Skill Cards");
					}
				} else if(!hasOption(me, "Move")) {
					options.push("Move");
				}
			}
			if(!initialDraws && me === z.turn && z.phase === 1) {
				if(z.vPersonalGoalsMovement) {
					if(canRevealAcquirePower()) {
						options.push("Reveal Acquire Power (Personal Goal)");
					}
					if(canRevealDevastation()) {
						options.push("Reveal Devastation (Personal Goal)");
					}
					if(canRevealPoliticalIntrigue()) {
						options.push("Reveal Political Intrigue (Personal Goal)");
					}
					if(canRevealSacrifice()) {
						options.push("Reveal Sacrifice (Personal Goal)");
					}
					if(canRevealSelfDestruction()) {
						options.push("Reveal Self-Destruction (Personal Goal)");
					}
					if(canRevealSelfish()) {
						options.push("Reveal Selfish (Personal Goal)");
					}
					if(canRevealStandAndFight()) {
						options.push("Reveal Stand and Fight (Personal Goal)");
					}
					if(canRevealUseCaution()) {
						options.push("Reveal Use Caution (Personal Goal)");
					}
				}
				if(!z.vBrutality && z.players[me] === "Cavil" && z.miracles[me] === 1 && (!z.theFarm || z.revealedCylons[me] === 1)) {
					options.push("Aggressive Tactics (OPG)");
				}
				if(z.players[me] === "Six") {
					options.push("Intimate");
				}
				if(z.players[me] === "Leoben") {
					options.push("Glimpse the Face of God");
				}
				if(z.vBrutality && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon) {
					if(z.players[me] === "Adama" && z.playerLocations[me] !== "Brig" && z.playerLocations[me] !== "Detention" && !versionAtLeast([2, 0, 1])) {
						let xo = false;
						for(let j = 0; !(j >= z.skillCardHands[me].length) && !xo; j++) {
							xo = cardName(z.skillCardHands[me][j]) === "Executive Order";
						}
						if(xo) {
							options.push("Inspirational Leader");
						}
					}
					if(z.players[me] === "Cain" && z.playerLocations[me] !== "Brig" && z.playerLocations[me] !== "Detention" && versionAtLeast([2, 0, 1])) {
						let xo = false;
						for(let j = 0; !(j >= z.skillCardHands[me].length) && !xo; j++) {
							xo = cardName(z.skillCardHands[me][j]) === "Executive Order";
						}
						if(xo) {
							options.push("Feared Leader");
						}
					}
					if(z.players[me] === "Anders") {
						options.push("[Movement] Star Player");
					}
					if(z.players[me] === "Cally" && otherPlayerInLocation(me, z.playerLocations[me]) && z.miracles[me] === 1 && !z.theFarm) {
						options.push("Discharge of a Firearm (OPG)");
					} else if(z.players[me] === "Gaius" && z.miracles[me] >= 2 && !z.theFarm && actsOfFaith("Cally") && otherPlayerInLocation(me, z
							.playerLocations[me])) {
						options.push("Discharge of a Firearm (OPG)");
					}
				}
				if(myPlayer === "Hoshi" && z.skillCardHands[me].length >= 2 && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !solo &&
					canPlayMovementCard() && !z.reluctant) {
					if(z.forLove && !z.vBrutality && z.forLoveCOs[me] === null) {
						options.push("[Reluctant] Choose a Skill Card to discard if Athena does not Love you");
					} else {
						options.push("[Reluctant] Discard a Skill Card");
					}
				}
				if(isInSpace(me) && z.eventHorizon && !z.gravityWell) {
					let fullThrottle = false;
					for(let j = 0; !(j >= z.skillCardHands[me].length) && !fullThrottle; j++) {
						fullThrottle = cardName(z.skillCardHands[me][j]) === "Full Throttle";
					}
					if(fullThrottle) {
						if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
							options.push("[Gravity Well] Choose a Skill Card to discard if Athena does not Love you");
						} else {
							options.push("[Gravity Well] Discard a Skill Card");
						}
					}
				}
				if(canPlayMovementCard() && (z.players[me] !== "Hoshi" || solo || me === z.theSympatheticCylon || z.revealedCylons[me] === 1 || z.reluctant)) {
					options.push("Play a Movement Skill Card");
				}
				options.push("Stay on " + z.playerLocations[me]);
			} else if((me === z.turn && z.phase === 2) || (me === z.turn && z.criticalSituation) || (me === z.xo1) || (me === z.xo2) || (me === z.SoEActor) || (
					z.players[me] === "Apollo" && z.AVPAction) || (z.players[me] === "Cavil" && !z.vBrutality && z.aggressiveTactics > 0) || z
				.emergencyAction || (z.players[me] === "Athena" && z.athenaProblem)) {
				let pre = false;
				if(me === z.turn && z.phase === 2) {
					for(let i = 0; z.preCrossroads && !(i >= z.allies.length) && !z.metAnAlly; i++) {
						if(myLocation === d.allyLocations[z.allies[i ][0]] && z.turn === me) {
							options.push("Meet an Ally on your location");
							pre = true;
							break;
						}
					}
					if(z.preCrossroads && z.metAlly !== null) {
						pre = true;
						options.push("Discard the Ally you just met and draw a new one");
					}
					if(z.preCrossroads && z.newAlly !== null) {
						pre = true;
						options.push("Place a Trauma Token on the new Ally");
					}
					if(hasOption(me, "[Kleptomania] Discard a Skill Card") || hasOption(me,
							"[Kleptomania] Choose a Skill Card to discard if Athena does not Love you") || hasOption(me, "Resolve Kleptomania") || hasOption(me,
							"I'm done with Critical Situation") || hasContext(me, "Move", "Meticulous") || hasOption(me,
							"[Selfish] Draw a replacement Loyalty card") || hasOption(me, "Exfiltrate") || hasOption(me, "Deinfiltrate") || hasOption(me, "Infiltrate Galactica")) {
						pre = true;
					}
				}
				if(me === z.turn && z.phase === 2 && z.players[me] === "Ellen" && otherPlayerInLocation(me, z.playerLocations[me],true) && z.revealedCylons[me] ===
					0 && me !== z.theSympatheticCylon && !z.politicallyAdroit) {
					options.push("Politically Adroit");
				}
				if(!pre) {
					if(myPlayer === "Six" && myLocation === "Cylon Fleet" && z.skillCardHands[me].length > 0 && !hasOption(me, "Activate Cylon Fleet")) {
						options.push("[Conflicted Loyalties] Discard a Skill Card");
					}
					if(z.players[me] === "Roslin" && z.skillCardHands[me].length >= 2 && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !solo &&
						canActivateLocation(me, z.playerLocations[me], true) && !hasOption(me, "[Terminal Illness] Discard another Skill Card") && !hasOption(
							me, "Activate another location") && !hasOption(me, "Activate " + z.playerLocations[me])) {
						options.push("[Terminal Illness] Discard a Skill Card");
					}
					if(canActivateLocation(me, z.playerLocations[me])) {
						options.push("Activate " + z.playerLocations[me]);
					}
					if(z.vBrutality && versionAtLeast([1, 2, 4, 6]) && (z.destination === "Earth" || z.destination === "Ionian Earth") && z.activeMission === null && 
					   (z.playerLocations[me] === "Communications" || z.playerLocations[me] === "Weapons Control" || z.playerLocations[me] === "Command")) {
						options.push("Activate Bridge");
					}
					if(myPlayer === "Hoshi" && z.skillCardHands[me].length >= 2 && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !solo &&
						canPlayActionCard() && !z.reluctant) {
						if(z.forLove && !z.vBrutality && z.forLoveCOs[me] === null) {
							options.push("[Reluctant] Choose a Skill Card to discard if Athena does not Love you");
						} else {
							options.push("[Reluctant] Discard a Skill Card");
						}
					}
					if(canPlayActionCard() && (z.players[me] !== "Hoshi" || solo || me === z.theSympatheticCylon || z.revealedCylons[me] === 1 || z
						.reluctant)) {
						options.push("Play an Action Skill Card");
					}
					if(myPlayer === "Cottle" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon) {
						options.push("Treatment");
					}
					if(myPlayer === "Anders" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon) {
						options.push("Star Player");
					}
					if(myPlayer === "Gaius" && cultLeaderUsable()) {
						options.push("Cult Leader");
					}
					if(myPlayer === "Cavil" && !z.galacticaAway) {
						options.push("Primacy");
					}
					if(myPlayer === "D'Anna" && z.revealedCylons[me] === 0 && !z.vBrutality) {
						options.push("Visions");
					}
					if((z.galacticaAway || z.galacticaReturned) && OFPresent(myLocation) && z.revealedCylons[me] === 0) {
						options.push("Attack Occupation Forces");
					}
					if((z.galacticaAway || z.galacticaReturned) && canDetain(me)) {
						options.push("Detain a Human");
					}
					if(z.daybreak && z.mutinies[me].length === 1 && mutinyPlayable(z.mutinies[me][0])) {
						options.push("Play my Mutiny card: " + d.mutinyNames[z.mutinies[me][0]]);
					}
					if(z.daybreak && me === z.theMutineer && z.mutinies[me].length === 2) {
						options.push("Play a Mutiny card");
					}
					if(z.CFB && me === z.cag) {
						options.push("Use your CAG title to activate an unmanned Viper then pass the CAG title");
					}
					if(z.CFB && me === z.cag && isInSpace(me) && z.cagTitle) {
						options.push("Use your CAG title to activate an unmanned viper");
					}
					if(isInSpace(me)) {
						if(z.eventHorizon && !z.gravityWell) {
							if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
								options.push("[Gravity Well] Choose a Skill Card to discard if Athena does not Love you");
							} else {
								options.push("[Gravity Well] Discard a Skill Card");
							}
						}
						if(!z.eventHorizon || z.gravityWell) {
							options.push("Move in Space");
							if(z.dieRollQueue.length === 0) {
								if(canAttackRaider(true) && !hasOption(me, "Attack a Raider")) {
									options.push("Attack a Raider");
								}
								if(canAttackScar(true) && !hasOption(me, "Attack Scar")) {
									options.push("Attack Scar");
								}
								if(canAttackHeavy(true) && !hasOption(me, "Attack a Heavy Raider")) {
									options.push("Attack a Heavy Raider");
								}
								if(canAttackBasestar(true) && !hasOption(me, "Attack a Basestar")) {
									options.push("Attack a Basestar");
								}
							}
							if(z.CFB && canEscort(true)) {
								options.push("Reshuffle a Civilian as an Action");
							}
						}
					}
					if(((z.players[me] === "Billy" && me !== z.president && z.billyHand.length > 0) || (me === z.president && z.quorumHand.length > 0)) && !
						hasOption(me, "Play a Quorum Card")) {
						options.push("Play a Quorum Card as an Action");
					}
					if(me === z.president && !hasOption(me, "Draw a Quorum Card")) {
						options.push("Draw a Quorum Card using the President Title");
					}
					if(cylonCards(me) > 0 && z.revealedCylons[me] === 0 && (myPlayer !== "Gaius" || myLocation === "Brig" || myLocation === "Detention" || solo) && z.cylonExecuted !== me &&
						me !== z.theSympatheticCylon) {
						options.push("Reveal as a Cylon");
					}
					if(!Array.isArray(z.personalGoalsBrutality)){
						if(canRevealAcquirePower()) {
							options.push("Reveal Acquire Power (Personal Goal)");
						}
						if(canRevealDevastation()) {
							options.push("Reveal Devastation (Personal Goal)");
						}
						if(canRevealPoliticalIntrigue()) {
							options.push("Reveal Political Intrigue (Personal Goal)");
						}
						if(canRevealSacrifice()) {
							options.push("Reveal Sacrifice (Personal Goal)");
						}
						if(canRevealSelfDestruction()) {
							options.push("Reveal Self-Destruction (Personal Goal)");
						}
						if(canRevealSelfish()) {
							options.push("Reveal Selfish (Personal Goal)");
						}
						if(canRevealStandAndFight()) {
							options.push("Reveal Stand and Fight (Personal Goal)");
						}
						if(canRevealUseCaution()) {
							options.push("Reveal Use Caution (Personal Goal)");
						}
					}
					if((isCylonLeader(myPlayer) || me === z.theSympatheticCylon) && z.revealedCylons[me] === 0) {
						options.push("Exfiltrate");
						if(z.players[me] === "Doral" && z.miracles[me] === 1) {
							options.push("Exfiltrate and use Meticulous (OPG)");
						}
					}
					if(z.admiral === me && z.nukes > 0 && ((z.basestars.length > 0 && z.basestars[0][0] !== 0) || (z.basestars.length > 1 &&
							z.basestars[1][0] !== 0) || z.CFB)) {
						options.push("Use a Nuke");
					}
					if(z.admiral === me && z.galacticaReturned) {
						options.push("Jump the Fleet away from New Caprica");
					}
					if(myPlayer === "Gaius" && z.miracles[me] === 3 && !z.theFarm) {
						options.push("Broadcast (OPG)");
					} else if(z.miracles[me] === 1 && z.revealedCylons[me] === 0 && !z.theFarm && me !== z.theSympatheticCylon) {
						if(myPlayer === "Apollo") {
							options.push("CAG (OPG)");
						} else if(myPlayer === "Baltar" && !z.detectorSabotage && !z.noCylonDetector) {
							options.push("Cylon Detector (OPG)");
						} else if(myPlayer === "Roslin" && z.quorumDeck.length + z.quorumDiscards.length > 0) {
							options.push("Skilled Politician (OPG)");
						} else if(myPlayer === "Tigh" && !z.vBrutality) {
							options.push("Declare Martial Law (OPG)");
						} else if(myPlayer === "Chief" && z.vBrutality && z.scout === -1) {
							let numDamaged = 0;
							for(let j = 0; !(j >= z.vipersII.length); j++) {
								if(z.vipersII[j] === -1) {
									numDamaged++;
								}
							}
							for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
								if(z.vipersVII[j] === -1) {
									numDamaged++;
								}
							}
							if(numDamaged >= 2) {
								options.push("The Blackbird (OPG)");
							}
						} else if(myPlayer === "Zarek" && z.population > 0 && !z.vBrutality) {
							options.push("Unconventional Tactics (OPG)");
						} else if(myPlayer === "Cain" && !(z.distance > 6) && z.destroyedCivilians.length !== 11 && z.destroyedCivilians.length !== 12 && !z
							.vBrutality) {
							options.push("Blind Jump (OPG)");
						} else if(myPlayer === "Cain" && z.vBrutality) {
							let num = 0;
							for(let j = 0; !(j >= z.numPlayers); j++) {
								if(j !== me) {
									num += z.mutinies[j].length;
								}
							}
							if(num > 0) {
								options.push("Stamp Authority (OPG)");
							}
						} else if(myPlayer === "Kat" && inSpace(myLocation)) {
							options.push("Sacrifice (OPG)");
						} else if(myPlayer === "Cally" && otherPlayerInLocation(me, z.playerLocations[me]) && !z.vBrutality) {
							options.push("Discharge of a Firearm (OPG)");
						} else if(myPlayer === "Gaeta") {
							options.push("Coup (OPG)");
						} else if(myPlayer === "Tory") {
							options.push("Influential (OPG)");
						} else if(myPlayer === "Cottle" && !z.vBrutality) {
							options.push("Quarantine (OPG)");
						} else if(myPlayer === "Hoshi" && myLocation !== "Brig" && myLocation !== "Detention" && (z.turn === me || !z.vBrutality)) {
							options.push("Organized (OPG)");
						} else if(myPlayer === "Romo" && ((isOnNewCaprica(me) && someoneInDetention()) || (!isOnNewCaprica(me) && someoneInBrig()))) {
							options.push("Attorney (OPG)");
						} else if(myPlayer === "Tom" && z.necessarySteps.length === 0) {
							options.push("Abuse Power (OPG)");
						} else if(myPlayer === "Racetrack" && z.scout === -1) {
							options.push("Critical Discovery (OPG)");
						} else if(myPlayer === "Shaw" && versionAtLeast([2,1,14]) && availableCivilians() > 0){
							options.push("Critical Mission (OPG)");
						}
					}
					if(z.assist === "Gaius" && z.assistMiracle === 3) {
						options.push("Broadcast (OPG)");
					}
					if(z.assistMiracle === 1 && !z.theFarm) {
						if(z.assist === "Apollo") {
							options.push("CAG (OPG)");
						} else if(z.assist === "Baltar" && !z.detectorSabotage && !z.noCylonDetector) {
							options.push("Cylon Detector (OPG)");
						} else if(z.assist === "Roslin" && z.quorumDeck.length + z.quorumDiscards.length > 0) {
							options.push("Skilled Politician (OPG)");
						} else if(z.assist === "Tigh" && !z.vBrutality) {
							options.push("Declare Martial Law (OPG)");
						} else if(z.assist === "Chief" && z.vBrutality && z.scout === -1) {
							let numDamaged = 0;
							for(let j = 0; !(j >= z.vipersII.length); j++) {
								if(z.vipersII[j] === -1) {
									numDamaged++;
								}
							}
							for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
								if(z.vipersVII[j] === -1) {
									numDamaged++;
								}
							}
							if(numDamaged >= 2) {
								options.push("The Blackbird (OPG)");
							}
						} else if(z.assist === "Zarek" && z.population > 0 && !z.vBrutality) {
							options.push("Unconventional Tactics (OPG)");
						} else if(z.assist === "Cain" && !(z.distance > 6) && z.destroyedCivilians.length !== 11 && z.destroyedCivilians.length !== 12 && !z
							.vBrutality) {
							options.push("Blind Jump (OPG)");
						} else if(z.assist === "Kat" && inSpace(myLocation)) {
							options.push("Sacrifice (OPG)");
						} else if(z.assist === "Cally" && otherPlayerInLocation(me, z.playerLocations[me]) && (me === z.turn || !z.vBrutality)) {
							options.push("Discharge of a Firearm (OPG)");
						} else if(z.assist === "Gaeta") {
							options.push("Coup (OPG)");
						} else if(z.assist === "Tory") {
							options.push("Influential (OPG)");
						} else if(z.assist === "Cottle" && !z.vBrutality) {
							options.push("Quarantine (OPG)");
						} else if(z.assist === "Hoshi" && myLocation !== "Brig" && myLocation !== "Detention" && (z.turn === me || !z.vBrutality)) {
							options.push("Organized (OPG)");
						} else if(z.assist === "Romo" && ((isOnNewCaprica(me) && someoneInDetention()) || (!isOnNewCaprica(me) && someoneInBrig()))) {
							options.push("Attorney (OPG)");
						} else if(z.assist === "Tom") {
							options.push("Abuse Power (OPG)");
						} else if(z.assist === "Racetrack" && z.scout === -1) {
							options.push("Critical Discovery (OPG)");
						} else if(z.assist === "Shaw" && versionAtLeast([2,1,14])&& availableCivilians() > 0){
							options.push("Critical Mission (OPG)");
						}
					}
					if(z.players[me] === "Gaius" && z.vBrutality && z.miracles[me] >= 2 && !z.theFarm) {
						if(actsOfFaith("Apollo")) {
							options.push("CAG (OPG)");
						} else if(actsOfFaith("Roslin") && z.quorumDeck.length + z.quorumDiscards.length > 0) {
							options.push("Skilled Politician (OPG)");
						} else if(actsOfFaith("Chief") && z.vBrutality && z.scout === -1) {
							let numDamaged = 0;
							for(let j = 0; !(j >= z.vipersII.length); j++) {
								if(z.vipersII[j] === -1) {
									numDamaged++;
								}
							}
							for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
								if(z.vipersVII[j] === -1) {
									numDamaged++;
								}
							}
							if(numDamaged >= 2) {
								options.push("The Blackbird (OPG)");
							}
						} else if(actsOfFaith("Gaeta")) {
							options.push("Coup (OPG)");
						} else if(actsOfFaith("Tory")) {
							options.push("Influential (OPG)");
						} else if(actsOfFaith("Hoshi") && myLocation !== "Brig" && myLocation !== "Detention" && z.turn === me) {
							options.push("Organized (OPG)");
						} else if(actsOfFaith("Romo") && ((isOnNewCaprica(me) && someoneInDetention()) || (!isOnNewCaprica(me) && someoneInBrig()))) {
							options.push("Attorney (OPG)");
						} else if(actsOfFaith("Tom")) {
							options.push("Abuse Power (OPG)");
						} else if(actsOfFaith("Racetrack") && z.scout === -1) {
							options.push("Critical Discovery (OPG)");
						} else if(actsOfFaith("Cain")) {
							let num = 0;
							for(let j = 0; !(j >= z.numPlayers); j++) {
								if(j !== me) {
									num += z.mutinies[j].length;
								}
							}
							if(num > 0) {
								options.push("Stamp Authority (OPG)");
							}
						} else if(actsOfFaith("Shaw") && versionAtLeast([2,1,14])&& availableCivilians() > 0){
							options.push("Critical Mission (OPG)");
						}
					}
					if(z.miracles[me] === 1 && (!z.theFarm || z.revealedCylons[me] === 1)) {
						if(myPlayer === "Athena") {
							options.push("Resolute (OPG)");
						} else if(myPlayer === "D'Anna") {
							options.push("Don't Trust Anyone (OPG)");
						} else if(myPlayer === "Cavil" && z.vBrutality) {
							options.push("Aggressive Tactics (OPG)");
						} else if(myPlayer === "Leoben") {
							options.push("Cryptic Message (OPG)");
						}
					}
					options.push("Do Nothing");
				}
			}
			if(z.phase === 3 && z.players[me] === "Kat" && (z.turn === me || z.vBrutality) && z.skillCardHands[me].length > 0 && z.revealedCylons[me] === 0 &&
				me !== z.theSympatheticCylon && z.dieRollQueue.length > 0 && (!z.vBrutality || (z.dieRollQueue[0] !== "FTL Control (Blue -3)" && z.dieRollQueue[
					0] !== "FTL Control (Blue -1)")) && z.dieRoller === me) {
				options.push("Hotshot");
			} /* TODO: don't let you draw the crisis if someone needs to pick a character */
			if(!initialDraws && !canAnyoneAction() && z.phase === 3 && (z.playerLocations[z.turn] !== "Brig" || z.numPlayers + z.boxedPlayers.length === 1) && z.revealedCylons[z
					.turn] !== 1 && z.currentCrisis === null && z.currentSkillCheck === null && z.scout === -1 && !z.executedCurrentPlayer && z
				.quorumPeeker === -1 && !z.drawSkills && z.dieRollQueue.length === 0 && z.lastDieRoll === null && (z.jumpTrack !== 5 || z.galacticaReturned) && z.humanExecuted === -1) {
				if(characterPresent("Lee") && hasOption(getPlayerNum("Lee"), "Forward Thinker") && ((z.vBrutality && z.skillCardHands[getPlayerNum("Lee")]
						.length > 0) || (!z.vBrutality && canActivateLocation(getPlayerNum("Lee"), z.playerLocations[getPlayerNum("Lee")])))) {
					if(z.players[me] === "Lee") {
						options.push("Play the top Crisis");
					}
				} else if(z.players[z.turn] === "Roslin" && z.turn !== z.theSympatheticCylon) {
					if(z.players[me] === "Roslin") {
						options.push("Religious Visions");
					}
				} else if(z.expertPilot && (isInSpace(z.turn) || !z.vBrutality || !versionAtLeast([1, 2, 4, 2])) && z.players[z.turn] === "Starbuck" && z
					.turn !== z.theSympatheticCylon) {
					if(me === z.turn) {
						options.push("Expert Pilot");
						options.push("Play the top Crisis");
					}
				} else {
					options.push("Play the top Crisis");
				}
			}
			if(z.miracles[me] === 1 && (!z.theFarm || z.revealedCylons[me] === 1)) {
				if(myPlayer === "Simon" && z.revealedCylons[z.turn] === 0 && (z.finishedCrisis || z.playerLocations[z.turn] === "Brig")) {
					options.push("Modifications (OPG)");
				}
			}
			if(z.miracles[me] === 1 && z.revealedCylons[me] === 0 && !z.theFarm && me !== z.theSympatheticCylon) {
				if(myPlayer === "Starbuck" && z.currentCrisis !== null && z.currentSkillCheck === null && !isSuperCrisis(z.currentCrisis) && !isMission(z
						.currentCrisis) && !z.finishedCrisis && (d.currentPlayerChooses[z.currentCrisis] === 1 || d.admiralChooses[z.currentCrisis] === 1 || d
						.presidentChooses[z.currentCrisis] === 1 || d.cagChooses[z.currentCrisis] === 1 || (d.CAC[z.currentCrisis] === 1 && (z.toDoRaiders || z
							.toDoHeavies || z.toDoBasestars || z.toDoLaunchRaiders)))) {
					options.push("Secret Destiny (OPG)");
				} else if(myPlayer === "Anders" && z.dieRollQueue.length > 0 && (me === z.turn || z.vBrutality)) {
					/* TODO: Brutality CO for Longshot */
					options.push("Longshot (OPG)");
				}
			}
			if(z.assistMiracle === 1 && !z.theFarm) {
				if(z.assist === "Starbuck" && z.currentCrisis !== null && z.currentSkillCheck === null && !isSuperCrisis(z.currentCrisis) && !isMission(z
						.currentCrisis) && !z.finishedCrisis && (d.currentPlayerChooses[z.currentCrisis] === 1 || d.admiralChooses[z.currentCrisis] === 1 || d
						.presidentChooses[z.currentCrisis] === 1 || d.cagChooses[z.currentCrisis] === 1 || (d.CAC[z.currentCrisis] === 1 && (z.toDoRaiders || z
							.toDoHeavies || z.toDoBasestars || z.toDoLaunchRaiders)))) {
					options.push("Secret Destiny (OPG)");
				} else if(z.assist === "Anders" && z.turn === me && z.dieRollQueue.length > 0) {
					options.push("Longshot (OPG)");
				} else if(z.assist === "Hot Dog" && spaceCiviliansList().length > 0) {
					options.push("Escort (OPG)");
				}
			}
			if(z.players[me] === "Gaius" && z.vBrutality && z.miracles[me] >= 2 && !z.theFarm) {
				if(actsOfFaith("Starbuck") && z.currentCrisis !== null && z.currentSkillCheck === null && !isSuperCrisis(z.currentCrisis) && !isMission(z
						.currentCrisis) && !z.finishedCrisis && (d.currentPlayerChooses[z.currentCrisis] === 1 || d.admiralChooses[z.currentCrisis] === 1 || d
						.presidentChooses[z.currentCrisis] === 1 || d.cagChooses[z.currentCrisis] === 1 || (d.CAC[z.currentCrisis] === 1 && (z.toDoRaiders || z
							.toDoHeavies || z.toDoBasestars || z.toDoLaunchRaiders)))) {
					options.push("Secret Destiny (OPG)");
				} else if(actsOfFaith("Anders") && z.dieRollQueue.length > 0) {
					options.push("Longshot (OPG)");
				} else if(actsOfFaith("Hot Dog") && spaceCiviliansList().length > 0) {
					options.push("Escort (OPG)");
				}
			}
			if(z.toDoRaiders) {
				options.push("Activate Raiders");
			}
			if(z.toDoHeavies) {
				options.push("Activate Heavy Raiders");
			}
			if(z.toDoLaunchRaiders) {
				options.push("Launch Raiders");
			} 
			if(z.toDoBasestars) {
				options.push("Activate Basestars");
			}
			if((z.galacticaAway || z.galacticaReturned) && z.toDoOFs && !z.toDoRaiders && !z.toDoHeavies && !z.toDoBasestars && !z.toDoLaunchRaiders) {
				options.push("Activate Occupation Forces");
			}
			if(z.toDoCACSetup && z.currentCrisis !== null) {
				options.push("Setup ships from the Cylon Attack Card");
			}
			if(z.toDoCACSpecial) {
				options.push("Process Special text from the Cylon Attack Card");
			}
			if(z.toDoJumpIcon && !z.galacticaReturned) {
				options.push("Advance the Jump Preparation Track");
			}
			if(z.toDoJumpIcon && z.galacticaReturned && z.turn === me && z.preparedCivilians.length > 0) {
				options.push("Evacuate a Civilian");
			}
			if(z.currentSkillCheck === null && z.currentCrisis !== null && z.finishedCrisis && z.capricaCrisis && !z.toDoJumpIcon && !isSuperCrisis(z
					.currentCrisis) && (z.revealedCylons[z.turn] === 0 || z.players[z.turn] === "Cavil" || z.executedCurrentPlayer)) {
				options.push("Discard this Crisis Card");
			}
			if(z.currentSkillCheck === null && z.currentCrisis !== null && z.finishedCrisis && z.capricaCrisis && isSuperCrisis(z.currentCrisis) && (z
					.revealedCylons[z.turn] === 0 || z.players[z.turn] === "Cavil" || z.executedCurrentPlayer)) {
				options.push("Discard this Super Crisis Card");
			} /* TODO: allow end turn only in late phase (execution a concern, though, as XO/SoE may need to wrap up. */
			if(z.currentSkillCheck === null && (z.executedCurrentPlayer || (!z.toDoJumpIcon && !z.toDoRaiders && !z.toDoHeavies && !z.toDoLaunchRaiders && !z
					.toDoBasestars && !z.toDoCACSetup && !z.toDoCACSpecial && !z.toDoOFs && (z.finishedCrisis || (z.phase === 3 && ((z.revealedCylons[z
						.turn] === 1 && z.currentCrisis === null)|| (z.playerLocations[z.turn] === "Brig" && z.numPlayers + z.boxedPlayers.length > 1))))))) {
				/* RULES: With Exodus not in play, can Boomer use Recon when she returns after an execution on her own turn? */
				if((z.friendsAdmiral || z.friendsCAG || z.friendsPresident) && z.players[me] === "Zarek" && z.miracles[me] === 1 && !z.theFarm){
					options.push("Friends in Low Places (OPG)");
				}
				if((z.cultAdmiral || z.cultCAG || z.cultPresident) && actsOfFaith("Zarek") && z.players[me] === "Gaius"){
					options.push("Friends in Low Places (OPG)");
				}
				if(z.klepto) {
					options.push("Send Romo to the Brig from his Kleptomania drawback");
				}
				if(myPlayer === "Boomer" && me === z.turn && z.revealedCylons[me] === 0 && !z.executedCurrentPlayer && z.scout === -1 && !z.recon) {
					options.push("Recon (OPT)");
				}
				if(myPlayer === "Billy" && me === z.turn && me !== z.president && z.revealedCylons[me] === 0 && z.billyHand.length > 0 && z.presidentialAide) {
					options.push("Presidential Aide (OPT)");
				}
				if(((me === z.president && z.quorumHand.length > z.quorumHandLimit) || (z.players[me] === "Billy" && me !== z.president && z.billyHand.length >
						2)) && !hasOption(me, "Discard a Quorum Card")) {
					options.push("Discard a Quorum Card");
				}
				if((z.skillCardHands[me].length > 10 || (myPlayer === "Chief" && z.revealedCylons[me] === 0 && z.skillCardHands[me].length > 8 && !solo)) && !
					hasOption(me, "Discard a Skill Card") && (myPlayer !== "Apollo" || z.revealedCylons[me] === 1 || solo)) {
					options.push("Discard a Skill Card");
				}
				if(z.skillCardHands[me].length > 10 && myPlayer === "Apollo" && z.revealedCylons[me] === 0 && !solo) {
					options.push("Discard a random Skill Card");
				} 
				if((z.players[z.turn] !== "Boomer" || myPlayer === "Boomer" || z.revealedCylons[z.turn] === 1 || z.turn === z.theSympatheticCylon || z.recon) &&
					(z.players[z.turn] !== "Lee" || z.revealedCylons[z.turn] === 1 || !z.xo || me === z.turn || z.playerLocations[z.turn] !== "Brig" || (z
						.vBrutality && versionAtLeast([2, 0, 1]))) && (z.players[z.turn] !== "Billy" || z.turn === z.president || (me === z.turn && 3 > z
						.billyHand.length) || z.billyHand.length === 0) && !z.drawSkills && !z.klepto && z.humanExecuted === -1 && 
						(!z.preCrossroads || (!z.midCrossroads && !z.earlyCrossroads && !z.lateCrossroads))) {
					options.push("End Turn");
				}
			}
			if(z.turn === me && z.currentCrisis !== null && z.currentSkillCheck === null && d.currentPlayerChooses[z.currentCrisis] === 1 && !z
				.finishedCrisis && !hasOption(me, "Process the OR on this crisis") && !hasOption(me, "Process Choose a Different Path")) {
				options.push("Choose the Skill Check on this crisis");
				options.push("Choose the OR on this crisis");
				if(((myPlayer === "Lee" && z.miracles[me] === 1) || (z.assist === "Lee" && z.assistMiracle === 1) || (myPlayer === "Gaius" && actsOfFaith(
						"Lee"))) && !z.theFarm && !isSuperCrisis(z.currentCrisis)) {
					options.push("Choose a Different Path (OPG)");
				}
			}
			if(z.currentCrisis !== null && !z.finishedCrisis && ((z.admiral === me && d.admiralChooses[z.currentCrisis] === 1) || (z.president === me && d
					.presidentChooses[z.currentCrisis] === 1) || (z.cag === me && d.cagChooses[z.currentCrisis] === 1))) {
				if(!hasOption(me, "Process the Bottom option on this crisis") && !hasOption(me, "Process the Top option on this crisis") && !hasOption(me,
						"Process Choose a Different Path")) {
					options.push("Choose the top option on this crisis");
					options.push("Choose the bottom option on this crisis");
					if(((myPlayer === "Lee" && z.miracles[me] === 1) || (z.assist === "Lee" && z.assistMiracle === 1) || (myPlayer === "Gaius" && actsOfFaith(
							"Lee"))) && !z.theFarm && !isSuperCrisis(z.currentCrisis)) {
						options.push("Choose a Different Path (OPG)");
					}
				}
			}
			options.push("[Settings and Conditional Orders]");
		} else if(menuPage === "[Settings and Conditional Orders]") {
			/* TODO: 600px wide image above textGameState */
			options.push("View the top card of each discard pile");
			if(z.destinationDiscards.length > 0){
				options.push("View visited Destinations");
			}
			for(let j = 0; !(j>=z.loyaltyDiscards.length); j++){
				if(z.loyaltyDiscards[j].length > 0){
					options.push("View discarded Loyalty cards");
					break;
				}
			}
			options.push("Submit Conditional Order for a rare action");
			if(z.secretMessages[me].length > 0) {
				options.push("Delete your secret messages");
			}
			options.push("Print your hand report in a spoiler (and quit)");
			options.push("Change your default banner");
			options.push("Change dialog display style");
			options.push("Check for BYC updates");
			options.push("[I still can't find what I'm looking for]");
		} else if(menuPage === "[Manual Viper Activation]") {
			for(let j = 0; !(j >= options.length); j++) {
				if(options[j] === "Activate an unmanned Viper") {
					options.splice(j, 1);
					j--;
				}
			}
			if(z.eventHorizon && !z.gravityWell) {
				if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
					options.push("[Gravity Well] Choose a Skill Card to discard if Athena does not Love you");
				} else {
					options.push("[Gravity Well] Discard a Skill Card");
				}
			}
			if(!z.eventHorizon || z.gravityWell) {
				/* TODO: trial by fire should only let you activate the AR */
				if(!z.galacticaAway && vipersIIReserves() > 0) {
					options.push("Launch a Viper Mk II in Sector 5");
					options.push("Launch a Viper Mk II in Sector 6");
				}
				if(!z.galacticaAway && vipersVIIReserves() > 0) {
					options.push("Launch a Viper Mk VII in Sector 5");
					options.push("Launch a Viper Mk VII in Sector 6");
				}
				if(!z.galacticaAway && assaultRaptorsReserves() > 0) {
					options.push("Launch an Assault Raptor in Sector 5");
					options.push("Launch an Assault Raptor in Sector 6");
				}
				if(!z.galacticaAway && isUnmannedInSpace()) {
					options.push("Move an unmanned Viper in space");
				}
				if(z.dieRollQueue.length === 0) {
					if(!z.galacticaAway && canAttackRaider(false)) {
						options.push("Order an attack on a Raider");
					}
					if(!z.galacticaAway && canAttackScar(false)) {
						options.push("Order an attack on Scar");
					}
					if(!z.galacticaAway && canAttackHeavy(false)) {
						options.push("Order an attack on a Heavy Raider");
					}
					if(!z.galacticaAway && canAttackBasestar(false)) {
						options.push("Order an attack on a Basestar");
					}
				}
				if(z.CFB && canEscort(false)) {
					options.push("Reshuffle a Civilian");
				}
			}
		} else if(menuPage === "[I still can't find what I'm looking for]") {
			options.push("Move");
			options.push("Allow players to take actions out of turn this turn");
			options.push("Make all options non-mandatory");
			options.push("Draw 1 Skill Card (any color)");
			if(Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0 && 4 > z.heavyCasualties && (z.players.includes("Apollo") || z.graveyard.includes("Apollo")) ){
				for(let j = 0; !(j>=z.raiders.length); j++){
					if(z.raiders[j] === 6){
						options.push("[Besieged] Increase the number of Raiders that are about to attack");
					}
				}
			}
			if(z.daybreak) {
				options.push("Deal a Mutiny card");
			}
			if(z.forLove && z.players[me] !== "Athena") {
				options.push("Choose a Skill Card to discard if Athena does not Love you");
			}
			if(z.players[me] === "Athena" && z.forLove) {
				options.push("For Love");
			}
			if((z.daybreak || z.vNoAgendas) && isCylonLeader(myPlayer) && hasRevealableMotive()) {
				options.push("Reveal a Motive");
			}
			if(z.revealedCylons[me] === 1 && z.superCrisisDeck.length > 0) {
				options.push("Draw a Super Crisis");
			}
			if(z.preCrossroads) {
				options.push("Deal Trauma Tokens");
				if(z.antagonistic[me] + z.benevolent[me] > 0) {
					options.push("Discard a Trauma Token");
				}
			}
			if(z.scout === -1) {
				options.push("Scout the Crisis Deck");
				options.push("Scout the Destination Deck");
			}
			if(z.skillCardHands[me].length > 0) {
				options.push("Discard a Skill Card");
				options.push("Discard a random Skill Card");
			}
			if(!z.galacticaAway) {
				options.push("Move a player to the Brig");
				options.push("Move a player to Sickbay");
			}
			if(someoneInBrig()) {
				options.push("Move a player out of the Brig");
			}
			if(z.galacticaAway || z.galacticaReturned) {
				options.push("Move a player to Detention");
				options.push("Move a player to the Medical Center");
			}
			if(someoneInDetention()) {
				options.push("Move a player out of Detention");
			}
			if(isPilot(me) && onGalactica(z.playerLocations[me]) && z.playerLocations[me] !== "Brig") {
				if(vipersIIReserves() > 0) {
					options.push("Launch in a Viper Mk II in Sector 5");
					options.push("Launch in a Viper Mk II in Sector 6");
				}
				if(z.CFB && vipersVIIReserves() > 0) {
					options.push("Launch in a Viper Mk VII in Sector 5");
					options.push("Launch in a Viper Mk VII in Sector 6");
				}
				if(z.daybreak && assaultRaptorsReserves() > 0) {
					options.push("Launch in an Assault Raptor in Sector 5");
					options.push("Launch in an Assault Raptor in Sector 6");
				}
			} /*RULES: can admiral title be passed if everyone is in the brig? */
			options.push("Move the Admiral title");
			options.push("Move the President title");
			if(z.CFB) {
				options.push("Move the CAG title");
			}
			if(z.miracles[z.numPlayers] === 1 && myPlayer !== "Gaius") {
				if(z.daybreak) {
					options.push("Discard a Miracle Token");
				} else {
					options.push("Mark your OPG ability as having been used");
				}
			}
			options.push("Decrease a resource");
			options.push("Increase a resource");
			if(z.jumpTrack !== 5 && !z.galacticaReturned) {
				options.push("Advance the Jump Preparation Track");
				if(z.jumpTrack !== 0) {
					options.push("Decrease the Jump Preparation Track");
				}
			}
			if(!z.galacticaAway) {
				options.push("Damage Galactica");
			}
			if(!z.galacticaAway && (z.pegasus && !z.pegasusDestroyed && !z.vAltDamage)) {
				options.push("Damage Pegasus");
			}
			if(canRepair() && z.revealedCylons[me] === 0) {
				options.push("Repair a location");
			}
			if(z.raptors !== 0) {
				options.push("Destroy a Raptor");
			}
			if(z.raptors !== 4) {
				options.push("Repair a Raptor");
			}
			for(let j = 0; !(j >= 6) && z.CFB; j++) {
				if(z.spaceCivilians[j].length > 0) {
					options.push("Reshuffle a Civilian");
					break;
				}
			}
			if(!z.galacticaAway && z.civilianPile.length > 0) {
				options.push("Place a Civilian on the board");
				options.push("Draw and destroy a Civilian");
			}
			if((z.galacticaAway || z.galacticaReturned) && z.lockedCivilians.length > 0) {
				options.push("Prepare a Civilian");
			}
			if(z.galacticaReturned && z.preparedCivilians.length > 0) {
				options.push("Evacuate a Civilian");
			}
			if(!z.galacticaAway && damagedVipersII() > 0) {
				options.push("Repair a damaged Viper Mk II");
			}
			if(!z.galacticaAway && damagedVipersVII() > 0) {
				options.push("Repair a damaged Viper Mk VII");
			}
			if(!z.galacticaAway && (d.destinationNames[z.destinationDiscards[z.destinationDiscards.length - 1]] === "Ragnar Anchorage" || (z.preCrossroads && z
					.midCrossroads && !z.lateCrossroads && me === z.crossroadsPlayer && z.crossroadsCards[me] === "Miraculous Return" && z.crossroadsTrauma[
						me] === 1))) {
				if(destroyedVipersII() > 0) {
					options.push("Repair a destroyed Viper Mk II");
				}
				if(destroyedVipersVII() > 0) {
					options.push("Repair a destroyed Viper Mk VII");
				}
				if(destroyedAssaultRaptors() > 0) {
					options.push("Repair a destroyed Assault Raptor");
				}
			}
			if(spaceCiviliansList().length > 0) {
				options.push("Inspect/Move a Civilian in space");
				if(myPlayer === "Dee" || (myPlayer === "Cottle" && !z.vBrutality)) {
					options.push("Inspect all Civilians in space");
				}
			}
			options.push("Change my username");
			if(z.daybreak || z.pegasus) {
				options.push("Shuffle 2 Treachery into Destiny");
			}
			if(z.CFB) {
				options.push("Advance the Pursuit Track");
			} /* RULES: Does Negotiation stop OFs? */
			if((z.galacticaAway || z.galacticaReturned)) {
				options.push("Activate Occupation Forces");
			}
			if((z.galacticaAway || z.galacticaReturned) && OFReserves() !== 4) {
				options.push("Destroy an Occupation Force");
			}
			if((z.galacticaAway || z.galacticaReturned) && OFReserves() !== 0) {
				options.push("Place an Occupation Force on the Occupation Authority");
			}
			if(!z.galacticaAway) {
				if(!z.negotiation) {
					options.push("Activate Basestars");
				}
				if(basestarsAway() > 0) {
					options.push("Place a basestar on the main game board");
				}
				if(z.CFB && basestarReserves() > 0) {
					options.push("Place a basestar on the Cylon Fleet Board");
				}
				if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length === 2 && z.basestars[1][0] > 0)) {
					options.push("Destroy a basestar");
				}
				if(!z.negotiation) {
					options.push("Launch Raiders");
				}
				if(heaviesAway() > 0) {
					options.push("Place a Heavy Raider on the main game board");
				}
				if(!z.negotiation) {
					options.push("Activate Heavy Raiders");
				}
				if(centurionReserves() > 0) {
					options.push("Place a Centurion at the start of the Boarding Party Track");
				}
				if(z.centurions.length - centurionReserves() > 0) {
					options.push("Destroy a Centurion");
				}
				if(!z.negotiation) {
					options.push("Activate Raiders");
				}
				if(raidersAway() !== 0) {
					options.push("Place Raider(s) on the main game board");
				}
			}
		}
	} /* TODO: shuffle various decks in case of screwup */ /*	What would you like to do, Baltar? (1-5)   	42											11: Print Hand Report (and exit).           	342: Display Game State.						243: TANK this skill check.					274: Play Destiny into skil...				26*/
	let maxOptions = options.length;
	let minOptions = 1;
	if(options.length > 22 && firstPage) {
		maxOptions = 22;
		options.splice(21, 0, "(scroll down)", "(scroll up)");
	}
	if(!firstPage) {
		minOptions = 22;
	}
	let promptText = "What would you like to do, " + myPlayer + "? (" + minOptions + "-" + maxOptions + ")\n\n";
	for(let i = minOptions - 1; !(i >= maxOptions); i++) {
		promptText += (i + 1) + ": " + options[i ] + ".\n";
	} 
	let cancelLabel = "Go Back";
	if(menuPage === "Default" && firstPage) {
		cancelLabel = "Save and Quit";
	}
	promptNum(promptText, (a) => minOptions > a || a > maxOptions, () => {
		if(menuPage === "Default" && firstPage) {
			saveAndQuit();
		} else {
			menuPage = "Default";
			firstPage = true;
			mainMenu();
		}
	}, (prompted) => {
		let ch = options[prompted - 1];
		if(menuPage === "[I still can't find what I'm looking for]" && ch !== "(scroll down)") {
			t.value += size("I had to dig deep into the menus to find this.  This is probably the result of a bug, which [us" +
				"er=Grafin]Zoe T[/us" + "er] should track down.\r\n", 8);
		}
		if(ch === "(scroll down)") {
			firstPage = false;
			mainMenu();
		} else {
			firstPage = true;
		}
		if(ch === "Blind Devotion (OPG)") {
			let maxColor = 5;
			if(z.daybreak || z.pegasus) {
				maxColor++;
			}
			let promptText = "Which color would you like to zero out with your Blind Devotion OPG? (1-" + maxColor +
				")\n1: Politics\n2: Leadership\n3: Tactics\n4: Piloting\n5: Engineering";
			if(z.daybreak || z.pegasus) {
				promptText += "\n6: Treachery";
			}
			promptNum(promptText, (a) => 1 > a || a > maxColor, mainMenu, (prompted) => {
				addAlert("Used Blind Devotion on " + colorIDAlert(prompted - 1)+".");
				t.value += bold(z.players[me] + " uses Blind Devotion to make all " + colorIDName(prompted - 1) +
					" skill cards count as 0 strength.") + "\r\n";
				z.blindDevotion = prompted - 1;
				if((z.assist === "Chief" && !z.vBrutality) || (z.vBrutality && z.assist === "Tigh")) {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				mainMenu();
			});
		} else if (ch === "Pass on Adaptable"){
			confirmify("Confirming you want to pass on Adaptable and not draw any skill cards.\n\nYou probably don't want to do this.",mainMenu,()=>{
				boldAlert("Tory passes on Adaptable.");
				removeOption(me,"Pass on Adaptable");
				removeOption(me,"Draw 2 Skill Cards (any color)");
				mainMenu();
			});
		} else if (ch === "View discarded Loyalty cards"){
			let alertText = bold("Discarded Loyalties:\r\n");
			for(let j = 0; !(j>=z.loyaltyDiscards.length); j++){
				if(z.loyaltyDiscards[j].length > 0){
					alertText += "\r\n"+bold(z.players[j])+":";
				}
				for(let k = 0; !(k>=z.loyaltyDiscards[j].length); k++){
					alertText += "\r\n"+d.loyaltyNames[z.loyaltyDiscards[j][k]];
				}
			}
			plainAlert(alertText);
			mainMenu();
		} else if (ch ==="[Besieged] Increase the number of Raiders that are about to attack"){
			confirmify("Confirming you want to have an additional Raider attack from Besieged.  Only do this if someone destroyed a Raider off Apollo's AVP, and wanted it to be an old rather than a new Raider.",
					   mainMenu,()=>{
							plainAlert("An old raider rather than a new raider (one placed by Besieged) is destroyed instead.");
							z.heavyCasualties++;
							mainMenu();
					   });
		} else if (ch ==="[Attack on the Colony] Remove a basestar from the game"){
			let promptText = "Which basestar would you like to remove from the game? (1-2)";
			promptText += "\n1: Basestar in CFB Sector "+(-z.basestars[0][0]);
			promptText += "\n2: Basestar in CFB Sector "+(-z.basestars[1][0]);
			promptNum(promptText,(a)=>1>a||a>2,mainMenu,(a)=>{
				if(a === 0){
					boldAlert(z.players[me]+" removed the basestar in CFB Sector "+(-z.basestars[0][0])+" from the game.");
					z.basestars.shift();
				} else {
					boldAlert(z.players[me]+" removed the basestar in CFB Sector "+(-z.basestars[1][0])+" from the game.");
					z.basestars.pop();
				}
				removeOption(me,ch);
				mainMenu();
			});
		} else if (ch === "View the top card of each discard pile"){
			let alertText = "";
			for(let j = 0; !(j>=z.skillCardDiscards.length); j++){
				if(j !== 0){
					alertText += "\n";
				}
				if(z.skillCardDiscards[j].length === 0){
					alertText += "There are no "+colorIDAlert(j)+" discards.";
				} else {
					alertText += cardText(z.skillCardDiscards[j][z.skillCardDiscards[j].length-1]);
				}
			}
			if(z.crisisDiscards.length > 0){
				alertText += "\nCrisis: "+d.crisisNames[z.crisisDiscards[z.crisisDiscards.length-1]];
			} else {
				alertText += "\nCrisis: (none)";
			}
			if(z.superCrisisDiscards.length > 0){
				alertText += "\nSuper Crisis: "+d.crisisNames[z.superCrisisDiscards[z.superCrisisDiscards.length-1]];
			} else {
				alertText += "\nSuper Crisis: (none)";
			}
			if((z.destination === "Earth" || z.destination === "Ionian Earth")){
				if(z.missionDiscards.length > 0){
					alertText += "\nMission: "+d.crisisNames[z.missionDiscards[z.missionDiscards.length-1]];
				} else {
					alertText += "\nMission: (none)";
				}
			}
			if(z.quorumDiscards.length > 0){
				alertText += "\nQuorum: "+d.quorumNames[z.quorumDiscards[z.quorumDiscards.length-1]];
			} else {
				alertText += "\nQuorum: (none)";
			}
			if(z.daybreak){
				if(z.mutinyDiscards.length > 0){
					alertText += "\nMutiny: "+d.mutinyNames[z.mutinyDiscards[z.mutinyDiscards.length-1]];
				} else {
					alertText += "\nMutiny: (none)";
				}
			}
			addAlert(alertText);
			mainMenu();
		} else if (ch === "View visited Destinations"){
			let alertText = "";
			for(let j = 0; !(j>=z.destinationDiscards.length); j++){
				if(j !== 0){
					alertText += "\n";
				}
				alertText += d.destinationNames[z.destinationDiscards[j]];
			}
			addAlert(alertText);
			mainMenu();
		} else if (ch === "Print your hand report in a spoiler (and quit)"){
			let report = handReport();
			t.value += spoiler(report);
			postSeed(true);
			if(t.value.slice(-4) !== ("[h" + bl + "r]")) {
				t.value += "[h" + bl + "r]";
			}
			clearBackground();
		} else if (ch === "Critical Mission (OPG)"){
			confirmify("Confirming you want to use your OPG, Critical Mission, to draw and destroy a civilian ship to increase the Jump Preparation Track by 1.",
					   mainMenu,()=>{
						   if(z.players[me] === "Gaius"){
							   z.miracles[me] -= 2;
						   } else if(z.assist === "Shaw") {
							   z.assistMiracle = 0;
						   } else {
							   z.miracles[me] = 0;
						   }
						   if(destroyPileCivilian(1)) {
								increaseJump();
							} else {
								plainAlert("Once the civilian destruction has been resolved, increase the Jump Preparation Track by 1.");
								optionForAll("Advance the Jump Preparation Track");
							}
							didAction();
							mainMenu();
					   });
		} else if (ch === "Trial without Process (OPG)"){
			confirmify("Confirming you want to use your OPG, Trial without Process, to bar any number of players of your choice from playing into the skill check.",
					   mainMenu,
					   ()=>{
						   if(z.players[me] === "Gaius"){
							   z.miracles[me] -= 2;
						   } else {
							   z.miracles[me] = 0;
						   }
						   z.trialWithoutProcess = [];
						   for(let j = 0; !(j>=z.numPlayers); j++){
							   z.trialWithoutProcess.push(false);
						   }
						   boldAlert("Seelix uses her OPG, Trial Without Process, and may now pick players to bar from participating in the skill check.");
						   removeOption(me,ch);
						   addOption(me,"[Trial Without Process] Pick a player to bar from the skill check",undefined,false);
						   mainMenu();
					   });
		} else if (ch === "[Trial Without Process] Pick a player to bar from the skill check"){
			let promptText = "Pick a player to bar (or unbar) from playing cards into this skill check (1-"+z.numPlayers+")";
			for(let j = 0; !(j>=z.numPlayers); j++){
				promptText += "\n"+(j+1)+": "+z.players[j];
				if(z.trialWithoutProcess[j]){
					promptText += " (barred)";
				}
			}
			promptNum(promptText,(a)=>1>a||a>z.numPlayers, mainMenu, (prompted)=>{
				z.trialWithoutProcess[prompted-1] = !z.trialWithoutProcess[prompted-1];
				if(z.trialWithoutProcess[prompted-1]){
					plainAlert(z.players[prompted-1]+" may not participate in this skill check.");
				} else {
					plainAlert(z.players[prompted-1]+" may participate in this skill check.");
				}
				mainMenu();
			});
		} else if(ch === "[Civilian Self Defense] Choose a civilian ship") {
			let promptText = "";
			let ships = [];
			let sectors = [];
			for(let j = 0; !(j >= 6); j++) {
				for(let k = 0; !(k >= z.spaceCivilians[j].length); k++) {
					ships.push(z.spaceCivilians[j][k][0]);
					sectors.push(j + 1);
					promptText += "\n" + ships.length + ": Civilian " + z.spaceCivilians[j][k][0] + " (Sector " + (j + 1) + ")";
				}
			}
			promptText = "Which ship would you like to choose? (1-" + ships.length + ")" + promptText;
			promptNum(promptText, (a) => 1 > a || a > ships.length, mainMenu, (prompted) => {
				let ship = ships[prompted - 1];
				let sector = sectors[prompted - 1];
				boldAlert(z.players[me] + " chooses Civilian " + ship + " (Sector " + sector + ").");
				let raidersAvailable = false;
				let heaviesAvailable = false;
				for(let j = 0; !(j >= z.raiders.length) && !raidersAvailable; j++) {
					if(z.raiders[j] === sector) {
						raidersAvailable = true;
					}
				}
				for(let j = 0; !(j >= z.heavies.length) && !heaviesAvailable; j++) {
					if(z.heavies[j] === sector) {
						heaviesAvailable = true;
					}
				} /* RULES: Can you pick a type that isn't there? */
				if(raidersAvailable && heaviesAvailable) {
					plainAlert(z.players[me] + " must now choose whether to destroy 3 Raiders or 1 Heavy Raider in Sector " + sector + ".");
					addOption(me, "Destroy Raider(s)", ["Civilian Self Defense", sector, ship], true);
					addOption(me, "Destroy a Heavy Raider", ["Civilian Self Defense", sector, ship], true);
				} else if(raidersAvailable) {
					let numDestroyed = 0;
					for(let j = 0; !(j >= z.raiders.length) && 3 > numDestroyed; j++) {
						if(z.raiders[j] === sector) {
							z.raiders[j] = 0;
							numDestroyed++;
						}
					}
					if(numDestroyed === 1) {
						plainAlert("Destroyed 1 Raider in Sector " + sector + ".");
					} else {
						plainAlert("Destroyed " + numDestroyed + " Raiders in Sector " + sector + ".");
					}
					if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
						plainAlert(
							"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					}
					if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
						z.heavyCasualties-=numDestroyed;
						if(0 > z.heavyCasualties){
							z.heavyCasualties = 0;
						}
						let left = 0;
						for(let j = 0; !(j>=z.raiders.length); j++){
							if(z.raiders[j] === 6){
								left++;
							}
						}	
						if(left > z.heavyCasualties){
							plainAlert("BYC assumes that the Raiders just placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
						}
					}
					SPTokenBad("Civilian Self Defense (" + ship + ")");
				} else if(heaviesAvailable) {
					for(let j = 0; !(j >= z.heavies.length); j++) {
						if(z.heavies[j] === sector) {
							z.heavies[j] = 0;
							break;
						}
					}
					plainAlert("Destroyed a Heavy Raider in Sector " + sector + ".");
					SPTokenBad("Civilian Self Defense (" + ship + ")");
				} else {
					plainAlert("No Raiders or Heavy Raiders are present in Sector " + sector + ".");
					SPTokenBad("Civilian Self Defense (" + ship + ")");
				}
				removeOption(me,ch);
				mainMenu();
			});
		} else if(ch === "Moment of Heroism (OPG)") {
			let promptText = "Who would you like to use your OPG, Moment of Heroism, on? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.revealedCylons[j] === 1 && !isTheCylonLeader(j)) {
					promptText += "[CYLON]";
				} else if(j === z.theSympatheticCylon) {
					promptText += "[Sympathetic Cylon]";
				} else if(z.players[j] === "Baltar" || z.players[j] === "Boomer" || z.players[j] === "Tom" || z.players[j] === "Helo" || z.players[
					j] === "Ellen") {
					promptText += "[ineligible]";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || (z.revealedCylons[a - 1] === 1 && !isTheCylonLeader(a - 1)) || a - 1 === z
				.theSympatheticCylon, mainMenu, (prompted) => {
					if(versionAtLeast([2,1,13])){
						boldAlert("Billy uses his OPG, Moment of Heroism, to cancel " + z.players[prompted - 1] +
							"'s drawback until the end of Billy's next turn.");
					} else {
						boldAlert("Billy uses his OPG, Moment of Heroism, to cancel " + z.players[prompted - 1] +
							"'s drawback until the end of their next turn.");
					}
					z.momentOfHeroism = prompted - 1;
					if((versionAtLeast([2,1,13]) && me === z.turn) || (!versionAtLeast([2,1,13]) && prompted - 1 === z.turn)) {
						z.momentOfHeroismExtra = true;
					}
					if(z.assist === "Billy") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					mainMenu();
				});
		} else if(ch === "[Bomb on Colonial One] Draw new Allies") {
			confirmify(
				"Confirming that Dee's execution has been fully resolved (including picking a new character, if she was Human), and you want to continue to replacing the Allies that were on Colonial One.",
				mainMenu, () => {
					removeFromAll("[Bomb on Colonial One] Draw new Allies");
					let killedAllies = 0;
					for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
						if(onColonialOne(d.allyLocations[z.allies[j][0]])) {
							plainAlert("The " + d.allyNames[z.allies[j][0]] + " Ally is hit, and is removed from the game.");
							let trauma = z.allies[j][1];
							if(trauma !== null){
								z.traumaPile.push(trauma);
							}
							shuffle(z.traumaPile);
							z.allies.splice(j, 1);
							j--;
							killedAllies++;
						}
					}
					for(let j = killedAllies; j > 0; j--) {
						let newAlly = allyPop();
						if(newAlly === -1) {
							plainAlert("Ally deck exhausted; it does not reshuffle.");
						} else {
							z.cylonAllyQueue.push(newAlly);
						}
					}
					if(z.preCrossroads && z.cylonAllyQueue.length > 0) {
						resolveCylonAllyQueue();
					}
					mainMenu();
				});
		} else if(ch === "Razor") {
			confirmify("Confirming you want to discard a skill card to move and then take two actions on this Executive Order.", mainMenu, () => {
				boldAlert(
					"Shaw uses her Razor ability; after discarding a skill card, she may move and take two actions on this Executive Order."
					);
				z.razor = true;
				promptAllyDiscards(me, 1);
				addOption(me, "Move", undefined, true);
				mainMenu();
			});
		} else if(ch === "Start in an Assault Raptor in Sector 5 instead") {
			confirmify("Confirming that you want to start in an Assault Raptor in Sector 6", mainMenu, () => {
				boldAlert("Apollo chooses to start in an Assault Raptor in Sector 5.");
				z.assaultRaptors[0] = "Apollo";
				z.vipersII[2] = 0;
				removeOption(me, ch);
				removeOption(me, "Start in a Viper Mk II in Sector 6 instead");
				removeOption(me, "Start in an Assault Raptor in Sector 6 instead");
				mainMenu();
			});
		} else if(ch === "Start in an Assault Raptor in Sector 6 instead") {
			confirmify("Confirming that you want to start in an Assault Raptor in Sector 5", mainMenu, () => {
				z.playerLocations[me] = "Sector 6";
				boldAlert("Apollo chooses to start in an Assault Raptor in Sector 6.");
				z.assaultRaptors[0] = "Apollo";
				z.vipersII[2] = 0;
				removeOption(me, ch);
				removeOption(me, "Start in an Assault Raptor in Sector 5 instead");
				removeOption(me, "Start in a Viper Mk II in Sector 6 instead");
				mainMenu();
			});
		} else if(ch === "Start in a Viper Mk II in Sector 6 instead") {
			confirmify("Confirming that you want to start in a Viper Mk II in Sector 6 rather than Sector 5", mainMenu, () => {
				movePlayer(me, "Sector 6");
				removeOption(me, ch);
				removeOption(me, "Start in an Assault Raptor in Sector 5 instead");
				removeOption(me, "Start in an Assault Raptor in Sector 6 instead");
				mainMenu();
			});
		} else if(ch === "[Encourage Mutiny] Choose who would become Admiral") {
			let promptText = "Who would receive the Admiral title if this die roll succeeds? (1-" + z.numPlayers + ")";
			let validTargets = 0;
			for(let i = 0; !(i >= z.numPlayers); i++) {
				promptText += "\n" + (i + 1) + ": ";
				if(z.revealedCylons[i ] === 1) {
					promptText += "(Cylon)";
				} else if(isCylonLeader(z.players[i ])) {
					promptText += "(Cylon Leader)";
				} else if(i === z.theSympatheticCylon) {
					promptText += "(Sympathetic Cylon)";
				} else if(z.playerLocations[i ] === "Brig") {
					promptText += "(in the Brig)";
				} else if(i === me) {
					promptText += "(cannot pick yourself)";
				} else {
					promptText += z.players[i ];
					validTargets++;
				}
			} /* TODO: RULES: special case of using this when everyone is in the Brig. */
			if(validTargets === 0) {
				plainAlert("There are no valid targets for Encourage Mutiny; the Admiral title will not move, but Morale may be lost.");
				SPTokenBad("Encourage Mutiny");
				mainMenu();
			} else {
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || (a - 1 == me) || (a > 0 && z.revealedCylons[a - 1] === 1) || (a > 0 && 
						isTheCylonLeader(a-1)) || (a > 0 && a - 1 === z.theSympatheticCylon) || (a > 0 && z.playerLocations[a - 1] === "Brig"),
					mainMenu, (prompted) => {
						boldAlert(z.players[me] + " chooses " + z.players[prompted - 1] +
							" to receive the Admiral title should they roll a 3 or higher.");
						SPTokenBad("Encourage Mutiny (" + z.players[prompted - 1] + ")");
						removeOption(me, ch);
						mainMenu();
					});
			}
		} else if(ch === "Expert Pilot") {
			confirmify("Confirming you want to take an extra action due to your Expert Pilot ability.", mainMenu, () => {
				plainAlert("Starbuck uses her Expert Pilot ability, and may now take another action.");
				z.phase = 2;
				z.expertPilot = false;
				mainMenu();
			});
		} else if(ch === "Avionics Expert") {
			/* TODO: there may be weird corner cases that this doesn't handle well, esp. Critical Situation / State of Emergency */
			confirmify("Confirming you want to take another action due to your Avionics Expert ability.", mainMenu, () => {
				plainAlert("Seelix uses her Avionics Expert ability, and may now take another action.");
				z.phase = 2;
				z.avionicsExpert = false;
				z.avionicsExpertAvailable = false;
				z.avionicsExpertAction = true;
				mainMenu();
			});
		} else if(ch === "Stay in space") {
			confirmify("Confirming you want to remain in your Assault Raptor in space during this jump.", mainMenu, () => {
				boldAlert(z.players[me] + " chooses to remain in space.");
				removeOption(me, ch);
				removeOption(me, "Land on the Hangar Deck");
				mainMenu();
			});
		} else if(ch === "Land on the Hangar Deck") {
			confirmify("Confirming you want to land on Hangar Deck and return your Assault Raptor to the reserves.", mainMenu, () => {
				boldAlert(z.players[me] + " chooses to land on the Hangar Deck.");
				movePlayer(me, "Hangar Deck");
				removeOption(me, ch);
				removeOption(me, "Stay in space");
				mainMenu();
			});
		} else if(ch === "Allow players to take actions out of turn this turn") {
			confirmify("Use this if someone should be entitled to an action but BYC won't let them take it.", mainMenu, () => {
				plainAlert("Turning off Action safeguards.");
				z.emergencyAction = true;
				mainMenu();
			});
		} else if(ch === "Make all options non-mandatory") {
			confirmify(
				"Use this if BYC seems to think one or more people need to do something in order to end the turn or draw the current crisis, but you are sure BYC is wrong.",
				mainMenu, () => {
					plainAlert("All current player options made non-mandatory.  You can now try drawing the top crisis / ending the turn again.");
					for(let j = 0; !(j >= z.numPlayers); j++) {
						for(let k = 0; !(k >= z.mandatory[j].length); k++) {
							z.mandatory[j][k] = false;
						}
					}
					mainMenu();
				});
		} else if(ch === "Resolve Kleptomania") {
			confirmify("Confirming you want to check whether your Kleptomania drawback applies.", mainMenu, () => {
				resolveKleptomania();
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "I'm done with Critical Situation") {
			confirmify(
				"Confirming that your action from Critical Situation has been completely resolved, and you are ready to check on whether your Kleptomania drawback is in effect.",
				mainMenu, () => {
					endMovement();
					removeOption(me, ch);
					mainMenu();
				});
		} else if(ch === "Play a Movement Skill Card") {
			let cards = [];
			promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(z.revealedCylons[me] === 1) {
					if(cardName(z.skillCardHands[me][j]) === "God's Plan") {
						cards.push(j);
						promptText += "\n" + cards.length + ": " + cardText(z.skillCardHands[me][j]);
					}
					continue;
				}
				if(cardName(z.skillCardHands[me][j]) === "Preventative Policy" || cardName(z.skillCardHands[me][j]) === "Critical Situation") {
					cards.push(j);
					promptText += "\n" + cards.length + ": " + cardText(z.skillCardHands[me][j]);
				} else if(cardName(z.skillCardHands[me][j]) === "Full Throttle" && isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z
						.skillCardHands[me].length > 1)) {
					cards.push(j);
					promptText += "\n" + cards.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Movement card would you like to play? (1-" + cards.length + ")" + promptText;
			promptNum(promptText, (a) => 1 > a || a > cards.length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][cards[prompted - 1]];
				if(z.players[me] === "Hoshi" && !solo) {
					z.reluctant = false;
				}
				if(cardName(card) === "God's Plan") {
					let destiny = z.destiny.pop(); /* RULES: 1-card destiny deck & God's Plan? (unlikely) */
					z.destiny.push(z.skillCardHands[me].splice(cards[prompted - 1], 1)[0]);
					z.skillCardHands[me].push(destiny);
					addAlert("Played " + cardText(card) + ", exchanging it for " + cardText(destiny) + " from the Destiny deck.");
					t.value += bold(myPlayer + " played " + cardText(card) +
						" as their Movement, exchanging it for the top card of the Destiny deck.\r\n");

					z.possibleColors[me] = [1, 1, 1, 1, 1, 1];

					endMovement();
				} else if(cardName(card) === "Preventative Policy") {
					z.preventative = "NONE";
					playSkillCard(me, cards[prompted - 1], true);
					addAlert("Playing " + cardText(card) + ". You must now designate which resource is to be protected.");
					t.value += myPlayer + " must now designate which resource is to be protected.\r\n";
					z.phase = -1;
					addOption(me, "[Preventative Policy] Pick a resource to protect", undefined, true);
				} else if(cardName(card) === "Critical Situation") {
					z.xo = true;
					playSkillCard(me, cards[prompted - 1], true);
					addAlert("Now, take an action.");
					z.criticalSituation = true; /* TODO: romo needs to flag that he's done. */
					z.phase = -1;
				} else if(cardName(card) === "Full Throttle") {
					playSkillCard(me, cards[prompted - 1], false);
					t.value += bold(myPlayer + " played " + cardText(card) + " as their Movement.\r\n");
					addAlert("Now, you may move to any space sector, then attack a Cylon ship in your sector.");
					z.phase = -1;
					addOption(me, "[Full Throttle] Move to a space sector", undefined, true);
					addOption(me, "[Full Throttle] Do not move", undefined, true);
				}
				mainMenu();
			});
		} else if(ch === "[Full Throttle] Move to a space sector") {
			promptNum("Which sector would you like to move to? (1-6)", (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				addAlert("You move to Sector " + prompted + ".");
				movePlayer(me, "Sector " + prompted);
				removeOption(me, ch);
				removeOption(me, "[Full Throttle] Do not move");
				let any = false;
				if(canAttackRaider(true)) {
					addOption(me, "Attack a Raider", "Full Throttle", true);
					any = true;
				}
				if(canAttackScar(true)) {
					addOption(me, "Attack Scar", "Full Throttle", true);
					any = true;
				}
				if(canAttackHeavy(true)) {
					addOption(me, "Attack a Heavy Raider", "Full Throttle", true);
					any = true;
				}
				if(canAttackBasestar(true)) {
					addOption(me, "Attack a Basestar", "Full Throttle", true);
					any = true;
				}
				if(any) {
					addOption(me, "[Full Throttle] Do not attack", true);
				} else if(z.phase === -1) {
					z.phase = 2;
				}
				mainMenu();
			});
		} else if(ch === "[Full Throttle] Do not move") {
			confirmify("Confirming you want to stay in your current sector", mainMenu, () => {
				plainAlert(z.players[me] + " chooses not to move from Full Throttle.");
				removeOption(me, ch);
				removeOption(me, "[Full Throttle] Move to a space sector");
				let any = false;
				if(canAttackRaider(true)) {
					addOption(me, "Attack a Raider", "Full Throttle", true);
					any = true;
				}
				if(canAttackScar(true)) {
					addOption(me, "Attack Scar", "Full Throttle", true);
					any = true;
				}
				if(canAttackHeavy(true)) {
					addOption(me, "Attack a Heavy Raider", "Full Throttle", true);
					any = true;
				}
				if(canAttackBasestar(true)) {
					addOption(me, "Attack a Basestar", "Full Throttle", true);
					any = true;
				}
				if(any) {
					addOption(me, "[Full Throttle] Do not attack", true);
				} else if(z.phase === -1) {
					z.phase = 2;
				}
				mainMenu();
			});
		} else if(ch === "[Full Throttle] Do not attack") {
			confirmify("Confirming you do not want to attack a Cylon ship with Full Throttle", mainMenu, () => {
				plainAlert(z.players[me] + " chooses not to attack a Cylon ship with Full Throttle.");
				removeOption(me, "Attack a Raider");
				removeOption(me, "Attack Scar");
				removeOption(me, "Attack a Heavy Raider");
				removeOption(me, "Attack a Basestar");
				removeOption(me, "[Full Throttle] Do not attack");
				if(z.phase === -1) {
					z.phase = 2;
				}
			});
		} else if(ch === "Inspirational Leader" || ch === "Feared Leader") {
			let promptText = "";
			let xos = [];
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Executive Order") {
					xos.push(j);
					promptText += "\n" + xos.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Executive Order would you like to discard to use your " + ch +
				" ability, which will let you activate a location occupied by another player? (1-" + xos.length + ")" + promptText;
			promptNum(promptText, (a) => 1 > a || a > xos.length, mainMenu, (prompted) => {
				boldAlert(z.players[me] + " uses their " + ch + " ability, and must now activate a location occupied by another player.");
				discardSkillCard(me, xos[prompted - 1]);
				addOption(me, "[" + ch + "] Activate another location", undefined, true);
				z.phase = -1;
				mainMenu();
			});
		} else if(ch === "Friends in Low Places (OPG)") {
			if(hasContext(me, ch, "Admiral") || (z.friendsAdmiral && !z.friendsCAG && !z.friendsPresident) || (z.cultAdmiral && !z.cultCAG && !z.cultPresident)) {
				confirmify("Confirming you want to use your OPG, Friends in Low Places, to take the Admiral title.", mainMenu, () => {
					if(z.players[me] === "Gaius"){
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					boldAlert("Zarek uses his OPG, Friends in Low Places, to take the Admiral title.");
					z.admiral = me;
					delete z.cultAdmiral;
					delete z.friendsAdmiral;
					removeOption(me, ch);
					mainMenu();
				});
			} else if(hasContext(me, ch, "President") || (!z.friendsAdmiral && !z.friendsCAG && z.friendsPresident) || (!z.cultAdmiral && !z.cultCAG && z.cultPresident)) {
				confirmify("Confirming you want to use your OPG, Friends in Low Places, to take the President title.", mainMenu, () => {
					if(z.players[me] === "Gaius"){
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					boldAlert("Zarek uses his OPG, Friends in Low Places, to take the President title.");
					movePresident(me);
					removeOption(me, ch);
					delete z.cultPresident;
					delete z.friendsPresident;
					mainMenu();
				});
			} else if(hasContext(me, ch, "CAG")|| (!z.friendsAdmiral && z.friendsCAG && !z.friendsPresident) || (!z.cultAdmiral && z.cultCAG && !z.cultPresident)) {
				confirmify("Confirming you want to use your OPG, Friends in Low Places, to take the CAG title.", mainMenu, () => {
					if(z.players[me] === "Gaius"){
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					boldAlert("Zarek uses his OPG, Friends in Low Places, to take the CAG title.");
					z.cag = me;
					removeOption(me, ch);
					delete z.cultCAG;
					delete z.friendsCAG;
					mainMenu();
				});
			} else {
				let max = 2;
				if(z.CFB) {
					max++;
				}
				let promptText = "Which title would you like to take with your OPG, Friends in Low Places? (1-" + max + ")\n1: Admiral\n2: President";
				if(z.CFB) {
					promptText += "\n3: CAG";
				}
				promptNum(promptText, (a) => 1 > a || a > max || (a === 1 && me === z.admiral) || (a === 2 && me === z.president) || (a === 3 && me ===
					z.cag), mainMenu, (prompted) => {
					if(z.players[me] === "Gaius"){
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					removeOption(me, ch);
					delete z.cultAdmiral;
					delete z.cultPresident;
					delete z.cultCAG;
					delete z.friendsPresident;
					delete z.friendsAdmiral;
					delete z.friendsCAG;
					if(prompted === 1) {
						boldAlert("Zarek uses his OPG, Friends in Low Places, to take the Admiral title.");
						z.admiral = me;
					} else if(prompted === 2) {
						boldAlert("Zarek uses his OPG, Friends in Low Places, to take the President title.");
						movePresident(me);
					} else {
						boldAlert("Zarek uses his OPG, Friends in Low Places, to take the CAG title.");
						z.cag = me;
					}
					mainMenu();
				});
			}
		} else if(ch === "The Blackbird (OPG)") {
			confirmify("Confirming you want to use your OPG, The Blackbird.", mainMenu, () => {
				t.value += bold("Chief uses his OPG, The Blackbird") + "\r\n";
				let numDestroyed = 0;
				if(!z.CFB) {
					for(let j = 0; !(j >= z.vipersII.length) && !(numDestroyed >= 2); j++) {
						if(z.vipersII[j] === -1) {
							z.vipersII[j] = -2;
							numDestroyed++;
						}
					}
					t.value += "2 damaged Vipers destroyed.\r\n";
				} else {
					let numII = 0;
					let numVII = 0;
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(z.vipersII[j] === -1) {
							numII++;
						}
					}
					for(let j = 0; !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === -1) {
							numVII++;
						}
					}
					if(numVII === 0) {
						for(let j = 0; !(j >= z.vipersII.length) && !(numDestroyed >= 2); j++) {
							if(z.vipersII[j] === -1) {
								z.vipersII[j] = -2;
								numDestroyed++;
								plainAlert("Viper Mk II destroyed.");
							}
						}
					} else if(numII === 0) {
						for(let j = 0; !(j >= z.vipersVII.length) && !(numDestroyed >= 2); j++) {
							if(z.vipersVII[j] === -1) {
								z.vipersVII[j] = -2;
								numDestroyed++;
								plainAlert("Viper Mk VII destroyed.");
							}
						}
					} else if(numII === 1 && numVII === 1) {
						for(let j = 0; !(j >= z.vipersII.length) && !(numDestroyed >= 2); j++) {
							if(z.vipersII[j] === -1) {
								z.vipersII[j] = -2;
								numDestroyed++;
								plainAlert("Viper Mk II destroyed.");
							}
						}
						for(let j = 0; !(j >= z.vipersVII.length) && !(numDestroyed >= 2); j++) {
							if(z.vipersVII[j] === -1) {
								z.vipersVII[j] = -2;
								numDestroyed++;
								plainAlert("Viper Mk VII destroyed.");
							}
						}
					}
				}
				if(z.assist === "Chief") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				let d1 = z.crisisDeck.pop();
				let d2 = z.crisisDeck.pop();
				let d3 = z.crisisDeck.pop();
				z.scout = me;
				z.scoutingCrisis = true;
				z.scouted.push(d1);
				z.scouted.push(d2);
				z.scouted.push(d3);
				didAction();
				if(numDestroyed === 2) {
					t.value += "Chief now looks at the top three cards of the Crisis deck.\r\n";
					addAlert("Top 3 cards of the Crisis deck:\n\n1: " + d.crisisNames[d1] + "\n2: " + d.crisisNames[d2] + "\n3: " + d
						.crisisNames[d3] + "\n\nNow, top or bottom these scouted Crises, in any order.");
					mainMenu();
				} else {
					plainAlert(
						"Chief must now destroy two damaged Vipers, then look at the top three cards of the Crisis deck and place them on the top or the bottom in any order."
						);
					addOption(me, "[The Blackbird] Destroy a Viper", 2, true);
					mainMenu();
				}
			});
		} else if(ch === "[The Blackbird] Destroy a Viper") {
			let numII = 0;
			let numVII = 0;
			for(let j = 0; !(j >= z.vipersII.length); j++) {
				if(z.vipersII[j] === -1) {
					numII++;
				}
			}
			for(let j = 0; !(j >= z.vipersVII.length); j++) {
				if(z.vipersVII[j] === -1) {
					numVII++;
				}
			}
			let promptText = "Which type of Viper would you like to destroy? (1-2)\n1: ";
			if(numII > 0) {
				promptText += "Viper Mk II";
			} else {
				promptText += "(none available)";
			}
			promptText += "\n2: ";
			if(numVII > 0) {
				promptText += "Viper Mk VII";
			} else {
				promptText += "(none available)";
			}
			promptNum(promptText, (a) => 1 > a || a > 2 || (a === 1 && numII === 0) || (a == 2 && numVII === 0), mainMenu, (prompted) => {
				if(prompted === 1) {
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(z.vipersII[j] === -1) {
							z.vipersII[j] = -2;
							plainAlert("Viper Mk II destroyed.");
							break;
						}
					}
				} else {
					for(let j = 0; !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === -1) {
							z.vipersVII[j] = -2;
							plainAlert("Viper Mk VII destroyed.");
							break;
						}
					}
				}
				let context = getContext(me, ch);
				if(context === 2) {
					addOption(me, ch, 1, true);
				} else {
					removeOption(me,ch);
				}
				mainMenu();
			});
		} else if(ch === "Start on Pegasus CIC") {
			confirmify("Confirming you want to start the game on Pegasus CIC.", mainMenu, () => {
				z.playerLocations[me] = "Pegasus CIC";
				removeOption(me, ch);
				boldAlert("Cain chooses to start on Pegasus CIC instead.");
				mainMenu();
			});
		} else if(ch === "Start on Main Batteries") {
			confirmify("Confirming you want to start the game on Main Batteries.", mainMenu, () => {
				z.playerLocations[me] = "Main Batteries";
				removeOption(me, ch);
				boldAlert(z.players[me] + " chooses to start on Main Batteries instead.");
				mainMenu();
			});
		} else if(ch === "[Send a Message] Target a Centurion") {
			let centurionBases = [0, 0, 0, 0];
			for(let j = 0; !(j >= z.centurions.length); j++) {
				if(z.centurions[j] > 0) {
					centurionBases[z.centurions[j] - 1]++;
				}
			}
			let promptText = "Which space on the Boarding Party track are you targeting? (1-4)";
			for(let j = 0; !(j >= 4); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(centurionBases[j] === 0) {
					promptText += "(no centurions here)";
				} else {
					promptText += "Space " + (j + 1);
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 4 || centurionBases[a - 1] === 0, mainMenu, (prompted) => {
				SPTokenBad("Send a Message vs. Centurion (space " + prompted + ")");
				z.dieRollModifier = 2;
				t.value += "Remember that this die roll receives a +2 bonus (which stacks with " + colorText("purple", "Strategic Planning") +
					").\r\n";
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Reveal Secrets (OPG)") {
			confirmify(
				"Confirming you want to use your OPG, Reveal Secrets, to negate the effect of the just-played Quorum card, then optionally play a Quorum from your own hand.",
				mainMenu, () => {
					if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					let quorum = getContext(me, ch);
					boldAlert("Billy uses his OPG, Reveal Secrets.");
					plainAlert(d.quorumNames[quorum] + " is discarded.");
					z.quorumDiscards.push(quorum);
					if((z.quorumHand.length > 0 && me === z.president) || (z.billyHand.length > 0 && z.players[me] === "Billy")) {
						boldAlert("Billy may now play a Quorum card from his hand.");
						if(me === z.president) {
							addOption(me, "Play a Quorum Card", undefined, false);
						}
					}
					removeFromAll("Process this Quorum Card");
					mainMenu();
				});
		} else if(ch === "Delete your secret messages") {
			confirmify("Confirming you want to delete your secret messages from your hand report.", mainMenu, () => {
				z.secretMessages[me] = "";
				mainMenu();
			});
		} else if(ch === "[A Civilian Convoy] Trade Morale for Fuel") {
			confirmify("Confirming you want to lower Morale by 1 to raise Fuel by 1.", mainMenu, () => {
				decreaseMorale();
				increaseFuel();
				removeOption(me, ch);
				removeOption(me, "[A Civilian Convoy] Decline to make the trade");
				mainMenu();
			});
		} else if(ch === "[A Civilian Convoy] Decline to make the trade") {
			confirmify("Confirming you do NOT want to make the trade from A Civilian Convoy.", mainMenu, () => {
				boldAlert("Admiral " + z.players[z.admiral] + " chooses not to make the trade.");
				removeOption(me, ch);
				removeOption(me, "[A Civilian Convoy] Trade Morale for Fuel");
				mainMenu();
			});
		} else if(ch === "I'm done with my part of State of Emergency") {
			let confirmText = "Confirming that you are done moving or taking an action from State of Emergency.";
			confirmify(confirmText, mainMenu, () => {
				if(z.SoEActor === -1) {
					if(z.executedCurrentPlayer) {
						plainAlert(colorText("green", "State of Emergency") + " complete.  You should, most likely, end the turn now.");
					} else {
						plainAlert(colorText("green", "State of Emergency") + " complete. " + z.players[z.turn] +
							" should now continue with the rest of their turn.");
					}
					removeFromAll(ch);
				} else {
					z.SoEDone = true;
					SoEToken();
				}
				mainMenu();
			});
		} else if(ch === "Choose which sector of Raiders activates next") {
			let sectors = [false, false, false, false, false, false];
			for(let j = 0; !(j >= z.raiders.length); j++) {
				if(z.raiderActivated[j] === 0 && z.raiders[j] > 0) {
					sectors[z.raiders[j] - 1] = true;
				}
			}
			if(z.scar > 0 && 3 > z.scarActivated) {
				sectors[z.scar - 1] = true;
			}
			let promptText = "Which sector are you activating next? (1-6)";
			for(let j = 0; !(j >= 6); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(sectors[j]) {
					promptText += "Sector " + (j + 1);
				} else {
					promptText += "(cannot activate)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 6 || !sectors[a - 1], mainMenu, (prompted) => {
				z.activatingSector = prompted;
				removeOption(me, ch);
				activateSector();
				mainMenu();
			});
		} else if(ch === "Resume Raider Activation") {
			confirmify("Confirming you want to resume raider activation.", mainMenu, () => {
				removeFromAll(ch);
				resetActivatingSector();
				mainMenu();
			});
		} else if(ch === "[Run Interference] Interfere with Scar") {
			confirmify("Confirming you want to prevent Scar from activating with Run Interference", mainMenu, () => {
				z.scarActivated = 4;
				removeOption(me, ch);
				removeOption(me, "[Run Interference] Interfere with a regular Raider");
				removeFromAll("Attack an unmanned Viper Mk II");
				removeFromAll("Attack an unmanned Viper Mk VII");
				removeFromAll("Attack an unmanned Assault Raptor");
				removeFromAll("Attack a piloted Viper");
				removeOption(z.turn, "Choose which sector of Raiders activates next");
				resetActivatingSector();
				mainMenu();
			});
		} else if(ch === "[Run Interference] Interfere with a regular Raider") {
			confirmify("Confirming you want to prevent a regular Raider activation with Run Interference; Scar will activate as normal.", mainMenu,
			() => {
					let context = getContext(me, ch);
					for(let j = 0; !(j >= z.raiders.length); j++) {
						if(z.raiders[j] === context && z.raiderActivated[j] === 0) {
							z.raiderActivated[j] = 2;
							break;
						}
					}
					removeOption(me, ch);
					removeOption(me, "[Run Interference] Interfere with Scar");
					removeFromAll("Attack an unmanned Viper Mk II");
					removeFromAll("Attack an unmanned Viper Mk VII");
					removeFromAll("Attack an unmanned Assault Raptor");
					removeFromAll("Attack a piloted Viper");
					removeOption(z.turn, "Choose which sector of Raiders activates next");
					resetActivatingSector();
					mainMenu();
				});
		} else if(ch === "[Assign Mission Specialist] Assign this Quorum card" || ch === "[Assign Vice President] Assign this Quorum card" || ch ===
			"[Assign Arbitrator] Assign this Quorum card" || ch === "[Assign Chief of Staff] Assign this Quorum card" || ch ===
			"[Probation] Assign this Quorum card") {
			let quorum = -1;
			if(ch === "[Assign Arbitrator] Assign this Quorum card") {
				quorum = 3;
			} else if(ch === "[Assign Mission Specialist] Assign this Quorum card") {
				quorum = 4;
			} else if(ch === "[Assign Vice President] Assign this Quorum card") {
				quorum = 5;
			} else if(ch === "[Assign Chief of Staff] Assign this Quorum card") {
				quorum = 17;
			} else if(ch === "[Probation] Assign this Quorum card") {
				quorum = 23;
			}
			let promptText = "Who would you like to give " + d.quorumNames[quorum] + " to? (1-" + z.numPlayers + ")\n";
			for(let i = 0; !(i >= z.numPlayers); i++) {
				if(i === me && quorum !== 23) {
					promptText += (i + 1) + ": (cannot choose yourself)\n";
				} else if(z.revealedCylons[i ] === 1) {
					promptText += (i + 1) + ": (cannot choose a revealed Cylon)\n";
				} else if(quorum === 5 && (i === z.theSympatheticCylon || isCylonLeader(z.players[i ]))) {
					promptText += (i + 1) + ": (cannot choose a Cylon Leader)\n";
				} else {
					promptText += (i + 1) + ": " + z.players[i ] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || (quorum === 23 && a - 1 === me) || (quorum ===
				5 && (isTheCylonLeader(a - 1) || a - 1 === z.theSympatheticCylon)), mainMenu, (prompted) => {
				z.quorumTitles[prompted - 1].push(quorum);
				boldAlert(myPlayer + " gave " + d.quorumNames[quorum] + " to " + z.players[prompted - 1] + ".");
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Send Romo to the Brig from his Kleptomania drawback") {
			confirmify(
				"Confirming you want to send Romo to the Brig due to his Kleptomania drawback.  You should only do this if Romo had to discard from his drawback but did not have the skill cards to do so.",
				mainMenu, () => {
					/* RULES: allies that move you? */
					plainAlert("Romo pays for his thievery.");
					if(isOnNewCaprica(z.turn)) {
						movePlayer(z.turn, "Detention");
					} else {
						movePlayer(z.turn, "Brig");
					}
					z.klepto = false;
					mainMenu();
				});
		} else if(ch === "Activate an unmanned Viper") {
			menuPage = '[Manual Viper Activation]';
			mainMenu();
		} else if(ch === "Attack a piloted Viper") {
			let options = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.playerLocations[j] === "Sector " + z.activatingSector) {
					options.push(z.players[j]);
				}
			}
			if(options.length === 1) {
				confirmify("Confirming you want to attack " + options[0] + ".", mainMenu, () => {
					if(getContext(me, ch)) {
						plainAlert("Scar shoots at " + options[0] + ".");
						z.dieRollQueue.push("Scar vs. " + options[0]);
						z.dieRoller = z.turn;
					} else {
						plainAlert("Raider shoots at " + options[0] + ".");
						z.dieRollQueue.push("Raider vs. " + options[0]);
						z.dieRoller = z.turn;
					}
					removeFromAll(ch);
					mainMenu();
				});
			} else if(options.length > 1) {
				let promptText = "Which pilot is being attacked? (1-" + options.length + ")";
				for(let j = 0; !(j >= options.length); j++) {
					promptText += "\n" + (j + 1) + ": " + options[j];
				}
				promptNum(promptText, (a) => 1 > a || a > options.length, mainMenu, (prompted) => {
					if(getContext(me, ch)) {
						plainAlert("Scar shoots at " + options[prompted - 1] + ".");
						z.dieRollQueue.push("Scar vs. " + options[prompted - 1]);
						z.dieRoller = z.turn;
					} else {
						plainAlert("Raider shoots at " + options[prompted - 1] + ".");
						z.dieRollQueue.push("Raider vs. " + options[prompted - 1]);
						z.dieRoller = z.turn;
					}
					removeFromAll(ch);
					mainMenu();
				});
			}
		} else if(ch === "Attack an unmanned Viper Mk II") {
			confirmify("Confirming you'd like to attack a Viper Mk II in Sector " + z.activatingSector + ".", mainMenu, () => {
				z.dieRoller = z.turn;
				if(getContext(me, ch)) {
					plainAlert("Scar shoots at a Viper Mk II in Sector " + z.activatingSector + ".");
					z.dieRollQueue.push("Scar vs. Viper Mk II (Sector " + z.activatingSector + ")");
				} else {
					plainAlert("Raider shoots at a Viper Mk II in Sector " + z.activatingSector + ".");
					z.dieRollQueue.push("Raider vs. Viper Mk II (Sector " + z.activatingSector + ")");
				}
				removeFromAll("Attack an unmanned Viper Mk II");
				removeFromAll("Attack an unmanned Viper Mk VII");
				removeFromAll("Attack an unmanned Assault Raptor");
				mainMenu();
			});
		} else if(ch === "Attack an unmanned Viper Mk VII") {
			confirmify("Confirming you'd like to attack a Viper Mk VII in Sector " + z.activatingSector + ".", mainMenu, () => {
				plainAlert("Raider shoots at a Viper Mk VII in Sector " + z.activatingSector + ".");
				z.dieRollQueue.push("Raider vs. Viper Mk VII (Sector " + z.activatingSector + ")");
				z.dieRoller = z.turn;
				removeFromAll("Attack an unmanned Viper Mk II");
				removeFromAll("Attack an unmanned Viper Mk VII");
				removeFromAll("Attack an unmanned Assault Raptor");
				mainMenu();
			});
		} else if(ch === "Attack an unmanned Assault Raptor") {
			confirmify("Confirming you'd like to attack an Assault Raptor in Sector " + z.activatingSector + ".", mainMenu, () => {
				z.dieRoller = z.turn;
				if(getContext(me, ch)) {
					plainAlert("Scar shoots at an Assault Raptor in Sector " + z.activatingSector + ".");
					z.dieRollQueue.push("Scar vs. Assault Raptor (Sector " + z.activatingSector + ")");
				} else {
					plainAlert("Raider shoots at an Assault Raptor in Sector " + z.activatingSector + ".");
					z.dieRollQueue.push("Raider vs. Assault Raptor (Sector " + z.activatingSector + ")");
				}
				removeFromAll("Attack an unmanned Viper Mk II");
				removeFromAll("Attack an unmanned Viper Mk VII");
				removeFromAll("Attack an unmanned Assault Raptor");
				mainMenu();
			});
		} else if(ch === "Risk a Raptor for Icy Moon") {
			confirmify("Confirming you want to risk a Raptor for Icy Moon.", mainMenu, () => {
				removeOption(z.admiral, "Risk a Raptor for Icy Moon");
				removeOption(z.admiral, "Do not risk a Raptor for Icy Moon");
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " risks the Raptor.") + "\r\n";
				SPTokenBad("Icy Moon", z.admiral);
				if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3])) {
					plainAlert("Remember that Racetrack may use her Expert Raptor Pilot ability to reroll the die.");
				}
				mainMenu();
			});
		} else if(ch === "Do not risk a Raptor for Icy Moon") {
			confirmify("Confirming you do NOT want to risk a Raptor for Icy Moon.", mainMenu, () => {
				removeOption(z.admiral, "Risk a Raptor for Icy Moon");
				removeOption(z.admiral, "Do not risk a Raptor for Icy Moon");
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " does not risk the Raptor.") + "\r\n";
				addAlert("You chose not to risk the Raptor.");
				mainMenu();
			});
		} else if(ch === "Risk a Raptor for Tylium Planet") {
			confirmify("Confirming you want to risk a Raptor for Tylium Planet.", mainMenu, () => {
				removeOption(z.admiral, "Risk a Raptor for Tylium Planet");
				removeOption(z.admiral, "Do not risk a Raptor for Tylium Planet");
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " risks the Raptor.") + "\r\n";
				SPTokenBad("Tylium Planet", z.admiral);
				if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3])) {
					plainAlert("Remember that Racetrack may use her Expert Raptor Pilot ability to reroll the die.");
				}
				mainMenu();
			});
		} else if(ch === "Do not risk a Raptor for Tylium Planet") {
			confirmify("Confirming you do NOT want to risk a Raptor for Tylium Planet.", mainMenu, () => {
				removeOption(z.admiral, "Risk a Raptor for Tylium Planet");
				removeOption(z.admiral, "Do not risk a Raptor for Tylium Planet");
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " does not risk the Raptor.") + "\r\n";
				addAlert("You chose not to risk the Raptor.");
				mainMenu();
			});
		} else if(ch === "[Cylon Refinery] Sometimes you have to roll the hard six") {
			confirmify("Confirming you want to risk two Vipers for Cylon Refinery.", mainMenu, () => {
				removeOption(z.admiral, "[Cylon Refinery] Sometimes you have to roll the hard six");
				removeOption(z.admiral, "[Cylon Refinery] Do not risk the vipers");
				SPTokenBad("Cylon Refinery", z.admiral);
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " risks the Vipers.") + "\r\n";
				if(vipersVIIReserves() > 0 || assaultRaptorsReserves() > 0) {
					/* RULES: is this right? */
					plainAlert("The Admiral should make sure to specify in thread which Vipers they are risking.");
				}
				mainMenu();
			});
		} else if(ch === "[Cylon Refinery] Do not risk the vipers") {
			confirmify("Confirming you do NOT want to risk the Vipers for Cylon Refinery.", mainMenu, () => {
				removeOption(z.admiral, "[Cylon Refinery] Sometimes you have to roll the hard six");
				removeOption(z.admiral, "[Cylon Refinery] Do not risk the vipers");
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] + " does not risk the Vipers.") + "\r\n";
				addAlert("You chose not to risk the Vipers.");
				mainMenu();
			});
		} else if(ch.slice(0, -1) === "Launch a Viper Mk II in Sector ") {
			let sector = parseInt(ch.slice(-1));
			confirmify("Confirming you want to launch a Viper Mk II in Sector " + sector + ".", mainMenu, () => {
				boldAlert(myPlayer + " launches a Viper Mk II in Sector " + sector + ".");
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(z.vipersII[j] === 0) {
						z.vipersII[j] = sector;
						if(canAVP()) {
							z.avp.push(j);
							plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
							addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
						}
						break;
					}
				}
				if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
					let num = getContext(me, "Activate an unmanned Viper");
					let man = isMandatory(me, "Activate an unmanned Viper");
					removeOption(me, "Activate an unmanned Viper");
					if(num > 1) {
						addOption(me, "Activate an unmanned Viper", num - 1, man);
					} else {
						menuPage = "Default";
					}
					if(z.eventHorizon && z.gravityWell) {
						z.gravityWell = false;
					}
				} else if(Number.isInteger(getContext(me, ch))) {
					let num = getContext(me, ch);
					if(num > 1) {
						if(vipersIIReserves() > 0) {
							addOption(me, "Launch a Viper Mk II in Sector " + sector, num - 1, true);
						} else {
							removeOption(me, "Launch a Viper Mk II in Sector " + sector);
						}
						if(vipersVIIReserves() > 0) {
							addOption(me, "Launch a Viper Mk VII in Sector " + sector, num - 1, true);
						} else {
							removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
						}
						if(assaultRaptorsReserves() > 0) {
							addOption(me, "Launch an Assault Raptor in Sector " + sector, num - 1, true);
						} else {
							removeOption(me, "Launch an Assault Raptor in Sector " + sector);
						}
					} else {
						removeOption(me, "Launch a Viper Mk II in Sector " + sector);
						removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
						removeOption(me, "Launch an Assault Raptor in Sector " + sector);
					}
					let otherSector = 5;
					if(sector === 5){
						otherSector = 6;
					}
					if(vipersIIReserves() === 0){
						removeOption(me, "Launch a Viper Mk II in Sector " + otherSector);
					}
				}
				mainMenu();
			});
		} else if(ch.slice(0, -1) === "Launch a Viper Mk VII in Sector ") {
			let sector = parseInt(ch.slice(-1));
			if(z.CFB) {
				confirmify("Confirming you want to launch a Viper Mk VII in Sector " + sector + ".", mainMenu, () => {
					boldAlert(myPlayer + " launches a Viper Mk VII in Sector " + sector + ".");
					for(let j = 0; !(j >= z.vipersVII.length); j++) {
						if(z.vipersVII[j] === 0) {
							z.vipersVII[j] = sector;
							if(canAVP()) {
								z.avp.push(8 + j);
								plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
								addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
							}
							break;
						}
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
						if(z.eventHorizon && z.gravityWell) {
							z.gravityWell = false;
						}
					} else if(Number.isInteger(getContext(me, ch))) {
						let num = getContext(me, ch);
						
						if(num > 1) {
							if(vipersIIReserves() > 0) {
								addOption(me, "Launch a Viper Mk II in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch a Viper Mk II in Sector " + sector);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, "Launch a Viper Mk VII in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, "Launch an Assault Raptor in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch an Assault Raptor in Sector " + sector);
							}
						} else {
							removeOption(me, "Launch a Viper Mk II in Sector " + sector);
							removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
							removeOption(me, "Launch an Assault Raptor in Sector " + sector);
						}
						let otherSector = 5;
						if(sector === 5){
							otherSector = 6;
						}
						if(vipersVIIReserves() === 0){
							removeOption(me, "Launch a Viper Mk VII in Sector " + otherSector);
						}
					}
					mainMenu();
				});
			} else {
				mainMenu();
			}
		} else if(ch.slice(0, -1) === "Launch an Assault Raptor in Sector ") {
			let sector = parseInt(ch.slice(-1));
			if(z.daybreak) {
				confirmify("Confirming you want to launch an Assault Raptor in Sector " + sector + ".", mainMenu, () => {
					boldAlert(myPlayer + " launches an Assault Raptor in Sector " + sector + ".");
					for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
						if(z.assaultRaptors[j] === 0) {
							z.assaultRaptors[j] = sector;
							if(canAVP()) {
								z.avp.push(12 + j);
								plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
								addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
							}
							break;
						}
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
						if(z.eventHorizon && z.gravityWell) {
							z.gravityWell = false;
						}
					} else if(Number.isInteger(getContext(me, ch))) {
						let num = getContext(me, ch);
						
						if(num > 1) {
							if(vipersIIReserves() > 0) {
								addOption(me, "Launch a Viper Mk II in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch a Viper Mk II in Sector " + sector);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, "Launch a Viper Mk VII in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, "Launch an Assault Raptor in Sector " + sector, num - 1, true);
							} else {
								removeOption(me, "Launch an Assault Raptor in Sector " + sector);
							}
						} else {
							removeOption(me, "Launch a Viper Mk II in Sector " + sector);
							removeOption(me, "Launch a Viper Mk VII in Sector " + sector);
							removeOption(me, "Launch an Assault Raptor in Sector " + sector);
						}
					} else if(getContext(me, ch) === "Trial by Fire") {
						removeOption(me, "Launch an Assault Raptor in Sector 5");
						removeOption(me, "Launch an Assault Raptor in Sector 6");
						addOption(z.turn, "Activate an unmanned Viper", 1, false);
						menuPage = "[Manual Viper Activation]";
					}
					let otherSector = 5;
					if(sector === 5){
						otherSector = 6;
					}
					if(assaultRaptorsReserves() === 0){
						removeOption(me, "Launch an Assault Raptor in Sector " + otherSector);
					}
					mainMenu();
				});
			} else {
				mainMenu();
			}
		} else if(ch === "Order an attack on a Raider") {
			let possibleSectors = [];
			let numSectors = 0;
			let lastSector = 0;
			for(let j = 1; !(j > 6); j++) {
				let foundRaider = false;
				for(let k = 0; !(k >= z.raiders.length); k++) {
					if(z.raiders[k] === j) {
						foundRaider = true;
						break;
					}
				}
				if(!foundRaider) {
					possibleSectors.push(false);
					continue;
				}
				let foundViper = false;
				for(let k = 0; !foundViper && !(k >= z.vipersII.length); k++) {
					foundViper = z.vipersII[k] === j;
				}
				for(let k = 0; !foundViper && z.CFB && !(k >= z.vipersVII.length); k++) {
					foundViper = z.vipersVII[k] === j;
				}
				for(let k = 0; !foundViper && z.daybreak && !(k >= z.assaultRaptors.length); k++) {
					foundViper = z.assaultRaptors[k] === j;
				}
				possibleSectors.push(foundViper);
				if(foundViper) {
					numSectors++;
					lastSector = j;
				}
			}
			if(numSectors === 1) {
				confirmify("Confirming you'd like to order an attack on a Raider in Sector " + lastSector + ".", mainMenu, () => {
					boldAlert(myPlayer + " orders an attack on a Raider in Sector " + lastSector + ".");
					z.dieRoller = me;
					z.dieRollQueue.push("Viper vs. Raider (Sector " + lastSector + ")");
					if(z.ambush) {
						plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
						z.dieRollModifier = -2;
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
					}
					if(z.eventHorizon && z.gravityWell) {
						z.gravityWell = false;
					}
					mainMenu();
				});
			} else if(numSectors > 0) {
				let promptText = "In which Sector are you ordering an attack on a Raider? (1-6)";
				for(let j = 1; !(j > 6); j++) {
					promptText += "\n" + j + ": ";
					if(possibleSectors[j - 1]) {
						promptText += "Sector " + j;
					} else {
						promptText += "(cannot attack here)";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 6 || !possibleSectors[a - 1], mainMenu, (prompted) => {
					boldAlert(myPlayer + " orders an attack on a Raider in Sector " + prompted + ".");
					z.dieRoller = me;
					z.dieRollQueue.push("Viper vs. Raider (Sector " + prompted + ")");
					if(z.ambush) {
						plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
						z.dieRollModifier = -2;
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
					}
					if(z.eventHorizon && z.gravityWell) {
						z.gravityWell = false;
					}
					mainMenu();
				});
			}
		} else if(ch === "Order an attack on a Heavy Raider") {
			let possibleSectors = [];
			let numSectors = 0;
			let lastSector = 0;
			for(let j = 1; !(j > 6); j++) {
				let foundRaider = false;
				for(let k = 0; !(k >= z.heavies.length); k++) {
					if(z.heavies[k] === j) {
						foundRaider = true;
						break;
					}
				}
				if(!foundRaider) {
					possibleSectors.push(false);
					continue;
				}
				let foundViper = false;
				for(let k = 0; !foundViper && !(k >= z.vipersII.length); k++) {
					foundViper = z.vipersII[k] === j;
				}
				for(let k = 0; !foundViper && z.CFB && !(k >= z.vipersVII.length); k++) {
					foundViper = z.vipersVII[k] === j;
				}
				for(let k = 0; !foundViper && z.daybreak && !(k >= z.assaultRaptors.length); k++) {
					foundViper = z.assaultRaptors[k] === j;
				}
				possibleSectors.push(foundViper);
				if(foundViper) {
					numSectors++;
					lastSector = j;
				}
			}
			
			let doAttack = (prompted,AR) => {
				let viperText = "a Viper";
				if(AR){
					viperText = "an Assault Raptor";
				}
				boldAlert(myPlayer + " orders an attack on a Heavy Raider with "+viperText+" in Sector " + prompted + ".");
				z.dieRoller = me;
				if(AR){
					z.dieRollQueue.push("Assault Raptor vs. Heavy Raider (Sector " + prompted + ")");
				} else {
					z.dieRollQueue.push("Viper vs. Heavy Raider (Sector " + prompted + ")");
				}
				if(z.ambush) {
					plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
					z.dieRollModifier = -2;
				}
				if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
					let num = getContext(me, "Activate an unmanned Viper");
					let man = isMandatory(me, "Activate an unmanned Viper");
					removeOption(me, "Activate an unmanned Viper");
					if(num > 1) {
						addOption(me, "Activate an unmanned Viper", num - 1, man);
					} else {
						menuPage = "Default";
					}
				}
				mainMenu();
			};
			
			if(numSectors === 1) {
				let foundBoth = false;
				let foundAR = false;
				let foundViper = false;
				if(z.vBrutality && z.daybreak){
					for(let k = 0; !foundAR && !(k >= z.assaultRaptors.length); k++) {
						foundAR = z.assaultRaptors[k] === lastSector;
					}
					for(let k = 0; !foundViper && !(k >= z.vipersII.length); k++) {
						foundViper = z.vipersII[k] === lastSector;
					}
					for(let k = 0; !foundViper && z.CFB && !(k >= z.vipersVII.length); k++) {
						foundViper = z.vipersVII[k] === lastSector;
					}
					foundBoth = foundAR && foundViper;
				}
				if(foundBoth){
					let promptText = "Would you like to attack with an Assault Raptor or a Viper?\n1: Assault Raptor\n2: Viper";
					promptNum(promptText,(a)=>1>a||a>2,mainMenu,(a)=>{
						if(a===1){
							doAttack(lastSector,true);
						} else {
							doAttack(lastSector,false);
						}
					});
				} else {
					confirmify("Confirming you'd like to order an attack on a Heavy Raider in Sector " + lastSector + ".", mainMenu, () => {
						doAttack(lastSector,foundAR);
					});
				}
			} else if(numSectors > 0) {
				let promptText = "In which Sector are you ordering an attack on a Heavy Raider? (1-6)";
				for(let j = 1; !(j > 6); j++) {
					promptText += "\n" + j + ": ";
					if(possibleSectors[j - 1]) {
						promptText += "Sector " + j;
					} else {
						promptText += "(cannot attack here)";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 6 || !possibleSectors[a - 1], mainMenu, (prompted) => {
					let foundBoth = false;
					let foundAR = false;
					let foundViper = false;
					if(z.vBrutality && z.daybreak){
						for(let k = 0; !foundAR && !(k >= z.assaultRaptors.length); k++) {
							foundAR = z.assaultRaptors[k] === prompted;
						}
						for(let k = 0; !foundViper && !(k >= z.vipersII.length); k++) {
							foundViper = z.vipersII[k] === prompted;
						}
						for(let k = 0; !foundViper && z.CFB && !(k >= z.vipersVII.length); k++) {
							foundViper = z.vipersVII[k] === prompted;
						}
						foundBoth = foundAR && foundViper;
					}
					if(foundBoth){
						let promptText = "Would you like to attack with an Assault Raptor or a Viper?\n1: Assault Raptor\n2: Viper";
						promptNum(promptText,(a)=>1>a||a>2,mainMenu,(a)=>{
							if(a===1){
								doAttack(prompted,true);
							} else {
								doAttack(prompted,false);
							}
						});
					} else {
						confirmify("Confirming you'd like to order an attack on a Heavy Raider in Sector " + prompted + ".", mainMenu, () => {
							doAttack(prompted,foundAR);
						});
					}
					
				});
			}
		} else if(ch === "Order an attack on Scar") {
			confirmify("Confirming you want to order an attack on Scar.", mainMenu, () => {
				boldAlert(myPlayer + " orders an attack on Scar.");
				z.dieRoller = me;
				z.dieRollQueue.push("Viper vs. Scar");
				if(z.ambush) {
					plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
					z.dieRollModifier = -2;
				}
				if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
					let num = getContext(me, "Activate an unmanned Viper");
					let man = isMandatory(me, "Activate an unmanned Viper");
					removeOption(me, "Activate an unmanned Viper");
					if(num > 1) {
						addOption(me, "Activate an unmanned Viper", num - 1, man);
					} else {
						menuPage = "Default";
					}
				}
				if(z.eventHorizon && z.gravityWell) {
					z.gravityWell = false;
				}
				mainMenu();
			});
		} else if(ch === "Order an attack on a Basestar") {
			let options2 = [];
			let bsName = "";
			for(let j = 0; !(j >= z.basestars.length); j++) {
				if(0 >= z.basestars[j][0] || basestarName(j) === bsName) {
					continue;
				}
				bsName = basestarName(j);
				let foundViper = false;
				for(let k = 0; !foundViper && !(k >= z.vipersII.length); k++) {
					foundViper = z.vipersII[k] === z.basestars[j][0];
				}
				for(let k = 0; !foundViper && z.CFB && !(k >= z.vipersVII.length); k++) {
					foundViper = z.vipersVII[k] === z.basestars[j][0];
				}
				if(foundViper) {
					options2.push(["Order a Viper to attack the " + bsName + ".", bsName, false]);
				}
				for(let k = 0; z.daybreak && !(k >= z.assaultRaptors.length); k++) {
					if(z.assaultRaptors[k] === z.basestars[j][0]) {
						options2.push(["Order an Assault Raptor to attack the " + bsName + ".", bsName, true]);
						break;
					}
				}
			}
			if(options2.length === 1) {
				confirmify("Confirming you'd like to " + options2[0][0].slice(1), mainMenu, () => {
					boldAlert(myPlayer + " orders" + options2[0][0].slice(5));
					z.destroyer = me;
					z.dieRoller = me;
					if(options2[0][2]) {
						z.dieRollQueue.push("Assault Raptor vs. " + options2[0][1]);
					} else {
						z.dieRollQueue.push("Viper vs. " + options2[0][1]);
					}
					if(z.ambush) {
						plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
						z.dieRollModifier = -2;
					}
					if(/Structural Damage/.test(options2[0][1])) {
						z.dieRollModifier += 2;
						plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
					}
					if(z.eventHorizon && z.gravityWell) {
						z.gravityWell = false;
					}
					mainMenu();
				});
			} else if(options2.length > 1) {
				let promptText = "Which attack would you like to order? (1-" + options2.length + ")";
				for(let j = 0; !(j >= options2.length); j++) {
					promptText += "\n" + (j + 1) + ": " + options2[j][0];
				}
				promptNum(promptText, (a) => 1 > a || a > options2.length, mainMenu, (prompted) => {
					boldAlert(myPlayer + " orders" + options2[prompted - 1][0].slice(5));
					z.dieRoller = me;
					if(options2[prompted - 1][2]) {
						z.dieRollQueue.push("Assault Raptor vs. " + options2[prompted - 1][1]);
					} else {
						z.dieRollQueue.push("Viper vs. " + options2[prompted - 1][1]);
					}
					if(z.ambush) {
						plainAlert("Due to Training New Pilots [Ambush CAC], this attack suffers a -2 penalty.");
						z.dieRollModifier = -2;
					}
					if(/Structural Damage/.test(options2[prompted - 1][1])) {
						z.dieRollModifier += 2;
						plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
					}
					if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
						let num = getContext(me, "Activate an unmanned Viper");
						let man = isMandatory(me, "Activate an unmanned Viper");
						removeOption(me, "Activate an unmanned Viper");
						if(num > 1) {
							addOption(me, "Activate an unmanned Viper", num - 1, man);
						} else {
							menuPage = "Default";
						}
					}
					if(z.eventHorizon && z.gravityWell) {
						z.gravityWell = false;
					}
					mainMenu();
				});
			}
		} else if(ch === "Attack a Raider") {
			confirmify("Confirming you want to attack a Raider in " + myLocation + ".", mainMenu, () => {
				boldAlert(myPlayer + " attacks a Raider in " + myLocation + ".");
				z.dieRoller = me;
				z.dieRollQueue.push(myPlayer + " vs. Raider (" + myLocation + ")");
				if(getContext(me, ch) === "Full Throttle") {
					removeOption(me, ch);
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					removeOption(me, "[Full Throttle] Do not attack");
					if(z.phase === -1) {
						z.phase = 2;
					}
				} else if(Number.isInteger(getContext(me, ch))) {
					let num = getContext(me, ch);
					let man = isMandatory(me, ch);
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					if(num > 1) {
						if(canAttackRaider(true)) {
							addOption(me, "Attack a Raider", num - 1, man);
						}
						if(canAttackScar(true)) {
							addOption(me, "Attack Scar", num - 1, man);
						}
						if(canAttackHeavy(true)) {
							addOption(me, "Attack a Heavy Raider", num - 1, man);
						}
						if(canAttackBasestar(true)) {
							addOption(me, "Attack a Basestar", num - 1, man);
						}
					}
				} else {
					didAction();
					if(z.eventHorizon) {
						z.gravityWell = false;
					}
				}
				mainMenu();
			});
		} else if(ch === "Attack Scar") {
			confirmify("Confirming you want to attack Scar.", mainMenu, () => {
				boldAlert(myPlayer + " attacks Scar.");
				z.dieRoller = me;
				z.dieRollQueue.push(myPlayer + " vs. Scar");
				if(getContext(me, ch) === "Full Throttle") {
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					removeOption(me, "[Full Throttle] Do not attack");
					if(z.phase === -1) {
						z.phase = 2;
					}
				} else if(Number.isInteger(getContext(me, ch))) {
					let num = getContext(me, ch);
					let man = isMandatory(me, ch);
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					if(num > 1) {
						if(canAttackRaider(true)) {
							addOption(me, "Attack a Raider", num - 1, man);
						}
						if(canAttackScar(true)) {
							addOption(me, "Attack Scar", num - 1, man);
						}
						if(canAttackHeavy(true)) {
							addOption(me, "Attack a Heavy Raider", num - 1, man);
						}
						if(canAttackBasestar(true)) {
							addOption(me, "Attack a Basestar", num - 1, man);
						}
					}
				} else {
					didAction();
					if(z.eventHorizon) {
						z.gravityWell = false;
					}
				}
				mainMenu();
			});
		} else if(ch === "Attack a Heavy Raider") {
			confirmify("Confirming you want to attack a Heavy Raider in " + myLocation + ".", mainMenu, () => {
				boldAlert(myPlayer + " attacks a Heavy Raider in " + myLocation + ".");
				z.dieRoller = me;
				z.dieRollQueue.push(myPlayer + " vs. Heavy Raider (" + myLocation + ")");
				if(getContext(me, ch) === "Full Throttle") {
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					removeOption(me, "[Full Throttle] Do not attack");
					if(z.phase === -1) {
						z.phase = 2;
					}
				} else if(Number.isInteger(getContext(me, ch))) {
					let num = getContext(me, ch);
					let man = isMandatory(me, ch);
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					if(num > 1) {
						if(canAttackRaider(true)) {
							addOption(me, "Attack a Raider", num - 1, man);
						}
						if(canAttackScar(true)) {
							addOption(me, "Attack Scar", num - 1, man);
						}
						if(canAttackHeavy(true)) {
							addOption(me, "Attack a Heavy Raider", num - 1, man);
						}
						if(canAttackBasestar(true)) {
							addOption(me, "Attack a Basestar", num - 1, man);
						}
					}
				} else {
					didAction();
					if(z.eventHorizon) {
						z.gravityWell = false;
					}
				}
				mainMenu();
			});
		} else if(ch === "Attack a Basestar") {
			let sector = parseInt(myLocation.slice(7));
			let bsName = "";
			let attackBasestar = function() {
				boldAlert(myPlayer + " attacks " + bsName + ".");
				z.destroyer = me;
				z.dieRoller = me;
				z.dieRollQueue.push(myPlayer + " vs. " + bsName);
				if(/Structural Damage/.test(bsName)) {
					z.dieRollModifier = 2;
					plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
				}
				if(getContext(me, ch) === "Full Throttle") {
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					removeOption(me, "[Full Throttle] Do not attack");
					if(z.phase === -1) {
						z.phase = 2;
					}
				} else if(Number.isInteger(getContext(me, ch))) {
					let num = getContext(me, ch);
					let man = isMandatory(me, ch);
					removeOption(me, "Attack a Raider");
					removeOption(me, "Attack Scar");
					removeOption(me, "Attack a Heavy Raider");
					removeOption(me, "Attack a Basestar");
					if(num > 1) {
						if(canAttackRaider(true)) {
							addOption(me, "Attack a Raider", num - 1, man);
						}
						if(canAttackScar(true)) {
							addOption(me, "Attack Scar", num - 1, man);
						}
						if(canAttackHeavy(true)) {
							addOption(me, "Attack a Heavy Raider", num - 1, man);
						}
						if(canAttackBasestar(true)) {
							addOption(me, "Attack a Basestar", num - 1, man);
						}
					}
				} else {
					didAction();
					if(z.eventHorizon) {
						z.gravityWell = false;
					}
				}
				mainMenu();
			};
			if(z.basestars.length === 2 && z.basestars[0][0] === sector && z.basestars[1][0] === sector && (z.basestars[0].length > 1 || z.basestars[1]
					.length > 1)) {
				confirmify("Which basestar do you want to attack?\n1: " + basestarName(0) + "\n2: " + basestarName(1), () => {
					bsName = basestarName(1);
					attackBasestar();
				}, () => {
					bsName = basestarName(0);
					attackBasestar();
				}, "Basestar 1", "Basestar 2");
			} else {
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === sector) {
						bsName = basestarName(j);
						attackBasestar();
						break;
					}
				}
			}
		} else if(ch === "Use your CAG title to activate an unmanned viper") {
			confirmify("Confirming you want to use your CAG title to activate an unmanned viper.", mainMenu, () => {
				boldAlert("CAG " + myPlayer + " uses the bottom option on their CAG title card to activate an unmanned viper.");
				z.cagTitle = false;
				menuPage = "[Manual Viper Activation]"; 
				addOption(me, "Activate an unmanned Viper", 1, true);
				mainMenu();
			});
		} else if(ch === "Use your CAG title to activate an unmanned Viper then pass the CAG title") {
			confirmify("Confirming you want to use your CAG title to activate an unmanned viper, then pass the CAG title to another player", mainMenu,
			() => {
				boldAlert("CAG " + myPlayer +
					" uses the top option on their CAG title card to activate an unmanned viper, then pass the CAG title.");
				menuPage = "[Manual Viper Activation]";
				addOption(me, "Activate an unmanned Viper", 1, true);
				let noTarget = true;
				for(let j = 0; !(j>=z.numPlayers); j++){
					if(z.revealedCylons[j] === 1 || isCylonLeader(z.players[j]) || j === z.theSympatheticCylon || z.playerLocations[j] === "Brig"){
						continue;
					}
					noTarget = false;
					break;
				}
				if(noTarget){
					boldAlert(myPlayer + " keeps the CAG title as there are no other eligible players.");
				} else {
					addOption(z.cag, "Move the CAG title", "CAG card", true);
				}
				didAction();
				mainMenu();
			});
		} else if(ch === "Pass on Strategic Planning") {
			confirmify("Confirming you want to pass on Strategic Planning.", mainMenu, () => {
				addAlert("You pass on Strategic Planning; token updated.");
				z.sps[me] = 0;
				SPToken(z.dieRollQueue[0]);
				mainMenu();
			});
		} else if(ch === "Pass on Declare Emergency") {
			confirmify("Confirming you want to pass on Declare Emergency.", mainMenu, () => {
				addAlert("You pass on Declare Emergency; token updated.");
				z.des[me] = 0;
				DEToken();
				mainMenu();
			}); /* TODO: a Cylon may want to get executed from a crisis; give them rare options to do so (or discard randomly) */
		} else if(ch.slice(0, 10) === "Roll a die") {
			confirmify("Confirming you want to roll a die for " + z.dieRollQueue[0] + ".", mainMenu, () => {
				z.spToken = false;
				z.lastDieRoll = z.dieRollQueue.shift(); /* TODO: hash by other things as well? (turn) */
				z.lastDieRollValue = ((z.dieRolls.pop() - 1 + hashString(z.lastDieRoll[0])) % 8) + 1;
				if(z.dieRolls.length === 0) {
					for(let j = 0; !(j >= 250); j++) {
						let rando = Math.floor((z.seed * 8)/mLCG) + 1;
						updateSeed();
						z.dieRolls.push(rando);
					}
				}
				if(z.dieRollModifier === 0) {
					addAlert("You roll a " + z.lastDieRollValue + ".");
				} else if(z.dieRollModifier > 0) {
					addAlert("You roll a " + z.lastDieRollValue + " + " + z.dieRollModifier + " = " + (z.lastDieRollValue + z.dieRollModifier));
				} else {
					addAlert("You roll a " + z.lastDieRollValue + " - " + (-z.dieRollModifier) + " = " + (z.lastDieRollValue + z
						.dieRollModifier));
				}
				z.lastDieRollModifier = z.dieRollModifier;
				t.value += dieRollImage() + "\r\n";
				if(!canModifyDieRoll()) {
					processDieRoll();
				}
				mainMenu();
			});
		} else if(ch === "Process the outcome of the die roll") {
			confirmify("Confiming you want to process the outcome of the die roll for " + z.lastDieRoll + " (result was a " + (z.lastDieRollValue + z
				.lastDieRollModifier) + ").", mainMenu, () => {
				processDieRoll();
				mainMenu();
			});
		} else if(ch.slice(0, 20) === "Deal a Skill Card to") {
			let target = ch.slice(21);
			let promptText = "Which color skill card would you like to deal to " + target +
				"? (1-6)\n1: Politics\n2: Leadership\n3: Tactics\n4: Piloting\n5: Engineering\n6: Treachery";
			promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				dealSkillCard(getPlayerNum(target), prompted - 1);
				addAlert("Dealt a " + colorIDAlert(prompted - 1) + " card to " + target + ".");
				removeOption(me, ch);
				endMovement();
				mainMenu();
			});
		} else if(ch === "Rebuild the empty Quorum Deck") {
			plainAlert("Rebuilding the empty Quorum deck.");
			z.quorumDeck = shuffle(z.quorumDiscards);
			z.quorumDiscards = [];
			mainMenu();
		} else if(ch === "Make Apollo discard down to his hand limit") {
			if(characterPresent("Apollo") && z.skillCardHands[getPlayerNum("Apollo")].length > 10) {
				confirmify("Confirming you want to make Apollo discard random skill cards until he has 10 skill cards in hand.", mainMenu, () => {
					while(z.skillCardHands[getPlayerNum("Apollo")].length > 10) {
						discardRandomSkillCard(getPlayerNum("Apollo"));
					}
					removeFromAll(ch);
					mainMenu();
				});
			} else {
				addAlert("Apollo does not need to discard for hand limit.");
				removeFromAll("Make Apollo discard down to his hand limit");
				mainMenu();
			}
		} else if(ch === "Make Apollo discard randomly") {
			if(characterPresent("Apollo") && hasOption(getPlayerNum("Apollo"), "Discard a random Skill Card")) {
				let num = getContext(getPlayerNum("Apollo"), "Discard a random Skill Card");
				let s = "";
				if(num > 1) {
					s = "s";
				}
				confirmify("Confirming you want to make Apollo discard " + num + " random Skill Card" + s, mainMenu, () => {
					for(let j = 0; !(j >= num); j++) {
						discardRandomSkillCard(getPlayerNum("Apollo"));
					}
					removeFromAll(ch);
					removeOption(getPlayerNum("Apollo"), "Discard a random Skill Card");
					mainMenu();
				});
			} else {
				addAlert("Apollo does not need to discard at this time.");
				removeFromAll("Make Apollo discard randomly");
				mainMenu();
			}
		} else if(ch === "Trigger the random discards from the Final Five") {
			confirmify(
				"Confirming you want to trigger the random discards from the Final Five card that was just inspected.  Make sure the execution has been fully processed first.",
				mainMenu, () => {
					cleanLove();
					removeFromAll(ch);
					mainMenu();
				});
		} else if(ch === "TANK this skill check") {
			confirmify(
				"Confirming you want to TANK this skill check.  You will automatically pass on interrupts and contributions to the skill check. " +
				"The TANK order will be automatically cancelled if anyone else plays a skill card into the skill check.", mainMenu, () => {
					z.tank[me] = true;
					addAlert("TANK order submitted.");
					let interruptsPhase = true;
					for(let j = 0; !(j > z.numPlayers); j++) {
						if(z.skillCheckCards[j].length > 0) {
							interruptsPhase = false;
						}
					}
					if(interruptsPhase) {
						interruptsToken();
					} else {
						skillCheckToken();
					}
					mainMenu();
				});
		} else if(ch === "Cancel your TANK order") {
			confirmify("Confirming you want to cancel your TANK order for this skill check.", mainMenu, () => {
				z.tank[me] = false;
				addAlert("TANK order cancelled.");
				let interruptsPhase = true;
				for(let j = 0; !(j > z.numPlayers); j++) {
					if(z.skillCheckCards[j].length > 0) {
						interruptsPhase = false;
					}
				}
				let contributingMe = (me - (z.turn + 1) + z.numPlayers) % z.numPlayers;
				if(z.contributingPlayer > contributingMe){
					z.contributingPlayer = contributingMe;
				}
				if(interruptsPhase) {
					interruptsToken();
				} else {
					skillCheckToken();
				}
				mainMenu();
			});
		} else if(ch === "Draw 1 Treachery") {
			confirmify("Confirming you want to draw 1 Treachery card.", mainMenu, () => {
				let card = dealSkillCard(me, 5);
				addAlert("You draw " + cardName(card));
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Draw 2 Treachery") {
			confirmify("Confirming you want to draw 2 Treachery cards.", mainMenu, () => {
				let card1 = dealSkillCard(me, 5);
				let card2 = dealSkillCard(me, 5);
				addAlert("You draw " + cardName(card1) + " and " + cardName(card2));
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Draw 3 Treachery") {
			confirmify("Confirming you want to draw 3 Treachery cards.", mainMenu, () => {
				let card1 = dealSkillCard(me, 5);
				let card2 = dealSkillCard(me, 5);
				let card3 = dealSkillCard(me, 5);
				addAlert("You draw " + cardName(card1) + ", " + cardName(card2) + ", and " + cardName(card3));
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Draw 6 Treachery") {
			confirmify("Confirming you want to draw 6 Treachery cards.", mainMenu, () => {
				let card1 = dealSkillCard(me, 5);
				let card2 = dealSkillCard(me, 5);
				let card3 = dealSkillCard(me, 5);
				let card4 = dealSkillCard(me, 5);
				let card5 = dealSkillCard(me, 5);
				let card6 = dealSkillCard(me, 5);
				addAlert("You draw:\n" + cardName(card1) + "\n" + cardName(card2) + "\n" + cardName(card3) + "\n" + cardName(card4) + "\n" +
					cardName(card5) + "\n" + cardName(card6));
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "[Scapegoat] Pick a target") {
			let promptText = "Who would you like to target with Scapegoat?  They will draw 2 skill cards and 2 trauma tokens.";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j === me) {
					promptText += "(cannot target yourself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me, mainMenu, (prompted) => {
				boldAlert(z.players[me] + " makes " + z.players[prompted - 1] + " a Scapegoat.");
				addOption(prompted - 1, "Draw 2 Skill Cards", undefined, true);
				addOption(prompted - 1, "[Scapegoat] Draw Trauma Tokens", undefined, true);
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "[Forgiven] Pick a target") {
			let promptText = "Who would you like to target with Forgiven?  They will discard 2 random skill cards and may discard 2 trauma tokens.";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j === me) {
					promptText += "(cannot target yourself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me, mainMenu, (prompted) => {
				boldAlert(z.players[me] + " Forgives " + z.players[prompted - 1] + ".");
				if(!z.forLove || z.players[prompted - 1] === "Athena") {
					if(z.skillCardHands[prompted - 1].length > 0) {
						discardRandomSkillCard(prompted - 1);
					}
					if(z.skillCardHands[prompted - 1].length > 0) {
						discardRandomSkillCard(prompted - 1);
					}
				} else {
					plainAlert(z.players[prompted - 1] + " must discard 2 random skill cards, but Athena may be able to Love them.");
					addOption(prompted - 1, "Discard a random Skill Card", 1, true);
					z.randomLove[prompted - 1] = true;
				}
				addOption(prompted - 1, "Discard a Trauma Token", 2, false);
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Draw 2 Skill Cards") {
			/* TODO: context persistence issues for Support the People; remove once destiny played in or it's switched out for guts? */
			let drawOptions = [0, 0, 0, 0, 0];
			if(z.pegasus || z.daybreak) {
				drawOptions.push(0);
			}
			if((z.revealedCylons[me] === 1 && !isCylonLeader(myPlayer)) || me === z.theSympatheticCylon) {
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = 1;
				}
			} else {
				let chr = getCharacter(myPlayer);
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = d.skillSets[j][chr];
				}
			}
			let card1 = -1;
			let card2 = -1;
			let drawCard = function(k) {
				if(k === 2) {
					let confirmText = "Confirming you want to draw ";
					if(card1 === card2) {
						confirmText += "2 " + colorIDAlert(card1) + ".";
					} else {
						confirmText += "1 " + colorIDAlert(card1) + " and 1 " + colorIDAlert(card2) + ".";
					}
					confirmify(confirmText, mainMenu, () => {
						card1 = dealSkillCard(me, card1);
						card2 = dealSkillCard(me, card2);
						addAlert("You drew " + cardText(card1) + " and " + cardText(card2) + ".");
						removeOption(me, ch);
						mainMenu();
					});
				} else {
					let promptText = "What is the ";
					if(k === 0) {
						promptText += "first";
					} else {
						promptText += "second";
					}
					promptText += " card you would like to draw? (1-" + drawOptions.length + ")";
					for(let j = 0; !(j >= drawOptions.length); j++) {
						promptText += "\n" + (j + 1) + ": ";
						if(drawOptions[j] === 1) {
							promptText += colorIDAlert(j);
						} else {
							promptText += "(not in your skill set)";
						}
					}
					promptNum(promptText, (a) => 1 > a || a > drawOptions.length || drawOptions[a - 1] === 0, mainMenu, (prompted) => {
						if(k === 0) {
							card1 = prompted - 1;
						} else {
							card2 = prompted - 1;
						}
						drawCard(k + 1);
					});
				}
			};
			let context = getContext(me,ch);
			if(context === "Support the People" && z.skillCardHands[me].length > 4){
				addAlert("You cannot benefit from Support the People while you have more than 4 skill cards in hand.");
				mainMenu();
			} else {
				drawCard(0);
			}
		} else if(ch === "[Ruined Reputation] Choose a target") {
			let promptText =
				"Who would you like to target with Ruined Reputation?  They will draw 2 skill cards of any color and on a die roll of 1-4 will go to the Brig/Detention.";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.revealedCylons[j] === 1) {
					promptText += "[CYLON]";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1, mainMenu, (prompted) => {
				boldAlert(z.players[me] + " targets " + z.players[prompted - 1] + ".");
				addOption(prompted - 1, "Draw 2 Skill Cards (any color)", 1, true);
				boldAlert(z.players[prompted - 1] + " must draw 2 skill cards (they may be outside their skill set).");
				SPTokenBad("Ruined Reputation vs. " + z.players[prompted - 1]);
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Draw 2 Skill Cards (any color)") {
			let card1 = -1;
			let card2 = -1;
			let maxColor = 5;
			if(z.pegasus || z.daybreak) {
				maxColor++;
			}
			let humanFleet = hasContext(me, ch, "Pegasus Human Fleet");
			let drawCard = function(k) {
				if(k === 2) {
					let confirmText = "Confirming you want to draw ";
					if(card1 === card2) {
						confirmText += "2 " + colorIDAlert(card1) + ".";
					} else {
						confirmText += "1 " + colorIDAlert(card1) + " and 1 " + colorIDAlert(card2) + ".";
					}
					confirmify(confirmText, mainMenu, () => {
						card1 = dealSkillCard(me, card1);
						card2 = dealSkillCard(me, card2);
						addAlert("You drew " + cardText(card1) + " and " + cardText(card2) + ".");
						let n = getContext(me, ch);
						let man = isMandatory(me, ch);
						if(Number.isInteger(n) && n > 1) {
							addOption(me, ch, n - 1, man);
						} else if(Array.isArray(n) && n[0] === "The Opera House Discovery") {
							drawSuperCrisis();
							removeOption(me, ch);
							if(n[1] > 1) {
								addOption(me, ch, ["The Opera House Discovery", n[1] - 1], true);
							}
						} else {
							removeOption(me, ch);
						}
						mainMenu();
					});
				} else {
					let promptText = "What is the ";
					if(k === 0) {
						promptText += "first";
					} else {
						promptText += "second";
					}
					promptText += " card you would like to draw? (1-" + maxColor + ")";
					for(let j = 0; !(j >= maxColor); j++) {
						promptText += "\n" + (j + 1) + ": ";
						if(!humanFleet || j !== card1) {
							promptText += colorIDAlert(j);
						} else {
							promptText += "(must draw 2 different colors)";
						}
					}
					promptNum(promptText, (a) => 1 > a || a > maxColor || (humanFleet && k === 1 && a - 1 === card1), mainMenu, (prompted) => {
						if(k === 0) {
							card1 = prompted - 1;
						} else {
							card2 = prompted - 1;
						}
						drawCard(k + 1);
					});
				}
			};
			drawCard(0);
		} else if(ch === "[Star Player] Draw Skill Cards") {
			let drawOptions = [0, 1, 1, 1, 0];
			if(z.pegasus || z.daybreak) {
				drawOptions.push(0);
			}
			let promptText = "What color of skill card would you like to draw? (1-" + drawOptions.length + ")";
			for(let j = 0; !(j >= drawOptions.length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(drawOptions[j] === 1) {
					promptText += colorIDAlert(j);
				} else {
					promptText += "(not in your skill set)";
				}
			}
			let context = getContext(me, ch);
			promptNum(promptText, (a) => 1 > a || a > drawOptions.length || drawOptions[a - 1] === 0, mainMenu, (prompted) => {
				confirmify("Confirming you want to draw " + context + " " + colorIDAlert(prompted - 1) + ".", mainMenu, () => {
					let alertText = "You drew:";
					for(let j = 0; !(j >= context); j++) {
						let card = dealSkillCard(me, prompted - 1);
						alertText += "\n" + cardText(card);
					}
					addAlert(alertText);
					removeOption(me, ch);
					removeOption(me, "[Star Player] Discard a Skill Card");
					if(me === z.turn && z.phase === -1) {
						endMovement();
					}
					mainMenu();
				});
			});
		} else if(ch === "Draw 1 Skill Card") {
			let drawOptions = [0, 0, 0, 0, 0];
			if(z.pegasus || z.daybreak) {
				drawOptions.push(0);
			}
			if((z.revealedCylons[me] === 1 && !isCylonLeader(myPlayer)) || me === z.theSympatheticCylon) {
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = 1;
				}
			} else {
				let chr = getCharacter(myPlayer);
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = d.skillSets[j][chr];
				}
				if(z.assist !== undefined && z.drawSkills) {
					let chr = getCharacter(z.assist);
					for(let j = 0; !(j >= drawOptions.length); j++) {
						if(d.skillSets[j][chr] === 1) {
							drawOptions[j] = 1;
						}
					}
				}
			}
			let promptText = "What color card you would like to draw? (1-" + drawOptions.length + ")";
			for(let j = 0; !(j >= drawOptions.length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(drawOptions[j] === 1) {
					promptText += colorIDAlert(j);
				} else {
					promptText += "(not in your skill set)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > drawOptions.length || drawOptions[a - 1] === 0, mainMenu, (prompted) => {
				confirmify("Confirming you want to draw 1 " + colorIDAlert(prompted - 1) + ".", mainMenu, () => {
					let context = getContext(me,ch);
					if(context !== "Medical Breakthrough"){
						z.drawSkills = false;
						z.phase = 1;
					}
					let card = dealSkillCard(me, prompted - 1);
					addAlert("You drew " + cardText(card) + ".");
					removeOption(me, ch);
					mainMenu();
				});
			});
		} else if(ch === "Draw 1 Skill Card (any color)" || ch === "Draw a skill card for Delusional Intuition") {
			let drawOptions = [0, 0, 0, 0, 0];
			if(z.pegasus || z.daybreak) {
				drawOptions.push(0);
			}
			if((z.revealedCylons[me] === 1 && !isCylonLeader(myPlayer)) || me === z.theSympatheticCylon) {
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = 1;
				}
			} else {
				let chr = getCharacter(myPlayer);
				for(let j = 0; !(j >= drawOptions.length); j++) {
					drawOptions[j] = d.skillSets[j][chr];
				}
			}
			let promptText = "What color card you would like to draw? (1-" + drawOptions.length + ")";
			for(let j = 0; !(j >= drawOptions.length); j++) {
				promptText += "\n" + (j + 1) + ": " + colorIDAlert(j);
			}
			promptNum(promptText, (a) => 1 > a || a > drawOptions.length, mainMenu, (prompted) => {
				confirmify("Confirming you want to draw 1 " + colorIDAlert(prompted - 1) + ".", mainMenu, () => {
					let card = dealSkillCard(me, prompted - 1);
					addAlert("You drew " + cardText(card) + ".");
					if(hasContext(me, ch, "Investigative Journalism")) {
						z.drawSkills = true;
					} else if(hasContext(me, ch, "Investigative Journalism Hub")) {
						z.phase = 1;
					}
					removeOption(me, ch);
					mainMenu();
				});
			});
		} else if(ch === "Submit Conditional Order for a rare action") {
			let rareActions = [];
			if((characterPresent("Adama") && (z.miracles[getPlayerNum("Adama")] === 1 || z.daybreak) && !z.theFarm) || (z.assist === "Adama" && (z
					.assistMiracle === 1 || z.daybreak) && !z.theFarm) || (characterPresent("Gaius") && characterPresent("Adama") && z.vBrutality && !z
					.theFarm)) {
				rareActions.push("Command Authority [Adama's OPG]");
			}
			if(((characterPresent("Chief") && z.miracles[getPlayerNum("Chief")] === 1) || (z.assist === "Chief" && z.assistMiracle === 1)) && !z
				.theFarm && !z.vBrutality) {
				rareActions.push("Blind Devotion [Chief's OPG]");
			}
			if(((characterPresent("Tigh") && z.miracles[getPlayerNum("Tigh")] === 1) || (z.assist === "Tigh" && z.assistMiracle === 1) || actsOfFaith(
					"Tigh")) && !z.theFarm && z.vBrutality) {
				rareActions.push("Blind Devotion [Tigh's OPG]");
			}
			if((characterPresent("Six") && z.miracles[getPlayerNum("Six")] === 1 && (!z.theFarm || z.revealedCylons[getPlayerNum("Six")] === 1))) {
				rareActions.push("Human Delusion [Six's OPG]");
			}
			if((characterPresent("Simon") && z.miracles[getPlayerNum("Simon")] === 1 && (!z.theFarm || z.revealedCylons[getPlayerNum("Simon")] ===
				1))) {
				rareActions.push("Modifications [Simon's OPG]");
			}
			if(((characterPresent("Karl") && z.miracles[getPlayerNum("Karl")] === 1) || (z.assist === "Karl" && z.assistMiracle === 1) || actsOfFaith(
					"Karl")) && !z.theFarm && (6 >= z.distance || ((z.destination === "Ionian Nebula" || z.destination === "Kobol") && z.distance ===
					7) || (z.destination === "Earth" && 10 >= z.distance))) {
				rareActions.push("No One Gets Left Behind [Karl's OPG]");
			}
			if(characterPresent("Billy") && (z.miracles[getPlayerNum("Billy")] === 1 || actsOfFaith("Billy")) && !z.theFarm && !versionAtLeast([2, 1,
					6])) {
				rareActions.push("Reveal Secrets [Billy's OPG]");
			}
			if((characterPresent("Starbuck") && z.miracles[getPlayerNum("Starbuck")] === 1 && !z.theFarm) || actsOfFaith("Starbuck")) {
				rareActions.push("Secret Destiny [Starbuck's OPG]");
			}
			if(characterPresent("Helo") && (z.miracles[getPlayerNum("Helo")] === 1 || actsOfFaith("Helo")) && !z.theFarm) {
				rareActions.push("Moral Compass [Helo's OPG]");
			}
			if(characterPresent("Hot Dog") && z.miracles[getPlayerNum("Hot Dog")] === 1 && !z.theFarm) {
				rareActions.push("Escort [Hot Dog's OPG]");
			}
			if(z.daybreak) {
				rareActions.push("Change of Plans");
			} /* TODO: verify this is working right. */
			rareActions.push("Strategic Planning to cause Damage (pro-Cylon!)");
			for(let j = 0; !(j >= z.numPlayers); j++) {
				for(let k = 0; !(k >= z.quorumTitles[j].length); k++) {
					if(d.quorumNames[z.quorumTitles[j][k]] === "Probation") {
						rareActions.push("Probation");
					}
				}
			}
			if(rareActions.length === 0) {
				addAlert("No rare actions available at this time.");
				mainMenu();
			} else {
				let promptText =
					"You may use this ability to request a pause for a rare interrupt-style ability when the next window for its use presents itself. " +
					"Nobody will know who requested the pause, but the request cannot be cancelled once made.\n\nFor which ability would you like to submit a pause request for? (1-" +
					rareActions.length + ")";
				for(let j = 0; !(j >= rareActions.length); j++) {
					promptText += "\n" + (j + 1) + ": " + rareActions[j];
				}
				promptNum(promptText, (a) => 1 > a || a > rareActions.length, mainMenu, (prompted) => {
					addAlert("Pause requested for " + rareActions[prompted - 1]);
					switch (rareActions[prompted - 1]) {
						case "Command Authority [Adama's OPG]":
							z.commandAuthorityPause = true;
							break;
						case "Blind Devotion [Chief's OPG]":
						case "Blind Devotion [Tigh's OPG]":
							z.blindDevotionPause = true;
							break;
						case "Human Delusion [Six's OPG]":
							z.humanDelusionPause = true;
							break;
						case "No One Gets Left Behind [Karl's OPG]":
							z.noOneGetsLeftBehindPause = true;
							break;
						case "Modifications [Simon's OPG]":
							z.modificationsPause = true;
							break;
						case "Change of Plans":
							z.changeOfPlansPause = true;
							break;
						case "Probation":
							z.probationPause = true;
							break;
						case "Reveal Secrets [Billy's OPG]":
							z.revealSecretsPause = true;
							break;
						case "Secret Destiny [Starbuck's OPG]":
							z.secretDestinyPause = true;
							addAlert("This CO will remain on for as long as Starbuck has her OPG.");
							break;
						case "Moral Compass [Helo's OPG]":
							z.moralCompassPause = true;
							addAlert("This CO will remain on for as long as Helo has his OPG, or until all Cylons reveal.");
							break;
						case "Escort [Hot Dog's OPG]":
							z.escortPause = true;
							if(z.CFB) {
								addAlert("This CO will remain on for as long as Hot Dog has his OPG.");
							} else {
								addAlert("This CO will remain on until the next time the fleet jumps.");
							}
							break;
						case "Strategic Planning to cause Damage (pro-Cylon!)":
							z.stratPlanPause = true;
							addAlert("This CO will remain on until it triggers, or until all Cylons reveal.");
							break;
					}
					mainMenu();
				});
			} /* TODO: it's pretty obvious you're requesting a pause if you're not doing anything else */
		} else if(ch === "[Other Options]") {
			menuPage = "Default";
			mainMenu();
		} else if(ch === "[Six Ally] Draw the top 2 cards of Destiny into your hand") {
			confirmify("Confirming you want to draw the top 2 cards of Destiny into your hand, since Caprica Six was Delusional.", mainMenu, () => {
				t.value += myPlayer + " draws the top 2 cards of Destiny to hand.\r\n";
				let card1 = z.destiny.pop();
				z.skillCardHands[me].push(card1);
				if(z.destiny.length === 0) {
					buildDestiny();
				}
				let card2 = z.destiny.pop();
				z.skillCardHands[me].push(card2);
				if(z.destiny.length === 0) {
					buildDestiny();
				}
				if(z.daybreak || z.pegasus) {
					z.possibleColors[me] = [1, 1, 1, 1, 1, 1];
				} else {
					z.possibleColors[me] = [1, 1, 1, 1, 1];
				}
				addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + " from Destiny.");
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "[Settings and Conditional Orders]" || ch === "[I still can't find what I'm looking for]") {
			menuPage = ch;
			mainMenu();
		} else if(ch === "[Human Fleet] Look at another player's hand and steal a Skill Card") {
			let promptText = "Who would you like to steal a card from? (1-" + z.numPlayers + ")\n";
			let validTargets = 0;
			for(let i = 0; !(i >= z.numPlayers); i++) {
				promptText += (i + 1) + ": ";
				if(i === me) {
					promptText += "(cannot steal from yourself)\n";
				} else if(z.skillCardHands[i ].length === 0) {
					promptText += "(no cards)\n";
				} else {
					validTargets++;
					promptText += z.players[i ] + "\n";
				}
			}
			if(validTargets === 0) {
				addAlert("Nobody else has any cards.");
				addAlert("Roll to damage Galactica (hit on a 5+).");
				removeOption(me, ch);
				if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && me === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
					delete z.stratPlanPause;
					plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
					SPTokenBad("Human Fleet",me);
				} else {
					z.dieRoller = me;
					z.dieRollQueue.push("Human Fleet");
				}
				mainMenu();
			} else {
				let stealSkillCard = function(prompted) {
					z.skillCardHands[prompted - 1].sort(cardCompare);
					let promptText = "Which skill card would you like to steal from " + z.players[prompted - 1] + "? (1-" + z.skillCardHands[
						prompted - 1].length + ")\n";
					for(let i = 0; !(i >= z.skillCardHands[prompted - 1].length); i++) {
						promptText += (i + 1) + ": " + cardText(z.skillCardHands[prompted - 1][i ]) + "\n";
					}
					promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[prompted - 1].length, () => {
						stealSkillCard(prompted);
					}, (prompted2) => {
						addAlert("Stole " + cardText(z.skillCardHands[prompted - 1][prompted2 - 1]) + " from " + z.players[prompted - 1] +
							".");
						t.value += bold(z.players[me] + " looked at " + z.players[prompted - 1] + "'s cards, and stole 1 of them.") +
						"\r\n";
						z.skillCardHands[me].push(z.skillCardHands[prompted - 1].splice(prompted2 - 1, 1)[0]);
						for(let j = 0; !(j >= z.possibleColors[0].length); j++) {
							if(z.possibleColors[prompted - 1][j] === 1) {
								z.possibleColors[me][j] = 1;
							}
						}
						if(z.skillCardHands[prompted - 1].length === 0) {
							z.possibleColors[prompted - 1] = [0, 0, 0, 0, 0];
						}
						addAlert("Now, roll to damage Galactica (hit on a 5+).");
						if(couldBeUnrevealed() && z.stratPlanPause && !(characterPresent("Billy") && me === getPlayerNum("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")))){
							delete z.stratPlanPause;
							plainAlert("Someone has asked for a pause here for "+colorText("purple","Strategic Planning")+".");
							SPTokenBad("Human Fleet",me);
						} else {
							z.dieRoller = me;
							z.dieRollQueue.push("Human Fleet");
						}
						removeOption(me, ch);
						mainMenu();
					});
				};
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me || z.skillCardHands[a - 1].length === 0, mainMenu, (
				prompted) => {
					stealSkillCard(prompted);
				});
			}
		} else if(ch === "Memento (OPT)") {
			if(myPlayer !== "Hot Dog") {
				addAlert("Only Hot Dog can use Memento.");
				removeOption(me, ch);
				mainMenu();
			} else {
				let memento = function() {
					z.mementoUsed = true;
					if(z.mementoCards.length === 0) {
						for(let j = 0; !(j >= 3) && z.skillCardDecks[3].length > 0; j++) {
							z.mementoCards.push(drawFromDeck(3));
						}
						t.value += bold("Hot Dog uses his Memento ability to draw " + z.mementoCards.length + colorText("red", " Piloting") +
							" cards.") + "\r\n";
						t.value += "He must discard 1 and keep 2.\r\n";
						if(z.activatingSector !== 0 && z.pegasus && isInSpace(me)) {
							plainAlert("Remember that any " + colorText("red", "Run Interference") +
								" he keeps cannot be used later in the current Raider activation.");
						}
					} /* RULES: what if there aren't 3 piloting cards available? */
					if(z.mementoCards.length === 0){
						addAlert("There are no Piloting cards available at all; Memento cancelled.");
						z.mementoUsed = false;
						removeOption(me,ch);
						mainMenu();
						return;
					}
					let promptText = "Which card would you like to discard? (1-"+z.mementoCards.length+") You will keep the others.";
					for(let j = 0; !(j >= z.mementoCards.length); j++) {
						promptText += "\n" + (j + 1) + ": " + cardText(z.mementoCards[j]);
					}
					promptNum(promptText, (a) => 1 > a || a > z.mementoCards.length, mainMenu, (prompted) => {
						let card = z.mementoCards.splice(prompted - 1, 1)[0];
						z.skillCardDiscards[3].push(card);
						boldAlert("Hot Dog discards " + cardText(card) + " from Memento.");
						reshuffleSkillCardDeck(3);
						z.skillCardHands[me] = z.skillCardHands[me].concat(z.mementoCards);
						if(z.mementoCards.length > 0){
							z.possibleColors[me][3] = 1;
						}
						z.mementoCards = [];
						removeOption(me, ch);
						mainMenu();
					});
				};
				if(z.mementoCards.length > 0) {
					memento();
				} else {
					confirmify("Confirming you want to use your Memento ability to draw 3 Piloting cards and keep 2.", mainMenu, memento);
				}
			}
		} else if(ch === "Shuffle 2 Treachery into Destiny") {
			confirmify("Confirming you want to shuffle 2 Treachery into Destiny", mainMenu, () => {
				shuffleTreachery();
				removeOption(me,ch);
				mainMenu();
			});
		} else if(ch === "Process outcome of this skill check") {
			let confirmText = "The outcome of the ";
			if(Number.isInteger(z.currentSkillCheck)) {
				confirmText += '"' + d.crisisNames[z.currentSkillCheck] + '"';
			} else {
				confirmText += '"' + z.currentSkillCheck + '"';
			}
			confirmText += " skill check will be a ";
			if(z.autoPass) {
				confirmText += "PASS.";
			} else {
				confirmText += skillCheckTally(true)[1];
			}
			confirmText += ".\n\nWould you like to process this outcome now?";
			confirmify(confirmText, mainMenu, () => {
				if(z.changeOfPlansPause && !isMission(z.currentSkillCheck) && !z.changeOfPlans && skillCheckTally(true)[1] == "PASS") {
					plainAlert(
						"Someone has requested a pause for Change of Plans.  Please wait for all Humans to pass on or play Change of Plans before proceeding."
						);
					confirmify("Press OK if all Humans have passed on Change of Plans.  Press Cancel if not all Humans have passed.", mainMenu,
						() => {
							processSkillCheckOutcome();
							mainMenu();
						});
				} else {
					processSkillCheckOutcome();
					mainMenu();
				}
			});
		} else if(ch === "Set up the New Caprica Phase") {
			confirmify("Confirming you want to set up the New Caprica phase.", mainMenu, () => {
				setupNC();
				mainMenu();
			});
		} else if(ch === "[Resistance Bombing] Decrease Morale") {
			confirmify("Confirming you want to lose a Morale.  You must then execute a revealed Cylon or destroy 2 Occupation Forces.", mainMenu,
		() => {
				/* RULES: What if Dee is executed here? */ /* RULES: can I pick an option that does nothing? */
				plainAlert("Admiral " + z.players[me] +
				" chooses to lose a Morale to execute a revealed Cylon or destroy 2 Occupation Forces.");
				addOption(me, "Execute a player", "Resistance Bombing", false);
				if(OFReserves() !== 4) {
					addOption(me, "Destroy an Occupation Force", "Resistance Bombing", false);
				}
				decreaseMorale();
				removeOption(me, ch);
				removeOption(me, "[Resistance Bombing] Do not decrease Morale");
				mainMenu();
			});
		} else if(ch === "[Resistance Bombing] Do not decrease Morale") {
			confirmify("Confirming you do not want to lose a Morale; you will not get to execute a revealed Cylon or destroy 2 Occupation Forces.",
				mainMenu, () => {
					boldAlert("Admiral " + z.players[me] + " chooses not to decrease Morale.");
					removeOption(me, ch);
					removeOption(me, "[Resistance Bombing] Decrease Morale");
					mainMenu();
				});
		} else if(ch === "Destroy an Occupation Force") {
			let locations = [0, 0, 0];
			for(let j = 0; !(j >= 4); j++) {
				if(z.OFs[j] > 0) {
					locations[z.OFs[j] - 1] = 1;
				}
			}
			if(locations[0] + locations[1] + locations[2] === 1) {
				for(let j = 0; !(j >= 4); j++) {
					if(z.OFs[j] > 0) {
						let alertText = "Destroyed an Occupation Force on ";
						if(z.OFs[j] === 1) {
							alertText += "the Occupation Authority.";
						} else if(z.OFs[j] === 2) {
							alertText += "Breeder's Canyon.";
						} else {
							alertText += "the Shipyard.";
						}
						z.OFs[j] = 0;
						boldAlert(alertText);
						break;
					}
				}
				if(hasContext(me, ch, "Resistance Bombing")) {
					if(OFReserves() !== 4) {
						addOption(me, ch, undefined, true);
					} else {
						removeOption(me,ch);
					}
					removeOption(me, "Execute a player");
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			} else {
				let promptText = "Destroy an Occupation Force on which of these locations? (1-" + (locations[0] + locations[1] + locations[2]) + ")";
				let options2 = [];
				let numbers2 = [];
				for(let j = 0; !(j >= 3); j++) {
					if(locations[j] === 1) {
						if(j === 0) {
							options2.push("Occupation Authority");
						} else if(j === 1) {
							options2.push("Breeder's Canyon");
						} else {
							options2.push("Shipyard");
						}
						numbers2.push(j + 1);
						promptText += "\n" + (options2.length) + ": " + options2[options2.length - 1];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > options2.length, mainMenu, (prompted) => {
					t.value += bold("Occupation Force on " + options2[prompted - 1]) + " destroyed.\r\n";
					for(let j = 0; !(j >= 4); j++) {
						if(z.OFs[j] === numbers2[prompted - 1]) {
							if(z.OFs[j] > 0) {
								let alertText = "Destroyed an Occupation Force on ";
								if(z.OFs[j] === 1) {
									alertText += "the Occupation Authority.";
								} else if(z.OFs[j] === 2) {
									alertText += "Breeder's Canyon.";
								} else {
									alertText += "the Shipyard.";
								}
								z.OFs[j] = 0;
								boldAlert(alertText);
								break;
							}
						}
					}
					if(hasContext(me, ch, "Resistance Bombing")) {
						if(OFReserves() !== 4) {
							addOption(me, ch, undefined, true);
						} else {
							removeOption(me,ch);
						}
						removeOption(me, "Execute a player");
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			}
		} else if(ch === "Evacuate a Civilian") {
			confirmify("Confirming you want to evacuate a civilian.", mainMenu, () => {
				
				confirmify("Would you like to evacuate a civilian to Sector 5 or Sector 6?", () => {
					/* TODO: shipyard issues with reshuffledseen */
					z.spaceCivilians[5].push([z.civilianLetters.shift(), z.preparedCivilians.pop(), true]);
					boldAlert("Evacuated Civilian " + z.spaceCivilians[5][z.spaceCivilians[5].length - 1][0] + " to Sector 6.");
					let num = getContext(me,ch);
					if(Number.isInteger(num) && num > 1){
						addOption(me,ch,num-1,true);
					} else {
						removeOption(me,ch);
					}
					removeOption(me, "Prepare a Civilian");
					if(z.toDoJumpIcon && !z.capricaCrisis && z.players[z.turn] === "Boomer" && characterPresent("Boomer")){
						plainAlert("Boomer may now do her Recon.");
					}
					z.toDoJumpIcon = false;
					mainMenu();
				}, () => {
					z.spaceCivilians[4].push([z.civilianLetters.shift(), z.preparedCivilians.pop(), true]);
					boldAlert("Evacuated Civilian " + z.spaceCivilians[4][z.spaceCivilians[4].length - 1][0] + " to Sector 5.");
					let num = getContext(me,ch);
					if(Number.isInteger(num) && num > 1){
						addOption(me,ch,num-1,true);
					} else {
						removeOption(me,ch);
					}
					removeOption(me, "Prepare a Civilian");
					if(z.toDoJumpIcon && !z.capricaCrisis && z.players[z.turn] === "Boomer" && characterPresent("Boomer")){
						plainAlert("Boomer may now do her Recon.");
					}
					z.toDoJumpIcon = false;
					mainMenu();
				}, "Sector 5", "Sector 6");
			});
		} else if(ch === "Prepare a Civilian") {
			confirmify("Confirming you want to prepare a civilian.", mainMenu, () => {
				prepareCivilian();
				removeOption(me, ch);
				removeOption(me, "Evacuate a Civilian");
				mainMenu();
			});
		} else if(ch === "Place an Occupation Force on the Occupation Authority") {
			confirmify("Confirming you want to place an Occupation Force on the Occupation Authority.", mainMenu, () => {
				for(let j = 0; !(j >= 4); j++) {
					if(z.OFs[j] === 0) {
						z.OFs[j] = 1;
						plainAlert("Placed an Occupation Force on the Occupation Authority.");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Jump the Fleet away from New Caprica") {
			/* RULES: Lured into a Trap */
			confirmify("Confirming you want to jump the fleet.  This will end the game!", mainMenu, () => {
				addAlert("You jump the fleet!");
				z.endGame = true;
				t.value += bold(colorText("green", "Admiral ") + z.players[z.admiral] +
				" jumps the fleet away from New Caprica!\r\n"); /* RULES: simultaneity if Dee executed by this? */
				let deeExecuted = false;
				while(z.preparedCivilians.length > 0) {
					deeExecuted = !destroyCivilian(z.preparedCivilians.shift()) || deeExecuted;
				}
				while(z.lockedCivilians.length > 0) {
					deeExecuted = !destroyCivilian(z.lockedCivilians.shift()) || deeExecuted;
				}
				if(deeExecuted) {
					plainAlert("Once Dee's execution is resolved, execute all players remaining on New Caprica.");
					optionForAll("Execute a player", "New Caprica", false);
				} else {
					let NCplayers = 0;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(isOnNewCaprica(j)) {
							NCplayers++;
						}
					}
					if(NCplayers === 0) {
						endGame(true);
					} else if(NCplayers === 1) {
						for(let k = 0; !(k >= z.numPlayers); k++) {
							if(isOnNewCaprica(k)) {
								executePlayer(k);
								break;
							}
						}
						addAlert('Press "End Game" once the execution is fully resolved.');
						t.value += "End the game once the execution is fully resolved.\r\n";
					} else if(NCplayers > 1) {
						for(let k = 0; !(k >= z.numPlayers); k++) {
							let j = (z.turn + k) % z.numPlayers;
							if(isOnNewCaprica(j)) {
								executePlayer(j);
								break;
							}
						}
						optionForAll("Execute a player", "New Caprica", false);
						addAlert('Once this execution is fully resolved, execute the other players on New Caprica, then press "End Game."');
						t.value += "Once this execution is fully resolved, execute the other players on New Caprica, then end the game.\r\n";
					}
				}
				mainMenu();
			});
		} else if(ch === "Attack Occupation Forces") {
			confirmify("Confirming you want to attack an Occupation Force on your location, " + myLocation + ".", mainMenu, () => {
				didAction();
				SPTokenBad(myPlayer + " vs. Occupation Force (" + myLocation + ")");
				if(z.possibleColors[me][3] === 1 && (z.players[me] !== "Billy" || z.phase !== 3 || solo || me === z.theSympatheticCylon)) {
					addAlert("Remember that you may play a Maximum Firepower to reroll the die.");
					t.value += "Remember that " + myPlayer + " may play a " + colorText("red", "Maximum Firepower") +
					" to reroll this die.\r\n";
				}
				mainMenu();
			});
		} else if(ch === "Detain a Human") {
			let target = -1;
			let targets = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(z.playerLocations[j] === myLocation && z.revealedCylons[j] === 0) {
					targets.push(j);
				}
			}
			let detain = function() {
				confirmify("Confirming you want to attempt to detain " + z.players[target] + ".", mainMenu, () => {
					didAction();
					SPTokenBad("Detain " + z.players[target]);
					mainMenu();
				});
			};
			if(targets.length === 1) {
				target = targets[0];
				detain();
			} else if(targets.length > 1) {
				let promptText = "Which Human would you like to detain? (1-" + targets.length + ")";
				for(let j = 0; !(j >= targets.length); j++) {
					promptText += "\n" + (j + 1) + ": " + z.players[targets[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > targets.length, mainMenu, (prompted) => {
					target = targets[prompted - 1];
					detain();
				});
			}
		} else if(ch === "Give the Mutineer card to a Human player after being boxed") {
			let promptText = "Who would you like to give the Mutineer card to? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "CYLON";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || isTheCylonLeader(a - 1), mainMenu, (
				prompted) => {
					for(let j = 0; !(j >= z.boxedPlayers[meBoxed][3].length); j++) {
						if(z.boxedPlayers[meBoxed][3][j] === 40) {
							z.loyaltyDiscards[prompted - 1].push(z.boxedPlayers[meBoxed][3].splice(j, 1)[0]);
							break;
						}
					}
					z.theMutineer = prompted - 1;
					t.value += bold(myPlayer + " makes " + z.players[z.theMutineer] + " the Mutineer.") + "\r\n";
					addAlert(z.players[z.theMutineer] + " is now the Mutineer.");
					dealMutiny(z.theMutineer, false);
					if(z.theMutineer === z.president) {
						passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
					}
					if(z.theMutineer === z.admiral) {
						passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
					}
					if(z.CFB && z.theMutineer === z.cag) {
						passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
					}
					mainMenu();
				});
		} else if(ch === "Choose a Human player to draw an additional Loyalty") {
			let promptText = "Who gets to draw an additional Loyalty? (1-" + z.numPlayers + ")";
			promptText +=
				"\nNOTE: This should only happen immediately after sleeper if the Mutineer card has not yet appeared.  It should only ever happen once per game.";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "CYLON";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || isTheCylonLeader(a - 1), mainMenu, (
				prompted) => {
					t.value += bold(myPlayer + " deals another Loyalty card to " + z.players[prompted - 1]) + ".\r\n";
					let loy = z.loyaltyDeck.pop();
					z.loyaltyHands[prompted - 1].push(loy);
					if(loy === 40) {
						becomeMutineer(prompted - 1, z.loyaltyHands[prompted-1].length-1);
					} else {
						addAlert("They did not become the Mutineer.  Do NOT repeat this process.");
						t.value += z.players[prompted - 1] +
							" did not become the Mutineer.  Do not repeat this process; the Mutineer may yet emerge after an execution.\r\n";
						z.theMutineer = -2;
					}
					mainMenu();
				});
		} else if(ch === "Give the Sympathizer card to a Human player") {
			let promptText = "Who would you like to give the Sympathizer card to? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "CYLON";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || isTheCylonLeader(a - 1), mainMenu, (
				prompted) => {
					for(let j = 0; !(j >= z.loyaltyDiscards[me].length); j++) {
						if(z.loyaltyDiscards[me][j] === 15) {
							z.loyaltyHands[prompted - 1].push(z.loyaltyDiscards[me].splice(j, 1)[0]);
							break;
						}
					}
					t.value += bold(myPlayer + " makes " + z.players[prompted - 1] + " the Sympathizer.") + "\r\n";
					becomeSympathizer(prompted - 1);
					mainMenu();
				});
		} else if(ch === "Give the Mutineer card to a Human player") {
			let promptText = "Who would you like to give the Mutineer card to? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "CYLON";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || isTheCylonLeader(a - 1), mainMenu, (
				prompted) => {
					for(let j = 0; !(j >= z.loyaltyDiscards[me].length); j++) {
						if(z.loyaltyDiscards[me][j] === 40) {
							z.loyaltyDiscards[prompted - 1].push(z.loyaltyDiscards[me].splice(j, 1)[0]);
							break;
						}
					}
					z.theMutineer = prompted - 1;
					t.value += bold(myPlayer + " makes " + z.players[z.theMutineer] + " the Mutineer.") + "\r\n";
					addAlert(z.players[z.theMutineer] + " is now the Mutineer.");
					dealMutiny(z.theMutineer, false);
					if(z.theMutineer === z.president) {
						passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
					}
					if(z.theMutineer === z.admiral) {
						passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
					}
					if(z.CFB && z.theMutineer === z.cag) {
						passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
					}
					mainMenu();
				});
		} else if(ch === "Trigger Probation") {
			let probate = -1;
			let position = -1;
			for(let j = 0; !(j >= z.numPlayers); j++) {
				for(let k = 0; !(k >= z.quorumTitles[j].length); k++) {
					if(z.quorumTitles[j][k] === 23) {
						probate = j;
						position = k;
						break;
					}
				}
			}
			confirmify("Confirming that you want to discard Probation to see the cards " + z.players[probate] + " played into the skill check.",
				mainMenu, () => {
					let alertText = z.players[probate] + " played the following cards into the skill check:";
					for(let j = 0; !(j >= z.skillCheckCards[probate].length); j++) {
						alertText += "\n" + cardText(z.skillCheckCards[probate][j]);
					}
					addAlert(alertText);
					z.secretMessages[me] += "\n" + alertText;
					t.value += bold(colorText("orange", "President ") + myPlayer + " discards Probation to look at the cards " + z.players[
						probate] + " played into the skill check.") + "\r\n";
					z.quorumDiscards.push(z.quorumTitles[probate].splice(position, 1)[0]);
					mainMenu();
				});
		} else if(ch === "End Game") {
			confirmify(
				"Confirming that you want to resume the end game process.  Make sure all necessary executions have been resolved (including choosing new characters).",
				mainMenu, () => {
					endGame(true);
					mainMenu();
				});
		} else if(ch === "Human Delusion (OPG)") {
			confirmify("Confirming you want to use your OPG, Human Delusion, to play additional cards into this skill check.", mainMenu, () => {
				if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				addAlert("Now, play as many skill cards into the check as you like.");
				addOption(me, "[Human Delusion] Play a card into the skill check", undefined, false);
				t.value += bold("Six uses her OPG, Human Delusion.") + "\r\n";
				mainMenu();
			});
		} else if(ch === "[Human Delusion] Play a card into the skill check") {
			let promptText = "What skill card would you like to play into the skill check? (1-" + z.skillCardHands[me].length + ")";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				promptText += "\n" + (j + 1) + ": " + cardText(z.skillCardHands[me][j]);
			}
			promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, mainMenu, (prompted) => {
				confirmify("Confirming you want to play " + cardText(z.skillCardHands[me][prompted - 1]) + " into the skill check.", mainMenu,
				() => {
					let card = z.skillCardHands[me].splice(prompted - 1, 1)[0];
					z.revealedCards.push(card);
					let tally = skillCheckTally(true);
					addAlert("Played " + cardText(card) + " into skill check.\n\n" + tally[2] + " - " + tally[1]);
					t.value += bold(myPlayer + " played in " + cardText(card)) + ".\r\n";
					t.value += "\r\n" + tally[0] + "\r\n";
					if(z.skillCardHands[me].length === 0) {
						z.possibleColors[me] = [0, 0, 0, 0, 0, 0];
						removeOption(me, ch);
					}
					if(skillCheckEffects().length === 0 && (!z.reckless || !z.daybreak) && (z.thisConsequence === 0 || !
							consequenceTriggered()) && (!characterPresent("Cally") || z.players[z.turn] !== "Cally")) {
						if(shouldDE()) {
							if(z.skillCardHands[me].length === 0) {
								addAlert("The check is now within Declare Emergency range.");
								DEToken();
								mainMenu();
							} else {
								confirmify("The check is now within Declare Emergency range.  Are you done playing cards?", mainMenu,
								() => {
										removeOption(me, ch);
										DEToken();
										mainMenu();
									}, "I'm done", "I'm not done yet");
							}
						} else {
							mainMenu();
						}
					} else {
						mainMenu();
					}
				});
			});
		} else if(ch === "Intimate") {
			let promptText = "Which player would you like to steal a skill card from? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j !== me) {
					promptText += z.players[j];
				} else {
					promptText += "(You cannot be Intimate with yourself.)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me, mainMenu, (prompted) => {
				confirmify("Confirming that you want to steal a skill card from " + z.players[prompted - 1], mainMenu, () => {
					if(z.skillCardHands[prompted - 1].length > 0) {
						let rando = Math.floor((z.seed * z.skillCardHands[prompted - 1].length)/mLCG);
						updateSeed();
						let card = z.skillCardHands[prompted - 1].splice(rando, 1)[0];
						for(let j = 0; !(j >= 6); j++) {
							if(z.possibleColors[prompted - 1][j] === 1) {
								z.possibleColors[me][j] = 1;
							}
						}
						if(z.skillCardHands[prompted - 1].length === 0) {
							z.possibleColors[prompted - 1] = [0, 0, 0, 0, 0, 0];
						}
						z.skillCardHands[me].push(card);
						addAlert("You steal " + cardText(card) + " from " + z.players[prompted - 1] +
							".\n\nNow, deal a skill card to that player (it may be from outside of their skill set).");
						t.value += bold("Six uses Intimate to steal a random skill card from " + z.players[prompted - 1]) + ".\r\n";
					} else {
						addAlert(z.players[prompted - 1] +
							" has no skill cards to steal.  Now, deal a skill card to that player (it may be from outside of their skill set)."
							);
						t.value += bold("Six uses Intimate on " + z.players[prompted - 1] +
							", but they have no skill cards to steal.") + "\r\n";
					}
					addOption(me, "Deal a Skill Card to " + z.players[prompted - 1], undefined, true);
					z.phase = -1;
					mainMenu();
				});
			});
		} else if(ch === "Glimpse the Face of God") {
			confirmify(
				"Confirming that you want to use your Movement ability, Glimpse the Face of God, to draw the top 2 cards of the Destiny deck to your hand.",
				mainMenu, () => {
					let card1 = z.destiny.pop();
					if(z.destiny.length === 0) {
						buildDestiny();
					}
					let card2 = z.destiny.pop();
					if(z.destiny.length === 0) {
						buildDestiny();
					}
					z.skillCardHands[me].push(card1);
					z.skillCardHands[me].push(card2);
					z.possibleColors[me] = [1, 1, 1, 1, 1, 1];
					addAlert("You draw " + cardText(card1) + " and " + cardText(card2) +
						" from Destiny into your hand.\n\nNow, put 2 cards from your hand on top of the Destiny deck.");
					t.value += bold("Leoben uses Glimpse the Face of God to draw 2 cards from the Destiny deck.") + "\r\n";
					addOption(me, "[Glimpse the Face of God] Put a Skill Card on top of the Destiny Deck", 1, true);
					z.phase = -1;
					mainMenu();
				});
		} else if(ch === "[Glimpse the Face of God] Put a Skill Card on top of the Destiny Deck") {
			let promptText = "Which card would you like to put on top of the Destiny deck? (1-" + z.skillCardHands[me].length + ")";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				promptText += "\n" + (j + 1) + ": " + cardText(z.skillCardHands[me][j]);
			}
			promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][prompted - 1];
				confirmify("Confirming you want to put " + cardText(card) + " on top of the Destiny deck.", mainMenu, () => {
					addAlert("You put " + cardText(card) +
						" on top of the Destiny Deck.\n\nRemember to put a second card on top of the Destiny deck (if you haven't already)."
						);
					t.value += bold("Leoben puts a skill card on top of the Destiny deck.") + "\r\n";
					z.skillCardHands[me].splice(prompted - 1, 1);
					z.destiny.push(card);
					if(z.skillCardHands[me].length === 0) {
						z.possibleColors[me] = [0, 0, 0, 0, 0, 0];
					}
					if(hasContext(me, ch, 1)) {
						addOption(me, ch, undefined, true);
					} else {
						removeOption(me, ch);
						endMovement();
					}
					mainMenu();
				});
			});
		} else if(ch === "Cryptic Message (OPG)") {
			let promptText = "Which player would you like to trade skill card hands with using your OPG, Cryptic Message? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j === me) {
					promptText += "(cannot choose yourself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me, mainMenu, (prompted) => {
				confirmify("Confirming that you want to trade skill card hands with " + z.players[prompted - 1], mainMenu, () => {
					let leobenHand = shuffle(z.skillCardHands[me]);
					let leobenColors = z.possibleColors[me];
					if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					z.skillCardHands[me] = shuffle(z.skillCardHands[prompted - 1]);
					z.possibleColors[me] = z.possibleColors[prompted - 1];
					z.skillCardHands[prompted - 1] = leobenHand;
					z.possibleColors[prompted - 1] = leobenColors;
					addAlert("You trade skill card hands with " + z.players[prompted - 1]);
					t.value += bold("Leoben uses his OPG, Cryptic Message, to trade skill card hands with " + z.players[prompted - 1]) +
						".\r\n";
					if(z.vBrutality) {
						plainAlert("Leoben may now take an additional action, or he may let " + z.players[prompted - 1] +
							" take an additional action.");
					}
					didAction();
					mainMenu();
				});
			});
		} else if(ch === "Sacrifice (OPG)") {
			confirmify("Confirming you want to use your OPG, Sacrifice.", mainMenu, () => {
				if(z.assist === "Kat") {
					z.assistMiracle = 0;
				} else {
					z.miracles[me] = 0;
				}
				t.value += bold("Kat uses her OPG, Sacrifice.") + "\r\n";
				if(z.vBrutality) {
					addAlert("Now, destroy 5 Raiders, 2 Heavy Raiders, 1 Basestar, or 2 Civilian Ships in your space area.");
				} else {
					addAlert("Now, destroy 5 Raiders, 2 Heavy Raiders, 1 Basestar, or 1 Civilian Ship in your space area.");
				}
				let sector = parseInt(myLocation.slice(7));
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] === sector) {
						addOption(me, "Destroy Raider(s)", ["Sacrifice", sector], true);
						break;
					}
				}
				for(let j = 0; !(j >= z.heavies.length); j++) {
					if(z.heavies[j] === sector) {
						addOption(me, "Destroy a Heavy Raider", ["Sacrifice", sector], true);
						break;
					}
				}
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === sector) {
						addOption(me, "Destroy a basestar", ["Sacrifice", sector], true);
						break;
					}
				}
				if(z.spaceCivilians[sector - 1].length > 0) {
					if(z.vBrutality && z.spaceCivilians[sector - 1].length > 1) {
						addOption(me, "Destroy a Civilian in space", ["Sacrifice2", sector], true);
					} else {
						addOption(me, "Destroy a Civilian in space", ["Sacrifice", sector], true);
					}
				}
				movePlayer(me, "Sickbay");
				addAlert("You are sent to Sickbay.");
				didAction();
				mainMenu();
			});
		} else if(ch === "Manipulative (OPG)") {
			confirmify("Confirming you want to use your OPG, Manipulative, to take the Admiral or President title.", mainMenu, () => {
				let doIt = function(takeAdmiral) {
					if(z.assist === "Ellen") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					removeOption(me,ch);
					if(takeAdmiral) {
						z.manipulativeVictim = z.admiral;
						z.manipulativeAdmiral = true;
						boldAlert("Ellen uses her OPG, Manipulative, to temporarily take the Admiralty.");
						z.admiral = me;
						if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z
							.admiral !== getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([
								2, 0, 1
							]) || z.manipulativeVictim !== getPlayerNum("Zarek"))) {
							if(versionAtLeast([2,2,25])){
								z.friendsAdmiral = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
						if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !==
							"Brig" && (!versionAtLeast([2, 0, 1]) || z.manipulativeVictim !== getPlayerNum("Gaius"))) {
							if(versionAtLeast([2,2,25])){
								z.cultAdmiral = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
						mainMenu();
					} else {
						z.manipulativeVictim = z.president;
						z.manipulativeAdmiral = false;
						addAlert("You take the Presidency.  Check your hand to view your Quorums.");
						t.value += bold("Ellen uses her OPG, Manipulative, to temporarily take the Presidency.") + "\r\n";
						movePresident(me);
						mainMenu();
					}
				};
				if(me === z.admiral || myLocation === "Brig") {
					doIt(false);
				} else if(me === z.president) {
					doIt(true);
				} else {
					confirmify("Would you like to become the Admiral or the President?", () => {
						doIt(false);
					}, () => {
						doIt(true);
					}, "Admiral", "President");
				}
			});
		} else if(ch === "Jump the Fleet") {
			let confirmText = "Confirming you want to jump the fleet.\n";
			if(z.blindJump) {
				confirmText += "Make sure you have destroyed 2 civilians first.";
			}
			confirmify(confirmText, mainMenu, () => {
				z.jumpTrack = 4;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					removeOption(j, "Jump the Fleet");
				}
				increaseJump();
				mainMenu();
			});
		} else if(ch === "Blind Jump (OPG)") {
			confirmify("Confirming you want to use your OPG, Blind Jump.", mainMenu, () => {
				t.value += bold("Cain uses her OPG, Blind Jump.") + "\r\n";
				if(z.assist === "Cain") {
					z.assistMiracle = 0;
				} else {
					z.miracles[me] = 0;
				}
				z.blindJump = true;
				if(z.vCain) {
					plainAlert("Per the house rule, bottoming the top 2 cards of the Destination deck.");
					z.destinationDeck.unshift(z.destinationDeck.pop());
					z.destinationDeck.unshift(z.destinationDeck.pop());
				}
				optionForAll("Jump the Fleet");
				if(destroyPileCivilian(2)) {
					removeFromAll("Jump the Fleet");
					z.jumpTrack = 4;
					increaseJump();
				} else {
					plainAlert("Once the civilian destruction has been resolved, jump the fleet.");
				}
				didAction();
				mainMenu();
			});
		} else if(ch === "[Mining Asteroid] Reshuffle the Crisis deck") {
			confirmify(
				"Confirming you want to reshuffle the Crisis deck from Mining Asteroid.  Make sure Apollo has finished (or passed on) his Alert Viper Pilot.",
				mainMenu, () => {
					t.value += "Reshuffled crisis deck.\r\n";
					addAlert("Crisis deck reshuffled.\n\n\Screw you, Apollo.");
					shuffle(z.crisisDeck);
					removeFromAll("[Mining Asteroid] Reshuffle the Crisis deck");
					mainMenu();
				});
		} else if(ch === "Process the effect of Consult the Oracle") {
			let options2 = ["Crisis", "Destination"];
			if(z.quorumDeck.length > 0) {
				options2.push("Quorum");
			}
			if(z.superCrisisDeck.length > 0) {
				options2.push("Super Crisis");
			}
			if(z.daybreak) {
				options2.push("Mutiny");
			}
			if(z.destination === "Earth" || z.destination === "Ionian Earth") {
				options2.push("Mission");
			}
			if(z.preCrossroads) {
				options2.push("Ally");
			}
			if(z.skillCardDecks[0].length > 0) {
				options2.push("Politics");
			}
			if(z.skillCardDecks[1].length > 0) {
				options2.push("Leadership");
			}
			if(z.skillCardDecks[2].length > 0) {
				options2.push("Tactics");
			}
			if(z.skillCardDecks[3].length > 0) {
				options2.push("Piloting");
			}
			if(z.skillCardDecks[4].length > 0) {
				options2.push("Engineering");
			}
			if(z.skillCardDecks[5].length > 0) {
				options2.push("Treachery");
			}
			let promptText = "Which deck would you like to look at the bottom card of? (1-" + options2.length + ")";
			for(let j = 0; !(j >= options2.length); j++) {
				promptText += "\n" + (j + 1) + ": " + options2[j];
			}
			promptNum(promptText, (a) => 1 > a || a > options2.length, mainMenu, (prompted2) => {
				switch (options2[prompted2 - 1]) {
					case "Crisis": {
						let crisis = z.crisisDeck.shift();
						if(z.crisisDeck.length === 0) {
							plainAlert("Crisis deck reshuffles.");
							z.crisisDeck = shuffle(z.crisisDiscards);
							z.crisisDiscards = [];
						}
						z.crisisDeck.unshift(crisis);
						t.value += myPlayer + " examines the bottom card of the Crisis deck.\r\n";
						addAlert("The bottom Crisis is: " + d.crisisNames[crisis]);
						break;
					}
					case "Destination":
						t.value += myPlayer + " examines the bottom card of the Destination deck.\r\n";
						addAlert("The bottom Destination is: " + d.destinationNames[z.destinationDeck[0]]);
						break;
					case "Quorum": {
						t.value += myPlayer + " examines the bottom card of the Quorum deck.\r\n";
						let quorum = z.quorumDeck.shift();
						if(z.quorumDeck.length === 0) {
							z.quorumDeck = shuffle(z.quorumDiscards);
							z.quorumDiscards = [];
							t.value += "Quorum deck reshuffles.\r\n";
						}
						z.quorumDeck.unshift(quorum);
						addAlert("The bottom Quorum is: " + d.quorumNames[quorum]);
						break;
					}
					case "Super Crisis": {
						t.value += myPlayer + " examines the bottom card of the Super Crisis deck.\r\n";
						let card = z.superCrisisDeck.shift();
						if(z.superCrisisDeck.length === 0) {
							z.superCrisisDeck = shuffle(z.superCrisisDiscards);
							z.superCrisisDiscards = [];
							t.value += "Super Crisis deck reshuffles.\r\n";
						}
						z.superCrisisDeck.unshift(card);
						addAlert("The bottom Super Crisis is: " + d.crisisNames[card]);
						break;
					}
					case "Mutiny": {
						t.value += myPlayer + " examines the bottom card of the Mutiny deck.\r\n";
						let card = z.mutinyDeck.shift();
						if(z.mutinyDeck.length === 0) {
							z.mutinyDeck = shuffle(z.mutinyDiscards);
							z.mutinyDiscards = [];
							t.value += "Mutiny deck reshuffles.\r\n";
							z.buriedMutinies = 0;
						}
						z.mutinyDeck.unshift(card);
						z.buriedMutinies++;
						addAlert("The bottom Mutiny is: " + d.mutinyNames[card]);
						break;
					}
					case "Mission": {
						t.value += myPlayer + " examines the bottom card of the Mission deck.\r\n";
						let card = z.missionDeck.shift();
						if(z.missionDeck.length === 0) {
							z.missionDeck = shuffle(z.missionDiscards);
							z.missionDiscards = [];
							t.value += "Mission deck reshuffles.\r\n";
						}
						z.missionDeck.unshift(card);
						addAlert("The bottom Mutiny is: " + d.crisisNames[card]);
						break;
					}
					case "Ally":
						t.value += myPlayer + " examines the bottom card of the Ally deck.\r\n";
						addAlert("The bottom Ally is: " + d.allyNames[z.allyDeck[0]]);
						break;
					case "Politics": {
						let card = z.skillCardDecks[0].shift();
						t.value += myPlayer + " examines the bottom card of the Politics deck.\r\n";
						if(z.skillCardDecks[0].length === 0) {
							z.skillCardDecks[0] = shuffle(z.skillCardDiscards[0]);
							z.skillCardDiscards[0] = [];
							t.value += "Politics deck reshuffles.\r\n";
						}
						z.skillCardDecks[0].unshift(card);
						addAlert("The bottom Politics card is: " + cardText(card));
						break;
					}
					case "Leadership": {
						let card = z.skillCardDecks[1].shift();
						t.value += myPlayer + " examines the bottom card of the Leadership deck.\r\n";
						if(z.skillCardDecks[1].length === 0) {
							z.skillCardDecks[1] = shuffle(z.skillCardDiscards[1]);
							z.skillCardDiscards[1] = [];
							t.value += "Leadership deck reshuffles.\r\n";
						}
						z.skillCardDecks[1].unshift(card);
						addAlert("The bottom Leadership card is: " + cardText(card));
						break;
					}
					case "Tactics": {
						let card = z.skillCardDecks[2].shift();
						t.value += myPlayer + " examines the bottom card of the Tactics deck.\r\n";
						if(z.skillCardDecks[2].length === 0) {
							z.skillCardDecks[2] = shuffle(z.skillCardDiscards[2]);
							z.skillCardDiscards[2] = [];
							t.value += "Tactics deck reshuffles.\r\n";
						}
						z.skillCardDecks[2].unshift(card);
						addAlert("The bottom Tactics card is: " + cardText(card));
						break;
					}
					case "Piloting": {
						let card = z.skillCardDecks[3].shift();
						t.value += myPlayer + " examines the bottom card of the Piloting deck.\r\n";
						if(z.skillCardDecks[3].length === 0) {
							z.skillCardDecks[3] = shuffle(z.skillCardDiscards[3]);
							z.skillCardDiscards[3] = [];
							t.value += "Piloting deck reshuffles.\r\n";
						}
						z.skillCardDecks[3].unshift(card);
						addAlert("The bottom Piloting card is: " + cardText(card));
						break;
					}
					case "Engineering": {
						let card = z.skillCardDecks[4].shift();
						t.value += myPlayer + " examines the bottom card of the Engineering deck.\r\n";
						if(z.skillCardDecks[4].length === 0) {
							z.skillCardDecks[4] = shuffle(z.skillCardDiscards[4]);
							z.skillCardDiscards[4] = [];
							t.value += "Engineering deck reshuffles.\r\n";
						}
						z.skillCardDecks[4].unshift(card);
						addAlert("The bottom Engineering card is: " + cardText(card));
						break;
					}
					case "Treachery": {
						let card = z.skillCardDecks[5].shift();
						t.value += myPlayer + " examines the bottom card of the Treachery deck.\r\n";
						if(z.skillCardDecks[5].length === 0) {
							z.skillCardDecks[5] = shuffle(z.skillCardDiscards[5]);
							z.skillCardDiscards[5] = [];
							t.value += "Treachery deck reshuffles.\r\n";
						}
						z.skillCardDecks[5].unshift(card);
						addAlert("The bottom Treachery card is: " + cardText(card));
						break;
					}
				}
				if(z.destiny.length === 1) {
					addAlert("The only card in Destiny is " + cardText(z.destiny[0]) + "; you discard it and build a new Destiny deck.");
					t.value += myPlayer + " discards the last card in Destiny, " + cardText(z.destiny[0]) +
						", then builds a new Destiny deck.\r\n";
					z.skillCardDiscards[cardColorID(z.destiny[0])].push(z.destiny[0]);
					refreshSkillDecks();
					z.destiny = [];
					buildDestiny();
					removeOption(me, ch);
					mainMenu();
				} else if(z.destiny.length === 2) {
					addAlert("The last two cards in Destiny are " + cardText(z.destiny[0]) + " and + " + cardText(z.destiny[1]) +
						"; you discard them and build a new Destiny deck.");
					t.value += myPlayer + " discards the last two cards in Destiny, " + cardText(z.destiny[0]) + " and + " + cardText(z.destiny[
						1]) + ", then builds a new Destiny deck.\r\n";
					z.skillCardDiscards[cardColorID(z.destiny[0])].push(z.destiny[0]);
					z.skillCardDiscards[cardColorID(z.destiny[1])].push(z.destiny[1]);
					refreshSkillDecks();
					z.destiny = [];
					buildDestiny();
					removeOption(me, ch);
					mainMenu();
				} else {
					t.value += myPlayer + " looks at the Destiny deck.\r\n";
					let discardFromDestiny = function(j) {
						if(j === 2) {
							shuffle(z.destiny);
							plainAlert("Destiny reshuffled.");
							removeOption(me, ch);
							mainMenu();
						} else {
							let promptText = "What is the ";
							if(j === 0) {
								promptText += "first";
							} else {
								promptText += "second";
							}
							promptText += " card you want to discard from Destiny? (1-" + z.destiny.length + ")";
							for(let k = 0; !(k >= z.destiny.length); k++) {
								promptText += "\n" + (k + 1) + ": " + cardText(z.destiny[k]);
							}
							promptNum(promptText, (a) => 1 > a || a > z.destiny.length, () => {
								discardFromDestiny(j);
							}, (prompted) => {
								addAlert("You discard " + cardText(z.destiny[prompted - 1]) + " from Destiny.");
								t.value += bold(myPlayer + " discards " + cardText(z.destiny[prompted - 1]) + " from Destiny.") +
									"\r\n";
								let card = z.destiny.splice(prompted - 1, 1)[0];
								z.skillCardDiscards[cardColorID(card)].push(card);
								refreshSkillDecks();
								discardFromDestiny(j + 1);
							});
						}
					};
					discardFromDestiny(0);
				}
			});
		} else if(ch === "Resolve the Reckless") {
			confirmify("Confirming you want to resolve the Reckless effect on this skill check.", mainMenu, () => {
				removeFromAll("[Human Delusion] Play a card into the skill check");
				if(z.skillCardDecks[5].length === 0) {
					z.reckless = false;
					plainAlert("Treachery deck is completely depleted; Reckless has no effect.");
					if(z.thisConsequence === 0 || !consequenceTriggered()) {
						if(shouldDE()) {
							addAlert("The check is within Declare Emergency range.");
							DEToken();
						}
					}
				} else {
					if(Number.isInteger(z.reckless) && z.reckless > 0){
						z.reckless--;
						if(z.reckless === 0){
							z.reckless = false;
						}
					} else {
						z.reckless = false;
					}
					let firstCard = z.skillCardDecks[5].pop();
					if(z.skillCardDecks[5].length === 0) {
						z.skillCardDecks[5] = shuffle(z.skillCardDiscards[5]);
						z.skillCardDiscards[5] = [];
						t.value += colorText("brown", "Treachery ") + "deck reshuffles.\r\n";
					}
					if(cardValue(firstCard) > 0) {
						plainAlert("Reckless reveals " + cardText(firstCard) + ": No Effect.");
						z.skillCardDiscards[5].push(firstCard);
						reshuffleSkillCardDeck(5);
						if(z.thisConsequence === 0 || !consequenceTriggered()) {
							if(shouldDE()) {
								addAlert("The check is within Declare Emergency range.");
								DEToken();
							}
						}
					} else {
						t.value += "First card from Reckless is " + cardText(firstCard) + ".\r\n";
						if(cardName(firstCard) === "Bait") {
							addAlert("First card from Reckless is a Bait; Civilian placed behind Galactica.");
							if(!z.galacticaAway) {
								placeCivilian(4);
							}
						} else if(cardName(firstCard) === "Dradis Contact") {
							addAlert("First card from Reckless is a Dradis Contact; 2 Raiders placed in front of Galactica.");
							if(!z.galacticaAway) {
								placeRaiders(1, 2);
							}
						}
						if(z.skillCardDecks[5].length === 0) {
							plainAlert("Treachery deck is completely depleted; no second card is drawn.");
							if(z.thisConsequence === 0 || !consequenceTriggered()) {
								if(shouldDE()) {
									addAlert("The check is within Declare Emergency range.");
									DEToken();
								}
							}
						} else {
							let secondCard = z.skillCardDecks[5].pop();
							if(z.skillCardDecks[5].length === 0) {
								z.skillCardDecks[5] = shuffle(z.skillCardDiscards[5]);
								z.skillCardDiscards[5] = [];
								t.value += colorText("brown", "Treachery ") + "deck reshuffles.\r\n";
							}
							t.value += "Second card from Reckless is " + cardText(secondCard) + ":\r\n";
							addAlert("Second card from Reckless is " + cardName(secondCard) + "; it is automatically resolved.");
							switch (cardName(secondCard)) {
								case "Bait":
									if(!z.galacticaAway) {
										placeCivilian(4);
									}
									break;
								case "Dradis Contact":
									if(!z.galacticaAway) {
										placeRaiders(1, 2);
									}
									break;
								case "Personal Vices":
									dealSkillCardToEveryone(z.turn, 5, false);
									if(z.revealedCylons[z.turn] === 0) {
										dealMutiny(z.turn, false);
									}
									break;
								case "A Better Machine":
									shuffleTreachery();
									break;
								case "Violent Outbursts":
									/* RULES: Cylons on NC sent to Medical Center? */ if(z.revealedCylons[z.turn] === 0 && z.playerLocations[z
											.turn] !== "Stranded on Caprica" && z.playerLocations[z.turn] !== "Brig" && z.playerLocations[z
											.turn] !== "Detention") {
										if(isOnNewCaprica(me)) {
											movePlayer(z.turn, "Medical Center");
										} else {
											movePlayer(z.turn, "Sickbay");
										}
									} else {
										plainAlert("No effect.");
									}
									break;
								case "Exploit Weakness":
									plainAlert(z.players[z.turn] + ", as current player, must give a Mutiny to a player of their choice.");
									addOption(z.turn, "Deal a Mutiny card", undefined, true);
									break;
							}
							z.skillCardDiscards[5].push(firstCard);
							z.skillCardDiscards[5].push(secondCard);
							reshuffleSkillCardDeck(5);
							if(z.thisConsequence === 0 || !consequenceTriggered()) {
								if(shouldDE()) {
									addAlert("The check is within Declare Emergency range.");
									DEToken();
								}
							}
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "[Misjump] Draw and resolve the next card of the Destination deck") {
			confirmify(
				"Confirming you want to draw and resolve the next card of the Destination deck.  Make sure a civilian was destroyed from Misjump first.",
				mainMenu, () => {
					let dest = z.destinationDeck.pop();
					z.destinationDiscards.push(dest);
					addAlert("Destination is " + d.destinationNames[dest] + ".");
					processDestination();
					removeOption(me, ch);
					mainMenu();
				});
		} else if(ch === "Move Scar") {
			let promptText = "Scar is currently in Sector " + z.scar + ". Which sector would you like to move him to? (1-6)";
			promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				z.scar = prompted;
				boldAlert("Scar moves to Sector " + z.scar);
				mainMenu();
			});
		} else if(ch === "Destroy Scar") {
			confirmify("Confirming you want to destroy Scar.  He can only be destroyed on a die roll of 7 or 8.", mainMenu, () => {
				z.scarCAC = false;
				z.scar = -1;
				z.raiders.push(0);
				if(z.galacticaReturned){
					z.oldCrisisDiscards.push(83);
				} else {
					z.crisisDiscards.push(83);
				}
				boldAlert("Scar is destroyed!");
				if(z.dogfightCAC && raidersAway() === z.raiders.length) {
					plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
					z.dogfightCAC = false;
					if(z.galacticaReturned){
						z.oldCrisisDiscards.push(76);
					} else {
						z.crisisDiscards.push(76);
					}
				}
				removeOption(me, ch);
				removeOption(me, "Destroy Raider(s)");
				mainMenu();
			});
		} else if(ch === "[Preventative Policy] Pick a resource to protect") {
			promptNum("Which resource would you like to protect with Preventative Policy? (1-4)\n1: Fuel\n2: Food\n3: Morale\n4: Population", (a) => 1 >
				a || a > 4, mainMenu, (prompted) => {
					switch (prompted) {
						case 1:
							z.preventative = "Fuel";
							break;
						case 2:
							z.preventative = "Food";
							break;
						case 3:
							z.preventative = "Morale";
							break;
						case 4:
							z.preventative = "Population";
							break;
					}
					addAlert("Played Preventative Policy on " + z.preventative);
					t.value += bold(myPlayer + " plays the " + colorText("orange", "Preventative Policy") + " on " + z.preventative) + ".\r\n";
					removeOption(me, ch);
					endMovement();
					mainMenu();
				});
		} else if(ch === "Box a Human") {
			let promptText = "";
			if(isMale(me)) {
				promptText += "Mr. ";
			} else {
				promptText += "Madam ";
			}
			promptText += "President, the mob demands a sacrifice.\nWho will you find guilty and eliminate from the game? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.antagonistic[j] > 2) {
					promptText += z.players[j];
				} else {
					promptText += "(not on trial)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || 3 > z.antagonistic[a - 1], mainMenu, (prompted) => {
				confirmify("Are you SURE you want to condemn " + z.players[prompted - 1] + " and permanently eliminate them from the game?",
					mainMenu, () => {
						let killThem = function() {
							t.value += bold(colorText("orange", "President ") + z.players[z.president] + " chooses to eliminate " + z
								.players[prompted - 1]) + ".\r\n";
							boxPlayer(prompted - 1);
							z.preCrossroads = false;
							if(z.numPlayers === 0) {
								endGame();
							} else {
								if(z.destinationDiscards[z.destinationDiscards.length - 1] === 32 || (z.destinationDiscards[z
										.destinationDiscards.length - 1] === 34 && z.destinationDiscards[z.destinationDiscards
										.length - 2] === 32 && z.distance >= 9 && z.destination === "Ionian Nebula")) {
									/* TODO: what if you pull some crazy AVP shit with Ionian Earth. */
									addAlert("Increasing Jump Prep by 2 from Lion's Head Nebula.");
									t.value += "Jump Prep increases due to Lion's Head Nebula.\r\n";
									increaseJump();
									increaseJump();
								}
								if(z.v20Jump){
									plainAlert("Jump Prep increases by 2 due to the 20 Loyalty Card variant rules, as there were 3 Cylons.");
									increaseJump();
									increaseJump();
								}
								textGameState(true);
								mainMenu();
							}
						};
						if(me === prompted - 1) {
							confirmify("This will make you immediately lose the game!", killThem, mainMenu, "I don't want to lose",
								"Yes, I really want to lose the game");
						} else {
							killThem();
						}
					}, "Kill Them!", "Never Mind");
			});
		} else if(ch === "Move on from this Crossroads card") {
			confirmify("Confirming that you are done with all effects from " + z.crossroadsCards[z.crossroadsPlayer] + ", and wish to move on.",
				mainMenu, () => {
					z.crossroadsPlayer++;
					z.crossroadsPlayer %= z.numPlayers;
					if(z.crossroadsPlayer === z.turn) {
						z.lateCrossroads = true;
						startBoxing();
					} else {
						flipCrossroads();
					}
					mainMenu();
				});
		} else if(ch === "[Strange Music] I Hear It") {
			let promptText = "Who is drawing a new Loyalty card? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.revealedCylons[j] === 1) {
					promptText += "(CYLON)";
				} else if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(j === z.theSympatheticCylon) {
					promptText += "(Sympathetic Cylon)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || isTheCylonLeader(a - 1)|| a - 1 === z
				.theSympatheticCylon, mainMenu, (prompted) => {
					let loy = z.loyaltyDeck.pop();
					z.loyaltyHands[prompted - 1].push(loy);
					addAlert("You dealt a new Loyalty card to " + z.players[prompted - 1]);
					t.value += bold(myPlayer + " deals a new Loyalty card to " + z.players[prompted - 1]) + ".\r\n";
					let pause = false;
					if(loy === 40) {
						becomeMutineer(prompted - 1);
						if(characterPresent("Tom")) {
							pause = true;
						}
					} else if(loy === 15) {
						pause = !becomeSympathizer(prompted - 1);
					} else if(loy === 17) {
						pause = !becomeSympatheticCylon(prompted - 1);
					}
					if(pause) {
						addAlert("Each Cylon will draw a Trauma after the Loyalty draw fully resolves.");
						t.value += "After the Loyalty draw fully resolves, each Cylon must draw a Trauma Token.\r\n";
						optionForAll("[Strange Music] Deal Trauma Tokens");
					} else {
						addAlert("Each Cylon player draws a trauma token.");
						for(let j = 0; !(j >= z.numPlayers); j++) {
							let k = (j + z.turn) % z.numPlayers;
							if(z.revealedCylons[k] === 1) {
								drawTraumas(k, 1);
							}
						}
					}
					removeOption(me, ch);
					mainMenu();
				});
		} else if(ch === "Choose the Benevolent (top) option on your Crossroads card") {
			confirmify("Confirming you want to choose the Benevolent (top) option on your Crossroads card.", mainMenu, () => {
				z.crossroadsTrauma[me] = 1;
				processCrossroads(1);
				mainMenu();
			});
		} else if(ch === "Choose the Antagonistic (bottom) option on your Crossroads card") {
			confirmify("Confirming you want to choose the Antagonistic (bottom) option on your Crossroads card.", mainMenu, () => {
				z.crossroadsTrauma[me] = 0;
				processCrossroads(0);
				mainMenu();
			});
		} else if(ch === "Set up the Battle of the Ionian Nebula") {
			confirmify("Confirming that you want to set up the Battle of the Ionian Nebula.", mainMenu, () => {
				setupIN();
				mainMenu();
			});
		} else if(ch === "[Brutality] Reveal the Loyalty deck") {
			confirmify("Confirming that you want to reveal the Loyalty deck to check for Brutality's solo Cylon penalty.", mainMenu, () => {
				brutalityCylonCheck();
				mainMenu();
			});
		} else if (ch === "[20 Loyalty Cards] Check the number of Cylons"){
			confirmify("Confirming that you want to check the number of Cylons at the table, per the 20 Loyalty Card variant rules.", mainMenu, () => {
				v20Check();
				mainMenu();
			});
		} else if (ch === "[Brutality] Discard Personal Goals and deal new Loyalty cards"){
			confirmify("Confirming that you want to resolve Brutality Personal Goals now that the Fleet has reached 6 distance.", mainMenu, () => {
				brutalityPersonalGoalsResolution();
				mainMenu();
			});
		} else if(ch === "Start the Crossroads Phase") {
			confirmify("Confirming that you want to start the Crossroads Phase.", mainMenu, () => {
				startCrossroads();
				mainMenu();
			});
		} else if(ch === "Place a Trauma Token on my Crossroads card") {
			let placeAntagonistic = function() {
				confirmify("Confirming you want to place an Antagonistic Trauma Token on your Crossroads Card, " + z.crossroadsCards[me] + ".",
					mainMenu, () => {
						addAlert("You place an Antagonistic Trauma token on your Crossroads card.");
						z.antagonistic[me]--;
						z.crossroadsTrauma[me] = 0;
						t.value += myPlayer + " places a Trauma token on their Crossroads card.\r\n";
						let canGo = true;
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.crossroadsTrauma[j] === false) {
								canGo = false;
								break;
							}
						}
						if(canGo) {
							z.midCrossroads = true;
							z.crossroadsPlayer = z.turn;
							flipCrossroads();
						}
						mainMenu();
					});
			};
			let placeBenevolent = function() {
				confirmify("Confirming you want to place a Benevolent Trauma Token on your Crossroads Card, " + z.crossroadsCards[me] + ".",
					mainMenu, () => {
						addAlert("You place a Benevolent Trauma token on your Crossroads card.");
						z.benevolent[me]--;
						z.crossroadsTrauma[me] = 1;
						t.value += myPlayer + " places a Trauma token on their Crossroads card.\r\n";
						let canGo = true;
						for(let j = 0; !(j >= z.numPlayers); j++) {
							if(z.crossroadsTrauma[j] === false) {
								canGo = false;
								break;
							}
						}
						if(canGo) {
							z.midCrossroads = true;
							z.crossroadsPlayer = z.turn;
							flipCrossroads();
						}
						mainMenu();
					});
			};
			if(z.antagonistic[me] > 0 && z.benevolent[me] === 0) {
				placeAntagonistic();
			} else if(z.antagonistic[me] === 0 && z.benevolent[me] > 0) {
				placeBenevolent();
			} else if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
				confirmify("Would you like to place an Antagonistic token or a Benevolent token on " + z.crossroadsCards[me] +
					"?\n(You will have the option to cancel on the next screen.)", placeBenevolent, placeAntagonistic, "Antagonistic", "Benevolent");
			}
		} else if(ch === "Discard a Trauma Token") {
			let discardAntagonistic = function() {
				confirmify("Confirming you want to discard an Antagonistic Trauma Token.", mainMenu, () => {
					addAlert("You discard an Antagonistic Trauma token.");
					z.antagonistic[me]--;
					z.traumaPile.push(0);
					shuffle(z.traumaPile);
					t.value += myPlayer + " discards a Trauma token.\r\n";
					if(hasContext(me, ch, "Cavil")) {
						if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
							let rand = Math.floor((z.seed * (z.antagonistic[me] + z.benevolent[me]))/mLCG);
							updateSeed();
							if(z.antagonistic[me] > rand) {
								addAlert("You discard an Antagonistic Trauma token randomly.");
								z.antagonistic[me]--;
								z.traumaPile.push(0);
								shuffle(z.traumaPile);
							} else {
								addAlert("You discard a Benevolent Trauma token randomly.");
								z.benevolent[me]--;
								z.traumaPile.push(1);
								shuffle(z.traumaPile);
							}
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						} else if(z.antagonistic[me] > 0) {
							addAlert("You discard an Antagonistic Trauma token.");
							z.antagonistic[me]--;
							z.traumaPile.push(0);
							shuffle(z.traumaPile);
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						} else if(z.benevolent[me] > 0) {
							addAlert("You discard a Benevolent Trauma token.");
							z.benevolent[me]--;
							z.traumaPile.push(1);
							shuffle(z.traumaPile);
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						}
						removeOption(me, ch);
					} else if(z.antagonistic[me] === 0 && z.benevolent[me] === 0) {
						removeOption(me, ch);
					} else if(hasContext(me, ch, 3)) {
						let man = isMandatory(me, ch);
						addOption(me, ch, 2, man);
					} else if(hasContext(me, ch, 2)) {
						let man = isMandatory(me, ch);
						addOption(me, ch, undefined, man);
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			};
			let discardBenevolent = function() {
				confirmify("Confirming you want to discard a Benevolent Trauma Token.", mainMenu, () => {
					addAlert("You discard a Benevolent Trauma token.");
					z.benevolent[me]--;
					z.traumaPile.push(1);
					shuffle(z.traumaPile);
					t.value += myPlayer + " discards a Trauma token.\r\n";
					if(hasContext(me, ch, "Cavil")) {
						if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
							let rand = Math.floor((z.seed * (z.antagonistic[me] + z.benevolent[me]))/mLCG);
							updateSeed();
							if(z.antagonistic[me] > rand) {
								addAlert("You discard an Antagonistic Trauma token randomly.");
								z.antagonistic[me]--;
								z.traumaPile.push(0);
								shuffle(z.traumaPile);
							} else {
								addAlert("You discard a Benevolent Trauma token randomly.");
								z.benevolent[me]--;
								z.traumaPile.push(1);
								shuffle(z.traumaPile);
							}
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						} else if(z.antagonistic[me] > 0) {
							addAlert("You discard an Antagonistic Trauma token.");
							z.antagonistic[me]--;
							z.traumaPile.push(0);
							shuffle(z.traumaPile);
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						} else if(z.benevolent[me] > 0) {
							addAlert("You discard a Benevolent Trauma token.");
							z.benevolent[me]--;
							z.traumaPile.push(1);
							shuffle(z.traumaPile);
							t.value += myPlayer + " discards a Trauma token randomly.\r\n";
						}
						removeOption(me, ch);
					} else if(z.antagonistic[me] === 0 && z.benevolent[me] === 0) {
						removeOption(me, ch);
					} else if(hasContext(me, ch, 3)) {
						let man = isMandatory(me, ch);
						addOption(me, ch, 2, man);
					} else if(hasContext(me, ch, 2)) {
						let man = isMandatory(me, ch);
						addOption(me, ch, man);
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			};
			if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
				confirmify("Would you like to discard an Antagonistic token or a Benevolent token?", discardBenevolent, discardAntagonistic,
					"Antagonistic", "Benevolent");
			} else if(z.antagonistic[me] > 0) {
				discardAntagonistic();
			} else if(z.benevolent[me] > 0) {
				discardBenevolent();
			}
		} else if(ch === "[Scapegoat] Draw Trauma Tokens" || ch === "[Gaeta] Draw Trauma Tokens" || ch === "[D'Anna] Draw Trauma Tokens") {
			confirmify("Confirming you want to draw 2 Trauma Tokens.", mainMenu, () => {
				drawTraumas(me, 2);
				removeOption(me, ch);
				removeOption(me, "Discard a Skill Card");
				removeOption(me, "Choose a Skill Card to discard if Athena does not Love you");
				mainMenu();
			});
		} else if(ch === "[Strange Music] Deal Trauma Tokens") {
			confirmify("Confirming you want to deal 1 Trauma Token to every Cylon.", mainMenu, () => {
				addAlert("Each Cylon player draws a trauma token.");
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (j + z.turn) % z.numPlayers;
					if(z.revealedCylons[k] === 1) {
						drawTraumas(k, 1);
					}
					removeOption(j, ch);
				}
				mainMenu();
			});
		} else if(ch === "Deal Trauma Tokens" || ch === "[The Opera House] Deal Trauma Tokens") {
			let promptText = "Who would you like to deal the Trauma Tokens to? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(j !== me || ch === "Deal Trauma Tokens") {
					promptText += "\n" + (j + 1) + ": " + z.players[j] + " (has " + (z.antagonistic[j] + z.benevolent[j]) + " Trauma)";
				} else {
					promptText += "\n" + (j + 1) + ": (cannot choose yourself)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || (ch === "[The Opera House] Deal Trauma Tokens" && a - 1 === me), mainMenu, (
				prompted) => {
				if(ch === "[The Opera House] Deal Trauma Tokens") {
					confirmify("Confiming you want to deal 3 Trauma Tokens to " + z.players[prompted - 1] + ".", mainMenu, () => {
						addAlert("Dealt 3 Traumas to " + z.players[prompted - 1]);
						drawTraumas(prompted - 1, 3);
						removeOption(me, ch);
						mainMenu();
					});
				} else {
					promptNum("How many Traumas would you like to deal to " + z.players[prompted - 1] + "? (1-3)", (a) => 1 > a || a > 3,
						mainMenu, (prompted2) => {
							addAlert("Dealt " + prompted2 + " Traumas to " + z.players[prompted - 1]);
							drawTraumas(prompted - 1, prompted2);
							mainMenu();
						});
				}
			});
		} else if(ch === "Place a Trauma token on the newly-revealed Ally") {
			/* TODO: only give the correct person this option. */
			let newAlly = z.cylonAllyQueue[z.cylonAllyQueue.length - 1];
			confirmify("Confirming you want to place a Trauma token on " + d.allyNames[newAlly] + ".\n\nMake sure you have been instructed to do so.",
				mainMenu, () => {
					if(z.benevolent[me] === 0 && z.antagonistic[me] > 0) {
						confirmify("Confirming you want to place an Antagonistic token on " + d.allyNames[newAlly] +
							"; you have no Benevolent tokens.", mainMenu, () => {
								z.antagonistic[me]--;
								z.allies.push([newAlly, 0]);
								addAlert("You place an Antagonistic Trauma on " + d.allyNames[newAlly]);
								t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[newAlly]) + ".\r\n";
								z.cylonAllyQueue.pop();
								resolveCylonAllyQueue();
								mainMenu();
							});
					} else if(z.antagonistic[me] === 0 && z.benevolent[me] > 0) {
						confirmify("Confirming you want to place a Benevolent token on " + d.allyNames[newAlly] +
							"; you have no Antagonistic tokens.", mainMenu, () => {
								z.benevolent[me]--;
								z.allies.push([newAlly, 1]);
								addAlert("You place a Benevolent Trauma on " + d.allyNames[newAlly]);
								t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[newAlly]) + ".\r\n";
								z.cylonAllyQueue.pop();
								resolveCylonAllyQueue();
								mainMenu();
							});
					} else if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
						confirmify("Which type of Trauma Token do you want to place on " + d.allyNames[newAlly] + "?" + "\nBenevolent (you have " +
							z.benevolent[me] + ")" + "\nAntagonistic (you have " + z.antagonistic[me] + ")", () => {
								z.antagonistic[me]--;
								z.allies.push([newAlly, 0]);
								addAlert("You place an Antagonistic Trauma on " + d.allyNames[newAlly]);
								t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[newAlly]) + ".\r\n";
								z.cylonAllyQueue.pop();
								resolveCylonAllyQueue();
								mainMenu();
							}, () => {
								z.benevolent[me]--;
								z.allies.push([newAlly, 1]);
								addAlert("You place a Benevolent Trauma on " + d.allyNames[newAlly]);
								t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[newAlly]) + ".\r\n";
								z.cylonAllyQueue.pop();
								resolveCylonAllyQueue();
								mainMenu();
							}, "Benevolent", "Antagonistic");
					}
				});
		} else if(ch === "Place a Trauma Token on the new Ally") {
			if(z.benevolent[me] === 0 && z.antagonistic[me] > 0) {
				confirmify("Confirming you want to place an Antagonistic token on " + d.allyNames[z.newAlly] + "; you have no Benevolent tokens.",
					mainMenu, () => {
						z.antagonistic[me]--;
						z.allies.push([z.newAlly, 0]);
						addAlert("You place an Antagonistic Trauma on " + d.allyNames[z.newAlly]);
						t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[z.newAlly]) + ".\r\n";
						z.newAlly = null;
						mainMenu();
					});
			} else if(z.antagonistic[me] === 0 && z.benevolent[me] > 0) {
				confirmify("Confirming you want to place a Benevolent token on " + d.allyNames[z.newAlly] + "; you have no Antagonistic tokens.",
					mainMenu, () => {
						z.benevolent[me]--;
						z.allies.push([z.newAlly, 1]);
						addAlert("You place a Benevolent Trauma on " + d.allyNames[z.newAlly]);
						t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[z.newAlly]) + ".\r\n";
						z.newAlly = null;
						mainMenu();
					});
			} else if(z.antagonistic[me] > 0 && z.benevolent[me] > 0) {
				confirmify("Confirming you want to place a Trauma token on " + d.allyNames[z.newAlly] + ".", mainMenu, () => {
					confirmify("Which type of Trauma Token do you want to place on " + d.allyNames[z.newAlly] + "?" +
						"\nBenevolent (you have " + z.benevolent[me] + ")" + "\nAntagonistic (you have " + z.antagonistic[me] + ")", () => {
							z.antagonistic[me]--;
							z.allies.push([z.newAlly, 0]);
							addAlert("You place an Antagonistic Trauma on " + d.allyNames[z.newAlly]);
							t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[z.newAlly]) + ".\r\n";
							z.newAlly = null;
							mainMenu();
						}, () => {
							z.benevolent[me]--;
							z.allies.push([z.newAlly, 1]);
							addAlert("You place a Benevolent Trauma on " + d.allyNames[z.newAlly]);
							t.value += bold(myPlayer + " places a Trauma on " + d.allyNames[z.newAlly]) + ".\r\n";
							z.newAlly = null;
							mainMenu();
						}, "Benevolent", "Antagonistic");
				});
			}
		} else if(ch === "Discard the Ally you just met and draw a new one") {
			confirmify("Confirming you have finished resolving " + d.allyNames[z.metAlly[0]] +
				" and want to discard them and replace them with a new Ally.", mainMenu, () => {
					let oldTrauma = z.metAlly[1];
					if(oldTrauma !== null){
						z.traumaPile.push(oldTrauma);
					}
					shuffle(z.traumaPile);
					z.metAlly = null;
					let newAlly = allyPop();
					if(newAlly === -1) {
						plainAlert("Ally deck exhausted; it does not reshuffle.");
					} else {
						boldAlert("New Ally is " + d.allyNames[newAlly] + ".");
						if(!z.executedCurrentPlayer) {
							if(z.antagonistic[me] + z.benevolent[me] === 0) {
								/* TODO / RULES: what if you completely run out of trauma? */
								let trauma = z.traumaPile.pop();
								if(trauma === undefined){
									z.allies.push([newAlly,null]);
									plainAlert("The Trauma pile is empty; no Trauma is placed on "+d.allyNames[newAlly]+".");
								} else {
									z.allies.push([newAlly, z.traumaPile.pop()]);
									plainAlert("Trauma for " + d.allyNames[newAlly] + " is placed randomly.");
								}
							} else if(z.antagonistic[me] + z.benevolent[me] === 1) {
								if(z.antagonistic[me] === 1) {
									z.allies.push([newAlly, 0]);
									z.antagonistic[me] = 0;
									addAlert("You place your last Trauma, an Antagonistic one, on " + d.allyNames[newAlly] + ".");
								} else {
									z.allies.push([newAlly, 1]);
									z.benevolent[me] = 0;
									addAlert("You place your last Trauma, a Benevolent one, on " + d.allyNames[newAlly] + ".");
								}
								t.value += bold(myPlayer + " places their last Trauma on " + d.allyNames[newAlly]) + ".\r\n";
							} else {
								z.newAlly = newAlly;
								addAlert("Now, place a Trauma token on " + d.allyNames[newAlly]);
								t.value += "Now, " + myPlayer + " must place a Trauma token on " + d.allyNames[newAlly] + ".\r\n";
							}
						} else {
							z.cylonAllyQueue.push(newAlly);
							resolveCylonAllyQueue();
						}
					}
					mainMenu();
				});
		} else if(ch === "Meet an Ally on your location") {
			/* TODO: Ally flavor (long term project) */
			let alliesHere = [];
			for(let j = 0; !(j >= z.allies.length); j++) {
				if(d.allyLocations[z.allies[j][0]] === myLocation) {
					alliesHere.push(j);
				}
			}
			let meetAlly = function(metAlly) {
				let alertText = "You encounter " + d.allyNames[z.allies[metAlly][0]] +
				", who is "; /* RULES: reshuffle trauma before or after effect? */
				let done = false;
				z.metAnAlly = true;
				z.metAlly = z.allies.splice(metAlly, 1)[0];
				switch (z.metAlly[1]) {
					case null:
						alertText += "possession of a thousand-yard stare, and little else.";
						addAlert(alertText);
						t.value += imageM(900697) + imageM(allyBanner(d.allyNames[z.metAlly[0]])) + imageM(900698) + "\r\n";
						plainAlert("No Effect.");
						done = true;
						break;
					case -1:
						alertText += "a DISASTER.";
						addAlert(alertText); /* TODO: not great on mobile */
						t.value += imageM(900697) + imageM(allyBanner(d.allyNames[z.metAlly[0]])) + imageM(900698) + "\r\n";
						plainAlert("No Effect.");
						done = true;
						break;
					case 0:
						alertText += "ANTAGONISTIC.";
						addAlert(alertText);
						t.value += imageO(900695) + imageM(allyBanner(d.allyNames[z.metAlly[0]])) + imageM(900696) + "\r\n";
						switch (d.allyNames[z.metAlly[0]]) {
							case "Hoshi":
								if(z.negotiation) {
									done = true;
									addAlert("Negotiation prevents the Basestar activation.");
									t.value += colorText("orange", "Negotiation") + " prevents the Basestar activation.\r\n";
								} else {
									done = activateBasestars();
								}
								break;
							case "Starbuck":
								if(z.negotiation) {
									done = true;
									addAlert("Negotiation prevents the Raider activation.");
									t.value += colorText("orange", "Negotiation") + " prevents the Raider activation.\r\n";
								} else {
									if(myPlayer === "Gaeta") {
										t.value += italics(
											"Are you enjoying yourself?  Is this how you get your kicks these days?  Oh wait, I'm sorry, I meant half-kicks."
											) + "\r\n";
									}
									done = activateRaiders();
								}
								break;
							case "Ellen":
							case "Zarek":
							case "Tigh":
								addAlert("You are sent to the Brig!");
								movePlayer(me, "Brig");
								done = true;
								break;
							case "Roslin":
							case "Dee":
							case "Leoben":
							case "Elosha":
								drawTraumas(me, 2);
								done = true;
								break;
							case "Gaeta":
								if(myPlayer === "Starbuck") {
									t.value += italics("So, I guess a pity frak's out of the question, then?") + "\r\n";
								}
								addAlert("Now, you must draw 2 Trauma Tokens or discard 3 Skill Cards.");
								t.value += myPlayer +
								" must now draw 2 Trauma Tokens or discard 3 Skill Cards.\r\n"; 
								addOption(me, "[Gaeta] Draw Trauma Tokens", undefined, false);
								if(z.forLove && z.players[me] !== "Athena" && z.forLoveCOs[me] === null) {
									if(z.players[me] === "Apollo" && !noDrawback(me)){
										/* TODO: make sure this doesn't cause issues */
										z.randomLove[me] = true;
										addOption(me, "Discard a random Skill Card", 2, false);
									} else {
										addOption(me, "Discard a Skill Card", 2, false);
										addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, false);
									}
								} else {
									if(z.players[me] === "Apollo" && !noDrawback(me)){
										addOption(me, "Discard a random Skill Card", 3, false);
									} else {
										addOption(me, "Discard a Skill Card", 3, false);
									}
								}
								break;
							case "D'Anna":
								addAlert("Now, you must draw 2 Trauma Tokens or discard 3 Skill Cards.");
								t.value += myPlayer + " must now draw 2 Trauma Tokens or discard 3 Skill Cards.\r\n";
								addOption(me, "[D'Anna] Draw Trauma Tokens", undefined, false);
								if(z.forLove && z.players[me] !== "Athena" && z.forLoveCOs[me] === null) {
									if(z.players[me] === "Apollo" && !noDrawback(me)){
										/* TODO: make sure this doesn't cause issues */
										z.randomLove[me] = true;
										addOption(me, "Discard a random Skill Card", 2, false);
									} else {
										addOption(me, "Discard a Skill Card", 2, false);
										addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, false);
									}
								} else {
									if(z.players[me] === "Apollo" && !noDrawback(me)){
										addOption(me, "Discard a random Skill Card", 3, false);
									} else {
										addOption(me, "Discard a Skill Card", 3, false);
									}
								}
								break;
							case "Hot Dog":
								plainAlert("Hot Dog is a Troublemaker; roll a die, on a 4 or less, lose 1 Morale.");
								SPTokenBad("Troublemaker (Hot Dog)");
								break;
							case "Chief":
							case "Seelix":
								if(d.allyNames[z.metAlly[0]] === "Seelix" && myPlayer === "Anders") {
									t.value += italics(
										"I really thought there was something between us, you know.  When that didn't happen, I wondered...was it me?  'Cause I know it's been months, but I just can't let it go."
										) + "\r\n";
								}
								addAlert("You are sent to Sickbay!");
								movePlayer(me, "Sickbay");
								break;
							case "Cally":
								plainAlert("Cally has Mood Swings; roll a die, on a 4 or less, lose 1 Morale.");
								SPTokenBad("Mood Swings (Cally)");
								break;
							case "Doral":
							case "Boomer":
							case "Kelly":
								if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
									t.value += myPlayer + " must now choose whether to damage Pegasus or Galactica.\r\n";
									addAlert("You must now choose whether to damage Pegasus or Galactica.");
									addOption(me, "Damage Pegasus", undefined, true);
									addOption(me, "Damage Galactica", undefined, true);
								} else {
									done = damageGalactica();
								}
								break;
							case "Anders": {
								let spaceVipers = 0;
								for(let j = 0; !(j >= z.vipersII.length); j++) {
									if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
										spaceVipers++;
									}
								}
								for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
									if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
										spaceVipers++;
									}
								}
								for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
									if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
										spaceVipers++;
									}
								}
								if(spaceVipers === 0) {
									plainAlert("There are no unmanned Vipers in space; no effect.");
									done = true;
								} else if(spaceVipers > 2) {
									t.value += "Anders is a Rookie Pilot; " + bold(myPlayer + " must now damage 2 unmanned Vipers in space.") +
										"\r\n";
									addAlert("Anders is a Rookie Pilot; you must now damage 2 unmanned Vipers in space.");
									addOption(me, "Damage a Viper", ["Anders", 2], true);
								} else {
									for(let j = 0; !(j >= z.vipersII.length); j++) {
										if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
											t.value += "Unmanned Viper Mk II in Sector " + z.vipersII[j] + " damaged.\r\n";
											z.vipersII[j] = -1;
										}
									}
									for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
										if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
											t.value += "Unmanned Viper Mk VII in Sector " + z.vipersVII[j] + " damaged.\r\n";
											z.vipersVII[j] = -1;
										}
									}
									for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
										if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
											t.value += "Unmanned Assault Raptor in Sector " + z.assaultRaptors[j] + " destroyed.\r\n";
											z.assaultRaptors[j] = -2;
										}
									}
									if(spaceVipers === 1) {
										addAlert("Anders automatically damages 1 unmanned Viper in space.");
									} else {
										addAlert("Anders automatically damages 2 unmanned Vipers in space.");
									}
									done = true;
								}
								break;
							}
							case "Crashdown":
								plainAlert("Crashdown is an Inexperienced Leader; roll a die, on a 4 or less, lose 1 Population.");
								SPTokenBad("Inexperienced Leader (Crashdown)");
								break;
							case "Kat":
								done = promptAllyDiscards(me, 3);
								t.value += "Kat has a Stim Addiction; " + myPlayer + " must now discard 3 Skill Cards.\r\n";
								break;
							case "Adama":
								decreaseJump();
								done = true;
								break;
							case "Helo":
								plainAlert("Helo makes Unpopular Decisions; roll a die, on a 4 or less, lose 1 Morale.");
								SPTokenBad("Unpopular Decisions (Helo)");
								break;
							case "Shaw":
							case "Kendra":
								done = destroyPileCivilian(1);
								break;
							case "Apollo":
								if(z.negotiation) {
									done = true;
									addAlert("Negotiation prevents the Launch Raiders icon.");
									t.value += colorText("orange", "Negotiation") + " prevents the Launch Raiders icon.\r\n";
								} else {
									done = launchRaiders();
								}
								break;
							case "Cain":
								if(z.playerLocations[z.admiral] === "Stranded on Caprica") {
									t.value += "Helo is Stranded, and cannot be sent to the Brig.\r\n";
								} else {
									movePlayer(z.admiral, "Brig");
								}
								done = true;
								break;
							case "Romo":
								addAlert("You discard all of your skill cards!");
								done = discardEntireHand(me);
								break;
							case "Cavil":
								placeBasestar(1);
								addAlert("3 Raiders placed in Sector 1.");
								placeRaiders(1, 3);
								placeCivilian(4);
								done = true;
								break;
							case "Racetrack":
							case "Billy":
								drawTraumas(me, 1);
								if(z.skillCardHands[me].length > 0) {
									if(!z.forLove || z.players[me] === "Athena") {
										discardRandomSkillCard(me);
									} else {
										plainAlert(myPlayer + " must discard 1 random Skill Card, but Athena can Love them.");
										promptRandomDiscards(me, 1, true);
									}
								}
								done = true;
								break;
							case "Baltar":
								if(7 >= z.distance && !isCylonLeader(myPlayer) && me !== z.theSympatheticCylon && z.numPlayers + z.boxedPlayers.length > 1 && 
								   z.loyaltyDeck.length + z.notCylonDeck.length > 0) {
									
									if(z.notCylonDeck.length > 0){
										z.loyaltyDeck.push(z.notCylonDeck.pop());
										t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
									}
									shuffle(z.loyaltyDeck);
									let loy = z.loyaltyDeck.pop();
									z.loyaltyHands[me].push(loy);
									addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
									
									t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
									if(loy === 40) {
										becomeMutineer(me);
										if(!characterPresent("Tom")) {
											done = true;
										}
									} else if(loy === 15) {
										done = becomeSympathizer(me);
									} else if(loy === 17) {
										done = becomeSympatheticCylon(me);
									} else {
										done = true;
									}
								} else {
									plainAlert("No Effect.");
									done = true;
								}
								break;
							case "Cottle":
								promptAllyDiscards(me, 3);
								addAlert("Now, move to any location.");
								t.value += "Then, " + myPlayer + " must move to any location.\r\n";
								addOption(me, "Move", undefined,
								true); /* RULES: can you move off of galactica with Cottle/Simon/Romo? must you discard a skill card? */
								break;
							case "Simon":
								drawTraumas(me, 2);
								if(!z.executedCurrentPlayer) {
									addAlert("Now, move to any location.");
									t.value += "Now, " + myPlayer + " must move to any location.\r\n";
									addOption(me, "Move", undefined, true);
								}
								break;
							case "Tory":
								t.value += "Tory has Questionable Ethics:\r\n";
								done = promptRandomDiscards(me, 2, true);
								break;
							case "Six":
								t.value += "Six is Delusional:\r\n";
								done = promptRandomDiscards(me, 3, true);
								if(done) {
									t.value += myPlayer + " draws the top 2 cards of Destiny to hand.\r\n";
									let card1 = z.destiny.pop();
									z.skillCardHands[me].push(card1);
									if(z.destiny.length === 0) {
										buildDestiny();
									}
									let card2 = z.destiny.pop();
									z.skillCardHands[me].push(card2);
									if(z.destiny.length === 0) {
										buildDestiny();
									}
									if(z.daybreak || z.pegasus) {
										z.possibleColors[me] = [1, 1, 1, 1, 1, 1];
									} else {
										z.possibleColors[me] = [1, 1, 1, 1, 1];
									}
									addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + " from Destiny.");
								} else {
									plainAlert("After the discards are resolved, " + myPlayer +
										" must draw the top 2 cards from Destiny to their hand.");
									addOption(me, "[Six Ally] Draw the top 2 cards of Destiny into your hand", undefined, true);
								}
								break;
						}
						break;
					case 1:
						alertText += "BENEVOLENT.";
						addAlert(alertText);
						t.value += imageM(900699) + imageM(allyBanner(d.allyNames[z.metAlly[0]])) + imageM(900700) + "\r\n";
						switch (d.allyNames[z.metAlly[0]]) {
							case "Hoshi":
								if(spaceCiviliansList().length > 0) {
									addAlert("Now, reshuffle a civilian ship in a space area.");
									t.value += "Now, " + myPlayer + " must reshuffle a civilian ship in a space area.\r\n";
									addOption(me, "Reshuffle a Civilian", "Hoshi", true);
								} else {
									plainAlert("No Effect.");
									done = true;
								}
								break;
							case "Starbuck":
								/* RULES: can you activate it less than 4 times? */ addAlert(
									"Now, choose 1 unmanned Viper, then activate it 4 times.");
								t.value += "Now, " + myPlayer + " should choose a Viper and activate it 4 times.\r\n";
								menuPage = "[Manual Viper Activation]";
								addOption(me, "Activate an unmanned Viper", 4, false);
								break;
							case "Ellen":
								addAlert("Now, you may choose any Human to receive the President or the Admiral title.");
								t.value += "Now, " + myPlayer +
									" may choose to move either the President or Admiral title to a player of her choice.\r\n";
								addOption(me, "Move the President title", "Ellen", false);
								addOption(me, "Move the Admiral title", "Ellen", false);
								break;
							case "Roslin":
								if(z.antagonistic[me] + z.benevolent[me] === 0) {
									plainAlert("No Effect.");
									done = true;
								} else if(2 >= z.antagonistic[me] + z.benevolent[me]) {
									while(z.antagonistic[me] > 0) {
										z.antagonistic[me]--;
										z.traumaPile.push(0);
									}
									while(z.benevolent[me] > 0) {
										z.benevolent[me]--;
										z.traumaPile.push(1);
									}
									shuffle(z.traumaPile);
									addAlert("You discard your remaining Trauma.");
									t.value += myPlayer + " reshuffles their remaining Trauma.\r\n";
									done = true;
								} else {
									addAlert("Now, discard 2 Trauma tokens.");
									t.value += "Now, " + myPlayer + " must discard 2 Trauma Tokens.\r\n";
									addOption(me, "Discard a Trauma Token", 2, true);
								}
								break;
							case "Gaeta":
							case "Six":
								increaseJump();
								if(z.jumpTrack !== 5) {
									done = true;
								}
								break;
							case "Hot Dog":
								addAlert("Now, choose a sector of the main game board and destroy 2 Raiders in that sector.");
								t.value += "Now, " + myPlayer +
									" must choose a sector of the main game board and destroy 2 Raiders in that sector.\r\n";
								addOption(me, "Destroy Raider(s)", "Hot Dog", true);
								break;
							case "Chief": {
								let pegText = "";
								if(z.pegasus && !z.pegasusDestroyed) {
									pegText = "(NOT on Pegasus) ";
								}
								addAlert("Now, repair up to 2 locations on Galactica " + pegText + "or up to 4 unmanned Vipers.");
								t.value += "Now, " + myPlayer + " may repair up to 2 locations on Galactica " + pegText +
									"or up to 4 unmanned Vipers.\r\n";
								let anyDamaged = false;
								for(let j = 0; !(j >= z.damagedLocations.length) && !anyDamaged; j++) {
									anyDamaged = onGalactica(z.damagedLocations[j]);
								}
								if(anyDamaged) {
									addOption(z.turn, "Repair a location", "Chief2", false);
								}
								if(damagedVipersII() > 0) {
									addOption(me, "Repair a damaged Viper Mk II", ["Chief", 4], false);
								}
								if(damagedVipersVII() > 0) {
									addOption(me, "Repair a damaged Viper Mk VII", ["Chief", 4], false);
								}
								break;
							}
							case "Cally": {
								let c1 = dealSkillCard(me, 4);
								let c2 = dealSkillCard(me, 4);
								let c3 = dealSkillCard(me, 4);
								addAlert("You draw " + cardText(c1) + ", " + cardText(c2) + ", and " + cardText(c3) + ".");
								done = true;
								break;
							}
							case "Doral": {
								z.quorumPeeker = me;
								let alertText = "You draw:";
								if(z.quorumDeck.length === 0) {
									z.quorumDeck = shuffle(z.quorumDiscards);
									z.quorumDiscards = [];
								}
								if(z.quorumDeck.length !== 0) {
									let quo = z.quorumDeck.pop();
									z.quorumPeek.push(quo);
									alertText += "\n" + d.quorumNames[quo];
								}
								if(z.quorumDeck.length === 0) {
									z.quorumDeck = shuffle(z.quorumDiscards);
									z.quorumDiscards = [];
								}
								if(z.quorumDeck.length !== 0) {
									let quo = z.quorumDeck.pop();
									z.quorumPeek.push(quo);
									alertText += "\n" + d.quorumNames[quo];
								}
								if(z.quorumDeck.length === 0) {
									z.quorumDeck = shuffle(z.quorumDiscards);
									z.quorumDiscards = [];
								}
								if(z.quorumDeck.length !== 0) {
									let quo = z.quorumDeck.pop();
									z.quorumPeek.push(quo);
									alertText += "\n" + d.quorumNames[quo];
								}
								alertText += "\nNow, play one of these, then place the rest on the bottom of the Quorum deck.\r\n";
								addAlert(alertText);
								addOption(me, "[Doral] Play a Quorum card", undefined, true);
								addOption(me, "[Doral] Bottom a Quorum card", undefined, true);
								break;
							}
							case "Zarek":
								addAlert("Now, you may lose 1 Population to gain 1 of any other resource.");
								t.value += "Now, " + myPlayer + " may lose 1 Population to gain 1 of any other resource.\r\n";
								addOption(me, "Decrease a resource", "Zarek", false);
								break;
							case "Shaw":
							case "Kendra":
								addAlert("Now, you may lose 1 Morale to gain either 1 Fuel or 1 Food.");
								t.value += "Now, " + myPlayer + " may lose 1 Morale to gain either 1 Fuel or 1 Food.\r\n";
								addOption(me, "Decrease a resource", "Shaw", false);
								break;
							case "Anders": {
								let anyEffect = false;
								for(let j = 0; !(j >= z.centurions.length); j++) {
									if(z.centurions[j] > 1) {
										anyEffect = true;
										z.centurions[j]--;
									}
								}
								if(anyEffect) {
									boldAlert("All Centurions on Galactica retreat 1 space.");
								} else {
									plainAlert("No Effect.");
								}
								done = true;
								break;
							}
							case "Crashdown": {
								z.scoutingDestination = true;
								z.scout = me;
								let dest = z.destinationDeck.pop();
								z.scouted.push(dest);
								addAlert("The top card of the Destination deck is:\n\n" + d.destinationNames[dest] +
									"\n\nNow, return this card to the top or the bottom of the Destination deck.");
								t.value += myPlayer + " scouts the Destination deck.\r\n";
								break;
							}
							case "Elosha": {
								z.scoutingCrisis = true;
								z.scout = me;
								let crisis = z.crisisDeck.pop();
								if(z.crisisDeck.length === 0) {
									plainAlert("Crisis deck reshuffles.");
									z.crisisDeck = shuffle(z.crisisDiscards);
									z.crisisDiscards = [];
								}
								z.scouted.push(crisis);
								addAlert("The top card of the Crisis deck is:\n\n" + d.crisisNames[crisis] +
									"\n\nNow, return this card to the top or the bottom of the Crisis deck.");
								t.value += myPlayer + " scouts the Crisis deck.\r\n";
								break;
							}
							case "Kat": {
								let c1 = dealSkillCard(me, 3);
								let c2 = dealSkillCard(me, 3);
								let c3 = dealSkillCard(me, 3);
								addAlert("You draw " + cardText(c1) + ", " + cardText(c2) + ", and " + cardText(c3) + ".");
								done = true;
								break;
							}
							case "Adama": {
								let c1 = dealSkillCard(me, 1);
								let c2 = dealSkillCard(me, 1);
								let c3 = dealSkillCard(me, 1);
								addAlert("You draw " + cardText(c1) + ", " + cardText(c2) + ", and " + cardText(c3) + ".");
								done = true;
								break;
							}
							case "Tory": {
								let c1 = dealSkillCard(me, 0);
								let c2 = dealSkillCard(me, 0);
								let c3 = dealSkillCard(me, 0);
								addAlert("You draw " + cardText(c1) + ", " + cardText(c2) + ", and " + cardText(c3) + ".");
								done = true;
								break;
							}
							case "Dee": {
								let civilians = "Civilians in Space:";
								for(let j = 0; !(j >= 6); j++) {
									for(let k = 0; !(k >= z.spaceCivilians[j].length); k++) {
										civilians += "\nCivilian " + z.spaceCivilians[j][k][0] + " (Sector " + (j + 1) + "): " + z.spaceCivilians[j][k][1];
									}
								}
								addAlert(civilians + "\n\nThis information has also been saved in your hand report for later perusal.");
								z.secretMessages[me] += "\n" + civilians;
								t.value += bold(myPlayer + " inspects all civilians in space areas, and may move any number of them to adjacent space areas.") + "\r\n";
								addOption(me, "Inspect all Civilians in space", undefined, false);
								addOption(me, "Inspect/Move a Civilian in space", [], false);
								break;
							}
							case "Helo": {
								let c1 = dealSkillCard(me, 2);
								let c2 = dealSkillCard(me, 2);
								let c3 = dealSkillCard(me, 2);
								addAlert("You draw " + cardText(c1) + ", " + cardText(c2) + ", and " + cardText(c3) + ".");
								done = true;
								break;
							}
							case "Apollo": {
								let doesAnything = false;
								let viperSectors = [0, 0, 0, 0, 0, 0];
								for(let j = 0; !(j >= z.vipersII.length); j++) {
									if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
										viperSectors[z.vipersII[j] - 1] = 1;
									}
								}
								for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
									if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
										viperSectors[z.vipersVII[j] - 1] = 1;
									}
								}
								for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
									if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
										viperSectors[z.assaultRaptors[j] - 1] = 1;
									}
								}
								for(let j = 0; !(j >= z.raiders.length); j++) {
									if(viperSectors[z.raiders[j] - 1] === 1) {
										doesAnything = true;
										break;
									}
								}
								if(doesAnything) {
									plainAlert("Now, each unmanned viper may destroy a raider in its current space area.");
									addOption(me, "Destroy Raider(s)", "Apollo", false);
								} else {
									plainAlert("No effect.");
								}
								break;
							}
							case "Cain":
								addAlert("Now, you may choose another Human character to be executed.");
								t.value += "Now, " + myPlayer + " may choose another Human character to be executed.\r\n";
								addOption(me, "Execute a player", "Cain Ally", false);
								break;
							case "Romo":
								/* TODO: RULES: do you have to discard to move between ships? */ addAlert(
									"Now, move out of the Brig to any location. ");
								t.value += "Now, " + myPlayer + " must move out of the Brig to any location.\r\n";
								addOption(me, "Move", undefined, true);
								break;
							case "Boomer":
								increaseFood();
								done = true;
								break;
							case "Kelly":
								addAlert("Now, activate up to 4 unmanned Vipers.");
								t.value += "Now, " + myPlayer + " may activate up to 4 unmanned Vipers.\r\n";
								menuPage = "[Manual Viper Activation]";
								addOption(me, "Activate an unmanned Viper", 4, false);
								break;
							case "Cavil":
								if(z.antagonistic[me] + z.benevolent[me] > 2) {
									addAlert("Now, discard a Trauma token.  Then, you will discard a random Trauma token.");
									addOption(me, "Discard a Trauma Token", "Cavil", true);
								} else if(z.antagonistic[me] + z.benevolent[me] > 0) {
									addAlert("You discard your remaining Trauma.");
									t.value += myPlayer + " discards their remaining Trauma.\r\n";
									while(z.antagonistic[me] > 0) {
										z.antagonistic[me]--;
										z.traumaPile.push(0);
										shuffle(z.traumaPile);
									}
									while(z.benevolent[me] > 0) {
										z.benevolent[me]--;
										z.traumaPile.push(1);
										shuffle(z.traumaPile);
									}
									done = true;
								}
								break;
							case "Seelix": {
								let damagedII = 0;
								let damagedVII = 0;
								for(let j = 0; !(j >= z.vipersII.length); j++) {
									if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] === -1) {
										damagedII++;
									}
								}
								for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
									if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] === -1) {
										damagedVII++;
									}
								}
								if(damagedII + damagedVII === 0) {
									plainAlert("No Effect.");
									done = true;
								} else if(3 >= damagedII + damagedVII) {
									for(let j = 0; !(j >= z.vipersII.length); j++) {
										if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] === -1) {
											z.vipersII[j] = 0;
										}
									}
									for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
										if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] === -1) {
											z.vipersVII[j] = 0;
										}
									}
									plainAlert("All damaged Vipers repaired.");
									done = true;
								} else if(damagedVII === 0) {
									let count = 0;
									for(let j = 0; !(j >= z.vipersII.length) && !(count >= 3); j++) {
										if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] === -1) {
											z.vipersII[j] = 0;
											count++;
										}
									}
									plainAlert("Repaired " + count + " Vipers Mk II.");
									done = true;
								} else if(damagedII === 0) {
									let count = 0;
									for(let j = 0; !(j >= z.vipersVII.length) && !(count >= 3); j++) {
										if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] === -1) {
											z.vipersVII[j] = 0;
											count++;
										}
									}
									plainAlert("Repaired " + count + " Vipers Mk VII.");
									done = true;
								} else {
									addAlert("Now, repair 3 damaged Vipers.");
									t.value += "Now, " + myPlayer + " must repair 3 damaged Vipers.\r\n";
									addOption(me, "Repair a damaged Viper Mk II", ["Seelix", 3], true);
									addOption(me, "Repair a damaged Viper Mk VII", ["Seelix", 3], true);
								}
								break;
							}
							case "Racetrack":
								increaseFuel();
								done = true;
								break;
							case "Baltar":
								if(z.detectorSabotage) {
									plainAlert("Loyalties may not be inspected due to Detector Sabotage; no effect.");
									done = true;
								} else {
									addAlert("You may now look at 1 random Loyalty card belonging to any other player.");
									t.value += myPlayer + " may now look at 1 random Loyalty card belonging to any other player.\r\n";
									addOption(me, "Inspect a random Loyalty card of another player", undefined, false);
								}
								break;
							case "Cottle":
								if(z.antagonistic[me] + z.benevolent[me] === 0) {
									addAlert("You have no Trauma to discard.  Now, move to any location.");
									t.value += myPlayer + " has no Trauma to discard, and may move to any location.";
								} else if(3 >= z.antagonistic[me] + z.benevolent[me]) {
									addAlert("You discard your remaining Trauma.  Now, move to any location.");
									t.value += myPlayer + " discards their remaining Trauma.  Now, they may move to any location.\r\n";
									while(z.antagonistic[me] > 0) {
										z.antagonistic[me]--;
										z.traumaPile.push(0);
										shuffle(z.traumaPile);
									}
									while(z.benevolent[me] > 0) {
										z.benevolent[me]--;
										z.traumaPile.push(1);
										shuffle(z.traumaPile);
									}
								} else {
									addAlert("Now, discard 3 Trauma tokens, then move to any location.");
									t.value += myPlayer + " must now discard 3 Trauma tokens, then move to any location.\r\n";
									addOption(me, "Discard a Trauma Token", 3, true);
								}
								addOption(me, "Move", undefined, true);
								break;
							case "Leoben":
								addAlert("Now, choose 1 sector on the main game board and destroy all Cylon ships within.");
								t.value += "Now, " + myPlayer +
									" must choose 1 sector on the main game board and destroy all Cylon ships within.\r\n";
								addOption(me, "[Leoben] Destroy all Cylon ships in one sector", undefined, true);
								break;
							case "Billy":
							case "D'Anna":
								increaseMorale();
								done = true;
								break;
							case "Simon":
								addAlert("Now, draw 2 skill cards (they may be from outside your skill set).  Then, move to any location.");
								t.value += "Now, " + myPlayer +
									" must draw 2 skill cards (they may be from outside their skill set).  Then, they must move to any location.\r\n";
								addOption(me, "Draw 2 Skill Cards (any color)", 1, true);
								addOption(me, "Move", undefined, true);
								break;
							case "Tigh":
								addAlert("Now, you may send another character to the Brig.");
								t.value += "Now, " + myPlayer + " may send another character to the Brig.\r\n";
								addOption(me, "Move a player to the Brig", "Tigh", false);
								break;
						}
						break;
				}
				if(done && !z.executedCurrentPlayer) {
					let oldTrauma = z.metAlly[1];
					if(oldTrauma !== null){
						z.traumaPile.push(oldTrauma);
					}
					shuffle(z.traumaPile);
					z.metAlly = null;
					let newAlly = allyPop();
					if(newAlly === -1) {
						plainAlert("Ally deck exhausted; it does not reshuffle.");
					} else {
						boldAlert("New Ally is " + d.allyNames[newAlly] + ".");
						if(z.antagonistic[me] + z.benevolent[me] === 0) {
							/* TODO / RULES: what if you completely run out of trauma? */
							let trauma = z.traumaPile.pop();
							if(trauma === undefined){
								z.allies.push([newAlly,null]);
								plainAlert("The Trauma pile is empty; no Trauma is placed on "+d.allyNames[newAlly]+".");
							} else {
								z.allies.push([newAlly, z.traumaPile.pop()]);
								plainAlert("Trauma for " + d.allyNames[newAlly] + " is placed randomly.");
							}
						} else if(z.antagonistic[me] + z.benevolent[me] === 1) {
							if(z.antagonistic[me] === 1) {
								z.allies.push([newAlly, 0]);
								z.antagonistic[me] = 0;
								addAlert("You place your last Trauma, an Antagonistic one, on " + d.allyNames[newAlly] + ".");
							} else {
								z.allies.push([newAlly, 1]);
								z.benevolent[me] = 0;
								addAlert("You place your last Trauma, a Benevolent one, on " + d.allyNames[newAlly] + ".");
							}
							t.value += bold(myPlayer + " places their last Trauma on " + d.allyNames[newAlly]) + ".\r\n";
						} else {
							z.newAlly = newAlly;
							addAlert("Now, place a Trauma token on " + d.allyNames[newAlly]);
							t.value += "Now, " + myPlayer + " must place a Trauma token on " + d.allyNames[newAlly] + ".\r\n";
						}
					}
				}
				mainMenu();
			};
			if(alliesHere.length === 1) {
				confirmify("Confirming you want to meet " + d.allyNames[z.allies[alliesHere[0]][0]] + ".", mainMenu, () => {
					meetAlly(alliesHere[0]);
				});
			} else if(alliesHere.length > 1) {
				let promptText = "Which Ally do you want to meet? (1-" + alliesHere.length + ")";
				for(let j = 0; !(j >= alliesHere.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.allyNames[z.allies[alliesHere[j]][0]];
				}
				promptNum(promptText, (a) => 1 > a || a > alliesHere.length, mainMenu, (prompted) => {
					meetAlly(alliesHere[prompted - 1]);
				});
			}
			let a3 = "ENDBYCD  [/size] [/c]" + 
			" [c][size=1] STARTBYCE";
		} else if(ch === "Reveal Stand and Fight (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Stand and Fight Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Stand and Fight Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Population at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 24) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[24]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[24]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});	
			}
		} else if(ch === "Reveal Sacrifice (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Sacrifice Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Sacrifice Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Fuel at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 25) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[25]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[25]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "Reveal Devastation (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Devastation Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Devastation Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Morale at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 26) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[26]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[26]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "Reveal Use Caution (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Use Caution Personal Goal.\n\nYou should not do this unless a turn has just ended in which 3 or more resources were lost.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Use Caution Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Population at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 27) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[27]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[27]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "Reveal Acquire Power (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Acquire Power Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Acquire Power Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Food at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 28) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[28]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[28]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "Reveal Political Intrigue (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Political Intrigue Personal Goal.\n\nNote that this should technically only happen at the end of a turn, and you should only do this if a Human player lost a title in that turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Political Intrigue Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Food at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 29) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[29]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[29]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "Reveal Self-Destruction (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Acquire Power Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Self-Destruction Personal Goal.\nThis generally requires an action.\n" +
					"This will save the Humans 1 Morale at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 31) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[31]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[31]) + ".\r\n";
							if(6 >= z.distance && z.notCylonDeck.length + z.loyaltyDeck.length > 0) {
								if(z.notCylonDeck.length > 0){
									z.loyaltyDeck.push(z.notCylonDeck.pop());
									shuffle(z.loyaltyDeck);
									t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
								}
								let loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
								
								t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
								if(loy === 40) {
									becomeMutineer(me);
								} else if(loy === 15) {
									becomeSympathizer(me);
								} else if(loy === 17) {
									becomeSympatheticCylon(me);
								}
							}
							if(z.phase === 1) {
								endMovement();
							} else {
								didAction();
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if(ch === "[Selfish] Draw a replacement Loyalty card") {
			confirmify(
				"Confirming you want to draw a new Loyalty card after revealing Selfish.  Make sure you have discarded 20 points worth of skill cards first.",
				mainMenu, () => {
					if(z.notCylonDeck.length > 0){
						z.loyaltyDeck.push(z.notCylonDeck.pop());
						shuffle(z.loyaltyDeck);
						t.value += 'An additional "You Are Not a Cylon" card is shuffled into the Loyalty Deck.\r\n';
					}
					if(z.loyaltyDeck.length > 0){
						let loy = z.loyaltyDeck.pop();
						z.loyaltyHands[me].push(loy);
						addAlert("You receive a new Loyalty card: " + d.loyaltyNames[loy]);
						t.value += bold(myPlayer + ' draws a new Loyalty.') + "\r\n";
						if(loy === 40) {
							becomeMutineer(me);
						} else if(loy === 15) {
							becomeSympathizer(me);
						} else if(loy === 17) {
							becomeSympatheticCylon(me);
						}
					} else {
						plainAlert("The Loyalty deck is completely exhausted; no Loyalty is drawn.");
					}
					removeOption(me, "Discard a Skill Card");
					removeOption(me, ch);
					if(z.phase === -1) {
						endMovement();
					} else {
						didAction();
					}
					mainMenu();
				});
		} else if(ch === "Reveal Selfish (Personal Goal)") {
			if(Array.isArray(z.personalGoalsBrutality)){
				let confirmText = "Confirming you want to reveal your Selfish Personal Goal.  Note that this should technically only happen at the end of a turn.";
				confirmify(confirmText,mainMenu,()=>{
					boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
					z.personalGoalsBrutality[me] = null;
					if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
						z.miracles[me]++;
						plainAlert(z.players[me] + " gains a Miracle Token.");
					}
					mainMenu();
				});
			} else {
				let confirmText = "Confirming you want to reveal your Selfish Personal Goal.\nThis generally requires an action.\n" +
					"\n\nYou will have to discard 20 points worth of skill cards after revealing this card.\n\nThis will save the Humans 1 Fuel at the end of the game.";
				if(6 >= z.distance) {
					confirmText += "\nYou will receive an extra Loyalty card for playing this.";
				}
				confirmify(confirmText, mainMenu, () => {
					for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
						if(z.loyaltyHands[me][j] === 26) {
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(j, 1)[0]);
							addAlert("You reveal " + d.loyaltyNames[26]);
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[26]) + ".\r\n"; /* TODO: better context here */
							addOption(me, "Discard a Skill Card", "Selfish", false);
							if(6 >= z.distance) {
								addOption(me, "[Selfish] Draw a replacement Loyalty card", undefined, true);
								z.phase = -1;
							} else {
								if(z.phase === 1) {
									/* TODO: this and Romo (variant only) */
									endMovement();
								} else {
									didAction();
								}
							}
							break;
						}
					}
					mainMenu();
				});
			}
		} else if (ch === "Reveal Infiltration (Personal Goal)"){
			let confirmText = "Confirming you want to reveal your Infiltration Personal Goal.  Note that this should technically only happen at the end of a turn.";
			confirmify(confirmText,mainMenu,()=>{
				boldAlert(z.players[me] + " reveals "+d.loyaltyNames[z.personalGoalsBrutality[me]]+".");
				z.personalGoalsBrutality[me] = null;
				if(z.miracles[me] === 0 || (z.players[me] === "Gaius" && 3 > z.miracles[me])){
					z.miracles[me]++;
					plainAlert(z.players[me] + " gains a Miracle Token.");
				}
				mainMenu();
			});
		} else if(ch === "Place a basestar on the Cylon Fleet Board") {
			let promptText =
				"In which sector of the Cylon Fleet Board would you like to to place a Basestar? (1-6)\n1: Sector 1 [die roll 7-8]\n2: Sector 2 [die roll 5-6]" +
				"\n3: Sector 3 [die roll 3]\n4: Sector 4 [die roll 1]\n5: Sector 5 [die roll 2]\n6: Sector 6 [die roll 4]";
			promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				if(z.basestars.length > 0 && z.basestars[0][0] === 0) {
					z.basestars[0][0] = -prompted;
				} else if(z.basestars.length > 1 && z.basestars[1][0] === 0) {
					z.basestars[1][0] = -prompted;
				}
				plainAlert("Placed a Basestar on Sector " + (prompted) + " of the Cylon Fleet Board.");
				removeOption(me, ch);
				removeOption(me, "Place 3 Raiders on the Cylon Fleet Board");
				mainMenu();
			});
		} else if(ch === "Place 3 Raiders on the Cylon Fleet Board") {
			let promptText =
				"In which sector of the Cylon Fleet Board would you like to to place 3 Raiders? (1-6)\n1: Sector 1 [die roll 7-8]\n2: Sector 2 [die roll 5-6]" +
				"\n3: Sector 3 [die roll 3]\n4: Sector 4 [die roll 1]\n5: Sector 5 [die roll 2]\n6: Sector 6 [die roll 4]";
			promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				let c = 0;
				for(let j = 0; !(j >= z.raiders.length) && !(c >= 3); j++) {
					if(z.raiders[j] === 0) {
						z.raiders[j] = -prompted;
						c++;
					}
				}
				plainAlert("Placed " + c + " Raiders on Sector " + (prompted) + " of the Cylon Fleet Board.");
				removeOption(me, ch);
				removeOption(me, "Place a basestar on the Cylon Fleet Board");
				mainMenu();
			});
		} else if(ch === "Advance the Pursuit Track") {
			confirmify("Confirming you want to advance the Pursuit Track.", mainMenu, () => {
				advancePursuit();
				for(let j = 0; !(j >= z.numPlayers); j++) {
					removeOption(j, ch);
				}
				mainMenu();
			});
		} else if(ch === "Process the Pass effect from Strange Beacon") {
			promptNum("From which Sector would you like to remove all Cylon ships? (1-6)", (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				boldAlert(z.players[z.turn] + " removes all Cylon ships from Sector " + prompted + ".");
				if(z.scarCAC && z.scar === prompted) {
					plainAlert("Scar requires a die roll to kill, and is not removed.");
				}
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] === prompted) {
						z.raiders[j] = 0;
					}
				}
				if(Number.isInteger(z.heavyCasualties)){
					z.heavyCasualties = 0;
				}
				if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
					plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
					z.dogfightCAC = false;
					if(z.galacticaReturned){
						z.oldCrisisDiscards.push(76);
					} else {
						z.crisisDiscards.push(76);
					}
				}
				for(let j = 0; !(j >= z.heavies.length); j++) {
					if(z.heavies[j] === prompted) {
						z.heavies[j] = 0;
					}
				}
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === prompted) {
						destroyBasestar(j, true);
					}
				}
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "[Leoben] Destroy all Cylon ships in one sector") {
			promptNum("From which Sector would you like to destroy all Cylon ships? (1-6)", (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				removeOption(me, ch);
				boldAlert(z.players[z.turn] + " destroys all Cylon ships in Sector " + prompted + ".");
				if(z.scarCAC && z.scar === prompted) {
					plainAlert("Scar requires a die roll to kill, and is not destroyed.");
				}
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] === prompted) {
						z.raiders[j] = 0;
					}
				}
				if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
					plainAlert("All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
					z.dogfightCAC = false;
					if(z.galacticaReturned){
						z.oldCrisisDiscards.push(76);
					} else {
						z.crisisDiscards.push(76);
					}
				}
				for(let j = 0; !(j >= z.heavies.length); j++) {
					if(z.heavies[j] === prompted) {
						z.heavies[j] = 0;
					}
				}
				for(let j = 0; !(j >= z.basestars.length); j++) {
					if(z.basestars[j][0] === prompted) {
						destroyBasestar(j);
					}
				}
				mainMenu();
			});
		} else if(ch === "Process the Pass effect from Mysterious Message") {
			confirmify("Confirming you want to process the Pass effect from Mysterious Message to search Destiny and discard 2 skill cards.", mainMenu,
				() => {
					if(z.destiny.length === 1) {
						addAlert("The only card in Destiny is " + cardText(z.destiny[0]) + "; you discard it and build a new Destiny deck.");
						t.value += myPlayer + " discards the last card in Destiny, " + cardText(z.destiny[0]) +
							", then builds a new Destiny deck.\r\n";
						z.skillCardDiscards[cardColorID(z.destiny[0])].push(z.destiny[0]);
						refreshSkillDecks();
						z.destiny = [];
						buildDestiny();
						removeOption(me, ch);
						mainMenu();
					} else if(z.destiny.length === 2) {
						addAlert("The last two cards in Destiny are " + cardText(z.destiny[0]) + " and + " + cardText(z.destiny[1]) +
							"; you discard them and build a new Destiny deck.");
						t.value += myPlayer + " discards the last two cards in Destiny, " + cardText(z.destiny[0]) + " and + " + cardText(z.destiny[
							1]) + ", then builds a new Destiny deck.\r\n";
						z.skillCardDiscards[cardColorID(z.destiny[0])].push(z.destiny[0]);
						z.skillCardDiscards[cardColorID(z.destiny[1])].push(z.destiny[1]);
						refreshSkillDecks();
						z.destiny = [];
						buildDestiny();
						removeOption(me, ch);
						mainMenu();
					} else {
						t.value += myPlayer + " looks at the Destiny deck.\r\n";
						let discardFromDestiny = function(j) {
							if(j === 2) {
								shuffle(z.destiny);
								plainAlert("Destiny reshuffled.");
								removeOption(me, ch);
								mainMenu();
							} else {
								let promptText = "What is the ";
								if(j === 0) {
									promptText += "first";
								} else {
									promptText += "second";
								}
								promptText += " card you want to discard from Destiny? (1-" + z.destiny.length + ")";
								for(let k = 0; !(k >= z.destiny.length); k++) {
									promptText += "\n" + (k + 1) + ": " + cardText(z.destiny[k]);
								}
								promptNum(promptText, (a) => 1 > a || a > z.destiny.length, () => {
									if(j === 0) {
										mainMenu();
									} else {
										discardFromDestiny(j);
									}
								}, (prompted) => {
									confirmify("Confiming you want to discard " + cardText(z.destiny[prompted - 1]) + " from Destiny.",
										() => {
											if(j === 0) {
												mainMenu();
											} else {
												discardFromDestiny(j);
											}
										}, () => {
											addAlert("You discard " + cardText(z.destiny[prompted - 1]) + " from Destiny.");
											t.value += bold(myPlayer + " discards " + cardText(z.destiny[prompted - 1]) +
												" from Destiny.") + "\r\n";
											let card = z.destiny.splice(prompted - 1, 1)[0];
											z.skillCardDiscards[cardColorID(card)].push(card);
											refreshSkillDecks();
											discardFromDestiny(j + 1);
										});
								});
							}
						};
						discardFromDestiny(0);
					}
				});
		} else if(ch === "Process the Fail effect from Human Prisoner") {
			/* RULES: Can a Resoluting Athena target herself with Human Prisoner? */
			confirmify("Confirming you want to process the Fail effect from Human Prisoner.", mainMenu, () => {
				let promptText = "Who would you like to target? (1-" + z.numPlayers +
					") You will steal their skill cards and send them to Sickbay.";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 1) {
						promptText += "(CYLON)";
					} else if(j === me) {
						promptText += " (nice try, Athena)";
					} else {
						promptText += z.players[j] + " (" + z.skillCardHands[j].length + " skill cards)";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || a - 1 === me, mainMenu, (
				prompted) => {
					confirmify("Confirming you want to steal all " + z.skillCardHands[prompted - 1].length + " skill cards from " + z
						.players[prompted - 1] + " and send them to Sickbay.", mainMenu, () => {
							t.value += bold(myPlayer + " steals all " + z.skillCardHands[prompted - 1].length +
								" skill cards from " + z.players[prompted - 1] + ".") + "\r\n";
							if(z.playerLocations[prompted - 1] === "Stranded on Caprica") {
								t.value += "Helo cannot be moved while he is Stranded.\r\n";
								addAlert("Helo remains Stranded.");
							} else if(z.playerLocations[prompted - 1] === "Brig") {
								plainAlert(z.players[prompted - 1] + " remains in the Brig.");
							} else if(z.playerLocations[prompted - 1] === "Detention") {
								plainAlert(z.players[prompted - 1] + " remains in Detention.");
							} else if(isOnNewCaprica(prompted - 1)) {
								movePlayer(prompted - 1, "Medical Center");
								addAlert(z.players[prompted - 1] + " is sent to the Medical Center.");
							} else {
								movePlayer(prompted - 1, "Sickbay");
								addAlert(z.players[prompted - 1] + " is sent to Sickbay.");
							}
							for(let j = 0; !(j >= z.possibleColors[prompted - 1].length); j++) {
								if(z.possibleColors[prompted - 1][j] === 1) {
									z.possibleColors[me][j] = 1;
								}
							}
							let alertText = "You steal the following cards:";
							z.skillCardHands[prompted - 1].sort(cardCompare);
							for(let j = 0; !(j >= z.skillCardHands[prompted - 1].length); j++) {
								alertText += "\n" + cardText(z.skillCardHands[prompted - 1][j]);
							}
							addAlert(alertText);
							z.skillCardHands[me] = z.skillCardHands[me].concat(z.skillCardHands[prompted - 1]);
							z.skillCardHands[prompted - 1] = [];
							for(let j = 0; !(j >= z.numPlayers); j++) {
								removeOption(j, ch);
							}
							mainMenu();
						});
				});
			});
		} else if(ch === "Execute a player") {
			let execute = function(prompted,thirtyFive) {
				confirmify("Are you SURE you want to execute " + z.players[prompted - 1] + ".", mainMenu, () => {
					executePlayer(prompted - 1, false, thirtyFive);
					if(hasContext(me, ch, "Resistance Bombing")) {
						removeOption(me, ch);
						removeOption(me, "Destroy an Occupation Force");
					} else if(hasContext(me, ch, "The Circle")) {
						removeOption(me, ch);
						removeOption(me, "Move the President title");
						if(!z.capricaCrisis){
							z.toDoRaiders = false;
							z.toDoJumpIcon = false;
						}
					} else if(Array.isArray(getContext(me, ch))) {
						if(getContext(me,ch).length === 2){
							removeOption(me, ch);
							removeOption(me, "Move a player to the Brig");
						} else {
							let context = getContext(me,ch);
							let other = context[1];
							if(other === prompted - 1){
								other = context[2];
							}
							removeOption(me,ch);
							if(context[0] === "Final Fives" && other === context[1]){
								addOption(me,"Execute a player",["Final Fives",other],true);
							} else {
								addOption(me,"Execute a player",z.players[other],true);
							}
						}
					} else if(hasContext(me, ch, "Detention") || hasContext(me, ch, "Brig") || hasContext(me, ch, "Cain Ally")) {
						removeOption(me, ch);
					} else if(hasContext(me, "Lured into a Trap") || hasContext(me, "New Caprica") || hasContext(me,"No Boxing")) {
						/* TODO: option persistence here */ } /* TODO: option persistence with Dee's execution caused by an execution */
					mainMenu();
				});
			};
			if(hasContext(me, ch, "Brig")) {
				let promptText = "Which character in the Brig would you like to execute? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.playerLocations[j] !== "Brig") {
						promptText += "(not in the Brig)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.playerLocations[a - 1] !== "Brig", mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "Detention")) {
				let promptText = "Which character in Detention would you like to execute? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.playerLocations[j] !== "Detention") {
						promptText += "(not in Detention)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.playerLocations[a - 1] !== "Detention", mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "Resistance Bombing")) {
				let promptText = "Which Cylon would you like to execute? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 0) {
						promptText += "(HUMAN)";
					} else if(j === me) {
						promptText += "(nice try, Dee)";
					} else {
						promptText += z.players[j];
					}
				} /* RULES: can you execute a cylon not on NC with Resistance Bombing? */
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 0 || a - 1 === me, mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "Cain Ally")) {
				let promptText = "Which Human would you like to execute? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 1) {
						promptText += "(CYLON)";
					} else if(j === me) {
						promptText += "(Cain does not condone suicide)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || a - 1 === me, mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "New Caprica")) {
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (z.turn + j) % z.numPlayers;
					if(isOnNewCaprica(k)) {
						execute(k + 1);
						break;
					}
				}
			} else if(hasContext(me, ch, "Lured into a Trap")) {
				let promptText = "Which player are you executing from Lured into a Trap? (1-" + z.numPlayers +
					")\nExecute players that were standing on FTL Control or Engine Room when the fleet jumped, in turn order starting with the current player.";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 1) {
						promptText += "(CYLON)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1, mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "No Boxing")) {
				let promptText = "Which player are you executing from Crossroads? (1-" + z.numPlayers +
					")\nExecute players that were tied for the most trauma, in turn order starting with the current player.";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 1) {
						promptText += "(CYLON)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1, mainMenu, (prompted) => {
					execute(prompted);
				});
			} else if(hasContext(me, ch, "The Circle")) {
				execute(z.turn + 1);
			} else if(Array.isArray(getContext(me, ch))) {
				let context = getContext(me, ch);
				let thirtyFive = undefined;
				if(context.length === 2){
					if(context[0] === "Final Fives"){
						thirtyFive = 2;
					}
					execute(context[1] + 1,thirtyFive);
				} else {
					let promptText = "Who would you like to execute? (1-"+(context.length-1)+")";
					for(let j = 1; !(j>=context.length); j++){
						promptText += "\n"+j+": "+z.players[context[j]];
					}
					promptNum(promptText,(a)=>1>a||a>=context.length,mainMenu,(prompted)=>{
						if(context[0] === "Final Fives" && prompted === 2){
							thirtyFive = 2;
						}
						execute(context[prompted]+1,thirtyFive);
					});
				}
			} else {
				execute(getPlayerNum(getContext(me, ch)) + 1);
			}
		} else if(ch === "Choose a new character after being executed") {
			let chars = availableCharacters();
			let promptText = "Which character would you like to return as? (1-" + chars.length + ")"; /* TODO: is this too long for one list? */
			for(let j = 0; !(j >= chars.length); j++) {
				promptText += "\n" + (j + 1) + ": " + chars[j];
			}
			promptNum(promptText, (a) => 1 > a || a > chars.length, mainMenu, (prompted) => {
				confirmify("Confirming you want to return as " + chars[prompted - 1] + ".", mainMenu, () => {
					if(chars[prompted - 1] === "Dee" && 2 >= z.morale) {
						addAlert("Dee is immediately executed due to her drawback.  Please pick another character.");
						t.value += bold(z.usernames[me] +
							" returns as Dee, but she is immediately executed due to Emotionally Fragile") + ".\r\n";
						z.graveyard.push("Dee");
						if(availableCharacters().length === 0) {
							addAlert("You have unlocked the secret loss condition: no characters remain, so Cylons Win!");
							t.value += "There are no characters available.";
							endGame(false);
						}
						mainMenu();
						return;
					}
					z.humanExecuted = -1;
					z.graveyard.push(myPlayer);
					let wasOnNewCaprica = isOnNewCaprica(me);
					z.players[me] = chars[prompted - 1];
					myPlayer = z.players[me];
					addAlert("You are now " + myPlayer + ".");
					t.value += bold(z.usernames[me] + " returns as " + myPlayer) + ".\r\n";
					if(z.preCrossroads) {
						let drawnDisasters = 0;
						for(let j = 0; !(j >= 3) && z.traumaPile.length > 0; j++) {
							let trauma = z.traumaPile.pop();
							if(trauma === 1) {
								z.benevolent[me]++;
							} else if(trauma === 0) {
								z.antagonistic[me]++;
							} else if(trauma === -1) {
								drawnDisasters++;
								j--;
							}
						}
						t.value += myPlayer + " draws " + (z.benevolent[me] + z.antagonistic[me]) + " new Trauma.\r\n";
						addAlert("You draw " + z.benevolent[me] + " Benevolent and " + z.antagonistic[me] +
						" Antagonistic Trauma.\r\n");
						while(drawnDisasters > 0) {
							z.traumaPile.push(-1);
							shuffle(z.traumaPile);
							drawnDisasters--;
							plainAlert("Reshuffled a Disaster Token.");
						}
					}
					for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
						let ally = d.allyNames[z.allies[j][0]];
						if(ally === myPlayer || (myPlayer === "Lee" && ally === "Apollo") || (myPlayer === "Tom" && ally === "Zarek") ||
							(myPlayer === "Karl" && ally === "Helo") || (myPlayer === "Gaius" && ally === "Baltar")) {
						
							let trauma = z.allies[j][1];
							if(trauma !== null){
								z.traumaPile.push(trauma);
							}
							shuffle(z.traumaPile);
							z.allies.splice(j, 1);
							plainAlert(ally + " Ally removed.");
							let newAlly = allyPop();
							if(newAlly === -1) {
								plainAlert("Ally deck exhausted; it does not reshuffle.");
							} else {
								z.cylonAllyQueue.push(newAlly);
								resolveCylonAllyQueue();
							}
							break;
						}
					}
					if(myPlayer === "Helo") {
						if(z.numPlayers + z.boxedPlayers.length > 1) {
							z.playerLocations[me] = "Stranded on Caprica";
							addAlert("You begin Stranded on Caprica.");
							t.value += "Helo begins Stranded on Caprica.\r\n";
							if(me > z.turn) {
								z.heloReturnRound = z.round + 1;
							} else {
								z.heloReturnRound = z.round + 2;
							}
						} else if(z.galacticaAway) {
							z.heloReturnRound = -1;
							z.playerLocations[me] = "Resistance HQ";
							addAlert("You begin on Resistance HQ.");
						} else {
							z.heloReturnRound = -1;
							z.playerLocations[me] = "Hangar Deck";
							addAlert("You begin on the Hangar Deck.");
						}
					} else if(z.galacticaAway) {
						z.playerLocations[me] = "Resistance HQ";
						addAlert("You are placed on Resistance HQ.");
						t.value += myPlayer + " is placed on Resistance HQ.\r\n";
					} else if(myPlayer === "Apollo") {
						z.avp = [];
						z.playerLocations[me] = "Hangar Deck";
						let any = false;
						if(vipersIIReserves() > 0) {
							addOption(me, "Launch in a Viper Mk II in Sector 5", undefined, true);
							addOption(me, "Launch in a Viper Mk II in Sector 6", undefined, true);
							any = true;
						}
						if(z.CFB && vipersVIIReserves() > 0) {
							addOption(me, "Launch in a Viper Mk VII in Sector 5", undefined, true);
							addOption(me, "Launch in a Viper Mk VII in Sector 6", undefined, true);
							any = true;
						}
						if(z.daybreak && assaultRaptorsReserves() > 0) {
							addOption(me, "Launch in an Assault Raptor in Sector 5", undefined, true);
							addOption(me, "Launch in an Assault Raptor in Sector 6", undefined, true);
							any = true;
						}
						if(any) {
							addAlert("Placed you on the Hangar Deck temporarily; you must now Launch yourself in a Viper.");
							t.value += "Apollo must immediately launch himself in a Viper.\r\n";
						} else if(isUnmannedInSpace()) {
							t.value += "Apollo must immediately recall an unmanned Viper and launch himself in it.\r\n";
							addAlert(
								"Placed you on the Hangar Deck temporarily; you must now recall an unmanned Viper and launch yourself in it."
								);
							addOption(me, "Recall an unmanned Viper", "Launch", true);
						} else {
							addAlert("No vipers available; you are placed on the Hangar Deck.");
							t.value += "Apollo is placed on the Hangar Deck, as there are no Vipers available.";
						}
					} else if((z.galacticaReturned || z.colonialOneDestroyed) && (myPlayer === "Zarek" || myPlayer === "Romo" ||
							myPlayer === "Tory" || myPlayer === "Roslin")) {
						/* RULES: are we sure about this? */
						if(z.exodus){
							z.playerLocations[me] = "Sickbay";
							addAlert("You are placed in Sickbay.");
							t.value += "As Colonial One is gone, " + myPlayer + " is placed in Sickbay.\r\n";
						} else {
							z.playerLocations[me] = "Hangar Deck";
							addAlert("You are placed on the Hangar Deck.");
							t.value += "As Colonial One is gone, " + myPlayer + " is placed on the Hangar Deck.\r\n";
						}
					} else if(myPlayer === "Cain" && !z.pegasusDestroyed && z.pegasus) {
						/* TODO: this should really happen before you see your new Loyalty */
						t.value += "Cain is placed on Command by default; she may choose to start on Pegasus CIC instead.\r\n";
						addAlert(
							"You have been placed on Command by default; if you would prefer to start on Pegasus CIC, you may do so."
							);
						addOption(me, "Start on Pegasus CIC", undefined, false);
					} else if(myPlayer === "Hoshi" && !z.pegasusDestroyed && z.vBrutality && z.pegasus) {
						t.value += "Hoshi is placed on Communications by default; he may choose to start on Main Batteries instead.\r\n";
						addAlert(
							"You have been placed on Communications by default; if you would prefer to start on Main Batteries, you may do so."
							);
						addOption(me, "Start on Main Batteries", undefined, false);
					} else if(myPlayer === "Shaw" && !z.pegasusDestroyed && z.pegasus) {
						t.value += "Shaw is placed on Weapons Control by default; she may choose to start on Main Batteries instead.\r\n";
						addAlert(
							"You have been placed on Weapons Control by default; if you would prefer to start on Main Batteries, you may do so."
							);
						addOption(me, "Start on Main Batteries", undefined, false);
					} else if(prompted === "Roslin" && z.vBrutality && z.daybreak) {
						z.playerLocations[me] = "Quorum Chamber";
					} else if(prompted === "Tory" && z.vBrutality && z.daybreak) {
						z.playerLocations[me] = "President's Office";
					} else {
						z.playerLocations[me] = d.startingLocations[getCharacter(myPlayer)];
						addAlert("You are placed on " + z.playerLocations[me]+".");
						t.value += myPlayer + " is placed on " + z.playerLocations[me] + ".\r\n";
					}
					let wasMutineer = (me === z.theMutineer);
					if(z.exodus) {
						/* RULES: can you run out of loyalty cards? */
						if(z.notCylonDeck.length > 0){
							z.loyaltyDeck.push(z.notCylonDeck.pop());
							shuffle(z.loyaltyDeck);
							t.value += 'A card from the "You Are Not a Cylon" deck is shuffled into the Loyalty Deck.\r\n';
						}
						if(z.loyaltyDeck.length > 0){
							let loy = z.loyaltyDeck.pop();
							z.loyaltyHands[me].push(loy);
							addAlert("You draw a new Loyalty:\n" + d
								.loyaltyNames[loy]);
							t.value += myPlayer +
								' draws a new Loyalty card.\r\n';
							if(loy === 40) {
								becomeMutineer(me);
							} else if(loy === 15) {
								becomeSympathizer(me);
							} else if(loy === 17) {
								becomeSympatheticCylon(me);
							}
						}
						if(z.graveyard[z.graveyard.length - 1] === "Boomer" && !z.sleeper && z.loyaltyDeck.length > 0) {
							let loy = z.loyaltyDeck.pop();
							z.loyaltyHands[me].push(loy);
							addAlert("As you were Boomer, you draw another Loyalty:\n" + d.loyaltyNames[loy]);
							t.value += 'As Boomer was just executed before sleeper, ' + myPlayer + ' draws another Loyalty card.\r\n';
							if(loy === 40) {
								becomeMutineer(me);
							} else if(loy === 15) {
								becomeSympathizer(me);
							} else if(loy === 17) {
								becomeSympatheticCylon(me);
							}
						}
					}
					if(myPlayer === "Boomer" && z.numPlayers + z.boxedPlayers.length > 1) {
						if((!z.sleeper || z.exodus) && z.notCylonDeck.length > 0) {
							z.loyaltyDeck.push(z.notCylonDeck.pop());
							shuffle(z.loyaltyDeck);
							addAlert("Loyalty deck gets an extra card for Boomer.");
							t.value += 'A card from the "You Are Not a Cylon" deck is shuffled into the Loyalty Deck for Boomer.\r\n';
						}
						if(z.sleeper) {
							let loy = 0;
							if(z.exodus && z.loyaltyDeck.length > 0) {
								loy = z.loyaltyDeck.pop();
								z.loyaltyHands[me].push(loy);
								addAlert("You draw an extra Loyalty card: " + d.loyaltyNames[loy]);
								t.value += "Boomer draws an extra Loyalty card.\r\n";
							}
							if(wasOnNewCaprica) {
								addAlert("You are sent to Detention, as your old character was on New Caprica when they died.");
								movePlayer(me, "Detention");
								if(z.endGame) {
									addAlert("You must now execute Boomer as well!");
									t.value += "Boomer must now also be executed.\r\n";
								}
							} else {
								addAlert("You are sent to the Brig.");
								movePlayer(me, "Brig");
							}
							if(loy === 40) {
								becomeMutineer(me);
							} else if(loy === 15) {
								becomeSympathizer(me);
							} else if(loy === 17) {
								becomeSympatheticCylon(me);
							}
						}
					}
					if(myPlayer === "Baltar" && !z.sleeper) {
						if(z.notCylonDeck.length > 0){
							z.loyaltyDeck.push(z.notCylonDeck.pop());
							shuffle(z.loyaltyDeck);
						}
						if(z.loyaltyDeck.length > 0){
							let loy = z.loyaltyDeck.pop();
							z.loyaltyHands[me].push(loy);
							addAlert("You draw an extra Loyalty card: " + d.loyaltyNames[loy]);
							t.value += "Baltar draws an extra Loyalty card.\r\n";
							if(loy === 40) {
								becomeMutineer(me);
							} else if(loy === 15) {
								becomeSympathizer(me);
							} else if(loy === 17) {
								becomeSympatheticCylon(me);
							}
						}
					}
					if(myPlayer === "Baltar" && !z.exodus && z.sleeper) {
						z.noCylonDetector = true;
						addAlert("You may not use your OPG, Cylon Detector.");
						t.value += "Baltar may not use his OPG, Cylon Detector.";
					}
					if(myPlayer === "Tom") {
						z.abusePower = [];
						z.necessarySteps = [];
						if(z.numPlayers + z.boxedPlayers.length > 1) {
							dealMutiny(me, false);
							if(!z.vBrutality) {
								t.value += "Tom's Disreputable Mutinies dealt.\r\n";
								t.value += "Tom must place one of these mutinies on the bottom of the Mutiny deck.\r\n";
							} else {
								t.value += "Tom's Disreputable Mutiny dealt.\r\n";
							}
						}
					}
					if(myPlayer === "Anders") {
						if(me > z.turn) {
							z.andersBenchRound = z.round;
						} else {
							z.andersBenchRound = z.round + 1;
						}
						if(z.numPlayers + z.boxedPlayers.length === 1) {
							z.andersBenchRound = -1;
						}
					}
					if(wasMutineer) {
						addAlert("Your new character receives the Mutineer card.");
						t.value += bold(myPlayer + " receives the Mutineer card face-up.") + "\r\n";
						dealMutiny(z.theMutineer, false);
						if(z.theMutineer === z.president) {
							passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
						}
						if(z.theMutineer === z.admiral) {
							passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
						}
						if(z.CFB && z.theMutineer === z.cag) {
							passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
						}
					} else {
						if(me === z.admiral) {
							passAdmiral(99);
						}
						if(me === z.president) {
							passPresident(99);
						}
						if(z.CFB && me === z.cag) {
							passCAG(99);
						}
					}
					if(z.exodus && z.turn === me) {
						z.executedCurrentPlayer = true; /* TODO: better handling of this. */
						addAlert("You should, most likely, end the turn now.");
					}
					z.banners[me] = d.banners[getCharacter(myPlayer)];
					mainMenu();
				});
			});
		} else if(ch === "Reveal a Cylon card after being boxed") {
			let revealingCard = -1;
			let cylonCards = 0;
			let revealCard = function() {
				confirmify("Confirming you want to reveal " + d.loyaltyNames[z.boxedPlayers[meBoxed][2][revealingCard]] + " after being boxed.",
					mainMenu, () => {
						let cylonCard = z.boxedPlayers[meBoxed][2][revealingCard];
						z.boxedPlayers[meBoxed][3].push(z.boxedPlayers[meBoxed][3].splice(revealingCard, 1)[0]);
						addAlert("You reveal " + d.loyaltyNames[cylonCard] + ".");
						t.value += bold(z.players[me] + " reveals " + d.loyaltyNames[cylonCard] + ".") + "\r\n";
						if(characterPresent("Cavil") && !noDrawback(getPlayerNum("Cavil"))) {
							if(z.vBrutality) {
								boldAlert("Cavil must discard five skill cards due to his Lies and Secrets drawback.");
								promptAllyDiscards(getPlayerNum("Cavil"), 5);
							} else {
								boldAlert("Cavil discards his skill card hand due to his Lies and Secrets drawback.");
								discardEntireHand(getPlayerNum("Cavil"));
							}
						}
						mainMenu();
					});
			};
			for(let j = 0; !(j >= z.boxedPlayers[meBoxed][2].length); j++) {
				if(isCylonCard(z.boxedPlayers[meBoxed][2][j])) {
					cylonCards++;
				}
			}
			if(cylonCards >= 2) {
				let promptText = "Which Cylon card would you like to reveal? (1-2)\n";
				let option1 = -1;
				let option2 = -1;
				for(let i = 0; !(i >= z.boxedPlayers[meBoxed][2].length); i++) {
					if(isCylonCard(z.boxedPlayers[meBoxed][2][i ])) {
						promptText += d.loyaltyNames[z.boxedPlayers[meBoxed][2][i ]] + "\n";
						if(option1 === -1) {
							option1 = i;
						} else {
							option2 = i;
							break;
						}
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 2, mainMenu, (prompted) => {
					if(prompted === 1) {
						revealingCard = option1;
					} else {
						revealingCard = option2;
					}
					revealCard();
				});
			} else {
				for(let i = 0; !(i >= z.boxedPlayers[meBoxed][2].length); i++) {
					if(isCylonCard(z.boxedPlayers[meBoxed][2][i ])) {
						revealingCard = i;
						revealCard();
						break;
					}
				}
			}
		} else if(ch === "Reveal a Cylon card after being executed") {
			let revealingCard = -1;
			let revealCard = function() {
				confirmify("Confirming you want to reveal " + d.loyaltyNames[z.loyaltyHands[me][revealingCard]] + " after being executed.",
					mainMenu, () => {
						z.cylonExecuted = -1;
						let cylonCard = z.loyaltyHands[me][revealingCard];
						z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(revealingCard, 1)[0]);
						addAlert("You reveal " + d.loyaltyNames[cylonCard] + ".");
						t.value += bold(z.players[me] + " reveals " + d.loyaltyNames[cylonCard] + ".") + "\r\n";
						if(characterPresent("Cavil") && !noDrawback(getPlayerNum("Cavil"))) {
							if(z.vBrutality) {
								boldAlert("Cavil must discard five skill cards due to his Lies and Secrets drawback.");
								promptAllyDiscards(getPlayerNum("Cavil"), 5);
							} else {
								boldAlert("Cavil discards his skill card hand due to his Lies and Secrets drawback.");
								discardEntireHand(getPlayerNum("Cavil"));
							}
						}
						if(z.galacticaAway) {
							movePlayer(me, "Medical Center");
						} else if(z.hubDestroyed) {
							movePlayer(me, "Hub Destroyed");
						} else {
							movePlayer(me, "Resurrection Ship");
						}
						z.revealedCylons[me] = 1;
						if(Array.isArray(z.personalGoalsBrutality)){
							z.personalGoalsBrutality[me] = null;
						}
						if(z.admiral === me) {
							passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
						}
						if(z.president === me) {
							passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
						}
						if(z.CFB && z.cag === me) {
							passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
						}
						if((z.pegasus || z.daybreak || z.vHandoff) && 7 > z.distance && z.loyaltyHands[me].length > 0) {
							plainAlert("Now, " + z.players[me] + " must pass their remaining Loyalties off to a player of their choice.");
						}
						if(z.turn === me) {
							z.executedCurrentPlayer = true;
							addAlert("You should, most likely, end the turn now.");
						}
						mainMenu();
					});
			};
			if(cylonCards(me) >= 2) {
				let promptText = "Which Cylon card would you like to reveal? (1-2)\n";
				let option1 = -1;
				let option2 = -1;
				for(let i = 0; !(i >= z.loyaltyHands[me].length); i++) {
					if(isCylonCard(z.loyaltyHands[me][i ])) {
						promptText += d.loyaltyNames[z.loyaltyHands[me][i ]] + "\n";
						if(option1 === -1) {
							option1 = i;
						} else {
							option2 = i;
							break;
						}
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 2, mainMenu, (prompted) => {
					if(prompted === 1) {
						revealingCard = option1;
					} else {
						revealingCard = option2;
					}
					revealCard();
				});
			} else {
				for(let i = 0; !(i >= z.loyaltyHands[me].length); i++) {
					if(isCylonCard(z.loyaltyHands[me][i ])) {
						revealingCard = i;
						revealCard();
						break;
					}
				}
			}
		} else if(ch === "Pass your remaining Loyalty cards to a Human of your choice") {
			let promptText = "Your remaining Loyalties are:";
			for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
				if(j === 0 && me === z.theSympatheticCylon) {
					continue;
				}
				promptText += "\n" + d.loyaltyNames[z.loyaltyHands[me][j]];
			}
			promptText += "\n\nWho would you like to pass your Loyalty cards to? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(isCylonLeader(z.players[j])) {
					promptText += "(Cylon Leader)";
				} else if(j === z.theSympatheticCylon) {
					promptText += "(Sympathetic Cylon)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "CYLON";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || isTheCylonLeader(a - 1) || a - 1 === z.theSympatheticCylon || z.revealedCylons[
				a - 1] === 1, mainMenu, (prompted) => {
				addAlert("You pass your Loyalties to " + z.players[prompted - 1] + ".");
				t.value += bold(myPlayer + " passes their remaining Loyalties to " + z.players[prompted - 1]) + ".\r\n";
				if(me !== z.theSympatheticCylon) {
					z.loyaltyHands[prompted - 1] = z.loyaltyHands[prompted - 1].concat(shuffle(z.loyaltyHands[me]));
					z.loyaltyHands[me] = [];
				} else {
					let loyalties = shuffle(z.loyaltyHands[me].slice(1));
					z.loyaltyHands[prompted - 1] = z.loyaltyHands[prompted - 1].concat(loyalties);
					z.loyaltyHands[me] = [z.loyaltyHands[me][0]];
				}
				if(z.mutineer) {
					for(let j = 0; !(j >= z.loyaltyHands[prompted - 1].length); j++) {
						if(z.loyaltyHands[prompted - 1][j] === 40) {
							becomeMutineer(prompted - 1, j);
						} else if(z.loyaltyHands[prompted - 1][j] === 15) {
							becomeSympathizer(prompted - 1, j);
						} else if(z.loyaltyHands[prompted - 1][j] === 17) {
							becomeSympatheticCylon(prompted - 1, j);
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "Trigger Consequences") {
			confirmify("Confirming you want to trigger the consequence for this skill check.", mainMenu, () => {
				removeFromAll("[Human Delusion] Play a card into the skill check");
				t.value += bold("Consequence Triggered.") + "\r\n";
				z.thisConsequence = 0;
				switch (d.crisisNames[z.currentCrisis]) {
					case "Divisive Behavior":
					case "In the Ring":
						if(validSickbayTarget(z.turn)) {
							boldAlert(z.players[z.turn] + ", as current player, must choose another player to send to Sickbay.");
							addOption(z.turn, "Move a player to Sickbay", "another", true);
						} else {
							plainAlert("No other players can be moved to Sickbay at this time; no effect.");
						}
						break;
					case "Haunted by the Past":
						if(z.turn !== z.president && z.turn !== z.admiral && (!z.CFB || z.turn !== z.cag)) {
							plainAlert("No Effect");
							break;
						}
						if(z.turn === z.president) {
							passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
						}
						if(z.turn === z.admiral) {
							passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
						}
						if(z.CFB && z.turn === z.cag) {
							passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
						}
						break;
					case "Power Failure":
						if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
							plainAlert("Now, " + z.players[z.turn] +
							", as current player, must choose whether to damage Pegasus or Galactica.");
							addOption(z.turn, "Damage Pegasus", undefined, true);
							addOption(z.turn, "Damage Galactica", undefined, true);
						} else {
							damageGalactica();
						}
						break;
					case "Threat of a Super Nova":
						if(!z.negotiation) {
							addAlert("Basestars activate.");
							activateBasestars();
						} else {
							addAlert("Negotiation prevents the Basestar activation.");
							t.value += colorText("orange", "Negotiation") + " prevents the Basestar activation.\r\n";
						}
						break;
					case "Fire All Missiles":
						if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
							plainAlert("Now, " + z.players[z.turn] +
								", as current player, must choose whether to damage Pegasus or Galactica for each damage, in turn.");
							addOption(z.turn, "Damage Pegasus", 2, true);
							addOption(z.turn, "Damage Galactica", 2, true);
						} else {
							if(damageGalactica()) {
								damageGalactica();
							} else {
								/* TODO: streamline this in some way? */
								addAlert("After resolving Ally placement, you must damage Galactica again.");
								t.value += "After resolving Ally placement, damage Galactica again.\r\n";
								for(let j = 0; !(j >= z.numPlayers); j++) {
									if(z.revealedCylons[j] === 1) {
										addOption(z.turn, "Damage Galactica", undefined, false);
									}
								}
							}
						}
						break;
				}
				if(shouldDE()) {
					addAlert("The check is within Declare Emergency range.");
					DEToken();
				}
				mainMenu();
			});
		} else if(ch === "Reveal a Motive") {
			let promptText = "Which Motive would you like to reveal? (1-" + z.loyaltyHands[me].length + ")";
			for(let j = 0; !(j >= z.loyaltyHands[me].length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				switch (z.loyaltyHands[me][j]) {
					case 53:
					case 54:
					case 60:
					case 61:
						promptText += d.loyaltyNames[z.loyaltyHands[me][j]];
						break;
					default:
						promptText += "(game is not over)";
						break;
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.loyaltyHands[me].length || (z.loyaltyHands[me][a - 1] !== 53 && z.loyaltyHands[me][a - 1] !==
				54 && z.loyaltyHands[me][a - 1] !== 60 && z.loyaltyHands[me][a - 1] !== 61), mainMenu, (prompted) => {
				switch (z.loyaltyHands[me][prompted - 1]) {
					case 53: {
						let satisfied = false;
						for(let j = 0; !(j >= z.damagedLocations.length); j++) {
							if(z.damagedLocations[j] === "FTL Control" || z.damagedLocations[j] === "Admiral's Quarters") {
								satisfied = true;
								break;
							}
						}
						let endTheChase = function() {
							addAlert("You reveal Human Allegiance: End the Chase.");
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[z.loyaltyHands[me][prompted - 1]]) + ".\r\n";
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(prompted - 1, 1)[0]);
							mainMenu();
						};
						if(satisfied) {
							endTheChase();
						} else {
							confirmify("Are you sure you want to reveal End the Chase?  Neither FTL Control nor Admiral's Quarters is damaged.",
								mainMenu, endTheChase);
						}
						break;
					}
					case 54: {
						let satisfied = false;
						for(let j = 0; ((!z.daybreak && !z.revealedCylons[me]) || z.mutinies[me].length > 0) && !(j >= z.numPlayers); j++) {
							if((z.playerLocations[j] === "Brig" && j !== me && !isOnNewCaprica(me)) || (z.playerLocations[j] === "Detention" &&
									j !== me && isOnNewCaprica(me))) {
								satisfied = true;
								break;
							}
						}
						let makeAnAlly = function() {
							addAlert("You reveal Human Allegiance: Make An Ally.");
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[z.loyaltyHands[me][prompted - 1]]) + ".\r\n";
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(prompted - 1, 1)[0]);
							mainMenu();
						};
						if(satisfied) {
							makeAnAlly();
						} else {
							confirmify(
								"Are you sure you want to reveal Make An Ally?  You need to have a Mutiny and someone else needs to be in the Brig; this is not the case at the moment.",
								mainMenu, makeAnAlly);
						}
						break;
					}
					case 60: {
						let satisfied = ((z.jumpTrack === 3 || z.jumpTrack === 4) && raidersAway() === z.raiders.length && heaviesAway() === z.heavies.length &&
							basestarsAway() === z.basestars.length);
						let blueSkies = function() {
							addAlert("You reveal Cylon Allegiance: A Justified Response.");
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[z.loyaltyHands[me][prompted - 1]]) + ".\r\n";
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(prompted - 1, 1)[0]);
							mainMenu();
						};
						if(satisfied) {
							blueSkies();
						} else {
							confirmify(
								"Are you sure you want to reveal A Justified Response?  The jump track must be in the blue, and there must be " +
								"no Raiders, Heavy Raiders, or Basestars on the main game board; this is not the case at the moment.",
								mainMenu, blueSkies);
						}
						break;
					}
					case 61: {
						let satisfied = (z.distance >= 5 && centurionReserves() === z.centurions.length);
						let unnecessaryForce = function() {
							addAlert("You reveal Cylon Allegiance: No Unnecessary Force.");
							t.value += bold(myPlayer + " reveals " + d.loyaltyNames[z.loyaltyHands[me][prompted - 1]]) + ".\r\n";
							z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(prompted - 1, 1)[0]);
							mainMenu();
						};
						if(satisfied) {
							unnecessaryForce();
						} else {
							confirmify(
								"Are you sure you want to reveal No Unnecessary Force?  Distance must be 5 or more, and there must be no Centurions on Galactica; this is not the case at the moment.",
								mainMenu, unnecessaryForce);
						}
						break;
					}
				}
			});
		} else if(ch === "Discard this Crisis Card") {
			addAlert("Discarded the crisis card.");
			discardCrisis();
			z.finishedCrisis = false;
			z.capricaCrisis = false;
			mainMenu();
		} else if(ch === "Discard this Super Crisis Card") {
			addAlert("Discarded the Super Crisis card.");
			z.currentCrisis = null;
			z.crisisPlayer = null;
			z.finishedCrisis = false;
			z.capricaCrisis = false;
			mainMenu();
		} else if(ch === "Activate Skill Check Effects") {
			let ef = skillCheckEffects();
			let promptText = "Which skill check effect would you like to activate first? (1-" + ef.length + ")";
			for(let j = 0; !(j >= ef.length); j++) {
				promptText += "\n" + (j + 1) + ": " + ef[j];
			}
			promptNum(promptText, (a) => 1 > a || a > ef.length, mainMenu, (prompted) => {
				let done = function() {
					removeFromAll("[Human Delusion] Play a card into the skill check");
					if(skillCheckEffects().length === 0 && (!z.reckless || !z.daybreak) && (z.thisConsequence === 0 || !
							consequenceTriggered())) {
						if(shouldDE()) {
							addAlert("The check is within Declare Emergency range.");
							DEToken();
						}
					}
					mainMenu();
				};
				switch (ef[prompted - 1]) {
					/* TODO: autotrigger if effect is automatic and can't be removed?  Or will always have no effect (e.g. Force Their Hand on a Cylon turn), though remember dumbass Protect the Fleet / AVP */
					case "Red Tape":
						confirmify(
							"Confirming you want to activate Red Tape and discard all cards with a printed strength of 5 or 6 from the skill check.",
							mainMenu, () => {
								z.redTape = true;
								for(let j = 0; !(j >= z.revealedCards.length); j++) {
									if(cardValue(z.revealedCards[j]) >= 5) {
										let color = cardColorID(z.revealedCards[j]);
										z.skillCardDiscards[color].push(z.revealedCards.splice(j, 1)[0]);
										j--;
									}
								}
								refreshSkillDecks();
								t.value += bold(myPlayer + " resolves " + colorText("orange", "Red Tape") +
									" to discard all 5- and 6-strength cards from the skill check.") + "\r\n\r\n";
								addAlert("5- and 6-strength cards discarded.\n\n" + skillCheckTally(true)[0]);
								printRevealedCards();
								done();
							});
						break;
					case "Iron Will":
						confirmify("Confirming you want to activate Iron Will now.", mainMenu, () => {
							z.ironWill = true;
							addAlert("Iron Will activated.");
							t.value += bold(myPlayer + " activates " + colorText("green", "Iron Will")) +
								"; its effects occur later.\r\n";
							done();
						});
						break;
					case "Trust Instincts":
						confirmify("Confirming you want to activate Trust Instincts and play 2 cards from Destiny into the skill check.",
							mainMenu, () => {
								z.trustInstincts = true;
								if(z.destiny.length === 0) {
									plainAlert("Destiny is empty and cannot be rebuilt.");
									done();
									return;
								}
								t.value += bold(myPlayer + " activates " + colorText("purple", "Trust Instincts")) +
								", which plays in:\r\n";
								let card1 = z.destiny.pop();
								z.revealedCards.push(card1);
								if(z.destiny.length === 0) {
									buildDestiny();
								}
								let card2 = z.destiny.pop();
								z.revealedCards.push(card2);
								if(z.destiny.length === 0) {
									buildDestiny();
								}
								addAlert("Destiny plays in " + cardText(card1) + " and " + cardText(card2) + ".\n\n" + skillCheckTally(
									true)[0]);
								t.value += "\n - " + cardText(card1) + "\n - " + cardText(card2) + "\r\n\r\n" + skillCheckTally(true)[0] +
									"\r\n";
								z.revealedCards.sort(cardCompare);
								done();
							});
						break;
					case "Protect the Fleet":
						confirmify(
							"Confirming you want to activate Protect the Fleet.  You do not have to (or may not even be able to) activate a Viper.",
							mainMenu, () => {
								z.protectTheFleet = true;
								let count = 0;
								for(let j = 0; !(j >= z.revealedCards.length); j++) {
									if(cardColor(z.revealedCards[j]) === "red") {
										count += cardValue(z.revealedCards[j]);
									}
								}
								if(count >= 3) {
									t.value += bold(myPlayer + " activates " + colorText("red", "Protect the Fleet")) +
										"\r\nThey may now activate an unmanned viper.\r\n";
									addAlert("Now, you may activate an unmanned viper.");
									menuPage = "[Manual Viper Activation]";
									addOption(me, "Activate an unmanned Viper", 1, false);
								} else {
									t.value += bold(myPlayer + " activates " + colorText("red", "Protect the Fleet")) + ": No Effect.\r\n";
									addAlert("Not enough Piloting in the skill check; no effect.");
								}
								done();
							});
						break;
					case "Establish Network":
						confirmify("Confirming you want to activate Establish Network; all Engineering cards will have double strength.",
							mainMenu, () => {
								z.establishNetwork = true;
								addAlert("Establish Network activated.");
								t.value += bold(myPlayer + " activates " + colorText("blue", "Establish Network")) + ".\r\n";
								done();
							});
						break;
					case "Force Their Hand":
						if(z.revealedCylons[z.turn] === 0) {
							confirmify(
								"Confirming you want to activate Force Their Hand; you will have to play a card into the skill check or draw a Mutiny.",
								mainMenu, () => {
									z.forceTheirHand = true;
									t.value += bold(myPlayer + " activates " + colorText("orange", "Force Their Hand")) + ".\r\n";
									if(z.skillCardHands[z.turn].length === 0) {
										addAlert("You have no skill cards, so you draw a Mutiny.");
										dealMutiny(z.turn, false);
										done();
									} else {
										confirmify("Would you like to play a card into the skill check, or draw a Mutiny?", () => {
											dealMutiny(z.turn, false);
											done();
										}, () => {
											let promptText = "What card would you like to play into the skill check? (1-" + z
												.skillCardHands[me].length + ")";
											for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
												promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
											}
											promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, () => {
												z.forceTheirHand = false;
												mainMenu();
											}, (prompted) => {
												addAlert("Played " + cardText(z.skillCardHands[me][prompted - 1]) +
													" into skill check.");
												t.value += bold(myPlayer + " played in " + cardText(z.skillCardHands[me][
													prompted - 1
												])) + ".\r\n";
												z.revealedCards.push(z.skillCardHands[me].splice(prompted - 1, 1)[0]);
												t.value += "\r\n" + skillCheckTally(true)[0] + "\r\n";
												if(z.skillCardHands[me].length === 0) {
													z.possibleColors[me] = [0, 0, 0, 0, 0, 0];
												}
												done();
											});
										}, "Play a card", "Draw a Mutiny");
									}
								});
						} else {
							confirmify("Confirming you want to activate Force Their Hand; as you are a Cylon, this will have no effect.",
								mainMenu, () => {
									z.forceTheirHand = true;
									t.value += bold(myPlayer + " activates " + colorText("orange", "Force Their Hand")) +
										": no effect, as they are a Cylon.\r\n";
									done();
								});
						}
						break;
					case "All Hands on Deck":
						confirmify("Confirming you want to activate All Hands on Deck; all zero-strength cards will count as +1.", mainMenu,
						() => {
								z.allHandsOnDeck = true;
								addAlert("All Hands on Deck activated.");
								t.value += bold(myPlayer + " activates " + colorText("green", "All Hands on Deck")) + ".\r\n";
								done();
							});
						break;
					case "Quick Thinking": {
						let removeableCards = [];
						for(let j = 0; !(j >= z.revealedCards.length); j++) {
							if(3 >= cardValue(z.revealedCards[j]) && cardName(z.revealedCards[j]) !== "Quick Thinking") {
								removeableCards.push([z.revealedCards[j], j]);
							}
						}
						removeableCards.push("I do not wish to take a card from this skill check.");
						let promptText = "Which card would you like to take to your hand with Quick Thinking? (1-" + removeableCards.length +
							")";
						for(let j = 0; !(j >= removeableCards.length); j++) {
							promptText += "\n" + (j + 1) + ": ";
							if(j === removeableCards.length - 1) {
								promptText += removeableCards[j];
							} else {
								promptText += cardText(removeableCards[j][0]);
							}
						}
						promptNum(promptText, (a) => 1 > a || a > removeableCards.length, mainMenu, (prompted) => {
							z.quickThinking = true;
							if(prompted === removeableCards.length) {
								addAlert("You chose not to take a card with Quick Thinking.");
								t.value += bold(myPlayer + " activates " + colorText("purple", "Quick Thinking") +
									", but does not take a card from the skill check.") + ".\r\n";
							} else {
								let card = removeableCards[prompted - 1][0];
								z.skillCardHands[me].push(z.revealedCards.splice(removeableCards[prompted - 1][1], 1)[0]);
								z.possibleColors[me][cardColorID(card)] = 1;
								addAlert("You took " + cardText(card) + ".");
								t.value += bold(myPlayer + " activates " + colorText("purple", "Quick Thinking") + ", taking " +
									cardText(card)) + ".\r\n\r\n" + skillCheckTally(true)[0] + "\r\n";
							}
							done();
						});
						break;
					}
					case "Dogfight": {
						let isIntactViper = false;
						for(let j = 0; !isIntactViper && !(j >= z.vipersII.length); j++) {
							isIntactViper = !Number.isInteger(z.vipersII[j]) || z.vipersII[j] >= 0;
						}
						for(let j = 0; !isIntactViper && z.CFB && !(j >= z.vipersVII.length); j++) {
							isIntactViper = !Number.isInteger(z.vipersVII[j]) || z.vipersVII[j] >= 0;
						}
						for(let j = 0; !isIntactViper && z.daybreak && !(j >= z.assaultRaptors.length); j++) {
							isIntactViper = !Number.isInteger(z.assaultRaptors[j]) || z.assaultRaptors[j] >= 0;
						}
						if(!isIntactViper) {
							z.dogfight = true;
							addAlert("There are no intact Vipers to damage.");
							t.value += bold(myPlayer + " activates " + colorText("red", "Dogfight")) +
								": No Effect as there are no Vipers to damage.\r\n";
							done();
							break;
						}
						let promptText = "Which card would you like to remove from this skill check with Dogfight? (1-" + (z.revealedCards
							.length + 1) + ")";
						let dogfight = -1;
						for(let j = 0; !(j >= z.revealedCards.length); j++) {
							promptText += "\n" + (j + 1) + ": ";
							if(cardName(z.revealedCards[j]) === "Dogfight" && dogfight === -1) {
								promptText += "(must remove another card)";
								dogfight = j;
							} else {
								promptText += cardText(z.revealedCards[j]);
							}
						}
						promptText += "\n" + (z.revealedCards.length + 1) +
							": I do not wish to damage a Viper to remove a card from this skill check.";
						promptNum(promptText, (a) => 1 > a || a > z.revealedCards.length + 1 || a - 1 === dogfight, mainMenu, (prompted2) => {
							z.dogfight = true;
							if(prompted2 === z.revealedCards.length + 1) {
								addAlert("You chose not to damage a Viper to remove a card with Dogfight.");
								t.value += bold(myPlayer + " activates " + colorText("red", "Dogfight") +
									", but chooses not to damage a Viper.") + "\r\n";
							} else {
								let card = z.revealedCards[prompted2 - 1];
								z.skillCardDiscards[cardColorID(card)].push(z.revealedCards.splice(prompted2 - 1, 1)[0]);
								reshuffleSkillCardDeck(cardColorID(card));
								addAlert("You removed " + cardText(card) + ".\n\nNow, damage a Viper.");
								t.value += bold(myPlayer + " activates " + colorText("red", "Dogfight") + ", removing " + cardText(
									card)) + ".\r\n";
								t.value += myPlayer + " must now damage a Viper.\r\n\r\n" + skillCheckTally(true)[0] + "\r\n";
								addOption(me, "Damage a Viper", ["Dogfight", 1], true);
							}
							done();
						});
						break;
					}
					case "Install Upgrades": {
						let confirmText =
							"Confirming you want to activate Install Upgrades; you will receive 2 Engineering if the check passes, 1 if it fails";
						if(z.thisPartial > 0) {
							confirmText += ", but 0 on a Partial";
						}
						confirmText += ".";
						confirmify(confirmText, mainMenu, () => {
							z.installUpgrades = true;
							addAlert("Install Upgrades activated; you will automatically receive the Engineering cards later.");
							t.value += bold(myPlayer + " activates " + colorText("blue", "Install Upgrades")) +
								"; they will get the Engineering card(s) automatically later.\r\n";
							done();
						});
						break;
					}
					case "Bait":
						if(z.galacticaAway) {
							addAlert("Bait has no effect while Galactica is away.");
							t.value += bold(myPlayer + " activates " + colorText("brown", "Bait")) + ": No Effect while Galactica is away.\r\n";
							z.bait = true;
							done();
						} else {
							confirmify("Confirming you want to activate Bait and place a Civilian behind Galactica.", mainMenu, () => {
								z.bait = true;
								t.value += bold(myPlayer + " activates " + colorText("brown", "Bait")) + ".\r\n";
								placeCivilian(4);
								done();
							});
						}
						break;
					case "Dradis Contact":
						if(z.galacticaAway) {
							addAlert("Dradis Contact has no effect while Galactica is away.");
							t.value += bold(myPlayer + " activates " + colorText("brown", "Dradis Contact")) +
								": No Effect while Galactica is away.\r\n";
							z.dradisContact = true;
							done();
						} else {
							confirmify("Confirming you want to activate Dradis Contact and place 2 Raiders in front of Galactica.", mainMenu,
							() => {
									z.dradisContact = true;
									t.value += bold(myPlayer + " activates " + colorText("brown", "Dradis Contact")) + ".\r\n";
									addAlert("Placed 2 Raiders in Sector 1.");
									placeRaiders(1, 2);
									done();
								});
						}
						break;
					case "Personal Vices": {
						let confirmText = "Confirming you want to activate Personal Vices; every Human will get a Treachery.";
						if(z.revealedCylons[z.turn] === 0) {
							confirmText += " Then, you will get a Mutiny.";
						}
						confirmify(confirmText, mainMenu, () => {
							z.personalVices = true;
							t.value += bold(myPlayer + " activates " + colorText("brown", "Personal Vices")) + ".\r\n";
							dealSkillCardToEveryone(z.turn, 5, false);
							if(z.revealedCylons[z.turn] === 0) {
								dealMutiny(z.turn, false);
							}
							done();
						});
						break;
					}
					case "A Better Machine":
						confirmify("Confirming you want to activate A Better Machine and shuffle 2 Treachery into Destiny.", mainMenu, () => {
							z.aBetterMachine = true;
							t.value += bold(myPlayer + " activates " + colorText("brown", "A Better Machine")) + ".\r\n";
							shuffleTreachery();
							done();
						});
						break;
					case "Violent Outbursts":
						z.violentOutbursts = true;
						if(z.revealedCylons[z.turn] === 1) {
							/* RULES: this on New Caprica */
							t.value += bold(myPlayer + " activates " + colorText("brown", "Violent Outbursts")) + ": No Effect.\r\n";
							addAlert("Violent Outbursts has no effect as you are a Cylon.");
							done();
						} else if(z.playerLocations[z.turn] === "Stranded on Caprica") {
							t.value += bold(myPlayer + " activates " + colorText("brown", "Violent Outbursts")) + ": No Effect.\r\n";
							addAlert("Violent Outbursts has no effect as you are Stranded on Caprica.");
							done();
						} else if(z.playerLocations[z.turn] === "Brig") {
							t.value += bold(myPlayer + " activates " + colorText("brown", "Violent Outbursts")) + ": No Effect.\r\n";
							addAlert("Violent Outbursts has no effect as you are in the Brig.");
							done();
						} else if(z.playerLocations[z.turn] === "Detention") {
							t.value += bold(myPlayer + " activates " + colorText("brown", "Violent Outbursts")) + ": No Effect.\r\n";
							addAlert("Violent Outbursts has no effect as you are in Detention.");
							done();
						} else {
							confirmify("Confirming you want to activate Violent Outbursts and send yourself to Sickbay.", mainMenu, () => {
								t.value += bold(myPlayer + " activates " + colorText("brown", "Violent Outbursts")) + ".\r\n";
								if(isOnNewCaprica(me)) {
									addAlert("You are sent to the Medical Center.");
									movePlayer(z.turn, "Medical Center");
								} else {
									addAlert("You are sent to Sickbay.");
									movePlayer(z.turn, "Sickbay");
								}
								done();
							});
						}
						break;
					case "Exploit Weakness":
						confirmify("Confirming you want to activate Exploit Weakness and deal a Mutiny.", mainMenu, () => {
							z.exploitWeakness = true;
							t.value += bold(myPlayer + " activates " + colorText("brown", "Exploit Weakness")) + ".\r\n";
							addAlert("Now, deal a Mutiny to a player of your choice.");
							addOption(me, "Deal a Mutiny card", undefined, true);
							done();
						});
						break;
					case "Special Destiny":
						confirmify("Confirming you want to activate Special Destiny and deal a Treachery to all players.", mainMenu, () => {
							z.specialDestiny = true;
							t.value += bold(myPlayer + " activates " + colorText("brown", "Special Destiny")) + ".\r\n";
							dealSkillCardToEveryone(z.turn, 5, true);
							addAlert("Dealt a Treachery to all players.");
							done();
						});
						break;
					case "Broadcast Location":
						confirmify(
							"Confirming you want to activate Broadcast Location and place a basestar in front of Galactica and a civilian behind.",
							mainMenu, () => {
								z.broadcastLocation = true;
								t.value += bold(myPlayer + " activates " + colorText("brown", "Broadcast Location")) + ".\r\n";
								placeBasestar(1);
								placeCivilian(4);
								done();
							});
						break;
					case "By Your Command":
						z.byYourCommand = true;
						if(z.galacticaAway) {
							activateOFs();
						} else if(activateRaiders()) {
							if(activateHeavies(true) && z.galacticaReturned) {
								activateOFs();
							} else if(z.galacticaReturned) {
								plainAlert("Once that's done, activate Occupation Forces.");
								addOption(me, "Activate Occupation Forces", undefined, true);
							}
						} else {
							if(z.galacticaReturned) {
								plainAlert("Once you have finished the Raider activation, activate Heavy Raiders and Occupation Forces.");
							} else {
								plainAlert("Once you have finished the Raider activation, activate Heavy Raiders.");
							}
							addOption(me, "Activate Heavy Raiders from By Your Command", undefined, true);
						}
						done();
						break;
				}
			});
		} else if(ch === "Use Quick Fix") {
			/* TODO: Quick Fix if >22 cards in check */
			let promptText = "Which card would you like to remove from this skill check with Quick Fix? (1-" + (z.revealedCards.length + 1) + ")";
			for(let j = 0; !(j >= z.revealedCards.length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				promptText += cardText(z.revealedCards[j]);
			}
			promptText += "\n" + (z.revealedCards.length + 1) + ": I do not wish to use Quick Fix on this skill check.";
			promptNum(promptText, (a) => 1 > a || a > z.revealedCards.length + 1, mainMenu, (prompted2) => {
				z.quickFix = true;
				removeFromAll("[Human Delusion] Play a card into the skill check");
				if(prompted2 === z.revealedCards.length + 1) {
					addAlert("You chose not to use Quick Fix.");
					t.value += bold(myPlayer + " passes on Quick Fix.") + ".\r\n";
				} else {
					let card = z.revealedCards[prompted2 - 1];
					z.skillCardDiscards[cardColorID(card)].push(z.revealedCards.splice(prompted2 - 1, 1)[0]);
					reshuffleSkillCardDeck(cardColorID(card));
					addAlert("You removed " + cardText(card) + " with Quick Fix.\n\n" + skillCheckTally(true)[0]);
					t.value += bold(myPlayer + " removes " + cardText(card)) + " with Quick Fix.\r\n";
					t.value += "\r\n" + skillCheckTally(true)[0] + "\r\n";
					if(skillCheckEffects().length === 0 && (!z.reckless || !z.daybreak) && (z.thisConsequence === 0 || !
					consequenceTriggered())) {
						if(shouldDE()) {
							addAlert("The check is within Declare Emergency range.");
							DEToken();
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "[Skilled Politician] Play a Quorum card" || ch === "[Doral] Play a Quorum card" || ch ===
			"[Popular Influence] Play a Quorum Card") {
			let promptText = "What Quorum Card would you like to play? (1-" + z.quorumPeek.length + ")";
			for(let i = 0; !(i >= z.quorumPeek.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumPeek[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.quorumPeek.length, mainMenu, (prompted) => {
				addAlert("Playing " + d.quorumNames[z.quorumPeek[prompted - 1]] + ".");
				playQuorumCard(prompted - 1, true);
				if(z.quorumPeek.length === 1) {
					plainAlert(z.players[me] + " gives the other Quorum to the President.");
					z.quorumHand.push(z.quorumPeek.pop());
				}
				z.quorumPeeker = -1;
				removeOption(me, "[Popular Influence] Pass a Quorum card to the President");
				removeOption(me, "[Popular Influence] Discard a Quorum Card");
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Don't Trust Anyone (OPG)") {
			confirmify("Confirming that you want to use your OPG, Don't Trust Anyone, to draw 2 Super Crises.", mainMenu, () => {
				t.value += bold("D'Anna uses her OPG, Don't Trust Anyone.") + "\r\n";
				z.miracles[me] = 0;
				drawSuperCrisis();
				drawSuperCrisis();
				didAction();
				mainMenu();
			});
		} else if(ch === "Discard all Super Crisis cards") {
			confirmify("Confirming you want to discard all your Super Crisis cards because you started your turn on Hub Destroyed.", mainMenu, () => {
				t.value += z.players[me] + " discards all Super Crises in hand:\r\n";
				z.superCrisisHands[z.turn].sort();
				for(let i = 0; !(i >= z.superCrisisHands[z.turn].length); i++) {
					t.value += d.crisisNames[z.superCrisisHands[z.turn][i ]] + "\r\n";
				}
				z.superCrisisDiscards = z.superCrisisDiscards.concat(z.superCrisisHands[z.turn]);
				z.superCrisisHands[z.turn] = [];
				removeOption(me, ch);
				z.phase = 1;
				mainMenu();
			});
		} else if(ch === "[Heretic] Discard 3 Skill Cards") {
			confirmify("Confirming you want to discard 3 skill cards for your Heretic drawback.", mainMenu, () => {
				addOption(me, "Discard a Skill Card", 3, true);
				t.value += "D'Anna chooses to discard 3 skill cards for her Heretic drawback.\r\n";
				addAlert("Now, discard 3 skill cards.");
				addOption(me, "Move", undefined, true);
				mainMenu();
			});
		} else if(ch === "[Heretic] Discard a Super Crisis") {
			let dis = -1;
			let heretic = function() {
				let sc = z.superCrisisHands[me].splice(dis, 1)[0];
				addAlert("Discarding " + d.crisisNames[sc]);
				t.value += bold("D'Anna discards " + d.crisisNames[sc] + " for her Heretic drawback.") + "\r\n";
				z.superCrisisDiscards.push(sc);
				removeOption(me, ch);
				addOption(me, "Move", undefined, true);
				mainMenu();
			};
			if(z.superCrisisHands[me].length === 1) {
				confirmify("Confirming you want to discard a Super Crisis due to your Heretic drawback.", mainMenu, () => {
					dis = 0;
					heretic();
				});
			} else {
				let promptText = "Which Super Crisis card would you like to discard due to your Heretic drawback? (1-" + z.superCrisisHands[me].length +
					")";
				for(let j = 0; !(j >= z.superCrisisHands[me].length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.crisisNames[z.superCrisisHands[me][j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.superCrisisHands[me].length, mainMenu, (prompted) => {
					dis = prompted - 1;
					heretic();
				});
			}
		} else if(ch === "Visions") {
			if(z.detectorSabotage) {
				confirmify("Confirming that you want to use Visions to exfiltrate?  Due to Detector Sabotage, you may not inspect a Loyalty.",
					mainMenu, () => {
						t.value += bold("D'Anna uses Visions.") + "\r\n";
						if((myLocation === "Brig" || myLocation === "Detention") && z.skillCardHands[me] > 3) {
							addAlert("Now, exfiltrate; you do not have to discard down to 3 skill cards when you do so.");
							t.value += "She does not have to discard down to 3 skill cards when exfiltrating.\r\n";
						} else {
							addAlert("Now, exfiltrate.");
						}
						addOption(me, "Exfiltrate", undefined, true);
						mainMenu();
					});
			} else {
				confirmify("Confirming that you want to use Visions to inspect a random Loyalty Card, then exfiltrate?", mainMenu, () => {
					t.value += bold("D'Anna uses Visions.") + "\r\n";
					t.value += "She must now choose a Human, look at one of their Loyalty cards at random, and then exfiltrate.\r\n";
					if((myLocation === "Brig" || myLocation === "Detention") && z.skillCardHands[me] > 3) {
						t.value += "She does not have to discard down to 3 skill cards when exfiltrating.\r\n";
					}
					addAlert("Now, inspect a random Loyalty card of another Human, then exfiltrate.");
					addOption(me, "Inspect a random Loyalty card of another player", "Visions", true);
					mainMenu();
				});
			}
		} else if(ch === "Cult Leader") {
			let taketargets = [];
			let givetargets = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(j !== me && z.playerLocations[j] === myLocation) {
					if(z.miracles[j] === 1 && z.miracles[me] !== 3) {
						taketargets.push(j);
					}
					if(z.miracles[j] === 0 && z.miracles[me] !== 0 && (!z.vBrutality || z.players[j] !== "D'Anna")) {
						givetargets.push(j);
					}
				}
			}
			let target = -1;
			let taking = true;
			let cultLeader = function() {
				if(taking) {
					z.miracles[me]++;
					z.miracles[target] = 0;
					addAlert("Stealing a Miracle Token from " + z.players[target] + ".");
					t.value += bold("Gaius uses Cult Leader to steal a Miracle Token from " + z.players[target] + ".") + "\r\n";
				} else {
					z.miracles[me]--;
					z.miracles[target] = 1;
					addAlert("Giving a Miracle Token to " + z.players[target] + ".");
					t.value += bold("Gaius uses Cult Leader to give a Miracle Token to " + z.players[target] + ".") + "\r\n";
				}
				didAction();
				mainMenu();
			};
			let pickTarget = function() {
				let promptText = "Who";
				let targets = [];
				if(taking) {
					promptText += "se Miracle Token would you like to steal";
					targets = taketargets;
				} else {
					promptText += " would you like to give a miracle token to";
					targets = givetargets;
				}
				promptText += "? (1-" + targets.length + ")";
				for(let j = 0; !(j >= targets.length); j++) {
					promptText += "\n" + (j + 1) + ": " + z.players[targets[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > targets.length, mainMenu, (prompted) => {
					target = targets[prompted - 1];
					cultLeader();
				});
			};
			if(givetargets.length === 0 && taketargets.length === 1) {
				confirmify("Confirming you want to steal a Miracle Token from " + z.players[taketargets[0]] + ".", mainMenu, () => {
					target = taketargets[0];
					cultLeader();
				});
			} else if(givetargets.length === 1 && taketargets.length === 0) {
				confirmify("Confirming you want to give a Miracle Token to " + z.players[givetargets[0]] + ".", mainMenu, () => {
					target = givetargets[0];
					taking = false;
					cultLeader();
				});
			} else if(givetargets.length > 0 && taketargets.length > 0) {
				confirmify("Would you like to steal a Miracle Token or give one away?", () => {
					taking = false;
					if(givetargets.length === 1) {
						confirmify("Confirming you want to give a Miracle Token to " + z.players[givetargets[0]] + ".", mainMenu, () => {
							target = givetargets[0];
							taking = false;
							cultLeader();
						});
					} else {
						pickTarget();
					}
				}, () => {
					if(taketargets.length === 1) {
						confirmify("Confirming you want to steal a Miracle Token from " + z.players[taketargets[0]] + ".", mainMenu, () => {
							target = taketargets[0];
							cultLeader();
						});
					} else {
						pickTarget();
					}
				}, "Taketh Away", "Giveth");
			} else {
				if(givetargets.length > 0) {
					taking = false;
				}
				pickTarget();
			}
		} else if(ch === "No One Gets Left Behind (OPG)") {
			confirmify("Confirming you want to use your OPG, No One Gets Left Behind.", mainMenu,
			() => {
					/* RULES: can you do this if Fuel is at zero? */
					if(z.vBrutality) {
						if(z.assist === "Karl") {
							z.assistMiracle = 0;
						} else if(z.players[me] === "Gaius") {
							z.miracles[me] -= 2;
						} else {
							z.miracles[me] = 0;
						}
						boldAlert("Karl uses his OPG, No One Gets Left Behind.");
						increasePopulation();
						plainAlert(
							"The top card of the Destination deck is placed on the bottom of the deck, then the next card is revealed and resolved."
							);
						z.destinationDeck.unshift(z.destinationDeck.pop());
						let dest = z.destinationDeck.pop();
						z.destinationDiscards.push(dest);
						addAlert("Destination is " + d.destinationNames[dest] + ".");
						processDestination();
					} else {
						if(z.assist === "Karl") {
							z.assistMiracle = 0;
						} else if(z.players[me] === "Gaius") {
							z.miracles[me] -= 2;
						} else {
							z.miracles[me] = 0;
						}
						boldAlert("Karl uses his OPG, No One Gets Left Behind.");
						decreaseFuel();
						increasePopulation();
						increasePopulation();
					}
					mainMenu();
				});
		} else if(ch === "Receive Skills for this turn" || ch === "Draw initial Skill Cards") {
			let initial = (ch === "Draw initial Skill Cards" && !isCylonLeader(myPlayer));
			let draw = [0, 0, 0, 0, 0, 0];
			let drawTotal = 0;
			if(!initial && z.assist !== undefined) {
				addAlert(
					"You will select a full draw from within your skill set; you will then be given the opportunity to pick a color from your assist character's skill set in lieu of one of the ones you chose."
					);
			}
			if(!initial && (me !== z.theSympatheticCylon) && (z.revealedCylons[me] === 0 || isCylonLeader(myPlayer)) && (myPlayer !== "Karl" || (
					onGalactica(myLocation) || z.vBrutality) || solo) && myPlayer !== "D'Anna" && (myPlayer !== "Anders" || !z.vBrutality || solo || z
					.round !== z.andersBenchRound)) {
				let alertText = "You will automatically draw:\n";
				for(let i = 0; !(i >= 6); i++) {
					for(let j = d.skillDraws[i ][myCharacter]; j > 0; j--) {
						draw[i ]++;
						drawTotal++;
					}
					if(draw[i ] > 0) {
						alertText += draw[i ] + " " + colorIDName(i) + "\n";
					}
					if(i === 1 && z.vBrutality && z.players[me] === "Adama" && !solo) {
						let penalty = 0;
						for(let j = 0; !(j >= z.numPlayers) && 3 > penalty; j++) {
							if(isOnNewCaprica(me) && z.playerLocations[j] === "Detention") {
								penalty++;
							} else if(!isOnNewCaprica(me) && z.playerLocations[j] === "Brig") {
								penalty++;
							}
						}
						draw[i ] -= penalty;
					}
				}
				if(z.players[me] === "Billy" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && (!versionAtLeast([2,1,9]) || versionAtLeast([2,1,13]) || me !== z.president)) {
					alertText += "1 Quorum";
				}
				addAlert(alertText);
			}
			let drawing = !((drawTotal === 5) || (myPlayer === "Adama" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && !initial) || (
				drawTotal === 4 && (myPlayer === "Baltar" || myPlayer === "Billy")));
			let confirmDraw = function(repeat) {
				if(z.assist !== undefined && repeat === undefined) {
					confirmify("Would you like to draw a card from your assist character's skill set?", () => {
						confirmDraw(true);
					}, () => {
						let maxDraw = 5;
						if(z.pegasus || z.daybreak) {
							maxDraw++;
						}
						let promptText = "Which color of card would you like to give up from your own draw? (1-" + maxDraw + ")";
						for(let j = 0; !(j >= maxDraw); j++) {
							promptText += "\n" + (j + 1) + ": ";
							if(draw[j] === 0) {
								promptText += "(you did not draw this)";
							} else {
								promptText += colorIDName(j) + " (1/" + draw[j] + ")";
							}
						}
						promptNum(promptText, (a) => 1 > a || a > maxDraw || draw[a - 1] === 0, confirmDraw, (prompted) => {
							draw[prompted - 1]--;
							let promptText = "Which color of card would you like to draw from " + z.assist + "'s skill set? (1 - " +
								maxDraw + ")";
							let chr = getCharacter(z.assist);
							for(let j = 0; !(j >= maxDraw); j++) {
								promptText += "\n" + (j + 1) + ": ";
								if(d.skillSets[j][chr] === 0) {
									promptText += "(not in their skill set)";
								} else {
									promptText += colorIDName(j);
								}
							}
							promptNum(promptText, (a) => 1 > a || a > maxDraw || d.skillSets[a - 1][chr] === 0, () => {
								draw[prompted - 1]++;
								confirmDraw();
							}, (prompted2) => {
								draw[prompted2 - 1]++;
								confirmDraw(true);
							});
						});
					});
				} else {
					let confirmText = "Confirming you want to draw:\n";
					for(let i = 0; !(i >= 6); i++) {
						if(draw[i ] > 0) {
							confirmText += draw[i ] + " " + colorIDName(i) + "\n";
						}
					}
					if(z.players[me] === "Billy" && !initial && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && (!versionAtLeast([2,1,9]) || versionAtLeast([2,1,13]) || me !== z.president)) {
						confirmText += "1 Quorum";
					}
					confirmify(confirmText, mainMenu, () => {
						if(ch === "Draw initial Skill Cards") {
							t.value += myPlayer + " draws their initial skill cards:\r\n";
						} else {
							t.value += myPlayer + " takes their Receive Skills step:\r\n";
						}
						let cardsDealt = "You draw:\n";
						for(let i = 0; !(i >= 6); i++) {
							for(let j = draw[i ]; j > 0; j--) {
								let card = dealSkillCard(me, i); /* TODO: better alert than undefined if out of cards in deck? */
								cardsDealt += cardText(card) + "\n";
							}
						}
						if(z.players[me] === "Billy" && !initial && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon && (!versionAtLeast([2,1,9]) || versionAtLeast([2,1,13]) || me !== z.president)) {
							let card = dealQuorumCard(true);
							cardsDealt += d.quorumNames[card] + "\n";
						}
						addAlert(cardsDealt);
						if(z.turn === me) {
							z.phase = 1;
							z.drawSkills = false;
							if(deathWish(me)) {
								plainAlert("Racetrack skips her Movement step due to her Death Wish.");
								z.phase = 2;
							} else if (z.turn === 0 && z.round === 1 && z.players[me] === "Helo"){
								plainAlert("Helo is Stranded on Caprica, and may not move or take an action this turn.");
								z.phase = 3;
							}
						}
						mainMenu();
					});
				}
			};
			if(drawing) {
				let drawOptions = [0, 0, 0, 0, 0, 0];
				if(z.revealedCylons[me] === 1 && !isCylonLeader(myPlayer)) {
					drawOptions = [1, 1, 1, 1, 1, 0];
					if(z.pegasus || z.daybreak) {
						drawOptions[5] = 1;
					}
				} else if(initial) {
					for(let j = 0; !(j >= 6); j++) {
						if(d.skillDraws[j][myCharacter] > 0) {
							drawOptions[j] = 1;
						}
					}
					if(myPlayer === "Apollo" || myPlayer === "Gaeta" || (myPlayer === "Lee" && !z.vBrutality)) {
						drawOptions[0] = 1;
						drawOptions[1] = 1;
					} else if(myPlayer === "Lee") {
						drawOptions[0] = 1;
						drawOptions[3] = 1;
					} else if(myPlayer === "Starbuck") {
						drawOptions[1] = 1;
						drawOptions[4] = 1;
					} else if(myPlayer === "Anders") {
						drawOptions[3] = 1;
					} else if(myPlayer === "Seelix") {
						drawOptions[4] = 1;
					} else if(myPlayer === "Shaw" && versionAtLeast([2,1,13])){
						drawOptions[4] = 1;
						drawOptions[0] = 1;
					}
				} else if(me === z.theSympatheticCylon) {
					drawOptions = [1, 1, 1, 1, 1, 1];
				} else {
					switch (myPlayer) {
						case "Karl":
							drawOptions = [0, 1, 1, 1, 0, 0];
							break;
						case "Apollo":
						case "Gaeta":
							drawOptions = [1, 1, 0, 0, 0, 0];
							break;
						case "Lee":
							if(!z.vBrutality) {
								drawOptions = [1, 1, 0, 0, 0, 0];
							} else {
								drawOptions = [1, 0, 0, 1, 0, 0];
							}
							break;
						case "Starbuck":
							drawOptions = [0, 1, 0, 0, 1, 0];
							break;
						case "Cain":
							drawOptions = [0, 1, 1, 0, 0, 0];
							break;
						case "Anders":
						case "Racetrack":
							if(myPlayer === "Anders" && z.vBrutality && z.andersBenchRound === z.round && !solo) {
								drawOptions = [0, 1, 1, 1, 0, 0];
							} else {
								drawOptions = [0, 0, 1, 1, 0, 0];
							}
							break;
						case "Seelix":
							drawOptions = [0, 0, 0, 1, 1, 0];
							break;
						case "Shaw":
							drawOptions = [1, 0, 0, 0, 1, 0];
							break;
						case "D'Anna":
							if(z.vBrutality) {
								drawOptions = [1, 0, 0, 0, 0, 1];
							} else {
								drawOptions = [1, 1, 0, 0, 1, 1];
							}
							break;
						case "Cavil":
							drawOptions = [0, 0, 0, 0, 1, 1];
							if(z.revealedCylons[me] === 0) {
								drawOptions[2] = 1;
							}
							break;
						case "Leoben":
							drawOptions = [0, 0, 0, 0, 1, 1];
							if(z.revealedCylons[me] === 0) {
								drawOptions[0] = 1;
							}
							break;
						case "Six":
							drawOptions = [0, 0, 0, 0, 1, 1];
							if(z.revealedCylons[me] === 0) {
								drawOptions[1] = 1;
							}
							break;
						case "Simon":
							drawOptions = [0, 0, 1, 0, 0, 1];
							if(z.revealedCylons[me] === 0) {
								drawOptions[4] = 1;
							}
							break;
						case "Doral":
							drawOptions = [1, 0, 1, 0, 0, 0];
							if(z.revealedCylons[me] === 0) {
								drawOptions[5] = 1;
							}
							break;
						case "Athena":
							drawOptions = [0, 1, 0, 0, 1, 0];
							if(z.revealedCylons[me] === 0) {
								drawOptions[3] = 1;
							}
							break;
					}
				}
				let drawACard = function() {
					let optionsDraw = [];
					if(drawOptions[0] === 0) {
						optionsDraw.push("(cannot draw this)");
					} else {
						optionsDraw.push("Draw 1 Politics.");
					}
					if(drawOptions[1] === 0) {
						optionsDraw.push("(cannot draw this)");
					} else {
						optionsDraw.push("Draw 1 Leadership.");
					}
					if(drawOptions[2] === 0) {
						optionsDraw.push("(cannot draw this)");
					} else {
						optionsDraw.push("Draw 1 Tactics.");
					}
					if(drawOptions[3] === 0) {
						optionsDraw.push("(cannot draw this)");
					} else {
						optionsDraw.push("Draw 1 Piloting.");
					}
					if(drawOptions[4] === 0) {
						optionsDraw.push("(cannot draw this)");
					} else {
						optionsDraw.push("Draw 1 Engineering.");
					}
					if(z.pegasus || z.daybreak) {
						if(drawOptions[5] === 0) {
							optionsDraw.push("(cannot draw this)");
						} else {
							optionsDraw.push("Draw 1 Treachery.");
						}
					}
					let promptText = "What skill card would you like? (1-" + optionsDraw.length + ")\r\n";
					for(let i = 0; !(i >= optionsDraw.length); i++) {
						promptText += (i + 1) + ": " + optionsDraw[i ] + "\n";
					}
					promptNum(promptText, (a) => 1 > a || a > optionsDraw.length || drawOptions[a - 1] === 0, mainMenu, (prompted2) => {
						draw[prompted2 - 1]++;
						drawTotal++;
						addAlert("You chose to draw a " + colorIDName(prompted2 - 1));
						if(drawTotal === 5 || (drawTotal === 2 && myPlayer === "Anders" && z.round === z.andersBenchRound && !solo && z
								.vBrutality && !initial) || (drawTotal === 4 && (myPlayer === "Karl" || myPlayer === "Doral")) || (z
								.vBrutality && myPlayer === "D'Anna" && ((drawTotal === 1 && z.revealedCylons[me] === 1) || drawTotal === 2)
								) || ((z.revealedCylons[me] === 1 || initial || me === z.theSympatheticCylon || (isCylonLeader(myPlayer) &&
								myPlayer !== "Doral")) && drawTotal === 3) || (z.revealedCylons[me] === 1 && drawTotal === 2 && !z
								.noSympathizer) || (initial && myPlayer === "Billy" && ((z.president === me && z.quorumHand.length === 2) ||
								(z.president !== me && z.billyHand.length === 1)))) {
							confirmDraw();
							return;
						} else if((z.revealedCylons[me] === 1 || me === z.theSympatheticCylon) && !isCylonLeader(myPlayer) && (z.pegasus ||
								z.exodus || z.daybreak)) {
							drawOptions[prompted2 - 1] = 0;
						} else if(myPlayer === "D'Anna") {
							if(z.revealedCylons[me] === 1) {
								if(draw[0] + draw[1] === 1) {
									drawOptions[0] = 0;
									drawOptions[1] = 0;
								}
								if(draw[4] + draw[5] === 1) {
									drawOptions[4] = 0;
									drawOptions[5] = 0;
								}
							} else {
								if(draw[0] + draw[1] === 2) {
									drawOptions[0] = 0;
									drawOptions[1] = 0;
								}
								if(draw[4] + draw[5] === 2) {
									drawOptions[4] = 0;
									drawOptions[5] = 0;
								}
							}
						} else if(myPlayer === "Doral") {
							if(draw[5] === 3) {
								drawOptions[5] = 0;
							}
						} else if(isCylonLeader(myPlayer) && d.skillDraws[prompted2 - 1][myCharacter] === 1 && draw[prompted2 - 1] === 2) {
							drawOptions[prompted2 - 1] = 0;
						} else if(initial || myPlayer === "Karl" || (myPlayer === "Anders" && z.vBrutality && z.round === z
								.andersBenchRound && !solo)) {
							if(myPlayer === "Anders") {
								if(draw[3] === 1) {
									drawOptions[3] = 0;
								}
								if(draw[1] === 2) {
									drawOptions[1] = 0;
								}
							} else if(myPlayer === "Racetrack") {
								if(draw[3] === 2) {
									drawOptions[3] = 0;
								}
							} else if (myPlayer === "Seelix") {
								if(draw[0] === 1){
									drawOptions[0] = 0;
								}
								if (draw[2] === 1){
									drawOptions[2] = 0;
								} 
								if (draw[4] === 2){
									drawOptions[4] = 0;
								}
								
							} else if(myPlayer !== "Cain") {
								if(draw[prompted2 - 1] === d.skillDraws[prompted2 - 1][myCharacter]) {
									drawOptions[prompted2 - 1] = 0;
								}
								if(((myPlayer === "Lee" && !z.vBrutality) || myPlayer === "Apollo" || myPlayer === "Gaeta") && draw[0] +
									draw[1] === 2) {
									drawOptions[0] = 0;
									drawOptions[1] = 0;
								} else if(myPlayer === "Starbuck" && draw[1] + draw[4] === 1) {
									drawOptions[1] = 0;
									drawOptions[4] = 0;
								} else if(myPlayer === "Lee" && draw[0] + draw[3] === 2) {
									drawOptions[0] = 0;
									drawOptions[3] = 0;
								} else if(myPlayer === "Shaw" && versionAtLeast([2,1,13]) && draw[0] + draw[4] === 1){
									drawOptions[0] = 0;
									drawOptions[4] = 0;
								}
							}
						}
						drawACard();
					});
				};
				drawACard();
			} else {
				confirmDraw();
			}
		} else if(ch === "Stamp Authority (OPG)") {
			confirmify(
				"Confirming you want to use your OPG, Stamp Authority, to take all Mutiny Cards from other players, play one, and discard the rest.",
				mainMenu, () => {
					if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					boldAlert("Cain uses her OPG, Stamp Authority, and takes all Mutinies from the other players.");
					t.value += "She must now pick one to play and discard the rest.\r\n";
					let anyPlayable = false;
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(j !== me) {
							shuffle(z.mutinies[j]);
							while(z.mutinies[j].length > 0) {
								let mut = z.mutinies[j].pop();
								addAlert("You take " + d.mutinyNames[mut] + " from " + z.players[j] + ".");
								z.mutinies[me].push(mut);
								anyPlayable = anyPlayable || mutinyPlayable(mut);
							}
						}
					}
					shuffle(z.mutinies[me]);
					if(!anyPlayable) {
						boldAlert("All mutinies Cain drew from Stamp Authority were unplayable, and are discarded.");
						while(z.mutinies[me].length > 0) {
							let mut = z.mutinies[me].pop();
							t.value += d.mutinyNames[mut] + " discarded.\r\n";
							z.mutinyDiscards.push(mut);
						}
					} else {
						addAlert("You must now play one of the Mutinies you drew.");
						addOption(me, "[Stamp Authority] Play a Mutiny", undefined, true);
					}
					didAction();
					mainMenu();
				});
		} else if(ch === "Abuse Power (OPG)") {
			confirmify("Confirming you want to use your OPG, Abuse Power, to draw 4 Mutinies then resolve 1 of them?", mainMenu, () => {
				t.value += bold("Tom uses his OPG, Abuse Power, to draw 4 Mutiny cards.") + "\r\n" +
					"He will now play one of them and then place the other 3 on the bottom of the deck.\r\n";
				let alertText = "You draw:\n";
				z.abusePower = [];
				for(let j = 0; !(j >= 4); j++) {
					let mut = z.mutinyDeck.pop();
					if(z.mutinyDeck.length === 0) {
						t.value += "Mutiny deck empty; reshuffling.\r\n";
						z.mutinyDeck = shuffle(z.mutinyDiscards);
						z.mutinyDiscards = [];
						z.buriedMutinies = 0;
					}
					z.abusePower.push(mut);
					alertText += d.mutinyNames[mut] + "\n";
				}
				addAlert(alertText + "Now, you will choose one of these to play, then place the other 3 on the bottom of the Mutiny deck.");
				if(z.assist === "Tom") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
					if(!mutinyPlayable(z.abusePower[0]) && !mutinyPlayable(z.abusePower[1]) && !mutinyPlayable(z.abusePower[2]) && !
						mutinyPlayable(z.abusePower[3])) {
						addOption(me, "Reveal that all your Abuse Power (OPG) Mutinies are unplayable, then bottom them.", undefined, true);
					} else {
						addOption(me, "Play a Mutiny from Abuse Power (OPG)", undefined, true);
					}
				} else {
					z.miracles[me] = 0;
				}
				didAction();
				mainMenu();
			});
		} else if(ch === "Resolve Necessary Steps") {
			let tar = z.necessarySteps[0];
			if(z.vBrutality) {
				let promptText = "What would you like to do with " + d.mutinyNames[z.necessarySteps[1]] + "? (1-2)\n1: Give it to " + z.players[tar] +
					"\n2: Place it on the bottom of the deck";
				promptNum(promptText, (a) => 1 > a || a > 2, mainMenu, (prompted) => {
					if(prompted === 1) {
						t.value += bold("Tom gives the Mutiny to " + z.players[tar] + ".") + "\r\n";
						addAlert("You give " + d.mutinyNames[z.necessarySteps[1]] + " to " + z.players[tar] + ".");
						z.mutinies[tar].push(z.necessarySteps[1]);
					} else {
						boldAlert("Tom bottoms the Mutiny from Necessary Steps, and " + z.players[tar] +
							" draws a Mutiny card from the top of the deck.");
						z.mutinyDeck.unshift(z.necessarySteps[1]);
						z.buriedMutinies++;
						z.mutinies[tar].push(z.mutinyDeck.pop());
					}
					z.necessarySteps.shift();
					z.necessarySteps.shift();
					if(z.mutinies[tar].length === 3 || (z.mutinies[tar].length === 2 && (tar !== z.theMutineer || z.pressRoomMutineer))) {
						boldAlert(z.players[tar] + " must now discard a Mutiny.");
						if(z.pressRoomMutineer){
							addOption(tar,"Discard a Mutiny card","Press Room Mutineer",true);
							delete z.pressRoomMutineer;
						}
					}
					if(z.necessarySteps.length > 0) {
						let tar = z.necessarySteps.shift();
						z.necessarySteps.unshift(z.mutinyDeck.pop());
						z.necessarySteps.unshift(tar);
						if(z.mutinyDeck.length === 0) {
							z.mutinyDeck = z.mutinyDiscards;
							shuffle(z.mutinyDeck);
							z.mutinyDiscards = [];
							plainAlert("Mutiny Deck reshuffles.");
							z.buriedMutinies = 0;
						}
						boldAlert("Next, Tom must resolve Necessary Steps for " + z.players[tar] + ".");
					}
					mainMenu();
				});
			} else {
				let promptText = "Which Mutiny would you like to give to " + z.players[tar] +
					", Tom? (1-2)\nThe other will be placed on the bottom of the Mutiny deck.\n\n1: " + d.mutinyNames[z.necessarySteps[1]] + "\n2: " + d
					.mutinyNames[z.necessarySteps[2]];
				promptNum(promptText, (a) => 1 > a || a > 2, mainMenu, (prompted) => {
					let other = 1;
					if(prompted === 1) {
						other = 2;
					}
					let mut1 = z.necessarySteps[prompted];
					let mut2 = z.necessarySteps[other];
					addAlert("Gave " + z.players[tar] + " " + d.mutinyNames[mut1] + " and buried " + d.mutinyNames[mut2] + ".");
					t.value += "Tom finishes his Necessary Steps.\r\n";
					z.mutinies[tar].push(mut1);
					z.mutinyDeck.unshift(mut2);
					z.necessarySteps.shift();
					z.necessarySteps.shift();
					z.necessarySteps.shift();
					if(z.mutinies[tar].length === 3 || (z.mutinies[tar].length === 2 && (tar !== z.theMutineer || z.pressRoomMutineer))) {
						boldAlert(z.players[tar] + " must now discard a Mutiny.");
						if(z.pressRoomMutineer){
							addOption(tar,"Discard a Mutiny card","Press Room Mutineer",true);
							delete z.pressRoomMutineer;
						}
					}
					z.buriedMutinies++;
					if(z.necessarySteps.length > 0) {
						let tar = z.necessarySteps.shift();
						let mut1 = z.mutinyDeck.pop();
						if(z.mutinyDeck.length === 0) {
							z.mutinyDeck = z.mutinyDiscards;
							shuffle(z.mutinyDeck);
							z.mutinyDiscards = [];
							plainAlert("Mutiny Deck reshuffles.");
							z.buriedMutinies = 0;
						}
						let mut2 = z.mutinyDeck.pop();
						if(z.mutinyDeck.length === 0) {
							z.mutinyDeck = z.mutinyDiscards;
							shuffle(z.mutinyDeck);
							z.mutinyDiscards = [];
							plainAlert("Mutiny Deck reshuffles.");
							z.buriedMutinies = 0;
						}
						z.necessarySteps.unshift(mut2);
						z.necessarySteps.unshift(mut1);
						z.necessarySteps.unshift(tar);
						boldAlert("Next, Tom must resolve Necessary Steps for " + z.players[tar] + ".");
					}
					mainMenu();
				});
			}
		} else if(ch === "Discard my Mutiny card") {
			confirmify("Confirming you want to discard your Mutiny card, " + d.mutinyNames[z.mutinies[me][0]] + ".", mainMenu, () => {
				let mut = z.mutinies[me].pop();
				addAlert("You discard " + d.mutinyNames[mut] + ".");
				z.mutinyDiscards.push(mut);
				t.value += bold(myPlayer + " discards " + d.mutinyNames[mut]) + ".\r\n";
				removeOption(me, ch);
				removeOption(me,"Do not discard a Mutiny card");
				mainMenu();
			});
		} else if(ch === "Discard a Mutiny card") {
			let promptText = "Which Mutiny would you like to discard? (1-" + z.mutinies[me].length + ")";
			for(let j = 0; !(j >= z.mutinies[me].length); j++) {
				promptText += "\n" + (j + 1) + ": " + d.mutinyNames[z.mutinies[me][j]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.mutinies[me].length, mainMenu, (prompted) => {
				let mut = z.mutinies[me].splice(prompted - 1, 1)[0];
				addAlert("You discard " + d.mutinyNames[mut] + ".");
				z.mutinyDiscards.push(mut);
				t.value += bold(myPlayer + " discards " + d.mutinyNames[mut]) + ".\r\n";
				if(!(hasContext(me, ch, "Press Room Mutineer") && z.mutinies[me].length === 2)) {
					removeOption(me, ch);
				}
				removeOption(me,"Do not discard a Mutiny card");
				mainMenu();
			});
		} else if (ch === "Do not discard a Mutiny card"){
			confirmify("Confirming you do not want to discard any Mutiny cards from Press Room.",mainMenu,()=>{
				plainAlert(z.players[me]+" chooses not to discard any Mutiny cards from Press Room.");
				removeOption(me,ch);
				removeOption(me,"Discard a Mutiny card");
				removeOption(me,"Discard my Mutiny card");
				mainMenu();
			});
		} else if(ch === "Play a Mutiny from Abuse Power (OPG)") {
			let promptText = "Which Mutiny would you like to play from your OPG, Abuse Power? (1-4)\n";
			for(let j = 0; !(j >= 4); j++) {
				promptText += (j + 1) + ": " + d.mutinyNames[z.abusePower[j]];
				if(!mutinyPlayable(z.abusePower[j])) {
					promptText += " (unplayable)";
				}
				promptText += "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > 4 || !mutinyPlayable(z.abusePower[a - 1]), mainMenu, (prompted) => {
				let mut = z.abusePower[prompted - 1];
				z.mutinyDiscards.push(mut);
				z.abusePower.splice(prompted - 1, 1);
				playMutiny(mut);
				if(z.players[me] === "Gaius" && z.assist !== "Tom") {
					addOption(me, "Bottom the remaining Mutinies from Abuse Power (OPG)", undefined, true);
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "[Stamp Authority] Play a Mutiny") {
			let promptText = "Which Mutiny would you like to play from your OPG, Stamp Authority? (1-" + z.mutinies[me].length + ")\n";
			for(let j = 0; !(j >= z.mutinies[me].length); j++) {
				promptText += (j + 1) + ": " + d.mutinyNames[z.mutinies[me][j]];
				if(!mutinyPlayable(z.mutinies[me][j])) {
					promptText += " (unplayable)";
				}
				promptText += "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > z.mutinies[me].length || !mutinyPlayable(z.mutinies[me][a - 1]), mainMenu, (prompted) => {
				let mut = z.mutinies[me][prompted - 1];
				z.mutinyDiscards.push(mut);
				z.mutinies[me].splice(prompted - 1, 1);
				playMutiny(mut);
				removeOption(me, ch);
				if(z.mutinies[me].length > 0) {
					addAlert("You discard the remaining mutinies.");
					t.value += z.players[me] + " discards the remaining Mutinies:\r\n";
					while(z.mutinies[me].length > 0) {
						let mut = z.mutinies[me].pop();
						t.value += d.mutinyNames[mut] + " discarded.\r\n";
					}
				}
				mainMenu();
			});
		} else if(ch === "Bottom the remaining Mutinies from Abuse Power (OPG)" || ch ===
			"Reveal that all your Abuse Power (OPG) Mutinies are unplayable, then bottom them.") {
			let abusePower = function() {
				if(z.abusePower.length === 1) {
					let mut = z.abusePower.pop();
					addAlert("Buried " + d.mutinyNames[mut]);
					z.mutinyDeck.unshift(mut);
					removeOption(me, ch);
					mainMenu();
					return;
				}
				if(z.abusePower.length === 4) {
					/* RULES: what happens if all Tom's mutinies are unplayable? */
					t.value += "Tom cannot play any of the Mutinies he drew with Abuse Power:\r\n";
					for(let j = 0; !(j >= 4); j++) {
						t.value += d.mutinyNames[z.abusePower[j]] + "\r\n";
					}
					t.value += "He will now bury all of them.\r\n";
				}
				let promptText = "Which Mutiny would you like to bury ";
				switch (z.abusePower.length) {
					case 4:
					case 3:
						promptText += "first";
						break;
					case 2:
						promptText += "second";
						break;
				}
				promptText += "? (1-" + z.abusePower.length + ")";
				for(let j = 0; !(j >= z.abusePower.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.mutinyNames[z.abusePower[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.abusePower.length, mainMenu, (prompted) => {
					let mut = z.abusePower.splice(prompted - 1, 1)[0];
					addAlert("Buried " + d.mutinyNames[mut]);
					z.mutinyDeck.unshift(mut);
					z.buriedMutinies++;
					abusePower();
				});
			};
			abusePower();
		} else if(ch.slice(0, 14) === "Play my Mutiny") {
			let mut = z.mutinies[me][0];
			confirmify("Confirming that you want to play your Mutiny, " + d.mutinyNames[mut] + ".", mainMenu, () => {
				z.mutinyDiscards.push(mut);
				z.mutinies[me] = [];
				didAction();
				playMutiny(mut);
				mainMenu();
			});
		} else if(ch === "Play a Mutiny card") {
			let promptText = "Which Mutiny card would you like to play? (1-" + z.mutinies[me].length + ")";
			for(let j = 0; !(j >= z.mutinies[me].length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(mutinyPlayable(z.mutinies[me][j])) {
					promptText += d.mutinyNames[z.mutinies[me][j]];
				} else {
					promptText += "(unplayable)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.mutinies[me].length, mainMenu, (prompted) => {
				let mut = z.mutinies[me][prompted - 1];
				confirmify("Confirming that you want to play your Mutiny, " + d.mutinyNames[mut] + ".", mainMenu, () => {
					z.mutinyDiscards.push(mut);
					z.mutinies[me].splice(prompted - 1, 1);
					didAction();
					playMutiny(mut);
					mainMenu();
				});
			});
		} else if(ch === "Deal a Mutiny card") {
			if(hasContext(me, ch, "Dangerous Plots")) {
				confirmify("Confirming you want to deal a Mutiny to the President.", mainMenu, () => {
					dealMutiny(z.president, false);
					removeOption(me, ch);
					mainMenu();
				});
			} else if(hasContext(me, ch, "A Desperate Pact")) {
				confirmify("Confirming you want to deal a Mutiny to the current player.", mainMenu, () => {
					dealMutiny(z.turn, false);
					removeOption(me, ch);
					mainMenu();
				});
			} else if(hasContext(me, ch, "Insubordinate Crew")) {
				let target = -1;
				let foundTwo = false;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					let k = (j + z.turn) % z.numPlayers;
					if(z.mutinies[k].length === 0 && z.revealedCylons[j] === 0) {
						if(target === -1) {
							target = k;
						} else {
							foundTwo = true;
							break;
						}
					}
				}
				confirmify("Confirming you want to deal a Mutiny to " + z.players[target] + ".", mainMenu, () => {
					dealMutiny(target, false);
					if(!foundTwo) {
						removeOption(me, ch);
					}
					mainMenu();
				});
			} else {
				let promptText = "Who is getting a Mutiny? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.revealedCylons[j] === 1) {
						promptText += "\n" + (j + 1) + ": CYLON";
					} else if(z.vBrutality && hasContext(me, ch, "Make a Deal") && z.mutinies[j].length > 0) {
						promptText += "\n" + (j + 1) + ": (already has one)";
					} else {
						promptText += "\n" + (j + 1) + ": " + z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || (z.vBrutality && hasContext(me, ch,
					"Make a Deal") && z.mutinies[a - 1].length > 0), mainMenu, (prompted) => {
					dealMutiny(prompted - 1, false);
					removeOption(me, ch);
					mainMenu();
				});
			}
		} else if(ch === "Draw a Mutiny card") {
			/* TODO: context (esp. Brutality Selfish Act) */
			confirmify("Confirming you want to draw a Mutiny card.", mainMenu, () => {
				dealMutiny(me, false);
				if(hasContext(me, ch, "Selfish Act") && z.players[me] === "Apollo" && !solo && z.vBrutality) {
					z.randomLove[me] = false;
					removeOption(me, "Discard a random Skill Card");
				}
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Discard Accept Prophecy to protect your President Title from Administration") {
			confirmify("Confirming you want to discard your Accept Prophecy card to stop the Presidency from being passed by Administration.", mainMenu,
				() => {
					z.quorumDiscards.push(z.quorumTitles[z.president].splice(prophetInPlay(), 1)[0]);
					addAlert("Accept Prophecy discarded.");
					t.value += bold(colorText("orange", "President ") + z.players[z.president] +
						" discards Accept Prophecy to keep the Presidency.") + "\r\n";
					removeOption(me, ch);
					removeFromAll("Move the President title");
					mainMenu();
				});
		} else if(ch === "Secret Destiny (OPG)") {
			confirmify("Confirming you want to cancel this crisis with your OPG ability, Secret Destiny, and draw a new crisis.", mainMenu, () => {
				z.crisisDiscards.push(z.currentCrisis);
				z.currentCrisis = null;
				z.toDoBasestars = false;
				z.toDoHeavies = false;
				z.toDoRaiders = false;
				z.toDoLaunchRaiders = false;
				z.toDoOFs = false;
				z.toDoJumpIcon = false;
				if(z.assist === "Starbuck") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				t.value += bold("Starbuck uses Secret Destiny to discard this crisis and draw a new one.") + "\r\n";
				if(z.engineRoom) {
					plainAlert("Note that the Engine Room does not benefit this crisis or the next.");
					z.engineRoom = false;
				}
				if(z.vBrutality && versionAtLeast([1, 2, 4, 2])) {
					addOption(me, "[Secret Destiny] Pick a new Crisis", undefined, true);
				} else {
					playCrisis(me);
					addAlert("New crisis is: " + d.crisisNames[z.currentCrisis] + ".");
					if((z.turn === me && d.currentPlayerChooses[z.currentCrisis] === 1) || (z.admiral === me && d.admiralChooses[z
							.currentCrisis] === 1) || (z.president === me && d.presidentChooses[z.currentCrisis] === 1) || (z.cag === me && d
							.cagChooses[z.currentCrisis] === 1)) {
						addAlert("It's your choice on this crisis.");
					}
				}
				mainMenu();
			});
		} else if(ch === "Draw a Galactica damage token to hand" || ch === "Deal a Galactica damage token to the Cylon") {
			confirmify("Confirming you want to deal a Galactica damage token to " + z.players[z.damagePlayer], mainMenu, () => {
				z.damageHand.push(z.damage.pop());
				if(z.damagePlayer === me) {
					addAlert("You drew " + z.damageHand[z.damageHand.length - 1] + ".\nYou now have " + z.damageHand.length +
						" damage tokens in hand.");
					t.value += "Galactica token drawn.\r\n";
				} else {
					addAlert("Galactica damage token dealt to " + z.players[z.damagePlayer] + ".\nYou now have " + z.damageHand.length +
						" damage tokens in hand.");
					t.value += "Galactica token dealt.\r\n";
				}
				mainMenu();
			});
		} else if(ch === "Draw a Pegasus damage token to hand" || ch === "Deal a Pegasus damage token to the Cylon") {
			confirmify("Confirming you want to deal a Pegasus damage token to " + z.players[z.damagePlayer], mainMenu, () => {
				z.damageHand.push(z.pegasusDamage.pop());
				if(z.damagePlayer === me) {
					addAlert("You drew " + z.damageHand[z.damageHand.length - 1] + ".\nYou now have " + z.damageHand.length +
						" damage tokens in hand.");
					t.value += "Pegasus token drawn.\r\n";
				} else {
					addAlert("Pegasus damage token dealt to " + z.players[z.damagePlayer] + ".\nYou now have " + z.damageHand.length +
						" damage tokens in hand.");
					t.value += "Pegasus token dealt.\r\n";
				}
				mainMenu();
			});
		} else if(ch === "Discard the damage tokens in your hand") {
			/* TODO: there's got to be a better way of doing this */
			let confirmText = "Confirming you want to discard the damage tokens in your hand.\n";
			if(myLocation === "Basestar Bridge" || myPlayer === "Athena") {
				confirmText += "You should have already damaged one location.";
			} else if(myLocation === "Resurrection Ship" || myLocation === "Hub Destroyed" || myLocation === "Medical Center") {
				confirmText += "You should have already damaged two locations.";
			}
			confirmify(confirmText, mainMenu, () => {
				while(z.damageHand.length > 0) {
					let dam = z.damageHand.shift();
					if(onPegasus(dam) && !z.vAltDamage) {
						z.pegasusDamage.push(dam);
						shuffle(z.pegasusDamage);
					} else {
						z.damage.push(dam);
					}
				}
				shuffle(z.damage);
				addAlert("Shuffled remaining damage tokens back into the pile.");
				t.value += myPlayer + " returned the remaining damage tokens to the pile.\r\n";
				z.damagePlayer = -1;
				mainMenu();
			});
		} else if(ch === "Process a damage token in your hand") {
			let promptText = "Which location would you like to damage? (1-" + z.damageHand.length + ")\n";
			for(let i = 0; !(i >= z.damageHand.length); i++) {
				promptText += (i + 1) + ": " + z.damageHand[i ] + "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > z.damageHand.length, mainMenu, (prompted) => {
				let loc = z.damageHand[prompted - 1];
				z.damagedLocations.push(loc);
				z.damageHand.splice(prompted - 1, 1);
				boldAlert(loc + " damaged.");
				if(loc === "Fuel") {
					decreaseFuel();
				} else if(loc === "Food") {
					decreaseFood();
				} else if(onPegasus(loc) && isPegasusDestroyed()) {
					destroyPegasus();
				} else {
					for(let i = 0; !(i >= z.numPlayers); i++) {
						if(z.playerLocations[i ] === loc) {
							movePlayer(i, "Sickbay");
							addAlert(z.players[i ] + " is sent to Sickbay.");
						}
					}
				}
				if(isGalacticaDestroyed()) {
					addAlert("Galactica destroyed; Cylons win!");
					t.value += bold("Galactica is destroyed.") + "\r\n\r\n";
					endGame(false);
					mainMenu();
					return;
				}
				let killedAllies = 0;
				for(let j = 0; z.preCrossroads && !(j >= z.allies.length); j++) {
					if(d.allyLocations[z.allies[j][0]] === loc) {
						killedAllies++;
						plainAlert("The " + d.allyNames[z.allies[j][0]] + " Ally is hit, and is removed from the game.");
						let trauma = z.allies[j][1];
						if(trauma !== null){
							z.traumaPile.push(trauma);
						}
						shuffle(z.traumaPile);
						z.allies.splice(j, 1);
						j--;
					}
				}
				for(let j = killedAllies; j > 0; j--) {
					let newAlly = allyPop();
					if(newAlly === -1) {
						plainAlert("Ally deck exhausted; it does not reshuffle.");
					} else {
						z.cylonAllyQueue.push(newAlly);
					}
				}
				if(z.preCrossroads && z.cylonAllyQueue.length > 0) {
					resolveCylonAllyQueue();
				}
				if(z.playerLocations[me] === "Basestar Bridge" || z.players[me] === "Athena") {
					if(z.damageHand.length > 0) {
						while(z.damageHand.length > 0) {
							let dam = z.damageHand.shift();
							if(onPegasus(dam) && !z.vAltDamage) {
								z.pegasusDamage.push(dam);
								shuffle(z.pegasusDamage);
							} else {
								z.damage.push(dam);
							}
						}
						shuffle(z.damage);
						addAlert("Shuffled remaining damage tokens back into the pile.");
						t.value += myPlayer + " returned the remaining damage tokens to the pile.\r\n";
					}
					z.damagePlayer = -1;
				} else {
					let damageLeft = z.damage.length;
					if(z.pegasus && !z.vAltDamage && !z.pegasusDestroyed) {
						damageLeft += z.pegasusDamage.length;
					}
					if(damageLeft > 0 && z.damageHand.length === 3) {
						while(z.damageHand.length > 0) {
							let dam = z.damageHand.shift();
							if(onPegasus(dam) && !z.vAltDamage) {
								z.pegasusDamage.push(dam);
								shuffle(z.pegasusDamage);
							} else {
								z.damage.push(dam);
							}
						}
						z.damagePlayer = -1;
						shuffle(z.damage);
						addAlert("Shuffled remaining damage tokens back into the pile.");
						t.value += myPlayer + " returned the remaining damage tokens to the pile.\r\n";
					}
					if(damageLeft === 0) {
						addAlert("Remember to discard the damage tokens in your hand once you're done.");
					}
				}
				mainMenu();
			});
		} else if(ch === "Draw a Super Crisis") {
			let confirmText = "Confirming you want to draw a Super Crisis.";
			confirmify(confirmText, mainMenu, () => {
				drawSuperCrisis();
				if(z.v20Super){
					drawSuperCrisis();
					delete z.v20Super;
				}
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Modifications (OPG)") {
			if(z.negotiation) {
				addAlert(
					"Negotiation is in effect, so your OPG will have no effect.  If you still really want to use your OPG, announce that you are doing so in thread, then " +
					"mark your OPG as having been used.");
				mainMenu();
			} else {
				let promptText =
					"Make sure that it is a player's Activate Cylon Ships step when using this ability.\n\nWhich ship type would you like to activate with your OPG, Modifications? (1-4)\n1: Activate Raiders\n2: Activate Heavy Raiders\n3: Activate Basestars\n4: Launch Raiders.";
				promptNum(promptText, (a) => 1 > a || a > 4, mainMenu, (prompted) => {
					if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					let any = z.toDoRaiders || z.toDoHeavies || z.toDoBasestars || z.toDoLaunchRaiders;
					z.toDoRaiders = false;
					z.toDoHeavies = false;
					z.toDoBasestars = false;
					z.toDoLaunchRaiders = false;
					t.value += bold("Simon uses his OPG, Modifications.") + "\r\n";
					switch (prompted) {
						case 1:
							activateRaiders();
							break;
						case 2:
							activateHeavies();
							break;
						case 3:
							activateBasestars();
							break;
						case 4:
							launchRaiders();
							break;
					}
					if(hasContext(me, ch, "Fulfiller of Prophecy")) {
						removeOption(me, ch);
						removeFromAll("Activate Basestars");
					}
					if(any && !z.toDoOFs) {
						primeJumpIcon();
					}
					mainMenu();
				});
			}
		} else if(ch === "Exfiltrate and use Meticulous (OPG)" || ch === "Deinfiltrate and use Meticulous (OPG)") {
			confirmify("Confirming you want to exfiltrate and use your OPG, Meticulous.", mainMenu, () => {
				t.value += bold(myPlayer + " exfiltrates.") + "\r\n";
				while(z.quorumTitles[me].length > 0) {
					/* RULES: I assume you lose Probation */
					let title = z.quorumTitles[me].pop();
					z.quorumDiscards.push(title);
					t.value += myPlayer + " discards " + d.quorumNames[title] + "\r\n";
				}
				if(z.daybreak) {
					while(z.mutinies[me].length > 0) {
						let mut = z.mutinies[me].pop();
						z.mutinyDiscards.push(mut);
						t.value += myPlayer + " discards " + d.mutinyNames[mut] + "\r\n";
					}
				}
				if(z.galacticaAway) {
					movePlayer(me, "Medical Center");
				} else if(z.hubDestroyed) {
					movePlayer(me, "Hub Destroyed");
				} else {
					movePlayer(me, "Resurrection Ship");
				}
				if(z.skillCardHands[me].length > 3 && (myLocation === "Brig" || myLocation === "Detention")) {
					promptAllyDiscards(me, z.skillCardHands[me].length - 3, true);
					addAlert("You must now discard down to 3 skill cards.");
				}
				z.revealedCylons[me] = 1;
				z.miracles[me] = 0;
				t.value += bold("Doral uses his OPG, Meticulous.") + "\r\n";
				if(z.galacticaReturned) {
					/* RULES: can he activate NC locations after Galactica returns? */
					addAlert(
						"Now, you must exfiltrate, then move to the non-hazardous Cylon location of your choice, then perform an action.\n\nYou do not need to discard for moving between New Caprica and other Cylon Locations."
						);
				} else if(z.rebelBasestar === -1) {
					addAlert(
						"Now, you must exfiltrate, then move to the non-hazardous Cylon location of your choice, then perform an action.\n\nYou do not need to discard for moving between the Rebel Basestar and other Cylon Locations."
						);
				} else {
					addAlert(
						"Now, you must exfiltrate, then move to the non-hazardous Cylon location of your choice, then perform an action.");
				} /* RULES: if Doral uses Meticulous to reinfiltrate off an XO, does he get a second action? */
				addOption(me, "Move", "Meticulous", true);
				mainMenu();
			});
		} else if(ch === "Exfiltrate" || ch === "Deinfiltrate") {
			confirmify("Confirming you want to exfiltrate.", mainMenu, () => {
				t.value += bold(myPlayer + " exfiltrates.") + "\r\n";
				while(z.quorumTitles[me].length > 0) {
					/* RULES: I assume you lose Probation */
					let title = z.quorumTitles[me].pop();
					z.quorumDiscards.push(title);
					t.value += myPlayer + " discards " + d.quorumNames[title] + "\r\n";
				}
				if(z.daybreak) {
					while(z.mutinies[me].length > 0) {
						let mut = z.mutinies[me].pop();
						z.mutinyDiscards.push(mut);
						t.value += myPlayer + " discards " + d.mutinyNames[mut] + "\r\n";
					}
				}
				if(z.galacticaAway) {
					movePlayer(me, "Medical Center");
				} else if(z.hubDestroyed) {
					movePlayer(me, "Hub Destroyed");
				} else {
					movePlayer(me, "Resurrection Ship");
				}
				if(z.skillCardHands[me].length > 3 && (myLocation === "Brig" || myLocation === "Detention") && !hasOption(me, ch)) {
					promptAllyDiscards(me, z.skillCardHands[me].length - 3);
				}
				if(z.turn === me) {
					z.executedCurrentPlayer = true;
					addAlert("You should, most likely, end the turn now.");
				}
				z.revealedCylons[me] = 1;
				removeOption(me,ch);
				didAction();
				mainMenu();
			});
		} else if(ch === "Reveal as a Cylon") {
			let revealingCard = -1;
			let reveal = function() {
				confirmify("Confirming you want to reveal " + d.loyaltyNames[z.loyaltyHands[me][revealingCard]] +
					".\nThis typically requires an action.", mainMenu, () => {
						addAlert("You reveal " + d.loyaltyNames[z.loyaltyHands[me][revealingCard]]);
						t.value += bold(myPlayer + " reveals " + d.loyaltyNames[z.loyaltyHands[me][revealingCard]]) + "\r\n";
						z.revealedCylons[me] = 1;
						if(z.players[me] === "Starbuck"){
							z.expertPilot = false;
						}
						didAction();
						if(z.momentOfHeroism >= 0 && z.players[me] === "Billy" && versionAtLeast([2,1,13])){
							boldAlert("Billy's Moment of Heroism ends.");
							if(characterPresent("Dee") && 2 >= z.morale && z.momentOfHeroism === getPlayerNum("Dee")) {
								optionForAll("Execute a player","Dee",true);
								boldAlert("Once Billy's reveal is resolved, execute Dee.");
							}
							z.momentOfHeroism = -1;
							z.momentOfHeroismExtra = false;
						}
						if(Array.isArray(z.personalGoalsBrutality)){
							z.personalGoalsBrutality[me] = null;
						}
						let done = true;
						let loyalty = z.loyaltyHands[me][revealingCard];
						z.loyaltyDiscards[me].push(z.loyaltyHands[me].splice(revealingCard, 1)[0]);
						if(characterPresent("Cavil") && !noDrawback(getPlayerNum("Cavil"))) {
							if(z.vBrutality) {
								boldAlert("Cavil must discard five skill cards due to his Lies and Secrets drawback.");
								promptAllyDiscards(getPlayerNum("Cavil"), 5);
							} else {
								boldAlert("Cavil discards his skill card hand due to his Lies and Secrets drawback.");
								discardEntireHand(getPlayerNum("Cavil"));
							}
						}
						if(z.vBrutality && characterPresent("D'Anna")) {
							/* TODO: weird interactions with ordering (e.g. Dee's execution) */
							boldAlert(
								"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card."
								);
							addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", 1], true);
						}
						if(characterPresent("Racetrack") && !noDrawback(getPlayerNum("Racetrack")) && !versionAtLeast([2, 1, 3]) && (me === z
								.admiral || me === z.president) && z.playerLocations[getPlayerNum("Racetrack")] !== "Brig" && z.playerLocations[
								getPlayerNum("Racetrack")] !== "Detention") {
							if(isOnNewCaprica(getPlayerNum("Racetrack"))) {
								boldAlert("Racetrack is moved to Detention due to her Driven to Mutiny drawback.");
								movePlayer(getPlayerNum("Racetrack"), "Detention");
							} else {
								boldAlert("Racetrack is moved to the Brig due to her Driven to Mutiny drawback.");
								movePlayer(getPlayerNum("Racetrack"), "Brig");
							}
						}
						let didPower = function(infil) {
							if(z.admiral === me) {
								passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
							}
							if(z.president === me) {
								passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
								if(z.skillCardHands[me].length > 3) {
									t.value += size(
										"Technically, the President title is not passed until after the revealing Cylon discards their cards.  As a result, " +
										colorText("orange", "President ") + z.players[z.president] +
										" should not look at their Quorum cards until the Cylon finishes discarding.\r\n", 8);
								}
							}
							if(z.CFB && z.cag === me) {
								passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
							}
							while(z.quorumTitles[me].length > 0) {
								/* RULES: I assume you lose Probation */
								let title = z.quorumTitles[me].pop();
								z.quorumDiscards.push(title);
								t.value += myPlayer + " discards " + d.quorumNames[title] + "\r\n";
							}
							if(z.players[me] === "Billy") {
								while(z.billyHand.length > 0) {
									let card = z.billyHand.pop();
									z.quorumDiscards.push(card);
									t.value += myPlayer + " discards " + d.quorumNames[card] + " from his hand.\r\n";
								}
							}
							if(z.daybreak) {
								while(z.mutinies[me].length > 0) {
									let mut = z.mutinies[me].pop();
									z.mutinyDiscards.push(mut);
									t.value += myPlayer + " discards " + d.mutinyNames[mut] + ".\r\n";
								}
							}
							z.miracles[me] = 0;
							if(z.galacticaAway) {
								movePlayer(me, "Medical Center");
							} else if(z.hubDestroyed) {
								movePlayer(me, "Hub Destroyed");
							} else {
								movePlayer(me, "Resurrection Ship");
							}
							if(z.skillCardHands[me].length > 3 && !infil) {
								if((z.pegasus || z.daybreak || z.vHandoff) && 7 > z.distance && z.loyaltyHands[me].length > 0) {
									if(done) {
										t.value += myPlayer +
											" must now discard down to 3 skill cards, then draw a Super Crisis, then pass off their remaining Loyalty.\r\n";
										addAlert(
											"You must now discard down to 3 skill cards, then draw a Super Crisis, then pass your remaining Loyalty cards to a Human of your choice."
											);
										if(z.forLove){
											plainAlert("Athena could use For Love here.");
											if(z.skillCardHands[me].length > 4){
												addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 4, true);
											}
											addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
										} else {
											addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 3, true);
										}
										
											
										
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									} else {
										t.value += "Once they are done with their reveal power, " + myPlayer +
											" must discard down to 3 skill cards, then draw a Super Crisis, then pass off their remaining Loyalty.\r\n";
										addAlert(
											"Once you're done with your reveal power, you must discard down to 3 skill cards, then draw a Super Crisis, then pass your remaining Loyalty cards to a player of your choice."
											);
											
										if(z.forLove){
											plainAlert("Athena could use For Love here.");
											if(z.skillCardHands[me].length > 4){
												addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 4, true);
											}
											addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
										} else {
											addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 3, true);
										}
										
										
										
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									}
								} else {
									if(done) {
										addAlert("You must now discard down to 3 skill cards, then draw a Super Crisis.");
										t.value += myPlayer + " must now discard down to 3 skill cards, then draw a Super Crisis.\r\n";
										
										if(z.forLove){
											plainAlert("Athena could use For Love here.");
											if(z.skillCardHands[me].length > 4){
												addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 4, true);
											}
											addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
										} else {
											addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 3, true);
										}
									
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									} else {
										addAlert(
											"Once you're done with your reveal power, you must discard down to 3 skill cards, then draw a Super Crisis."
											);
										t.value += "Once they are done with their reveal power, " + myPlayer +
											" must discard down to 3 skill cards, then draw a Super Crisis.\r\n";
										if(z.forLove){
											plainAlert("Athena could use For Love here.");
											if(z.skillCardHands[me].length > 4){
												addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 4, true);
											}
											addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
										} else {
											addOption(me, "Discard a Skill Card", z.skillCardHands[me].length - 3, true);
										}
										
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									}
								}
							} else {
								if((z.pegasus || z.daybreak || z.vHandoff) && 7 > z.distance && z.loyaltyHands[me].length > 0) {
									if(done) {
										drawSuperCrisis();
										if(z.v20Super){
											drawSuperCrisis();
											delete z.v20Super;
										}
										addAlert("Now, you must pass your remaining Loyalties off to a Human of your choice.");
										t.value += "Now, " + myPlayer +
											" must pass their remaining Loyalties off to a Human of their choice.\r\n";
									} else {
										addAlert(
											"Once you're done with your reveal power, you must draw a super crisis, then pass your remaining Loyalties off to a player of your choice."
											);
										t.value += "Once they are done with their reveal power, " + myPlayer +
											" must draw a super crisis, then pass their remaining Loyalties off to a Human of their choice.\r\n";
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									}
								} else {
									if(done) {
										drawSuperCrisis();
										if(z.v20Super){
											drawSuperCrisis();
											delete z.v20Super;
										}
									} else {
										addAlert("Once you're done with your reveal power, you must draw a super crisis.");
										t.value += "Once they are done with their reveal power, " + myPlayer +
											" must draw a super crisis.\r\n";
										addOption(me, "Draw a Super Crisis", "Reveal", true);
									}
								}
							}
							if(me === z.theMutineer) {
								addAlert("Remember to pass off the Mutineer title to a Human of your choice once you're done revealing.");
							}
							if(z.turn === me) {
								addAlert("After you've finished revealing, you should, most likely, end your turn.");
								z.executedCurrentPlayer = true;
							}
							mainMenu();
						};
						if(z.playerLocations[me] === "Brig") {
							addAlert("You do not get to use your reveal power as you were in the Brig");
							t.value += myPlayer + " was in the Brig, and did not get to use their reveal power.\r\n";
							didPower();
						} else if(z.playerLocations[me] === "Detention") {
							addAlert("You do not get to use your reveal power as you were in Detention");
							t.value += myPlayer + " was in Detention, and did not get to use their reveal power.\r\n";
							didPower();
						} else {
							switch (loyalty) {
								case 11: {
									let anyoneOnGalactica = false;
									for(let i = 0; !(i >= z.numPlayers); i++) {
										if(i !== me && isOnGalactica(i)) {
											anyoneOnGalactica = true;
											break;
										}
									}
									if(anyoneOnGalactica) {
										addAlert("You may now make a player on Galactica move to Sickbay and discard 5 skill cards.");
										t.value += myPlayer + " may now make a character " + bold("on Galactica") +
											" move to Sickbay and discard 5 skill cards.\r\n";
										addOption(me, "Move a player to Sickbay", "Reveal", false);
										done = false;
									} else {
										addAlert("There is nobody on Galactica to send to Sickbay.");
										t.value += "There is nobody on Galactica to target.\r\n";
									}
									didPower();
									break;
								}
								case 12: {
									let anyoneOnGalactica = false;
									for(let i = 0; !(i >= z.numPlayers); i++) {
										if(i !== me && isOnGalactica(i) && z.playerLocations[i ] !== "Brig") {
											anyoneOnGalactica = true;
											break;
										}
									}
									if(anyoneOnGalactica) {
										addAlert("You may now send a player on Galactica to the Brig.");
										t.value += myPlayer + " may now send a character " + bold("on Galactica") + " to the Brig.\r\n";
										addOption(me, "Move a player to the Brig", "Reveal", false);
										done = false;
									} else {
										addAlert("There is nobody on Galactica to send to the Brig.");
										t.value += "There is nobody on Galactica to target.\r\n";
									}
									didPower();
									break;
								}
								case 13:
									confirmify("Would you like to decrease Morale by 1?", () => {
										didPower();
									}, () => {
										done = decreaseMorale() && done;
										didPower();
									}, "YES", "NO");
									break;
								case 14: {
									let totalToDraw = Math.min(5, z.damage.length);
									z.damagePlayer = me;
									if(z.galacticaAway) {
										plainAlert("Galactica may not be damaged while she is away.");
									} else if(!z.pegasus || z.pegasusDestroyed || z.vAltDamage || z.vBrutality) {
										z.damagePlayer = me;
										let damageText = "You draw: ";
										for(let i = 0; !(i >= totalToDraw) && z.damage.length > 0; i++) {
											let damage = z.damage.pop();
											z.damageHand.push(damage);
											damageText += "[" + damage + "] ";
										}
										addAlert(damageText + "\nManually choose 2 of them to resolve.");
										t.value += myPlayer + " draws " + totalToDraw + " damage tokens.  They will now resolve 2 of them.\r\n";
									} else {
										if(me === z.turn) {
											addAlert("Please draw your 5 damage tokens manually.");
										} else {
											let realTotal = Math.min(5, z.damage.length + z.pegasusDamage.length);
											plainAlert(z.players[z.turn] +
												", as current player, gets to choose whether you draw Pegasus or Galactica tokens.  They must deal you " +
												realTotal + " damage tokens now.");
										}
									}
									done = false;
									didPower();
									break;
								}
								case 18:
									if(z.forLove || (z.vBrutality && characterPresent("D'Anna"))) {
										let athena = ".";
										if(z.forLove) {
											athena = "; remember that Athena can Love someone.";
										}
										if(z.vBrutality) {
											plainAlert("All Humans must discard a random skill card, then draw 2 Treachery cards" + athena);
										} else {
											plainAlert("All Humans must discard a random skill card, then draw a Treachery card" + athena);
										}
										let numDrawers = 0;
										let numDiscarders = 0;
										for(let j = 0; !(j >= z.numPlayers); j++) {
											if(z.revealedCylons[j] === 0) {
												if(z.possibleColors[j][5] === 1 && z.dradisBait[j]) {
													numDiscarders++;
												}
												if(!z.forLove || z.players[j] === "Athena") {
													addOption(j, "Discard a random Skill Card", 1, true);
												} else {
													z.randomLove[j] = true;
												}
												if(z.vBrutality) {
													numDrawers += 2;
													addOption(j, "Draw 2 Treachery", undefined, true);
												} else {
													numDrawers++;
													addOption(j, "Draw 1 Treachery", undefined, true);
												}
											}
										}
										if(numDrawers + 1 > z.skillCardDecks[5].length || !z.daybreak || numDiscarders > z.mutinyDeck.length - z
											.buriedMutinies) {
											plainAlert("The order of discards and Treachery draws may matter here.");
										}
										done = false;
									} else {
										if(z.vBrutality) {
											addAlert("All players discard a random skill card and draw 2 Treachery cards.");
										} else {
											addAlert("All players discard a random skill card and draw a Treachery card.");
										}
										t.value += "All Human players discard a random skill card.\r\n";
										for(let i = 0; !(i >= z.numPlayers); i++) {
											let j = (z.turn + i) % z.numPlayers;
											if(z.skillCardHands[j].length === 0 && z.revealedCylons[j] === 0) {
												plainAlert(z.players[j] + " has no skill cards to discard, but draws a Treachery card.");
												dealSkillCard(j, 5);
												if(z.vBrutality) {
													dealSkillCard(j, 5);
												}
											} else if(z.revealedCylons[j] === 0 && j !== me) {
												let discard = discardRandomSkillCard(j);
												addAlert(z.players[j] + " discards " + cardText(discard) + " randomly.");
												dealSkillCard(j, 5);
												if(z.vBrutality) {
													dealSkillCard(j, 5);
												}
											}
										}
									}
									addAlert("Remember to draw 2 Treachery cards after you discard down to 3 skill cards.");
									addOption(me, "Draw 2 Treachery", undefined, true);
									t.value += myPlayer + " will draw 2 Treachery cards after they discard down to 3 skill cards.\r\n";
									didPower();
									break;
								case 37:
									confirmify("Would you like to place a Centurion on the Boarding Party Track?", () => {
										didPower();
									}, () => {
										boardGalactica();
										didPower();
									}, "YES", "NO");
									break;
								case 38:
									confirmify("Would you like to decrease the Jump Preparation track by 2?", () => {
										didPower();
									}, () => {
										decreaseJump();
										decreaseJump();
										didPower();
									}, "YES", "NO");
									break;
								case 68:
									plainAlert(z.players[me]+" does not have to down to 3 skill cards.");
									didPower(true);
									break;
							}
						}
					});
			};
			if(cylonCards(me) >= 2) {
				let promptText = "";
				let choices = [];
				for(let i = 0; !(i >= z.loyaltyHands[me].length); i++) {
					if(isCylonCard(z.loyaltyHands[me][i ])) {
						choices.push(i);
						promptText += "\n"+choices.length+": "+d.loyaltyNames[z.loyaltyHands[me][i ]];
					}
				}
				promptText = "Which Cylon card would you like to reveal with? (1-"+choices.length+")"+promptText;
				promptNum(promptText, (a) => 1 > a || a > choices.length, mainMenu, (a) => {
					revealingCard = choices[a-1];
					reveal();
				});
			} else {
				for(let i = 0; !(i >= z.loyaltyHands[me].length); i++) {
					if(isCylonCard(z.loyaltyHands[me][i ])) {
						revealingCard = i;
						reveal();
						break;
					}
				}
			}
		} else if(ch === "Destroy a Viper") {
			let list = mannedVipersList().concat(unmannedVipersList());
			if(assaultRaptorsReserves() > 0) {
				list.unshift(["Assault Raptor", assaultRaptorsReserves(), 0]);
			}
			if(vipersVIIReserves() > 0) {
				list.unshift(["Viper Mk VII", vipersVIIReserves(), 0]);
			}
			if(vipersIIReserves() > 0) {
				list.unshift(["Viper Mk II", vipersIIReserves(), 0]);
			}
			let promptText = "Which viper would you like to destroy? (1-" + list.length + ")\n";
			for(let i = 0; !(i >= list.length); i++) {
				if(list[i ][2] === 0) {
					promptText += (i + 1) + ": " + list[i ][0] + " in the Reserves (" + list[i ][1] + " available)\n";
				} else if(list[i ].length === 4) {
					promptText += (i + 1) + ": " + list[i ][2] + "'s " + list[i ][0] + " in " + list[i ][3] + "\n";
				} else {
					promptText += (i + 1) + ": Unmanned " + list[i ][0] + " in Sector " + list[i ][2] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > list.length, mainMenu, (prompted) => {
				let confirmText = "Confirming you want to destroy: ";
				if(list[prompted - 1][2] === 0) {
					confirmText += list[prompted - 1][0] + " in the Reserves (" + list[prompted - 1][1] + " available)";
				} else if(list[prompted - 1].length === 4) {
					confirmText += list[prompted - 1][2] + "'s " + list[prompted - 1][0] + " in " + list[prompted - 1][3] +
						"\nThey will be sent to Sickbay.";
				} else {
					confirmText += "Unmanned " + list[prompted - 1][0] + " in Sector " + list[prompted - 1][2];
				}
				confirmify(confirmText, mainMenu, () => {
					if(list[prompted - 1][2] === 0) {
						for(let i = 0; list[prompted - 1][0] === "Viper Mk II" && !(i >= z.vipersII.length); i++) {
							if(z.vipersII[i ] === 0) {
								z.vipersII[i ] = -2;
								boldAlert("Destroyed a Mk II Viper in the Reserves.");
								break;
							}
						}
						for(let i = 0; list[prompted - 1][0] === "Viper Mk VII" && !(i >= z.vipersVII.length); i++) {
							if(z.vipersVII[i ] === 0) {
								z.vipersVII[i ] = -2;
								boldAlert("Destroyed a Mk VII Viper in the Reserves.");
								break;
							}
						}
						for(let i = 0; list[prompted - 1][0] === "Assault Raptor" && !(i >= z.vipersII.length); i++) {
							if(z.assaultRaptors[i ] === 0) {
								z.assaultRaptors[i ] = -2;
								boldAlert("Destroyed an Assault Raptor in the Reserves.");
								break;
							}
						}
					} else if(list[prompted - 1].length === 4) {
						let alertText = "Destroyed " + list[prompted - 1][2] + "'s " + list[prompted - 1][0] + " in " + list[prompted -
							1][3];
						if(list[prompted - 1][0] === "Viper Mk II") {
							z.vipersII[list[prompted - 1][1]] = -2;
						} else if(list[prompted - 1][0] === "Viper Mk VII") {
							z.vipersVII[list[prompted - 1][1]] = -2;
						} else if(list[prompted - 1][0] === "Assault Raptor") {
							z.assaultRaptors[list[prompted - 1][1]] = -2;
						}
						boldAlert(alertText);
						movePlayer(getPlayerNum(list[prompted - 1][2]), "Sickbay");
					} else {
						let alertText = "Destroyed Unmanned " + list[prompted - 1][0] + " in Sector " + list[prompted - 1][2];
						if(list[prompted - 1][0] === "Viper Mk II") {
							z.vipersII[list[prompted - 1][1]] = -2;
						} else if(list[prompted - 1][0] === "Viper Mk VII") {
							z.vipersVII[list[prompted - 1][1]] = -2;
						} else if(list[prompted - 1][0] === "Assault Raptor") {
							z.assaultRaptors[list[prompted - 1][1]] = -2;
							alertText = "Destroyed " + alertText;
						}
						boldAlert(alertText);
					}
					if(getContext(me, ch) === "Gas Giant") {
						increaseFuel();
					} else {
						addOption(me,"Reshuffle a Civilian",getContext(me,ch),true);
					}
					removeOption(me, ch);
					mainMenu();
				});
			});
		} else if(ch === "Damage a Viper") {
			let man = isMandatory(me, ch);
			let context = getContext(me, ch);
			let num = 1;
			if(context) {
				num = context[1];
				context = context[0];
			} else {
				context = "";
			}
			let list = [];
			if(context !== "Tactical Strike" && context !== "Cylon Refinery" && context !== "Review Camera Footage" && context !== "Hangar Accident") {
				list = mannedVipersList().concat(unmannedVipersList());
			}
			if(context !== "Main Batteries" && context !== "Weapons Malfunction" && context !== "Standoff with Pegasus" && context !== "Anders") {
				if(assaultRaptorsReserves() > 0) {
					list.unshift(["Assault Raptor", assaultRaptorsReserves(), 0]);
				}
				if(vipersVIIReserves() > 0) {
					list.unshift(["Viper Mk VII", vipersVIIReserves(), 0]);
				}
				if(vipersIIReserves() > 0) {
					list.unshift(["Viper Mk II", vipersIIReserves(), 0]);
				}
			}
			let promptText = "Which viper would you like to damage? (1-" + list.length + ")\n";
			for(let i = 0; !(i >= list.length); i++) {
				if(list[i ][2] === 0) {
					promptText += (i + 1) + ": " + list[i ][0] + " in the Reserves (" + list[i ][1] + " available)\n";
				} else if(list[i ].length === 4) {
					promptText += (i + 1) + ": " + list[i ][2] + "'s " + list[i ][0] + " in " + list[i ][3] + "\n";
				} else {
					promptText += (i + 1) + ": Unmanned " + list[i ][0] + " in Sector " + list[i ][2] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > list.length, mainMenu, (prompted) => {
				let confirmText = "Confirming you want to ";
				if(list[prompted - 1][0] === "Assault Raptor") {
					confirmText += "destroy: ";
				} else {
					confirmText += "damage: ";
				}
				if(list[prompted - 1][2] === 0) {
					confirmText += list[prompted - 1][0] + " in the Reserves (" + list[prompted - 1][1] + " available)";
				} else if(list[prompted - 1].length === 4) {
					confirmText += list[prompted - 1][2] + "'s " + list[prompted - 1][0] + " in " + list[prompted - 1][3] +
						"\nThey will be sent to Sickbay.";
				} else {
					confirmText += "Unmanned " + list[prompted - 1][0] + " in Sector " + list[prompted - 1][2];
				}
				confirmify(confirmText, mainMenu, () => {
					if(list[prompted - 1][2] === 0) {
						for(let i = 0; list[prompted - 1][0] === "Viper Mk II" && !(i >= z.vipersII.length); i++) {
							if(z.vipersII[i ] === 0) {
								z.vipersII[i ] = -1;
								boldAlert("Damaged a Mk II Viper in the Reserves.");
								break;
							}
						}
						for(let i = 0; list[prompted - 1][0] === "Viper Mk VII" && !(i >= z.vipersVII.length); i++) {
							if(z.vipersVII[i ] === 0) {
								z.vipersVII[i ] = -1;
								boldAlert("Damaged a Mk VII Viper in the Reserves.");
								break;
							}
						}
						for(let i = 0; list[prompted - 1][0] === "Assault Raptor" && !(i >= z.vipersII.length); i++) {
							if(z.assaultRaptors[i ] === 0) {
								z.assaultRaptors[i ] = -2;
								boldAlert("Destroyed an Assault Raptor in the Reserves.");
								break;
							}
						}
					} else if(list[prompted - 1].length === 4) {
						let alertText = list[prompted - 1][2] + "'s " + list[prompted - 1][0] + " in " + list[prompted - 1][3] + ".";
						if(list[prompted - 1][0] === "Viper Mk II") {
							if(list[prompted - 1][2] === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) {
								z.vipersII[list[prompted - 1][1]] = -2;
								alertText = "Destroyed " + alertText + " (due to his Forced to Eject drawback)";
							} else {
								z.vipersII[list[prompted - 1][1]] = -1;
								alertText = "Damaged " + alertText;
							}
						} else if(list[prompted - 1][0] === "Viper Mk VII") {
							if(list[prompted - 1][2] === "Hot Dog" && !noDrawback(getPlayerNum("Hot Dog"))) {
								z.vipersVII[list[prompted - 1][1]] = -2;
								alertText = "Destroyed " + alertText + " (due to his Forced to Eject drawback)";
							} else {
								z.vipersVII[list[prompted - 1][1]] = -1;
								alertText = "Damaged " + alertText;
							}
						} else if(list[prompted - 1][0] === "Assault Raptor") {
							z.assaultRaptors[list[prompted - 1][1]] = -2;
							alertText = "Destroyed " + alertText;
						}
						boldAlert(alertText);
						movePlayer(getPlayerNum(list[prompted - 1][2]), "Sickbay");
					} else {
						let alertText = "Unmanned " + list[prompted - 1][0] + " in Sector " + list[prompted - 1][2];
						if(list[prompted - 1][0] === "Viper Mk II") {
							z.vipersII[list[prompted - 1][1]] = -1;
							alertText = "Damaged " + alertText;
						} else if(list[prompted - 1][0] === "Viper Mk VII") {
							z.vipersVII[list[prompted - 1][1]] = -1;
							alertText = "Damaged " + alertText;
						} else if(list[prompted - 1][0] === "Assault Raptor") {
							z.assaultRaptors[list[prompted - 1][1]] = -2;
							alertText = "Destroyed " + alertText;
						}
						boldAlert(alertText);
					}
					
					if(context === "Cylon Refinery") {
						removeFromAll(ch);
					}
					if(num > 1) {
						addOption(me, ch, [context, num - 1], man);
						if(context === "Cylon Refinery") {
							optionForAll(ch, ["Cylon Refinery", 1]);
						}
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			});
		} else if(ch === "Repair a damaged Viper Mk II") {
			confirmify("Confirming you want to repair a damaged Viper Mk II.", mainMenu, () => {
				repairII();
				let context = getContext(me, ch);
				let man = isMandatory(me, ch);
				if(context) {
					let num = context[1];
					context = context[0];
					
					removeOption(me, "Repair a damaged Viper Mk VII");
					if(context === "Ragnar Anchorage") {
						removeOption(me, "Repair a destroyed Viper Mk VII");
						removeOption(me, "Repair a destroyed Viper Mk II");
						removeOption(me, "Repair a destroyed Assault Raptor");
					}
					if(context === "Chief2" || context === "Repair") {
						removeOption(me, "Repair a location");
					}
					if(num > 1) {
						if(damagedVipersII() > 0) {
							addOption(me, ch, [context, num - 1], man);
						} else {
							removeOption(me, ch);
						}
						if(damagedVipersVII() > 0) {
							addOption(me, "Repair a damaged Viper Mk VII", [context, num - 1], man);
						}
						if(context === "Ragnar Anchorage") {
							if(destroyedVipersII() > 0) {
								addOption(me, "Repair a destroyed Viper Mk II", [context, num - 1], man);
							}
							if(destroyedVipersVII() > 0) {
								addOption(me, "Repair a destroyed Viper Mk VII", [context, num - 1], man);
							}
							if(destroyedAssaultRaptors() > 0) {
								addOption(me, "Repair a destroyed Assault Raptor", [context, num - 1], man);
							}
						}
					} else {
						removeOption(me, ch);
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Repair a damaged Viper Mk VII") {
			confirmify("Confirming you want to repair a damaged Viper Mk VII.", mainMenu, () => {
				repairVII();
				let context = getContext(me, ch);
				let man = isMandatory(me, ch);
				if(context) {
					let num = context[1];
					context = context[0];
					removeOption(me, "Repair a damaged Viper Mk II");
					if(context === "Ragnar Anchorage") {
						removeOption(me, "Repair a destroyed Viper Mk VII");
						removeOption(me, "Repair a destroyed Viper Mk II");
						removeOption(me, "Repair a destroyed Assault Raptor");
					}
					if(context === "Chief2" || context === "Repair") {
						removeOption(me, "Repair a location");
					}
					if(num > 1) {
						if(damagedVipersII() > 0) {
							addOption(me, "Repair a damaged Viper Mk II", [context, num - 1], man);
						}
						if(damagedVipersVII() > 0) {
							addOption(me, ch, [context, num - 1], man);
						} else {
							removeOption(me, ch);
						}
						if(context === "Ragnar Anchorage") {
							if(destroyedVipersII() > 0) {
								addOption(me, "Repair a destroyed Viper Mk II", [context, num - 1], man);
							}
							if(destroyedVipersVII() > 0) {
								addOption(me, "Repair a destroyed Viper Mk VII", [context, num - 1], man);
							}
							if(destroyedAssaultRaptors() > 0) {
								addOption(me, "Repair a destroyed Assault Raptor", [context, num - 1], man);
							}
						}
					} else {
						removeOption(me, ch);
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Repair a destroyed Viper Mk II") {
			confirmify("Confirming you want to repair a destroyed Viper Mk II.", mainMenu, () => {
				repairIID();
				let context = getContext(me, ch);
				let man = isMandatory(me, ch);
				removeOption(me, "Repair a destroyed Viper Mk VII");
				removeOption(me, "Repair a destroyed Assault Raptor");
				
				if(context === "Miraculous Return"){
					removeOption(me, ch);
					if(activateRaiders()) {
						activateRaiders();
					} else {
						plainAlert("Once the Raiders are done activating, activate Raiders again.");
						optionForAll("Activate Raiders");
					}
			    } else if(context) {
					let num = context[1];
					context = context[0];
					removeOption(me, "Repair a damaged Viper Mk II");
					removeOption(me, "Repair a damaged Viper Mk VII");
					context = "Ragnar Anchorage";
					if(num > 1) {
						if(damagedVipersII() > 0) {
							addOption(me, "Repair a damaged Viper Mk II", [context, num - 1], man);
						}
						if(damagedVipersVII() > 0) {
							addOption(me, "Repair a damaged Viper Mk VII", [context, num - 1], man);
						}
						if(destroyedVipersII() > 0) {
							addOption(me, ch, [context, num - 1], man);
						} else {
							removeOption(me, ch);
						}
						if(destroyedVipersVII() > 0) {
							addOption(me, "Repair a destroyed Viper Mk VII", [context, num - 1], man);
						}
						if(destroyedAssaultRaptors() > 0) {
							addOption(me, "Repair a destroyed Assault Raptor", [context, num - 1], man);
						}
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Repair a destroyed Viper Mk VII") {
			confirmify("Confirming you want to repair a destroyed Viper Mk VII.", mainMenu, () => {
				repairVIID();
				let context = getContext(me, ch);
				let man = isMandatory(me, ch);
				removeOption(me, "Repair a destroyed Viper Mk II");
				removeOption(me, "Repair a destroyed Assault Raptor");
				if(context === "Miraculous Return"){
					removeOption(me, ch);
					if(activateRaiders()) {
						activateRaiders();
					} else {
						plainAlert("Once the Raiders are done activating, activate Raiders again.");
						optionForAll("Activate Raiders");
					}
			    } else if(context) {
					let num = context[1];
					context = context[0];
					removeOption(me, "Repair a damaged Viper Mk II");
					removeOption(me, "Repair a damaged Viper Mk VII");
					context = "Ragnar Anchorage";
					if(num > 1) {
						if(damagedVipersII() > 0) {
							addOption(me, "Repair a damaged Viper Mk II", [context, num - 1], man);
						}
						if(damagedVipersVII() > 0) {
							addOption(me, "Repair a damaged Viper Mk VII", [context, num - 1], man);
						}
						if(destroyedVipersII() > 0) {
							addOption(me, "Repair a destroyed Viper Mk II", [context, num - 1], man);
						}
						if(destroyedVipersVII() > 0) {
							addOption(me, ch, [context, num - 1], man);
						} else {
							removeOption(me, ch);
						}
						if(destroyedAssaultRaptors() > 0) {
							addOption(me, "Repair a destroyed Assault Raptor", [context, num - 1], man);
						}
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Repair a destroyed Assault Raptor") {
			confirmify("Confirming you want to repair a destroyed Assault Raptor.", mainMenu, () => {
				repairAR();
				let context = getContext(me, ch);
				let man = isMandatory(me, ch);
				
				removeOption(me, "Repair a destroyed Viper Mk VII");
				removeOption(me, "Repair a destroyed Viper Mk II");
				if(context === "Miraculous Return"){
					removeOption(me, ch);
					if(activateRaiders()) {
						activateRaiders();
					} else {
						plainAlert("Once the Raiders are done activating, activate Raiders again.");
						optionForAll("Activate Raiders");
					}
			    } else if(context) {
					let num = context[1];
					removeOption(me, "Repair a damaged Viper Mk II");
					removeOption(me, "Repair a damaged Viper Mk VII");
					context = "Ragnar Anchorage";
					if(num > 1) {
						if(damagedVipersII() > 0) {
							addOption(me, "Repair a damaged Viper Mk II", [context, num - 1], man);
						}
						if(damagedVipersVII() > 0) {
							addOption(me, "Repair a damaged Viper Mk VII", [context, num - 1], man);
						}
						if(destroyedVipersII() > 0) {
							addOption(me, "Repair a destroyed Viper Mk II", [context, num - 1], man);
						}
						if(destroyedVipersVII() > 0) {
							addOption(me, "Repair a destroyed Viper Mk VII", [context, num - 1], man);
						}
						if(destroyedAssaultRaptors() > 0) {
							addOption(me, ch, [context, num - 1], man);
						} else {
							removeOption(me, ch);
						}
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Process Special text from the Cylon Attack Card") {
			let confirmText =
				"Confirming you want to process the special text on this Cylon Attack card.\nMake sure the current player has placed all ships possible first.";
			if(canAVP()) {
				confirmText += "\nMake sure Apollo has had a chance to use his Alert Viper Pilot ability (if he hasn't already used it this turn).";
			}
			confirmify(confirmText, mainMenu, () => {
				specialCAC();
				mainMenu();
			});
		} else if(ch === "Swap out a Viper Mk II for an Assault Raptor") {
			let promptText = "In which sector would you like to swap a just-placed Viper Mk II for an Assault Raptor? (1-6)";
			let context = getContext(me, ch);
			for(let j = 0; Array.isArray(context) && !(j >= context.length); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(context[j] === 0) {
					promptText += "(no vipers placed here)";
				} else if(context[j] === 1) {
					promptText += "Sector " + (j + 1) + " (" + context[j] + " Viper placed)";
				} else {
					promptText += "Sector " + (j + 1) + " (" + context[j] + " Vipers placed)";
				}
			}
			promptNum(promptText, (a) => 1 > a || !Array.isArray(context) || a > context.length || 0 === context[a - 1], mainMenu, (prompted) => {
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(z.vipersII[j] === prompted) {
						z.vipersII[j] = 0;
						if(canAVP() && z.avp.includes(j)) {
							z.avp.splice(z.avp.indexOf(j), 1);
						}
						break;
					}
				}
				for(let j = 0; !(j >= z.assaultRaptors.length); j++) {
					if(z.assaultRaptors[j] === 0) {
						z.assaultRaptors[j] = prompted;
						if(canAVP()) {
							z.avp.push(12 + j);
						}
						break;
					}
				}
				boldAlert(z.players[me] + " swapped out a Viper Mk II in Sector " + prompted + " for an Assault Raptor.");
				
				if(assaultRaptorsReserves() > 0) {
					context[prompted - 1]--;
					let total = 0;
					for(let j = 0; !(j >= context.length); j++) {
						total += context[j];
					}
					if(total > 0) {
						addOption(me, ch, context, false);
					} else {
						removeOption(me, ch);
					}
				} else {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Place a Viper Mk II in space") {
			/* TODO: better option persistence */
			let promptText = "What sector would you like to place the Viper Mk II in? (1-6)";
			let context = getContext(me, ch);
			let man = isMandatory(me, ch);
			let illegal = function(a) {
				if(1 > a || a > 6) {
					return true;
				}
				if(Array.isArray(context)) {
					return context[a - 1] === 0;
				}
				if(context === "Launch Reserves") {
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(isInSpace(j) && parseInt(z.playerLocations[j].slice(7)) === a) {
							return false;
						}
					}
					return true;
				}
				return false;
			};
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(illegal(j)) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, illegal, mainMenu, (prompted) => {
				for(let i = 0; !(i >= z.vipersII.length); i++) {
					if(z.vipersII[i ] === 0) {
						z.vipersII[i ] = prompted;
						boldAlert("Placed a Viper Mk II in Sector " + prompted);
						if(canAVP()) {
							z.avp.push(i);
							plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
							addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
						}
						break;
					}
				}
				if(vipersIIReserves() === 0) {
					removeOption(me, ch);
				}
				if(context === "Launch Reserves") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk VII in space");
					removeOption(me, "Place an Assault Raptor in space");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 1;
					let anything = false;
					if(vipersIIReserves() > 0) {
						anything = true;
						addOption(me, ch, arr, false);
					}
					if(vipersVIIReserves() > 0) {
						anything = true;
						addOption(me, "Place a Viper Mk VII in space", arr, false);
					}
					if(assaultRaptorsReserves() > 0) {
						anything = true;
						addOption(me, "Place an Assault Raptor in space", arr, false);
					}
					if(anything) {
						addOption(me, "Activate an unmanned Viper", 2, false);
					} else {
						menuPage = "[Manual Viper Activation]";
						addOption(me, "Activate an unmanned Viper", 1, false);
					}
				} else if(context === "Raider Bay") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk VII in space");
					removeOption(me, "Place an Assault Raptor in space");
					removeOption(me, "Place Raider(s) on the main game board");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 3;
					if(vipersIIReserves() > 0) {
						addOption(me, ch, arr, man);
					}
					if(vipersVIIReserves() > 0) {
						addOption(me, "Place a Viper Mk VII in space", arr, man);
					}
					if(assaultRaptorsReserves() > 0) {
						addOption(me, "Place an Assault Raptor in space", arr, man);
					}
					let total = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves();
					if(total > 3) {
						total = 3;
					}
					addOption(me, "Activate an unmanned Viper", total + 1, false);
					if(total === 0) {
						menuPage = "[Manual Viper Activation]";
					}
				} else if(Array.isArray(context)) {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk VII in space");
					removeOption(me, "Place an Assault Raptor in space");
					context[prompted - 1] -= 1;
					let total = 0;
					for(let j = 0; !(j >= 6); j++) {
						total += context[j];
						if(total > 0) {
							if(vipersIIReserves() > 0) {
								addOption(me, ch, context, man);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, "Place a Viper Mk VII in space", context, man);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, "Place an Assault Raptor in space", context, man);
							}
							break;
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "Place a Viper Mk VII in space") {
			let promptText = "What sector would you like to place the Viper Mk VII in? (1-6)";
			let context = getContext(me, ch);
			let man = isMandatory(me, ch);
			let illegal = function(a) {
				if(1 > a || a > 6) {
					return true;
				}
				if(Array.isArray(context)) {
					return context[a - 1] === 0;
				}
				if(context === "Launch Reserves") {
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(isInSpace(j) && parseInt(z.playerLocations[j].slice(7)) === a) {
							return false;
						}
					}
					return true;
				}
				return false;
			};
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(illegal(j)) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, illegal, mainMenu, (prompted) => {
				for(let i = 0; !(i >= z.vipersVII.length); i++) {
					if(z.vipersVII[i ] === 0) {
						z.vipersVII[i ] = prompted;
						boldAlert("Placed a Viper Mk VII in Sector " + prompted);
						if(canAVP()) {
							z.avp.push(8 + i);
							plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
							addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
						}
						break;
					}
				}
				if(vipersVIIReserves() === 0) {
					removeOption(me, ch);
				}
				if(context === "Launch Reserves") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place an Assault Raptor in space");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 1;
					let anything = false;
					if(vipersIIReserves() > 0) {
						anything = true;
						addOption(me, "Place a Viper Mk II in space", arr, false);
					}
					if(vipersVIIReserves() > 0) {
						anything = true;
						addOption(me, ch, arr, false);
					}
					if(assaultRaptorsReserves() > 0) {
						anything = true;
						addOption(me, "Place an Assault Raptor in space", arr, false);
					}
					if(anything) {
						addOption(me, "Activate an unmanned Viper", 2, false);
					} else {
						menuPage = "[Manual Viper Activation]";
						addOption(me, "Activate an unmanned Viper", 1, false);
					}
				} else if(context === "Raider Bay") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place an Assault Raptor in space");
					removeOption(me, "Place Raider(s) on the main game board");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 3;
					if(vipersIIReserves() > 0) {
						addOption(me, "Place a Viper Mk II in space", arr, man);
					}
					if(vipersVIIReserves() > 0) {
						addOption(me, ch, arr, man);
					}
					if(assaultRaptorsReserves() > 0) {
						addOption(me, "Place an Assault Raptor in space", arr, man);
					}
					let total = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves();
					if(total > 3) {
						total = 3;
					}
					addOption(me, "Activate an unmanned Viper", total + 1, false);
					if(total === 0) {
						menuPage = "[Manual Viper Activation]";
					}
				} else if(Array.isArray(context)) {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place an Assault Raptor in space");
					context[prompted - 1] -= 1;
					let total = 0;
					for(let j = 0; !(j >= 6); j++) {
						total += context[j];
						if(total > 0) {
							if(vipersIIReserves() > 0) {
								addOption(me, "Place a Viper Mk II in space", context, man);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, ch, context, man);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, "Place an Assault Raptor in space", context, man);
							}
							break;
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "Place an Assault Raptor in space") {
			/* TODO: improve context */
			let promptText = "What sector would you like to place the Assault Raptor in? (1-6)";
			let context = getContext(me, ch);
			let man = isMandatory(me, ch);
			let illegal = function(a) {
				if(1 > a || a > 6) {
					return true;
				}
				if(Array.isArray(context)) {
					return context[a - 1] === 0;
				}
				if(context === "Launch Reserves") {
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(isInSpace(j) && parseInt(z.playerLocations[j].slice(7)) === a) {
							return false;
						}
					}
					return true;
				}
				return false;
			};
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(illegal(j)) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, illegal, mainMenu, (prompted) => {
				for(let i = 0; !(i >= z.assaultRaptors.length); i++) {
					if(z.assaultRaptors[i ] === 0) {
						z.assaultRaptors[i ] = prompted;
						boldAlert("Placed an Assault Raptor in Sector " + prompted);
						if(canAVP()) {
							z.avp.push(12 + i);
							plainAlert("Apollo may have an opportunity to use Alert Viper Pilot here.");
							addOption(getPlayerNum("Apollo"), "Use Alert Viper Pilot to jump in a Viper in space", undefined, false);
						}
						break;
					}
				}
				if(vipersVIIReserves() === 0) {
					removeOption(me, ch);
				}
				if(context === "Launch Reserves") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place a Viper Mk VII in space");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 1;
					let anything = false;
					if(vipersIIReserves() > 0) {
						anything = true;
						addOption(me, "Place a Viper Mk II in space", arr, false);
					}
					if(vipersVIIReserves() > 0) {
						anything = true;
						addOption(me, "Place a Viper Mk VII in space", arr, false);
					}
					if(assaultRaptorsReserves() > 0) {
						anything = true;
						addOption(me, ch, arr, false);
					}
					if(anything) {
						addOption(me, "Activate an unmanned Viper", 2, false);
					} else {
						menuPage = "[Manual Viper Activation]";
						addOption(me, "Activate an unmanned Viper", 1, false);
					}
				} else if(context === "Raider Bay") {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place a Viper Mk VII in space");
					removeOption(me, "Place Raider(s) on the main game board");
					let arr = [0, 0, 0, 0, 0, 0];
					arr[prompted - 1] = 3;
					if(vipersIIReserves() > 0) {
						addOption(me, "Place a Viper Mk II in space", arr, man);
					}
					if(vipersVIIReserves() > 0) {
						addOption(me, "Place a Viper Mk VII in space", arr, man);
					}
					if(assaultRaptorsReserves() > 0) {
						addOption(me, ch, arr, man);
					}
					let total = vipersIIReserves() + vipersVIIReserves() + assaultRaptorsReserves();
					if(total > 3) {
						total = 3;
					}
					addOption(me, "Activate an unmanned Viper", total + 1, false);
					if(total === 0) {
						menuPage = "[Manual Viper Activation]";
					}
				} else if(Array.isArray(context)) {
					removeOption(me, ch);
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place a Viper Mk VII in space");
					context[prompted - 1] -= 1;
					let total = 0;
					for(let j = 0; !(j >= 6); j++) {
						total += context[j];
						if(total > 0) {
							if(vipersIIReserves() > 0) {
								addOption(me, "Place a Viper Mk II in space", context, man);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, "Place a Viper Mk VII in space", context, man);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, ch, context, man);
							}
							break;
						}
					}
				}
				mainMenu();
			});
		} else if(ch === "Setup ships from the Cylon Attack Card") {
			confirmify("Confirming you want to set up ships for " + d.crisisNames[z.currentCrisis] +
				".  Make sure you have activated Cylon ships appropriately before doing this.", mainMenu, () => {
					setupCAC();
					mainMenu();
				});
		} else if(ch === "Activate Basestars") {
			confirmify("Confirming you want to process an Activate Basestars icon.", mainMenu, () => {
				activateBasestars();
				if(!hasOption(me,ch) && z.toDoBasestars) {
					z.toDoBasestars = false;
					if(!z.toDoOFs) {
						primeJumpIcon();
					}
				}
				removeFromAll(ch);
				mainMenu();
			});
		} else if(ch === "End Turn") {
			confirmify("Confirming that you want to end the current turn.", mainMenu, () => {
				let manipulativeCheck = false;
				let goodToEndTurn = true;
				for(let i = 0; !(i >= z.numPlayers); i++) {
					let j = (i + z.turn) % z.numPlayers;
					if(z.players[j] === "Chief" && z.revealedCylons[j] === 0 && z.skillCardHands[j].length > 8 && !noDrawback(j)) {
						let plural = "";
						if(z.skillCardHands[j].length - 8 >= 2) {
							plural = "s";
						}
						boldAlert("Chief is over his hand limit and must discard " + (z.skillCardHands[j].length - 8) + " card" + plural + ".");
						goodToEndTurn = false;
						manipulativeCheck = true;
					} else if(z.skillCardHands[j].length > 10) {
						let plural = "";
						if(z.skillCardHands[j].length - 10 >= 2) {
							plural = "s";
						}
						boldAlert(z.players[j] + " is over their hand limit and must discard " + (z.skillCardHands[j].length - 10) + " card" +
							plural + ".");
						if(z.players[j] === "Apollo" && !noDrawback(j) && z.revealedCylons[j] === 0 && j !== z.theSympatheticCylon) {
							plainAlert("Apollo is Headstrong and must discard randomly; you may make him do so.");
							optionForAll("Make Apollo discard down to his hand limit");
						}
						goodToEndTurn = false;
						manipulativeCheck = true;
					} /* TODO: issues with Missions and SoEs with crisis later in the turn? */
				}
				if(characterPresent("Athena") && couldLove()) {
					boldAlert("Please wait for Athena to decide on For Love before ending the turn.");
					goodToEndTurn = false;
				}
				if(characterPresent("Athena") && Array.isArray(z.allForLove)){
					for(let j = 0; !(j>=z.numPlayers); j++){
						if(z.allForLove[j]){
							boldAlert(z.players[j] + " must discard down to 1 card before the turn can end.");
						}
					}
				}
				if(z.mutineer && z.theMutineer === -1 && z.sleeper){
					boldAlert(z.players[z.turn]+ " must pick someone to draw an additional Loyalty card before the turn can end.");
					goodToEndTurn = false;
				}
				if(characterPresent("Cain") && hasOption(getPlayerNum("Cain"), "[Stamp Authority] Play a Mutiny")) {
					boldAlert("Cain must finish her Stamp Authority before the turn can end.");
					goodToEndTurn = false;
				}
				if(characterPresent("Cavil") && hasOption(getPlayerNum("Cavil"), "[Aggressive Tactics] Play a Super Crisis")) {
					boldAlert("Cavil must finish his Aggressive Tactics before the turn can end.");
					goodToEndTurn = false;
				}
				if(characterPresent("Gaius") && (hasOption(getPlayerNum("Gaius"), "[Aggressive Tactics] Play a Super Crisis") || hasOption(
						getPlayerNum("Gaius"), "[Stamp Authority] Play a Mutiny"))) {
					boldAlert("Gaius must finish his Acts of Faith before the turn can end.");
					goodToEndTurn = false;
				}
				if(characterPresent("Tom") && z.necessarySteps.length > 0) {
					boldAlert("Tom must finish Necessary Steps before the turn can end.");
					goodToEndTurn = false;
				}
				if(z.jumpTrack === 5 && !z.galacticaReturned) {
					boldAlert("A new Destination must be chosen before the turn can end.");
					goodToEndTurn = false;
				}
				if(z.quorumPeeker !== -1) {
					boldAlert(z.players[z.quorumPeeker] + " must finish dealing with the Quorum cards in their hand.");
					goodToEndTurn = false;
				}
				if(z.dieRollQueue.length > 0 || z.lastDieRoll !== null) {
					boldAlert("Finish all die rolls from the current turn before continuing.");
					goodToEndTurn = false;
				}
				if(z.quorumHand.length > z.quorumHandLimit) {
					let plural = "";
					if(z.quorumHand.length - z.quorumHandLimit >= 2) {
						plural = "s";
					}
					t.value += bold(colorText("orange", "President ") + z.players[z.president] +
						" is over the Quorum hand limit and must discard " + (z.quorumHand.length - z.quorumHandLimit) + " Quorum Card" +
						plural + ".\r\n");
					addAlert("The President is over the Quorum Hand Limit");
					addOption(z.president, "Discard a Quorum Card", undefined, false);
					goodToEndTurn = false;
					manipulativeCheck = true;
				}
				if(characterPresent("Billy") && getPlayerNum("Billy") !== z.president && z.billyHand.length > 2) {
					let plural = "";
					if(z.billyHand.length - 2 >= 2) {
						plural = "s";
					}
					t.value += "Billy is over his Quorum hand limit and must discard " + (z.billyHand.length - 2) + " Quorum Card" + plural +
						".\r\n";
					if(z.presidentialAide && getPlayerNum("Billy") === z.turn) {
						t.value += "In lieu of one discard, he may give a Quorum Card to " + colorText("orange", "President ") + z.players[z
							.president] + " using his Presidential Aide ability.\r\n";
					}
					addAlert("Billy is over his Quorum Hand Limit.");
					addOption(getPlayerNum("Billy"), "Discard a Quorum Card", undefined, false);
					goodToEndTurn = false;
				}
				let mandatories = anyMandatory();
				if(mandatories.length > 0) {
					plainAlert(
						"It looks like some things still need to be done before the turn can end.  The following players must do one or more of the following things:"
						);
					for(let j = 0; !(j >= mandatories.length); j++) {
						plainAlert(z.players[mandatories[j][0]] + ": " + mandatories[j][1]);
					}
					plainAlert(
						'If you are sure this is in error, you may use the deep menus to "Make all options non-mandatory", then try again.');
					goodToEndTurn = false;
				}
				if(manipulativeCheck && z.manipulativeVictim !== -1) {
					if(z.manipulativeAdmiral) {
						if(z.turn === z.admiral) {
							if(100 > z.manipulativeVictim && z.revealedCylons[z.manipulativeVictim] === 0 && z.playerLocations[z
									.manipulativeVictim] !== "Brig") {
								plainAlert("Ellen may pass the Admiral title back to " + z.players[z.manipulativeVictim] +
									" now, or wait until it is done automatically after the discards.");
							} else {
								plainAlert(
									"Ellen may pass the Admiral title to the highest player on the Admiral succession list now, or wait until it is done automatically after the discards."
									);
							}
							addOption(z.turn, "Move the Admiral title", "Manipulative", false);
						}
					} else {
						if(z.turn === z.president) {
							if(100 > z.manipulativeVictim && z.revealedCylons[z.manipulativeVictim] === 0) {
								plainAlert("Ellen may pass the President title back to " + z.players[z.manipulativeVictim] +
									" now, or wait until it is done automatically after the discards.");
							} else {
								t.value +=
									"Ellen may pass the Admiral title to the highest player on the President succession list now, or wait until it is done automatically after the discards.";
							}
							addOption(z.turn, "Move the President title", "Manipulative", false);
						}
					}
				}
				if(goodToEndTurn && characterPresent("Dee") && 2 >= z.morale 
				   && ((!versionAtLeast([2,1,13]) && z.turn === getPlayerNum("Dee") && z.momentOfHeroism === z.turn)
						|| (versionAtLeast([2,1,13]) && z.momentOfHeroism === getPlayerNum("Dee") && z.players[z.turn] === "Billy")) && !z.momentOfHeroismExtra) {
					t.value += italics("I know you think you can get that gun....You're not trained for that.  You've got nothing to prove.\r\n");
					z.momentOfHeroism = -1;
					executePlayer(getPlayerNum("Dee"));
					goodToEndTurn = false;
				}
				let endThatTurn = function() {
					if(z.preCrossroads && z.vAltTrauma && z.playerLocations[z.turn] === "Brig") {
						if(z.brigTrauma === undefined){
							if(z.traumaPile.length === 0){
								t.value += "There is no Trauma in the Brig or the Trauma pile; no effect.\r\n";
							} else {
								z.brigTrauma = z.traumaPile.pop();
								t.value += "There is no Trauma in the Brig; one is drawn from the Trauma pile instead.\r\n";
							}
						}
						if(z.brigTrauma === 0) {
							z.antagonistic[z.turn]++;
							plainAlert(z.players[z.turn] + " draws a Trauma from the Brig, and survives.");
							z.brigTrauma = z.traumaPile.pop();
						} else if(z.brigTrauma === 1) {
							z.benevolent[z.turn]++;
							plainAlert(z.players[z.turn] + " draws a Trauma from the Brig, and survives.");
							z.brigTrauma = z.traumaPile.pop();
						} else if(z.brigTrauma === -1) {
							addAlert(z.players[z.turn] +
								" draws a DISASTER token from the Brig, and is executed!\nEnd the turn again once the execution is resolved."
								);
							t.value += bold(z.players[z.turn] + " draws a " + colorText("red", "DISASTER") + " token from the Brig!") +
								"\r\n" + "End the turn again once the execution is resolved.\r\n";
							executePlayer(z.turn, false);
							t.value += "Reshuffling Disaster Token.\r\n";
							z.traumaPile.push(-1);
							shuffle(z.traumaPile);
							z.brigTrauma = z.traumaPile.pop();
							mainMenu();
							return;
						}
					}
					if(z.manipulativeVictim !== -1) {
						if(z.manipulativeAdmiral) {
							if(z.turn === z.admiral) {
								if(100 > z.manipulativeVictim && z.revealedCylons[z.manipulativeVictim] === 0 && z.playerLocations[z
										.manipulativeVictim] !== "Brig") {
									z.admiral = z.manipulativeVictim;
									addAlert(z.players[z.manipulativeVictim] + " is once again the Admiral.");
									t.value += bold("Ellen gives the " + colorText("green", "Admiral") + " title back to " + z.players[z
										.manipulativeVictim]) + ".\r\n";
									if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm &&
										z.admiral !== getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig") {
										plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
										/* TODO: new version */
										if(!versionAtLeast([2,2,25])){
											if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
												addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
											} else {
												addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
											}
										}
									}
									if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum(
											"Gaius")] !== "Brig" && (!versionAtLeast([2, 0, 1]) || z.players[z.turn] !== "Gaius")) {
										/* TODO: this doesn't actually do anything */
										if(!versionAtLeast([2,2,25])){											
											plainAlert(
											"Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
											if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
												addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
											} else {
												addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
											}
										}
									}
								} else {
									t.value += "Ellen's Manipulative ends, but the original " + colorText("green", "Admiral") +
										" is no longer eligible.\r\n";
									passAdmiral(99);
								}
							} else {
								t.value += "Ellen is no longer the " + colorText("green", "Admiral") + ", and cannot return the title.\r\n";
							}
						} else {
							if(z.turn === z.president) {
								if(100 > z.manipulativeVictim && z.revealedCylons[z.manipulativeVictim] === 0) {
									movePresident(z.manipulativeVictim);
									addAlert(z.players[z.manipulativeVictim] + " is once again the President.");
									t.value += bold("Ellen gives the " + colorText("orange", "President") + " title back to " + z.players[z
										.manipulativeVictim]) + ".\r\n";
								} else {
									t.value += "Ellen's Manipulative ends, but the original " + colorText("orange", "President") +
										" is no longer eligible.\r\n";
									passPresident(99);
								}
							} else {
								t.value += "Ellen is no longer the " + colorText("orange", "President") +
									", and cannot return the title.\r\n";
							}
						}
						z.manipulativeVictim = -1;
					}
					if((z.turn === z.momentOfHeroism && !versionAtLeast([2,1,13])) || (versionAtLeast([2,1,13]) && z.players[z.turn] === "Billy" && z.momentOfHeroism >= 0)) {
						if(z.momentOfHeroismExtra) {
							z.momentOfHeroismExtra = false;
						} else {
							boldAlert("Billy's Moment of Heroism ends; " + z.players[z.momentOfHeroism] +
								" must once again deal with their drawback.");
							z.momentOfHeroism = -1;
						}
					}
					if(z.fuel === 0) {
						addAlert("Fuel is at 0; Cylons Win!");
						t.value += bold("Fuel is at Zero.") + "\r\n";
					}
					if(z.food === 0) {
						addAlert("Food is at 0; Cylons Win!");
						t.value += bold("Food is at Zero.") + "\r\n";
					}
					if(z.morale === 0) {
						addAlert("Morale is at 0; Cylons Win!");
						t.value += bold("Morale is at Zero.") + "\r\n";
					}
					if(z.population === 0) {
						addAlert("Population is at 0; Cylons Win!");
						t.value += bold("Population is at Zero.") + "\r\n";
					}
					if(z.fuel === 0 || z.food === 0 || z.morale === 0 || z.population === 0) {
						endGame(false);
					} else {
						z.turn++;
						if(z.turn === z.numPlayers) {
							z.turn = 0;
							z.round++;
						}
						addAlert("It is now " + z.players[z.turn] + "'s turn.");
						if(z.heloReturnRound > z.round && z.players[z.turn] === "Helo") {
							addAlert("Helo is Stranded.");
							t.value += "Helo is Stranded on Caprica; he may not move or take an action this turn.\r\n";
						} else if(z.round === z.heloReturnRound && z.players[z.turn] === "Helo" && z.numPlayers + z.boxedPlayers.length >
							1 && z.revealedCylons[z.turn] === 0) {
							addAlert("Helo returns from being Stranded, arriving on the Hangar Deck.");
							if(!z.galacticaAway) {
								t.value += "Helo is no longer Stranded, and is placed on the Hangar Deck.\r\n";
								movePlayer(z.turn, "Hangar Deck");
							} else {
								t.value += "Helo is no longer Stranded, and is placed on Resistance HQ.\r\n";
								movePlayer(z.turn, "Resistance HQ");
							}
						}
						textGameState(true);
						if(z.currentCrisis !== null && !isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis)) {
							discardCrisis();
						}
						if(z.razor) {
							z.razor = false;
						}
						if(z.politicallyAdroit){
							z.politicallyAdroit = false;
						}
						delete z.selfishLove;
						delete z.friendsPresident;
						delete z.friendsAdmiral;
						delete z.friendsCAG;
						delete z.cultCAG;
						delete z.cultAdmiral;
						delete z.cultPresident;
						z.forwardThinker = false;
						z.metAnAlly = false;
						z.phase = 0;
						z.SoEActor = -1;
						z.SoEPlayer = -1;
						z.emergencyAction = false;
						z.capricaCrisis = false;
						z.preventative = null;
						z.negotiation = false;
						z.currentCrisis = null;
						z.crisisPlayer = null;
						z.toDoJumpIcon = false;
						z.toDoRaiders = false;
						z.toDoHeavies = false;
						z.toDoLaunchRaiders = false;
						z.toDoBasestars = false;
						z.toDoOFs = false;
						z.finishedCrisis = false;
						z.executedCurrentPlayer = false;
						z.engineRoom = false;
						z.establishSanitation = false;
						z.crisisOptions = blankArrays(z.numPlayers);
						delete z.sabotageMove;
						z.context = blankArrays(z.numPlayers);
						z.mandatory = blankArrays(z.numPlayers);
						z.mementoUsed = false;
						z.xo = false;
						z.xo1 = undefined;
						z.xo2 = undefined;
						z.recon = false;
						z.majorVictory = false;
						z.sabotage = false;
						z.sabotageAnnounced = false;
						z.treacheryDiscarded = false;
						z.raptorPilot = false;
						z.expertPilot = false;
						z.destroyer = -1;
						z.dieRoller = z.turn;
						if(z.damageHand.length > 0) {
							while(z.damageHand.length > 0) {
								let dam = z.damageHand.shift();
								if(onPegasus(dam) && !z.vAltDamage) {
									z.pegasusDamage.push(dam);
									shuffle(z.pegasusDamage);
								} else {
									z.damage.push(dam);
								}
							}
							shuffle(z.damage);
							addAlert("Shuffled remaining damage tokens back into the pile.");
							if(z.damagePlayer !== -1) {
								t.value += z.players[z.damagePlayer] + " returned the remaining damage tokens to the pile.\r\n";
							}
						}
						z.damagePlayer = -1;
						z.eco = z.players[z.turn] === "Helo" && characterPresent("Helo");
						z.avionicsExpert = z.players[z.turn] === "Seelix" && characterPresent("Seelix");
						z.avionicsExpertAvailable = false;
						if(z.players[z.turn] === "Billy"){
							z.presidentialAide = true;
						}
						z.stim = null;
						for(let j = 0; !(j >= z.numPlayers); j++) {
							z.dradisBait[j] = true;
							z.skillCardHands[j].sort(cardCompare);
						}
						z.forLove = characterPresent("Athena");
						if(z.CFB) {
							z.cagTitle = true;
						}
						if(z.maintenanceEngineer) {
							z.maintenanceEngineer = false;
						}
						if(z.captainsCabin) {
							z.captainsCabin = false;
						}
						if(z.hasOwnProperty("avp")) {
							z.avp = [];
						}
						if(z.aggressiveTacticsSkip) {
							z.aggressiveTacticsSkip = false;
						}
						let newPlayer = z.players[z.turn];
						let newPlayerLoc = z.playerLocations[z.turn];
						z.drawSkills = true;
						if(characterPresent("Tigh") && z.skillCardHands[z.players.indexOf("Tigh")].length === 1 && !noDrawback(getPlayerNum("Tigh")) && z.preCrossroads && !z.vAltTrauma &&
								(newPlayerLoc === "Brig" || newPlayerLoc === "Sickbay")){
							plainAlert(z.players[z.turn]+ " must draw a Trauma from "+newPlayerLoc+", and Tigh must discard a card from Alcoholic.\n"+z.players[z.turn]+" must choose the order in which this occurs.");
							z.drawSkills = false;
							addOption(z.turn,"Draw a Trauma from my location",undefined,true);
							addOption(z.turn,"Trigger Tigh's Alcoholic",undefined,true);
							if(((z.players[z.turn] === "Ellen" && z.miracles[z.turn] > 0 && !z.theFarm) || (z.players[z.turn] === "Gaius" && actsOfFaith("Ellen"))) &&
								  (z.turn !== z.president || (z.turn !== z.admiral && z.playerLocations[me] !== "Brig"))){
									  
								plainAlert(z.players[z.turn]+" could also use Manipulative here.");
								addOption(z.turn,"Manipulative (OPG)",undefined,false);
							}
						} else if(((z.players[z.turn] === "Ellen" && z.miracles[z.turn] > 0 && !z.theFarm) || 
								  (z.players[z.turn] === "Gaius" && actsOfFaith("Ellen"))) &&
								  (newPlayerLoc === "Brig" || newPlayerLoc === "Sickbay") && z.preCrossroads && !z.vAltTrauma && 
								  (z.turn !== z.president || (z.turn !== z.admiral && z.playerLocations[me] !== "Brig"))){
							plainAlert(z.players[z.turn] + " must draw a Trauma from "+newPlayerLoc+", but may use Manipulative beforehand if she desires.");
							z.drawSkills = false;
							addOption(z.turn,"Draw a Trauma from my location",undefined,true);
							addOption(z.turn,"Manipulative (OPG)",undefined,false);
						} else {
							if(z.preCrossroads && !z.vAltTrauma && newPlayerLoc === "Sickbay") {
								let trauma = z.sickbayTrauma;
								if(trauma === undefined && (!z.vEuropeanTrauma || z.brigTrauma === undefined)){
									if(z.traumaPile.length === 0){
										t.value += "There is no Trauma in Sickbay or the Trauma pile; no effect.\r\n";
									} else {
										trauma = z.traumaPile.pop();
										t.value += "There is no Trauma in Sickbay; one is drawn from the Trauma pile instead.\r\n";
									}
								} else if (trauma === undefined && z.vEuropeanTrauma){
									trauma = z.brigTrauma;
								}
								if(trauma === 0) {
									z.antagonistic[z.turn]++;
									t.value += newPlayer + " draws a Trauma from Sickbay, and survives.\r\n";
									if(z.vEuropeanTrauma){
										z.brigTrauma = z.traumaPile.pop();
									} else {
										z.sickbayTrauma = z.traumaPile.pop();
									}
								} else if(trauma === 1) {
									z.benevolent[z.turn]++;
									t.value += newPlayer + " draws a Trauma from Sickbay, and survives.\r\n";
									if(z.vEuropeanTrauma){
										z.brigTrauma = z.traumaPile.pop();
									} else {
										z.sickbayTrauma = z.traumaPile.pop();
									}
								} else if(trauma === -1) {
									addAlert(newPlayer + " draws a DISASTER token from Sickbay, and is executed!");
									t.value += bold(newPlayer + " draws a " + colorText("red", "DISASTER") + " token from Sickbay!") + "\r\n";
									executePlayer(z.turn,
									false); /* TODO: you are executed by disaster trauma, pick an char corresponding to ally on the board, new ally trauma is placed randomly.  That same disaster token is not reshuffled until AFTERWARDS, then new sickbay/brig trauma placed */
									t.value += "Reshuffling Disaster Token.\r\n";
									z.traumaPile.push(-1);
									shuffle(z.traumaPile);
									if(z.vEuropeanTrauma){
										z.brigTrauma = z.traumaPile.pop();
									} else {
										z.sickbayTrauma = z.traumaPile.pop();
									}
									z.drawSkills = false;
									z.phase = 4;
								}
							}
							if(z.preCrossroads && !z.vAltTrauma && newPlayerLoc === "Brig") {
								if(z.brigTrauma === undefined){
									if(z.traumaPile.length === 0){
										t.value += "There is no Trauma in the Brig or the Trauma pile; no effect.\r\n";
									} else {
										z.brigTrauma = z.traumaPile.pop();
										t.value += "There is no Trauma in the Brig; one is drawn from the Trauma pile instead.\r\n";
									}
								}
								if(z.brigTrauma === 0) {
									z.antagonistic[z.turn]++;
									t.value += newPlayer + " draws a Trauma from the Brig, and survives.\r\n";
									z.brigTrauma = z.traumaPile.pop();
								} else if(z.brigTrauma === 1) {
									z.benevolent[z.turn]++;
									t.value += newPlayer + " draws a Trauma from the Brig, and survives.\r\n";
									z.brigTrauma = z.traumaPile.pop();
								} else if(z.brigTrauma === -1) {
									addAlert(newPlayer + " draws a DISASTER token from the Brig, and is executed!");
									t.value += bold(newPlayer + " draws a " + colorText("red", "DISASTER") + " token from the Brig!") + "\r\n";
									executePlayer(z.turn, false);
									t.value += "Reshuffling Disaster Token.\r\n";
									z.traumaPile.push(-1);
									shuffle(z.traumaPile);
									z.brigTrauma = z.traumaPile.pop();
									z.drawSkills = false;
									z.phase = 7;
								}
							}
							if(characterPresent("Tigh") && z.skillCardHands[z.players.indexOf("Tigh")].length === 1 && !characterPresent(
									"Athena") && !noDrawback(getPlayerNum("Tigh"))) {
								addAlert("Dammit, Saul, you have lupus!");
								t.value += "Tigh is Alcoholic.\r\n";
								discardRandomSkillCard(z.players.indexOf("Tigh"));
							}
							/* TODO: make sure Tigh-Athena interaction works */
							if(characterPresent("Tigh") && z.skillCardHands[z.players.indexOf("Tigh")].length === 1 && characterPresent(
									"Athena") && !noDrawback(getPlayerNum("Tigh"))) {
								plainAlert("Tigh is Alcoholic, but Athena may Love him.");
								z.randomLove[getPlayerNum("Tigh")] = true;
								if(z.round === z.andersBenchRound && z.players[z.turn] === "Anders" && !noDrawback(z.turn)) {
									plainAlert("Anders Starts on the Bench.");
									if(!z.vBrutality) {
										z.drawSkills = false;
										z.phase = 1;
									}
								} if(z.players[z.turn] === "Athena" && (newPlayerLoc === "Brig" || newPlayerLoc === "Sickbay" ||
										newPlayerLoc === "Medical Center" || newPlayerLoc === "Detention" || newPlayerLoc ===
										"Resurrection Ship")) {
									plainAlert("Athena is Grieving.");
									z.drawSkills = false;
									z.phase = 1;
								} else if(newPlayerLoc === "Hub Destroyed") {
									if(z.superCrisisHands[z.turn].length > 0) {
										plainAlert(z.players[z.turn] +
											" must discard any Super Crises they have after Alcoholic is resolved.");
										addOption(z.turn, "Discard all Super Crisis cards", undefined, true);
									}
									z.drawSkills = false;
								} else {
									plainAlert(z.players[z.turn] + " must take their Receive Skills step after Alcoholic is resolved.");
								}
							}
							if(z.humanExecuted === -1 && z.cylonExecuted === -1 && !z.executedCurrentPlayer) {
								startThatTurn();
							}
						}
					}
					mainMenu();
				};
				if(goodToEndTurn) {
					endThatTurn();
				} else {
					mainMenu();
				}
			});
		} else if (ch === "Draw a Trauma from my location"){
			let newPlayer = z.players[z.turn];
			let newPlayerLoc = z.playerLocations[z.turn];
			if(z.preCrossroads && !z.vAltTrauma && newPlayerLoc === "Sickbay") {
				let trauma = z.sickbayTrauma;
				if(trauma === undefined && (!z.vEuropeanTrauma || z.brigTrauma === undefined)){
					if(z.traumaPile.length === 0){
						t.value += "There is no Trauma in Sickbay or the Trauma pile; no effect.\r\n";
					} else {
						trauma = z.traumaPile.pop();
						t.value += "There is no Trauma in Sickbay; one is drawn from the Trauma pile instead.\r\n";
					}
				} else if (trauma === undefined && z.vEuropeanTrauma){
					trauma = z.brigTrauma;
				}
				if(trauma === 0) {
					z.antagonistic[z.turn]++;
					t.value += newPlayer + " draws a Trauma from Sickbay, and survives.\r\n";
					if(z.vEuropeanTrauma){
						z.brigTrauma = z.traumaPile.pop();
					} else {
						z.sickbayTrauma = z.traumaPile.pop();
					}
				} else if(trauma === 1) {
					z.benevolent[z.turn]++;
					t.value += newPlayer + " draws a Trauma from Sickbay, and survives.\r\n";
					if(z.vEuropeanTrauma){
						z.brigTrauma = z.traumaPile.pop();
					} else {
						z.sickbayTrauma = z.traumaPile.pop();
					}
				} else if(trauma === -1) {
					addAlert(newPlayer + " draws a DISASTER token from Sickbay, and is executed!");
					t.value += bold(newPlayer + " draws a " + colorText("red", "DISASTER") + " token from Sickbay!") + "\r\n";
					executePlayer(z.turn,
					false); /* TODO: you are executed by disaster trauma, pick an char corresponding to ally on the board, new ally trauma is placed randomly.  That same disaster token is not reshuffled until AFTERWARDS, then new sickbay/brig trauma placed */
					t.value += "Reshuffling Disaster Token.\r\n";
					z.traumaPile.push(-1);
					shuffle(z.traumaPile);
					if(z.vEuropeanTrauma){
						z.brigTrauma = z.traumaPile.pop();
					} else {
						z.sickbayTrauma = z.traumaPile.pop();
					}
					z.drawSkills = false;
					z.phase = 4;
				}
			}
			if(z.preCrossroads && !z.vAltTrauma && newPlayerLoc === "Brig") {
				if(z.brigTrauma === undefined){
					if(z.traumaPile.length === 0){
						t.value += "There is no Trauma in the Brig or the Trauma pile; no effect.\r\n";
					} else {
						z.brigTrauma = z.traumaPile.pop();
						t.value += "There is no Trauma in the Brig; one is drawn from the Trauma pile instead.\r\n";
					}
				}
				if(z.brigTrauma === 0) {
					z.antagonistic[z.turn]++;
					t.value += newPlayer + " draws a Trauma from the Brig, and survives.\r\n";
					z.brigTrauma = z.traumaPile.pop();
				} else if(z.brigTrauma === 1) {
					z.benevolent[z.turn]++;
					t.value += newPlayer + " draws a Trauma from the Brig, and survives.\r\n";
					z.brigTrauma = z.traumaPile.pop();
				} else if(z.brigTrauma === -1) {
					addAlert(newPlayer + " draws a DISASTER token from the Brig, and is executed!");
					t.value += bold(newPlayer + " draws a " + colorText("red", "DISASTER") + " token from the Brig!") + "\r\n";
					executePlayer(z.turn, false);
					t.value += "Reshuffling Disaster Token.\r\n";
					z.traumaPile.push(-1);
					shuffle(z.traumaPile);
					z.brigTrauma = z.traumaPile.pop();
					z.drawSkills = false;
					z.phase = 7;
				}
			}
			if(z.humanExecuted === -1 && z.cylonExecuted === -1 && !z.executedCurrentPlayer && !hasOption(me,"Trigger Tigh's Alcoholic")) {
				z.drawSkills = true;
				removeOption(me,"Manipulative (OPG)");
				startThatTurn();
			}
			removeOption(me,ch);
			mainMenu();
		} else if(ch === "Trigger Tigh's Alcoholic"){
			if(characterPresent("Tigh") && z.skillCardHands[z.players.indexOf("Tigh")].length === 1 && !characterPresent(
					"Athena") && !noDrawback(getPlayerNum("Tigh"))) {
				addAlert("Dammit, Saul, you have lupus!");
				t.value += "Tigh is Alcoholic.\r\n";
				discardRandomSkillCard(z.players.indexOf("Tigh"));
			}
			if(characterPresent("Tigh") && z.skillCardHands[z.players.indexOf("Tigh")].length === 1 && characterPresent(
					"Athena") && !noDrawback(getPlayerNum("Tigh"))) {
				plainAlert("Tigh is Alcoholic, but Athena may Love him.");
				z.randomLove[getPlayerNum("Tigh")] = true;
			}
			if(!hasOption(me,"Draw a Trauma from my location")){
				z.drawSkills = true;
				removeOption(me,"Manipulative (OPG)");
				startThatTurn();
			}
			removeOption(me,ch);
			mainMenu();
		} else if(ch === "Check for BYC updates") {
			confirmify(
				"Confirming you want to quit BYC and apply any pending updates.\n\nYou probably don't want to do this unless you were instructed to do so.",
				mainMenu, () => {
					window.localStorage.setItem("bycUrgent", "requested");
					saveAndQuit();
				});
		} else if(ch === "Change your default banner") {
			let chr = getCharacter(z.players[me]);
			let defaultBanner = d.banners[chr];
			if(me === z.president && me === z.admiral) {
				defaultBanner = d.dictatorBanners[chr];
			} else if(me === z.president) {
				defaultBanner = d.presidentBanners[chr];
			} else if(me === z.admiral) {
				defaultBanner = d.admiralBanners[chr];
			} else if(me === z.cag) {
				defaultBanner = d.cagBanners[chr];
			} else if(z.revealedCylons[me] === 1) {
				defaultBanner = d.cylonBanners[chr];
			}
			let changeBanner = function() {
				promptString("What imageID would you like to use for your new banner?", mainMenu, (prompted0) => {
					let prompted = parseInt(prompted0);
					if(isNaN(prompted0) || 1 > prompted0) {
						changeBanner();
					} else {
						let bannerRegExp = new RegExp("\\[ima" + bl + "geid=" + z.banners[me] + " medium\\]", "g");
						t.value = t.value.replace(bannerRegExp, "");
						z.banners[me] = prompted;
						mainMenu();
					}
				}, "" + defaultBanner);
			};
			changeBanner();
		} else if(ch === "Destroy Raider(s)") {
			let context = getContext(me, ch);
			if(context === "Nuke" || context === "Main Batteries" || ch === "Best of the Best") {
				confirmify("Confirming you want to destroy a regular raider in Scar's sector, instead of Scar.", mainMenu, () => {
					for(let j = 0; !(j >= z.raiders.length); j++) {
						if(z.raiders[j] === z.scar) {
							z.raiders[j] = 0;
							plainAlert("Destroyed a Raider in Sector " + z.scar + ".");
							if(j === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
								z.heavyCasualties-=1;
								if(0 > z.heavyCasualties){
									z.heavyCasualties = 0;
								}
								let left = 0;
								for(let j = 0; !(j>=z.raiders.length); j++){
									if(z.raiders[j] === 6){
										left++;
									}
								}	
								if(left > z.heavyCasualties){
									plainAlert("BYC assumes the raider destroyed was one just placed by Besieged; if not, you can fix this in the deep menus.");
								}
							}
							removeOption(me, ch);
							removeOption(me, "Destroy Scar");
							mainMenu();
							break;
						}
					}
				});
			} else if(context === "Apollo") {
				let viperSectors = [0, 0, 0, 0, 0, 0];
				for(let j = 0; !(j >= z.vipersII.length); j++) {
					if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
						viperSectors[z.vipersII[j] - 1]++;
					}
				}
				for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
					if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
						viperSectors[z.vipersVII[j] - 1]++;
					}
				}
				for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
					if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
						viperSectors[z.assaultRaptors[j] - 1]++;
					}
				}
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(viperSectors[z.raiders[j] - 1] === 1) {
						break;
					}
				}
				let apolloAlly = function(sector) {
					if(sector === 6) {
						/* TODO: clear the ally */
						removeOption(me, ch);
						mainMenu();
					} else {
						if(viperSectors[sector] === 0) {
							apolloAlly(sector + 1);
						} else {
							let raiderTargets = 0;
							for(let j = 0; !(j >= z.raiders.length); j++) {
								if(z.raiders[j] - 1 === sector) {
									raiderTargets++;
								}
							}
							if(raiderTargets === 0) {
								apolloAlly(sector + 1);
							} else {
								if(raiderTargets > viperSectors[sector]) {
									raiderTargets = viperSectors[sector];
								}
								promptNum("How many Raiders do you want to destroy? (0-" + raiderTargets + ")", (a) => 0 > a || a > raiderTargets,
								() => {
									apolloAlly(sector);
								}, (prompted) => {
									if(prompted === 0) {
										plainAlert(z.players[me] + " chose not to destroy any Raiders in Sector " + (sector + 1) + ".");
									} else if(prompted === 1) {
										plainAlert("Destroyed 1 Raider in Sector " + (sector + 1) + ".");
									} else {
										plainAlert("Destroyed " + prompted + " Raiders in Sector " + (sector + 1) + ".");
									}
									
									let count = 0;
									for(let j = 0; !(j >= z.raiders.length) && prompted > count; j++) {
										if(z.raiders[j] - 1 === sector) {
											z.raiders[j] = 0;
											count++;
										}
									}
									if(sector + 1 === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0 && prompted > 0){
										let c = prompted;
										z.heavyCasualties-=c;
										if(0 > z.heavyCasualties){
											z.heavyCasualties = 0;
										}
										let left = 0;
										for(let j = 0; !(j>=z.raiders.length); j++){
											if(z.raiders[j] === 6){
												left++;
											}
										}	
										if(left > z.heavyCasualties){
											plainAlert("BYC assumes the raiders placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
										}
									}
									if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
										plainAlert(
											"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
										z.dogfightCAC = false;
										if(z.galacticaReturned){
											z.oldCrisisDiscards.push(76);
										} else {
											z.crisisDiscards.push(76);
										}
									}
									apolloAlly(sector + 1);
								});
							}
						}
					}
				};
				apolloAlly(0);
			} else if(context === "Hot Dog") {
				let promptText = "Which sector would you like to destroy 2 raiders in? (1-6)";
				let raiders = [0, 0, 0, 0, 0, 0];
				for(let j = 0; !(j >= z.raiders.length); j++) {
					if(z.raiders[j] > 0) {
						raiders[z.raiders[j] - 1]++;
					}
				}
				for(let j = 1; !(j > 6); j++) {
					promptText += "\nSector " + j + " (" + raiders[j - 1] + " Raider";
					if(raiders[j - 1] !== 1) {
						promptText += "s";
					}
					promptText += ")";
				}
				promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
					let count = 0;
					for(let j = 0; !(j >= z.raiders.length) && 2 > count; j++) {
						if(z.raiders[j] === prompted) {
							z.raiders[j] = 0;
							count++;
						}
					}
					if(count === 1) {
						plainAlert("Destroyed 1 Raider in Sector " + prompted + ".");
					} else {
						plainAlert("Destroyed " + count + " Raiders in Sector " + prompted + ".");
					}
					if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
						plainAlert(
							"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					}
					if(prompted === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
						z.heavyCasualties-=count;
						if(0 > z.heavyCasualties){
							z.heavyCasualties = 0;
						}
						let left = 0;
						for(let j = 0; !(j>=z.raiders.length); j++){
							if(z.raiders[j] === 6){
								left++;
							}
						}	
						if(left > z.heavyCasualties){
							plainAlert("BYC assumes the raiders placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
						}
					}
					removeOption(me, ch);
					mainMenu();
				});
			} else if(context && context[0] === "Civilian Self Defense") {
				let sector = context[1];
				let ship = context[2];
				confirmify("Confirming you want to destroy 3 Raiders in Sector " + sector + ".", mainMenu, () => {
					let numDestroyed = 0;
					for(let j = 0; !(j >= z.raiders.length) && 3 > numDestroyed; j++) {
						if(z.raiders[j] === sector) {
							z.raiders[j] = 0;
							numDestroyed++;
						}
					}
					if(numDestroyed === 1) {
						plainAlert("Destroyed 1 Raider in Sector " + sector + ".");
					} else {
						plainAlert("Destroyed " + numDestroyed + " Raiders in Sector " + sector + ".");
					}
					if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
						plainAlert(
							"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					}
					if(sector === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
						z.heavyCasualties-=numDestroyed;
						if(0 > z.heavyCasualties){
							z.heavyCasualties = 0;
						}
						let left = 0;
						for(let j = 0; !(j>=z.raiders.length); j++){
							if(z.raiders[j] === 6){
								left++;
							}
						}	
						if(left > z.heavyCasualties){
							plainAlert("BYC assumes the raiders placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
						}
					}
					removeOption(me, ch);
					removeOption(me, "Destroy a Heavy Raider");
					SPTokenBad("Civilian Self Defense (" + ship + ")");
					mainMenu();
				});
			} else if(context && context[0] === "Sacrifice") {
				confirmify("Confirming you want to destroy 5 Raiders in Sector " + context[1] + ".", mainMenu, () => {
					let count = 0;
					for(let j = 0; !(j >= z.raiders.length) && 5 > count; j++) {
						if(z.raiders[j] === context[1]) {
							z.raiders[j] = 0;
							count++;
						}
					}
					if(count === 1) {
						plainAlert("Destroyed 1 Raider in Sector " + context[1] + ".");
					} else {
						plainAlert("Destroyed " + count + " Raiders in Sector " + context[1] + ".");
					}
					if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
						plainAlert(
							"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
						z.dogfightCAC = false;
						if(z.galacticaReturned){
							z.oldCrisisDiscards.push(76);
						} else {
							z.crisisDiscards.push(76);
						}
					}
					if(context[1] === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
						z.heavyCasualties-=count;
						if(0 > z.heavyCasualties){
							z.heavyCasualties = 0;
						}
						let left = 0;
						for(let j = 0; !(j>=z.raiders.length); j++){
							if(z.raiders[j] === 6){
								left++;
							}
						}	
						if(left > z.heavyCasualties){
							plainAlert("BYC assumes the raiders placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
						}
					}
					removeOption(me, ch);
					removeOption(me, "Destroy a Heavy Raider");
					removeOption(me, "Destroy a basestar");
					removeOption(me, "Destroy a Civilian in space");
					mainMenu();
				});
			} else {
				promptNum("Which sector would you like to destroy Raiders in? (1-6)", (a) => 1 > a || a > 6, mainMenu, (prompted) => {
					let raiderCount = 0;
					for(let i = 0; !(i >= z.raiders.length); i++) {
						if(z.raiders[i ] === prompted) {
							raiderCount++;
						}
					}
					if(raiderCount === 0) {
						addAlert("There are no Raiders in Sector " + prompted);
						mainMenu();
					} else {
						if(context) {
							if(raiderCount > context[1]) {
								raiderCount = context[1];
							}
						}
						promptNum("How many raiders would you like to destroy? (1-" + raiderCount + ")", (a) => 1 > a || a > raiderCount,
							mainMenu, (prompted2) => {
								let movedRaiders = 0;
								for(let i = 0; !(i >= z.raiders.length) && !(movedRaiders >= prompted2); i++) {
									if(z.raiders[i ] === prompted) {
										z.raiders[i ] = 0;
										movedRaiders++;
									}
								}
								boldAlert("Destroyed " + prompted2 + " Raiders in Sector " + prompted + ".");
								if(z.dogfightCAC && raidersAway() === z.raiders.length && !z.scarCAC) {
									plainAlert(
										"All Raiders on the game board have been destroyed; Constant Barrage [Dogfight CAC] cancelled.");
									z.dogfightCAC = false;
									if(z.galacticaReturned){
										z.oldCrisisDiscards.push(76);
									} else {
										z.crisisDiscards.push(76);
									}
								}
								if(prompted === 6 && Number.isInteger(z.heavyCasualties) && z.heavyCasualties > 0){
									z.heavyCasualties-=prompted2;
									if(0 > z.heavyCasualties){
										z.heavyCasualties = 0;
									}
									let left = 0;
									for(let j = 0; !(j>=z.raiders.length); j++){
										if(z.raiders[j] === 6){
											left++;
										}
									}	
									if(left > z.heavyCasualties){
										plainAlert("BYC assumes the raiders placed by Besieged were prioritized; if not, you can fix this in the deep menus.");
									}
								}
								if(context) {
									let num = context[1];
									let subcontext = context[0];
									let man = isMandatory(me, ch);
									
									if(subcontext === "ABF") {
										removeOption(me, "Destroy a Heavy Raider");
										removeOption(me, "Destroy a Centurion");
									}
									if(num > prompted2 && z.raiders.length > raidersAway()) {
										addOption(me, ch, [subcontext, num - prompted2], man);
									} else {
										removeOption(me, ch);
									}
								}
								mainMenu();
							});
					}
				});
			}
		} else if(ch === "Place Raider(s) on the main game board") {
			let promptText = "Which sector would you like to place Raider(s) in? (1-6)";
			let context = getContext(me, ch);
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(Array.isArray(context) && context[j - 1] === 0) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 6 || (Array.isArray(context) && context[a - 1] === 0), mainMenu, (prompted) => {
				let raiderMax = raidersAway();
				if(hasContext(me, ch, "Necessary Risk")) {
					if(raiderMax > 3) {
						raiderMax = 3;
					}
					for(let j = 0; !(j >= raiderMax); j++) {
						placeRaider(prompted);
					}
					if(basestarsAway() > 0) {
						placeBasestar(prompted);
						removeOption(me, "Place a basestar on the main game board");
					}
					removeOption(me, ch);
					mainMenu();
				} else if(hasContext(me, ch, "Raider Bay")) {
					if(raiderMax > 2) {
						raiderMax = 2;
					}
					for(let j = 0; !(j >= raiderMax); j++) {
						placeRaider(prompted);
					}
					let numActivating = 0;
					resetRaiderActivations();
					for(let j = 0; !(j >= z.raiders.length); j++) {
						if(z.raiders[j] !== prompted) {
							z.raiderActivated[j] = 1;
						} else if(raiderMax > numActivating) {
							numActivating++;
						} else {
							z.raiderActivated[j] = 1;
						}
						z.activatingSector = prompted;
						optionForAll("Resume Raider Activation");
					}
					removeOption(me, "Place a Viper Mk II in space");
					removeOption(me, "Place a Viper Mk VII in space");
					removeOption(me, "Place an Assault Raptor in space");
					removeOption(me, ch);
					mainMenu();
				} else {
					if(raiderMax > 4) {
						raiderMax = 4;
					}
					if(Array.isArray(context) && raiderMax > context[prompted - 1]) {
						raiderMax = context[prompted - 1];
					}
					promptNum("How many raiders would you like to place in Sector " + prompted + "? (1-" + raiderMax + ")", (a) => 1 > a || a >
						raiderMax, mainMenu, (prompted2) => {
							for(let i = 0; !(i >= prompted2); i++) {
								placeRaider(prompted);
							}
							if(raidersAway() === 0) {
								removeOption(me, ch);
							} else if(Array.isArray(context)) {
								let man = isMandatory(me, ch);
								let added = false;
								context[prompted - 1] -= prompted2;
								let total = 0;
								for(let j = 0; !(j >= 6); j++) {
									total += context[j];
									if(total > 0) {
										added = true;
										addOption(me, ch, context, man);
										break;
									}
								}
								if(!added){
									removeOption(me, ch);	
								}
							}
							mainMenu();
						});
				}
			});
		} else if(ch === "Activate Occupation Forces") {
			confirmify("Confirming you want to process an Activate Occupation Forces icon.", mainMenu, () => {
				activateOFs();
				if(z.toDoOFs && !hasOption(me,ch)) {
					z.toDoOFs = false;
					primeJumpIcon();
				}
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Activate Raiders") {
			confirmify("Confirming you want to process an Activate Raiders icon.", mainMenu, () => {
				activateRaiders();
				if(z.toDoRaiders && !hasOption(me,ch)) {
					z.toDoRaiders = false;
					if(!z.toDoOFs) {
						primeJumpIcon();
					}
				}
				if(hasContext(me, ch, "Miraculous Return")) {
					addAlert("Now, activate Raiders again.");
					removeFromAll(ch);
					optionForAll("Activate Raiders");
				} else {
					removeFromAll(ch);
				}
				mainMenu();
			});
		} else if(ch === "Destroy a Centurion") {
			let boardHeavies = [];
			let promptText = "";
			for(let i = 0; !(i >= z.centurions.length); i++) {
				if(z.centurions[i ] > 0) {
					boardHeavies.push(i);
					promptText += boardHeavies.length + ": The Centurion on space " + z.centurions[i ] + " of the Boarding Party Track.\n";
				}
			}
			promptText = "Which Centurion would you like to destroy? (1-" + boardHeavies.length + ")\n" + promptText;
			promptNum(promptText, (a) => 1 > a || a > boardHeavies.length, mainMenu, (prompted) => {
				boldAlert("Destroyed Centurion on space " + z.centurions[boardHeavies[prompted - 1]] + " of the Boarding Party Track.");
				z.centurions[boardHeavies[prompted - 1]] = 0;
				if(hasContext(me, ch, "ABF")) {
					removeOption(me, "Destroy a Heavy Raider");
					removeOption(me, "Destroy Raider(s)");
				}
				if(z.vBrutality && characterPresent("Karl") && !noDrawback(getPlayerNum("Karl"))) {
					t.value += "Karl's Conflicted triggers.\r\n";
					if(getPlayerNum("Karl") === z.destroyer && z.pegasus && !z.majorVictory && z.possibleColors[z.destroyer][1] === 1 &&
						hasContext(me, ch, "ABF")) {
						promptAllyDiscards(z.destroyer, 2, true);
					} else {
						promptAllyDiscards(getPlayerNum("Karl"), 2);
					}
				}
				if(Number.isInteger(z.destroyer) && z.destroyer >= 0 && z.possibleColors[z.destroyer][1] === 1 && z.pegasus && !z
					.majorVictory && hasContext(me, ch, "ABF")) {
					plainAlert(z.players[z.destroyer] + " may want to use Major Victory here.");
					let mv = false;
					for(let j = 0; !(j >= z.skillCardHands[z.destroyer].length) && !mv; j++) {
						mv = cardName(z.skillCardHands[z.destroyer][j]) === "Major Victory";
					}
					if(mv) {
						addOption(z.destroyer, "Play a Major Victory", undefined, false);
					}
				}
				removeFromAll(ch);
				mainMenu();
			});
		} else if(ch === "Place a Centurion at the start of the Boarding Party Track") {
			confirmify("Confirming you want to place a Centurion on board Galactica (not one coming from a Heavy Raider).", mainMenu, () => {
				boardGalactica();
				boldAlert("A Centurion boards Galactica.");
				mainMenu();
			});
		} else if(ch === "Have a Heavy Raider board Galactica") {
			let boardHeavies = [];
			let promptText = "";
			for(let i = 0; !(i >= z.heavies.length); i++) {
				if(z.heavies[i ] === 5 || z.heavies[i ] === 6) {
					boardHeavies.push(i);
					promptText += boardHeavies.length + ": The Heavy Raider in Sector " + z.heavies[i ] + ".\n";
				}
			}
			promptText = "Which Heavy Raider would you like to have board Galactica? (1-" + boardHeavies.length + ")\n" + promptText;
			promptNum(promptText, (a) => 1 > a || a > boardHeavies.length, mainMenu, (prompted) => {
				boldAlert("Heavy Raider in Sector " + z.heavies[boardHeavies[prompted - 1]] + " boards Galactica.");
				z.heavies[boardHeavies[prompted - 1]] = 0;
				boardGalactica();
				if(centurionReserves() === 0) {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Activate Heavy Raiders") {
			let confirmText = "Confirming you want to activate Heavy Raiders.";
			if(z.pegasus && !z.daybreak) {
				confirmText += "\n\nThis will include Centurions.";
			}
			confirmify(confirmText, mainMenu, () => {
				activateHeavies();
				if(z.toDoHeavies && !hasOption(me,ch)) {
					z.toDoHeavies = false;
					if(!z.toDoOFs) {
						primeJumpIcon();
					}
				}
				removeFromAll(ch);
				mainMenu();
			});
		} else if(ch === "Activate Heavy Raiders from By Your Command") {
			let confirmText = "Confirming you want to activate Heavy Raiders from By Your Command.\n\nThis will NOT activate Centurions.";
			confirmify(confirmText, mainMenu, () => {
				activateHeavies(true);
				removeOption(me, ch);
				if(z.galacticaReturned) {
					addOption(me, "Activate Occupation Forces", undefined, true);
				}
				mainMenu();
			});
		} else if(ch === "Destroy a Heavy Raider") {
			let context = getContext(me, ch);
			if(Array.isArray(context) && (context[0] === "Sacrifice" || context[0] === "Civilian Self Defense")) {
				let sector = context[1];
				confirmify("Confirming you want to destroy a Heavy Raider in Sector " + sector + ".", mainMenu, () => {
					for(let j = 0; !(j >= z.heavies.length); j++) {
						if(z.heavies[j] === sector) {
							z.heavies[j] = 0;
							plainAlert("Destroyed a Heavy Raider in Sector " + sector + ".");
							break;
						}
					}
					removeOption(me, "Destroy Raider(s)");
					removeOption(me, "Destroy a basestar");
					removeOption(me, "Destroy a Civilian in space");
					if(context[0] === "Civilian Self Defense") {
						SPTokenBad("Civilian Self Defense (" + context[2] + ")");
					}
					removeOption(me, ch);
					mainMenu();
				});
			} else {
				let boardHeavies = [];
				let promptText = "";
				for(let i = 0; !(i >= z.heavies.length); i++) {
					if(z.heavies[i ] > 0) {
						boardHeavies.push(i);
						promptText += boardHeavies.length + ": The Heavy Raider in Sector " + z.heavies[i ] + ".\n";
					}
				}
				promptText = "Which Heavy Raider would you like to destroy? (1-" + boardHeavies.length + ")\n" + promptText;
				promptNum(promptText, (a) => 1 > a || a > boardHeavies.length, mainMenu, (prompted) => {
					boldAlert("Destroyed Heavy Raider in Sector " + z.heavies[boardHeavies[prompted - 1]]);
					z.heavies[boardHeavies[prompted - 1]] = 0;
					removeOption(me, ch);
					if(context === "ABF") {
						removeOption(me, "Destroy Raider(s)");
						removeOption(me, "Destroy a Centurion");
					}
					mainMenu();
				});
			}
		} else if(ch === "Place a Heavy Raider on the main game board") {
			let promptText = "Which sector would you like to place a Heavy Raider in? (1-6)";
			let context = getContext(me, ch);
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(Array.isArray(context) && context[j - 1] === 0) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 6 || (Array.isArray(context) && context[a - 1] === 0), mainMenu, (prompted) => {
				placeHeavy(prompted);
				addAlert("Placed a Heavy Raider in Sector " + prompted);
				if(heaviesAway() === 0) {
					removeOption(me, ch);
				} else if(Array.isArray(context)) {
					let man = isMandatory(me, ch);
					
					context[prompted - 1] -= 1;
					let total = 0;
					let added = false;
					for(let j = 0; !(j >= 6); j++) {
						total += context[j];
						if(total > 0) {
							added = true;
							addOption(me, ch, context, man);
							break;
						}
					}
					if(!added){
						removeOption(me, ch);
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch Raiders") {
			confirmify("Confirming you want to process a Launch Raiders icon.", mainMenu, () => {
				launchRaiders();
				if(z.toDoLaunchRaiders && !hasOption(me,ch)) {
					z.toDoLaunchRaiders = false;
					if(!z.toDoOFs) {
						primeJumpIcon();
					}
				}
				removeFromAll(ch);
				mainMenu();
			});
		} else if(ch === "Place a basestar on the main game board") {
			let promptText = "Which sector would you like to place a Basestar in? (1-6)";
			let context = getContext(me, ch);
			for(let j = 1; !(j > 6); j++) {
				promptText += "\n" + j + ": ";
				if(Array.isArray(context) && context[j - 1] === 0) {
					promptText += "(cannot place here)";
				} else {
					promptText += "Sector " + j;
				}
			}
			promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
				addAlert("Placed a basestar in Sector " + prompted);
				placeBasestar(prompted);
				if(hasContext(me, ch, "Necessary Risk")) {
					let numRaiders = raidersAway();
					if(numRaiders > 3) {
						numRaiders = 3;
					}
					if(numRaiders > 0) {
						placeRaiders(prompted, numRaiders);
					}
					removeOption(me, "Place Raider(s) on the main game board");
				}
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Damage a basestar") {
			confirmify("Confirming you want to damage a basestar on the main game board.", mainMenu, () => {
				let firstNuke = false;
				if(hasContext(me, ch, "Nuke")) {
					let man = isMandatory(me, ch);
					addOption(me, ch, undefined, man);
					firstNuke = true;
				} else {
					removeOption(me, ch);
				}
				if(z.basestars.length > 0 && z.basestars[0][0] > 0 && z.basestars.length > 1 && z.basestars[1][0] > 0 && (z.basestars[0][0] !==
						z.basestars[1][0] || z.basestars[0].length > 1 || z.basestars[1].length > 1)) {
					let bs1 = basestarName(0);
					let bs2 = basestarName(1);
					confirmify("Which basestar do you want to damage?\n1: " + bs1 + "\n2: " + bs2, () => {
						addAlert("You damage the " + bs2);
						t.value += bold(bs2 + " damaged: ");
						damageBasestar(1);
						if(!firstNuke) {
							z.destroyer = -1;
						}
						mainMenu();
					}, () => {
						addAlert("You damage the " + bs1);
						t.value += bold(bs1 + " damaged: ");
						damageBasestar(0);
						if(!firstNuke) {
							z.destroyer = -1;
						}
						mainMenu();
					}, "Basestar 1", "Basestar 2");
				} else if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
					addAlert("Basestar damaged.");
					t.value += bold("Basestar damaged: ");
					if(z.basestars[0][0] > 0) {
						damageBasestar(0);
					} else {
						damageBasestar(1);
					}
					if(!firstNuke) {
						z.destroyer = -1;
					}
					mainMenu();
				}
			});
		} else if(ch === "Destroy a basestar") {
			confirmify("Confirming you want to destroy a basestar on the main game board.", mainMenu, () => {
				if(Array.isArray(getContext(me, ch))) {
					z.destroyer = me;
				} /* TODO: improve context for which basestar to be destroyed. */
				if(z.basestars.length > 0 && z.basestars[0][0] > 0 && z.basestars.length > 1 && z.basestars[1][0] > 0 && (z.basestars[0][0] !==
						z.basestars[1][0] || z.basestars[0].length > 1 || z.basestars[1].length > 1)) {
					let bs1 = basestarName(0);
					let bs2 = basestarName(1);
					confirmify("Which basestar do you want to destroy?\n1: " + bs1 + "\n2: " + bs2, () => {
						let sector = z.basestars[1][0];
						destroyBasestar(1);
						if(getContext(me, ch) === "Small Nuke" || Array.isArray(getContext(me, ch)) || (getContext(me, ch) ===
								"Big Nuke" && z.basestars[0][0] !== sector)) {
							removeOption(me, ch);
						}
						z.destroyer = -1;
						mainMenu();
					}, () => {
						addAlert("You destroy the " + bs1);
						let sector = z.basestars[0][0];
						destroyBasestar(0);
						if(getContext(me, ch) === "Small Nuke" || Array.isArray(getContext(me, ch)) || (getContext(me, ch) ===
								"Big Nuke" && z.basestars[1][0] !== sector)) {
							removeOption(me, ch);
						}
						z.destroyer = -1;
						mainMenu();
					}, "Basestar 1", "Basestar 2");
				} else if((z.basestars.length > 0 && z.basestars[0][0] > 0) || (z.basestars.length > 1 && z.basestars[1][0] > 0)) {
					addAlert("Basestar destroyed.");
					t.value += bold("Basestar damaged: ");
					if(z.basestars[0][0] > 0) {
						destroyBasestar(0);
					} else {
						destroyBasestar(1);
					}
					removeOption(me, ch);
					z.destroyer = -1;
					mainMenu();
				}
			});
		} else if(ch === "Reshuffle a Civilian" || ch === "Reshuffle a Civilian as an Action") {
			let context = getContext(me, ch);
			let civvies = spaceCiviliansList();
			let illegal = function(a) {
				if(1 > a || a > civvies.length) {
					return true;
				}
				if(Array.isArray(context)) {
					return civvies[a-1][1] + 1 !== context[1];
				}
				if(context !== undefined) {
					return false;
				}
				if(ch === "Reshuffle a Civilian as an Action") {
					let sector = parseInt(z.playerLocations[me].slice(7));
					if(civvies[a - 1][1] + 1 === sector) {
						return false;
					}
				} else {
					for(let j = 0; !(j >= z.vipersII.length); j++) {
						if(Number.isInteger(z.vipersII[j]) && z.vipersII[j] > 0) {
							if(z.vipersII[j] === civvies[a - 1][1] + 1) {
								return false;
							}
						}
					}
					for(let j = 0; z.CFB && !(j >= z.vipersVII.length); j++) {
						if(Number.isInteger(z.vipersVII[j]) && z.vipersVII[j] > 0) {
							if(z.vipersVII[j] === civvies[a - 1][1] + 1) {
								return false;
							}
						}
					}
					for(let j = 0; z.daybreak && !(j >= z.assaultRaptors.length); j++) {
						if(Number.isInteger(z.assaultRaptors[j]) && z.assaultRaptors[j] > 0) {
							if(z.assaultRaptors[j] === civvies[a - 1][1] + 1) {
								return false;
							}
						}
					}
				}
				return true;
			};
			let promptText = "Which civilian would you like to reshuffle? (1-" + civvies.length + ")\n";
			for(let i = 0; !(i >= civvies.length); i++) {
				promptText += "\n" + (i + 1) + ": ";
				if(illegal(i + 1)) {
					promptText += "(cannot be escorted now)";
				} else {
					promptText += "Civilian " + civvies[i ][0][0] + " (Sector " + (civvies[i ][1] + 1) + ")";
				}
			}
			promptNum(promptText, illegal, mainMenu, (prompted) => {
				t.value += bold(myPlayer + " reshuffles Civilian " + civvies[prompted - 1][0][0] + ".\r\n");
				let civ = z.spaceCivilians[civvies[prompted - 1][1]].splice(civvies[prompted - 1][2], 1)[0];
				z.civilianLetters.push(civ[0]);
				z.civilianPile.push(civ[1]);
				if(civ[2]) {
					z.reshuffledSeen = true;
				}
				if(civvies.length === 1) {
					z.reshuffledSeen = false;
				}
				shuffle(z.civilianPile);
				z.civilianLetters.sort();
				let context = getContext(me,ch);
				if(context !== undefined){
					if(Number.isInteger(context) && context > 1){
						removeOption(me, ch);
						destroyPileCivilian(context - 1);
					} else if(Array.isArray(context) && context[0] === "Nuke" && z.spaceCivilians[context[1] - 1].length > 0) {
						addOption(z.turn, ch, ["Nuke", context[1]], true);
					} else if(Array.isArray(context) && context[0] === "Sacrifice2" && z.spaceCivilians[context[1] - 1].length > 0) {
						addOption(z.turn, ch, ["Sacrifice", context[1]], true);
					} else if(Array.isArray(context) && context[0] === "Raider"){
						removeOption(me, ch);
						resetActivatingSector();
					} else {
						removeOption(me, ch);
					}
				} else if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
					removeOption(me, ch);
					let num = getContext(me, "Activate an unmanned Viper");
					let man = isMandatory(me, "Activate an unmanned Viper");
					removeOption(me, "Activate an unmanned Viper");
					if(num > 1) {
						addOption(me, "Activate an unmanned Viper", num - 1, man);
					} else {
						menuPage = "Default";
					}
				} else {
					removeOption(me, ch);
				}
				if(z.eventHorizon && z.gravityWell) {
					z.gravityWell = false;
				}
				if(ch === "Reshuffle a Civilian as an Action") {
					didAction();
				}
				mainMenu();
			});
		} else if(ch === "Destroy a Civilian in space") {
			let context = getContext(me, ch);
			let civvies = spaceCiviliansList();
			let promptText = "Which civilian would you like to destroy? (1-" + civvies.length + ")";
			for(let i = 0; !(i >= civvies.length); i++) {
				promptText += "\n" + (i + 1) + ": ";
				if((Array.isArray(context) && (context[1] === civvies[i ][1] + 1 || context[1] === civvies[i ][0][0])) ||  !Array.isArray(context)) {
					promptText += "Civilian " + civvies[i ][0][0] + " (Sector " + (civvies[i ][1] + 1) + ")";
				} else {
					promptText += "(cannot destroy this civilian)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > civvies.length || (Array.isArray(context) && civvies[a-1][1]+1 !== context[1] && context[1] !== civvies[a-1][0][0]),
				mainMenu, (prompted) => {
					let destroyShip = function() {
						plainAlert("Civilian " + civvies[prompted - 1][0][0] + " destroyed.");
						let done = destroyCivilian(civvies[prompted - 1][0][1]);
						z.spaceCivilians[civvies[prompted - 1][1]].splice(civvies[prompted - 1][2], 1);
						if(civvies.length === 1) {
							z.reshuffledSeen = false;
						}
						
						if(characterPresent("Hot Dog")){
							removeOption(getPlayerNum("Hot Dog"),"Escort (OPG)");
						}
						if(Number.isInteger(context) && context > 1) {
							removeOption(me, ch);
							destroyPileCivilian(context - 1);
						} else if(Array.isArray(context) && context[0] === "Nuke" && z.spaceCivilians[context[1] - 1].length > 0) {
							addOption(me, ch, ["Nuke", context[1]], true);
						} else if(Array.isArray(context) && context[0] === "Sacrifice2" && z.spaceCivilians[context[1] - 1].length > 0) {
							addOption(me, ch, ["Sacrifice", context[1]], true);
						} else if(Array.isArray(context) && context[0] === "Raider"){
							removeFromAll(ch);
							if(done){
								resetActivatingSector();
							} else {
								optionForAll("Resume Raider Activation");
							}
						} else if(Array.isArray(context) && context[0] === "Civilian Self Defense"){
							if(characterPresent("Tory") && hasOption(getPlayerNum("Tory"), "Draw 2 Skill Cards (any color)")) {
								plainAlert("Remember that Tory gets to draw 2 skill cards (of any color) from her Adaptable ability.");
							}
							removeFromAll(ch);
						} else {
							removeFromAll(ch);
						}
						mainMenu();
					};
					let anyInspected = false;
					if(Array.isArray(context) && z.spaceCivilians[context[1]-1].length > 1){
						for(let j = 0; !(j >= z.spaceCivilians[context[1]-1].length) && !anyInspected; j++) {
							anyInspected = z.spaceCivilians[context[1]-1][j][2];
						}
					}
					if((Array.isArray(context) && (context[0] === "Sacrifice2" || context[0] === "Sacrifice" || context[0] === "Nuke")) || Number.isInteger(context)){
						anyInspected = true;
					}
					let noHotDog = (Array.isArray[context] && context[0] === "Raider" && Number.isInteger(z.currentCrisis) && d.crisisNames[z.currentCrisis] === "Lured into a Trap") ||
								   (Array.isArray[context] && context[0] === "Raider" && Number.isInteger(z.currentSkillCheck) && d.crisisNames[z.currentSkillCheck] === "Fleet Mobilization") ||
								   (Number.isInteger(context) && Number.isInteger(z.currentSkillCheck) && d.crisisNames[z.currentSkillCheck] === "Fire All Missiles");
					if(characterPresent("Hot Dog") && z.miracles[getPlayerNum("Hot Dog")] && !z.theFarm && numUndamagedVipers() > 0 && !noHotDog) {
						if(z.escortPause){
							boldAlert(z.players[me]+" chooses to destroy Civilian "+civvies[prompted - 1][0][0]+".");
							boldAlert("A pause has been requested for Hot Dog's OPG; you should wait for his input before actually destroying the ship.");
							addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",context,false);
							confirmify("Are you sure you want to destroy this ship?  Only do so if you're sure Hot Dog is not using his OPG.", mainMenu,
								destroyShip);
						} else if(anyInspected){
							boldAlert(z.players[me]+" chooses to destroy Civilian "+civvies[prompted - 1][0][0]+".");
							plainAlert("Hot Dog could use his OPG here; you may want to wait for his input before actually destroying the ship.");
							addOption(getPlayerNum("Hot Dog"),"Escort (OPG)",context,false);
							confirmify("Are you sure you want to destroy this ship?  Only do so if you're sure Hot Dog is not using his OPG.", mainMenu,
								destroyShip);
						} else {
							destroyShip();
						}
					} else {
						destroyShip();
					}
				});
		} else if(ch === "Repair a location") {
			let context = getContext(me, ch);
			if(context === "Repair") {
				confirmify("Confirming you want to repair the Hangar Deck.", mainMenu, () => {
					z.damagedLocations.splice(z.damagedLocations.indexOf("Hangar Deck"), 1);
					z.damage.push("Hangar Deck");
					boldAlert(z.players[me]+" repairs the Hangar Deck.");
					removeOption(me,"Repair a damaged Viper Mk II");
					removeOption(me,"Repair a damaged Viper Mk VII");
					removeOption(me, ch);
					mainMenu();
				});
			} else {
				let damages = [];
				let promptText = "";
				for(let j = 0; !(j >= z.damagedLocations.length); j++) {
					if(z.damagedLocations[j] !== "Food" && z.damagedLocations[j] !== "Fuel" && ((context !== "Chief" && context !== "Chief2") || !
							onPegasus(z.damagedLocations[j])) && (!z.pegasusDestroyed || !onPegasus(z.damagedLocations[j]))) {
						damages.push([z.damagedLocations[j], j]);
						promptText += damages.length + ": " + z.damagedLocations[j] + "\n";
					}
				}
				promptText = "Which location would you like to repair? (1-" + damages.length + ")\n" + promptText;
				promptNum(promptText, (a) => 1 > a || a > damages.length, mainMenu, (prompted) => {
					let damage = z.damagedLocations.splice(damages[prompted - 1][1], 1)[0];
					addAlert("Repairing " + damage);
					t.value += bold(damage + " repaired.\r\n");
					if(z.pegasus && onPegasus(damage) && !z.vAltDamage) {
						z.pegasusDamage.push(damage);
						shuffle(z.pegasusDamage);
					} else {
						z.damage.push(damage);
						shuffle(z.damage);
					}
					if(context === "Chief2") {
						if(damages.length > 1) {
							addOption(me, ch, "Chief", false);
						} else {
							removeOption(me, ch);
						}
						removeOption(me,"Repair a damaged Viper Mk II");
						removeOption(me,"Repair a damaged Viper Mk VII");
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			}
		} else if(ch === "Inspect/Move a Civilian in space") {
			/* TODO: fix this! (?) */
			let civvies = spaceCiviliansList();
			let context = getContext(me, ch);
			let promptText = "Which civilian would you like to inspect? (1-" + civvies.length + ")";
			for(let i = 0; !(i >= civvies.length); i++) {
				promptText += "\n" + (i + 1) + ": ";
				if(context === undefined || 
				   (z.players[me] === "Dee" && z.revealedCylons[me] === 0) || 
				   (Array.isArray(z.metAlly) && d.allyNames[z.metAlly[0]] === "Dee") || 
				    2 > context.length || 
					context.includes(civvies[i ][0][0]) || 
					context.includes(civvies[i ][0][0].toLowerCase())) {
					promptText += "Civilian " + civvies[i ][0][0] + " (Sector " + (civvies[i ][1] + 1) + ")";
				} else {
					promptText += "(cannot inspect or move this civilian)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > civvies.length || (context !== undefined && (z.players[me] !== "Dee" || z.revealedCylons[me] ===
				1) && context.length >= 2 && !context.includes(civvies[a - 1][0][0]) && !context.includes(civvies[a - 1][0][0]
			.toLowerCase()) && (!Array.isArray(z.metAlly) || d.allyNames[z.metAlly[0]] !== "Dee")), mainMenu, (prompted) => {
				z.spaceCivilians[civvies[prompted - 1][1]][civvies[prompted - 1][2]][2] = true;
				addAlert("Civilian " + civvies[prompted - 1][0][0] + " contains " + civvies[prompted - 1][0][1] + ".");
				t.value += bold(myPlayer + " inspects Civilian " + civvies[prompted - 1][0][0] + ".\r\n");
				if(context !== undefined && context.includes(civvies[prompted - 1][0][0].toLowerCase())) {
					addAlert("You have already moved this civilian, and cannot move it again.");
					mainMenu();
				} else {
					let promptText = "Where would you like to move this civilian? (1-6)\nIf you don't want to move the civilian right away, press Cancel.";
					let leftSector = civvies[prompted - 1][1];
					let rightSector = (civvies[prompted - 1][1] + 2);
					if(leftSector === 0) {
						leftSector = 6;
					} else if(rightSector === 7) {
						rightSector = 1;
					}
					for(let j = 1; !(j>6); j++){
						promptText += "\n" + j + ": ";
						if(j === leftSector || j === rightSector){
							promptText += " Sector "+j;
						} else {
							promptText += " (cannot move here)";
						}
					}
					promptNum(promptText,(a)=>a!==leftSector && a !== rightSector,()=>{
						if(context !== undefined && !context.includes(civvies[prompted - 1][0][0])) {
							context.push(civvies[prompted - 1][0][0]);
						}
						addOption(me, ch, context, false);
						mainMenu();
					},(prompted2)=>{
						if(context !== undefined) {
							if(context.includes(civvies[prompted - 1][0][0])) {
								context.splice(context.indexOf(civvies[prompted - 1][0][0]), 1);
							}
							context.push(civvies[prompted - 1][0][0].toLowerCase());
							
							if(z.revealedCylons[me] === 1 || (z.players[me] !== "Dee" && (!Array.isArray(z.metAlly) || d.allyNames[z.metAlly[0]] !== "Dee")) ) {
								if(2 > context.length || context[0] === context[0].toUpperCase() || context[1] === context[1].toUpperCase()) {
									addOption(me, ch, context, false);
								} else {
									removeOption(me, ch);
								}
							} else {
								if(context.length !== civvies.length) {
									addOption(me, ch, context, false);
								} else {
									
									let movedAll = true;
									for(let j = 0; !(j >= context.length) && movedAll; j++) {
										movedAll = context[j] === context[j].toLowerCase();
									}
									if(!movedAll) {
										addOption(me, ch, context, false);
									} else {
										removeOption(me, ch);
									}
								}
							}
						}
						if(prompted2 === rightSector){
							addAlert("Moving it to Sector " + rightSector);
							t.value += bold(myPlayer + " moves Civilian " + civvies[prompted - 1][0][0] + " to Sector " +
								rightSector + ".\r\n");
							z.spaceCivilians[rightSector - 1].push(z.spaceCivilians[civvies[prompted - 1][1]].splice(civvies[
								prompted - 1][2], 1)[0]);
							mainMenu();
						} else {
							addAlert("Moving it to Sector " + leftSector);
							t.value += bold(myPlayer + " moves Civilian " + civvies[prompted - 1][0][0] + " to Sector " +
								leftSector + ".\r\n");
							z.spaceCivilians[leftSector - 1].push(z.spaceCivilians[civvies[prompted - 1][1]].splice(civvies[
								prompted - 1][2], 1)[0]);
							mainMenu();
						}
					});
					
				}
			});
		} else if(ch === "Inspect all Civilians in space") {
			/* TODO: option persistence */
			let confirmText = "Confirming you want to inspect all Civilians in space areas.";
			confirmify(confirmText, mainMenu, () => {
				let civilians = "Civilians in Space:";
				for(let j = 0; !(j >= 6); j++) {
					for(let k = 0; !(k >= z.spaceCivilians[j].length); k++) {
						z.spaceCivilians[j][k][2] = true;
						civilians += "\nCivilian " + z.spaceCivilians[j][k][0] + " (Sector " + (j + 1) + "): " + z.spaceCivilians[j][k][1];
					}
				}
				addAlert(civilians);
				t.value += bold(myPlayer + " inspects all civilians in space areas.") + "\r\n";
				confirmify("Would you like to add this information to your hand report for later perusal?", mainMenu, () => {
					addAlert("Added to your hand report.");
					z.secretMessages[me] += "\n" + civilians;
					mainMenu();
				}, "YES", "NO");
			});
		} else if(ch === "Draw and destroy a Civilian") {
			confirmify("Confirming you want to draw a civilian ship from the pile of civilian ships and immediately destroy it.", mainMenu, () => {
				let num = getContext(me, ch);
				removeFromAll(ch);
				if(Number.isInteger(num) && num) {
					destroyPileCivilian(num);
				} else {
					destroyPileCivilian(1);
				}
				if(num === "Miraculous Return"){
					addOption(z.crossroadsPlayer, "Damage a basestar", "Miraculous Return", true);
				}
				mainMenu();
			});
		} else if(ch === "Place a Civilian on the board") {
			let context = getContext(me, ch);
			let man = isMandatory(me, ch);
			if(Number.isInteger(context) && sectorsWithCivilians() !== 6) {
				let promptText = "Where would you like to place the Civilian? (1-6)";
				for(let j = 0; !(j >= 6); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.spaceCivilians[j].length > 0) {
						promptText += "(already has a civilian)";
					} else {
						promptText += "Sector " + (j + 1);
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 6 || z.spaceCivilians[a - 1].length > 0, mainMenu, (prompted) => {
					placeCivilian(prompted);
					
					if(context > 1 && z.civilianPile.length > 0) {
						addOption(me, ch, context - 1, man);
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			} else {
				let promptText = "Where would you like to place the Civilian? (1-6)";
				for(let j = 1; !(j > 6); j++) {
					promptText += "\n" + j + ": ";
					if(Array.isArray(context) && context[j - 1] === 0) {
						promptText += "(cannot place here)";
					} else {
						promptText += "Sector " + j;
					}
				}
				promptNum(promptText, (a) => 1 > a || a > 6 || (Array.isArray(context) && context[a - 1] === 0), mainMenu, (prompted) => {
					placeCivilian(prompted);
					if(z.civilianPile.length === 0) {
						removeOption(me, ch);
					} else if(context === "Medal of Distinction") {
						addOption(me, ch, "Medal of Distinction 2", man);
					} else if(Number.isInteger(context)) {
						
						if(context > 1) {
							addOption(me, ch, context - 1, man);
						} else {
							removeOption(me, ch);
						}
					} else if(Array.isArray(context)) {
						
						
						context[prompted - 1] -= 1;
						if(z.civilianPile.length !== 0) {
							let found = false;
							let total = 0;
							for(let j = 0; !(j >= 6); j++) {
								total += context[j];
								if(total > 0) {
									found = true;
									addOption(me, ch, context, man);
									break;
								}
							}
							if(!found){
								removeOption(me, ch);
							}
						} else {
							removeOption(me, ch);
						}
					} else if(context) {
						removeOption(me, ch);
					}
					mainMenu();
				});
			}
		} else if(ch === "Destroy a Raptor") {
			confirmify("Confirming you want to destroy a Raptor.", mainMenu, () => {
				destroyRaptor();
				mainMenu();
			});
		} else if(ch === "Repair a Raptor") {
			confirmify("Confirming you want to repair a Raptor.", mainMenu, () => {
				repairRaptor();
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Trigger Sleeper Phase") {
			confirmify("Confirming you want to trigger Sleeper Phase.", mainMenu, () => {
				sleeper();
				mainMenu();
			});
		} else if(ch === "[Blind Jump] Reveal the top Destination") {
			confirmify("Confirming you want to draw and process the top Destination for Blind Jump.", mainMenu, () => {
				let dest = z.destinationDeck.pop();
				z.destinationDiscards.push(dest);
				addAlert("Destination is " + d.destinationNames[dest] + ".");
				processDestination();
				mainMenu();
			});
		} else if(ch === "Choose a Destination") {
			let numDestinations = 2;
			if(missionSpecialist() !== "NONE") {
				t.value += colorText("orange", "Mission Specialist ") + missionSpecialist() + " looks at the Destinations.\r\n";
				numDestinations++;
			} else {
				t.value += colorText("green", "Admiral ") + z.players[z.admiral] + " looks at the Destinations.\r\n";
			}
			if(numDestinations > z.destinationDeck.length) {
				numDestinations = z.destinationDeck.length;
			}
			let promptText = "Which Destination does the fleet jump to? (1-" + numDestinations + ")\n";
			for(let i = 1; !(i > numDestinations); i++) {
				promptText += (i) + ": " + d.destinationNames[z.destinationDeck[z.destinationDeck.length - i]] + "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > numDestinations, mainMenu, (prompted) => {
				let destination = z.destinationDeck[z.destinationDeck.length - prompted];
				z.destinationDiscards.push(z.destinationDeck.splice(z.destinationDeck.length - prompted, 1)[0]);
				addAlert("Jumping to " + d.destinationNames[destination] + ".");
				if(numDestinations === 2) {
					z.destinationDeck.unshift(z.destinationDeck.pop());
					processDestination();
					mainMenu();
				} else if(numDestinations === 3) {
					confirmify("Which destination should be bottomed first?", () => {
						z.destinationDeck.unshift(z.destinationDeck.pop());
						z.destinationDeck.unshift(z.destinationDeck.pop());
						let hold = z.destinationDeck[0];
						z.destinationDeck[0] = z.destinationDeck[1];
						z.destinationDeck[1] = hold;
						for(let j = 0; !(j >= z.quorumTitles[me].length); j++) {
							if(d.quorumNames[z.quorumTitles[me][j]] === "Assign Mission Specialist") {
								z.quorumDiscards.push(z.quorumTitles[me].splice(j, 1)[0]);
								plainAlert("Assign Mission Specialist is discarded.");
								break;
							}
						}
						processDestination();
						mainMenu();
					}, () => {
						z.destinationDeck.unshift(z.destinationDeck.pop());
						z.destinationDeck.unshift(z.destinationDeck.pop());
						for(let j = 0; !(j >= z.quorumTitles[me].length); j++) {
							if(d.quorumNames[z.quorumTitles[me][j]] === "Assign Mission Specialist") {
								z.quorumDiscards.push(z.quorumTitles[me].splice(j, 1)[0]);
								plainAlert("Assign Mission Specialist is discarded.");
								break;
							}
						}
						processDestination();
						mainMenu();
					}, d.destinationNames[z.destinationDeck[z.destinationDeck.length - 1]], d.destinationNames[z.destinationDeck[z
						.destinationDeck.length - 2]]);
				} else if(numDestinations === 1) {
					processDestination();
					mainMenu();
				}
			});
		} else if(ch === "Decrease the Jump Preparation Track") {
			confirmify("Confirming you want to decrease the Jump Preparation Track.", mainMenu, () => {
				decreaseJump();
				mainMenu();
			});
		} else if(ch === "Advance the Jump Preparation Track") {
			let confirmText = "Confirming you want to advance the Jump Preparation Track.";
			if(z.jumpTrack === 4) {
				confirmText += "\nThis will trigger an Auto-Jump.";
			}
			confirmify(confirmText, mainMenu, () => {
				increaseJump();
				removeFromAll(ch);
				mainMenu();
			});
		} else if(ch === "Use a Nuke" || ch === "[Unauthorized Usage] Use a Nuke") {
			if(z.galacticaAway && ch === "Use a Nuke"){
				confirmify("Are you sure you want to throw away a Nuke?",mainMenu,()=>{
					z.nukes--;
					didAction();
					boldAlert("The Admiral conducts a nuclear test.");
					mainMenu();
				});
			} else if(z.CFB) {
				let promptText = "Which Sector are you targeting with the Nuke? (1-6)";
				promptNum(promptText, (a) => 1 > a || a > 6, mainMenu, (prompted) => {
					z.nukes--;
					z.destroyer = me;
					if(ch === "Use a Nuke") {
						didAction();
					}
					SPTokenBad("Nuke vs. Sector " + prompted);
					removeOption(me, ch);
					mainMenu();
				});
			} else if(basestarsAway() === z.basestars.length) {
				addAlert("There are no Basestars to target.");
				removeOption(me, ch);
				mainMenu();
			} else {
				confirmify("Nuclear Weapons Launch: Authorization Required", mainMenu, () => {
					z.nukes--;
					z.destroyer = me;
					if(ch === "Use a Nuke") {
						didAction();
					}
					if(z.basestars.length > 1 && z.basestars[0][0] > 0 && z.basestars[1][0] > 0 && (z.basestars[0][0] !== z.basestars[1][0] || z
							.basestars[0].length > 1 || z.basestars[1].length > 1)) {
						let bs1 = basestarName(0);
						let bs2 = basestarName(1);
						confirmify("Which basestar do you want to nuke?\nBasestar 1: " + bs1 + "\nBasestar 2: " + bs2, () => {
							SPTokenBad("Nuke vs. " + bs2);
							if(/Structural Damage/.test(bs2)) {
								z.dieRollModifier += 2;
								plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
							}
							removeOption(me, ch);
							mainMenu();
						}, () => {
							SPTokenBad("Nuke vs. " + bs1);
							if(/Structural Damage/.test(bs1)) {
								z.dieRollModifier += 2;
								plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
							}
							removeOption(me, ch);
							mainMenu();
						}, "Basestar 1", "Basestar 2");
					} else {
						for(let j = 0; !(j >= z.basestars.length); j++) {
							if(z.basestars[j][0] > 0) {
								let bs1 = basestarName(j);
								SPTokenBad("Nuke vs. " + bs1);
								if(/Structural Damage/.test(bs1)) {
									z.dieRollModifier += 2;
									plainAlert("The die roll receives a +2 bonus due to the basestar's Structural Damage.");
								}
								removeOption(me, ch);
								mainMenu();
								break;
							}
						}
					}
				}, "AUTHORIZE NUCLEAR LAUNCH", "CANCEL");
			}
		} else if(ch === "Use Alert Viper Pilot to jump in a Viper in space") {
			let promptText = "";
			for(let j = 0; !(j >= z.avp.length); j++) {
				if(!Number.isInteger(z.avp[j]) || 0 > z.avp[j]) {
					z.avp.splice(j, 1);
					j--;
					continue;
				}
				promptText += "\n" + (j + 1) + ": ";
				if(z.avp[j] >= 12) {
					promptText += "Assault Raptor in Sector " + z.assaultRaptors[z.avp[j] - 12];
				} else if(z.avp[j] >= 8) {
					promptText += "Viper Mk VII in Sector " + z.vipersVII[z.avp[j] - 8];
				} else {
					promptText += "Viper Mk II in Sector " + z.vipersII[z.avp[j]];
				}
			}
			if(z.avp.length === 0) {
				addAlert("There are no valid targets for Alert Viper Pilot at present.");
				removeOption(me, ch);
				mainMenu();
			} else {
				promptText = "Which viper would you like to jump into? (1-" + z.avp.length +
					")\nRemember that you may only use this on a Viper that was just placed in space." + promptText;
				promptNum(promptText, (a) => 1 > a || a > z.avp.length, mainMenu, (prompted) => {
					let type = "";
					let sector = 0;
					if(z.avp[prompted - 1] >= 12) {
						type = "an Assault Raptor";
						sector = z.assaultRaptors[z.avp[prompted - 1] - 12];
					} else if(z.avp[prompted - 1] >= 8) {
						type = "a Viper Mk VII";
						sector = z.vipersVII[z.avp[prompted - 1] - 8];
					} else {
						type = "a Viper Mk II";
						sector = z.vipersII[z.avp[prompted - 1]];
					}
					confirmify("Confirming you want to jump into " + type + " in Sector " + sector + ".", mainMenu, () => {
						z.playerLocations[me] = "Sector " + sector;
						boldAlert("Apollo uses Alert Viper Pilot to jump into " + type + " in Sector " + sector + ".");
						if(z.avp[prompted - 1] >= 12) {
							z.assaultRaptors[z.avp[prompted - 1] - 12] = "Apollo";
						} else if(z.avp[prompted - 1] >= 8) {
							z.vipersVII[z.avp[prompted - 1] - 8] = "Apollo";
						} else {
							z.vipersII[z.avp[prompted - 1]] = "Apollo";
						}
						removeOption(me, ch);
						z.avp = [];
						z.AVPAction = true;
						mainMenu();
					});
				});
			}
		} else if(ch === "Move an unmanned Viper in space") {
			let unmannedVipers = unmannedVipersList();
			let promptText = "Which viper would you like to move? (1-" + unmannedVipers.length + ")\n";
			for(let i = 0; !(i >= unmannedVipers.length); i++) {
				promptText += (i + 1) + ": " + unmannedVipers[i ][0] + " in Sector " + unmannedVipers[i ][2] + ".\n";
			}
			promptNum(promptText, (a) => 1 > a || a > unmannedVipers.length, mainMenu, (prompted) => {
				confirmify("Confirming you want to move a " + unmannedVipers[prompted - 1][0] + " in Sector " + unmannedVipers[prompted - 1][
					2] + ".", mainMenu, () => {
						if(unmannedVipers[prompted - 1][0] === "Viper Mk VII") {
							let promptText = "Which Sector would you like to move it to? (1-6)";
							let sector = unmannedVipers[prompted - 1][2];
							for(let j = 1; !(j > 6); j++) {
								promptText += "\n" + j + ": ";
								if(j === sector) {
									promptText += "(current sector)";
								} else if(j === sector - 3 || j === sector + 3) {
									promptText += "(too far)";
								} else {
									promptText += "Sector " + j;
								}
							}
							promptNum(promptText, (a) => 1 > a || a > 6 || a === sector - 3 || a === sector + 3, mainMenu, (prompted2) => {
								z.vipersVII[unmannedVipers[prompted - 1][1]] = prompted2;
								addAlert("Moving it to Sector " + prompted2);
								t.value += bold(myPlayer + " moves a " + unmannedVipers[prompted - 1][0] + " from Sector " +
									unmannedVipers[prompted - 1][2] + " to Sector " + prompted2 + ".\r\n");
								if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
									let num = getContext(me, "Activate an unmanned Viper");
									let man = isMandatory(me, "Activate an unmanned Viper");
									removeOption(me, "Activate an unmanned Viper");
									if(num > 1) {
										addOption(me, "Activate an unmanned Viper", num - 1, man);
									} else {
										menuPage = "Default";
									}
								}
								if(z.eventHorizon && z.gravityWell) {
									z.gravityWell = false;
								}
								mainMenu();
							});
						} else {
							let leftSector = unmannedVipers[prompted - 1][2] - 1;
							let rightSector = unmannedVipers[prompted - 1][2] + 1;
							if(leftSector === 0) {
								leftSector = 6;
							} else if(rightSector === 7) {
								rightSector = 1;
							}
							let moveViper = function(sectorChoice) {
								addAlert("Moving it to Sector " + sectorChoice);
								t.value += bold(myPlayer + " moves a " + unmannedVipers[prompted - 1][0] + " from Sector " +
									unmannedVipers[prompted - 1][2] + " to Sector " + sectorChoice + ".\r\n");
								if(unmannedVipers[prompted - 1][0] === "Viper Mk II") {
									z.vipersII[unmannedVipers[prompted - 1][1]] = sectorChoice;
								} else if(unmannedVipers[prompted - 1][0] === "Assault Raptor") {
									z.assaultRaptors[unmannedVipers[prompted - 1][1]] = sectorChoice;
								}
								if(hasOption(me, "Activate an unmanned Viper") && menuPage === "[Manual Viper Activation]") {
									let num = getContext(me, "Activate an unmanned Viper");
									let man = isMandatory(me, "Activate an unmanned Viper");
									removeOption(me, "Activate an unmanned Viper");
									if(num > 1) {
										addOption(me, "Activate an unmanned Viper", num - 1, man);
									} else {
										menuPage = "Default";
									}
								}
								if(z.eventHorizon && z.gravityWell) {
									z.gravityWell = false;
								}
								mainMenu();
							};
							confirmify("Where would you like to move the Viper?", () => {
								moveViper(rightSector);
							}, () => {
								moveViper(leftSector);
							}, "Sector " + leftSector, "Sector " + rightSector);
						}
					});
			});
		} else if(ch === "Recall an unmanned Viper") {
			let unmannedVipers = [];
			for(let i = 0; !(i >= z.vipersII.length); i++) {
				if(Number.isInteger(z.vipersII[i ]) && z.vipersII[i ] > 0) {
					unmannedVipers.push(["Viper Mk II", i, z.vipersII[i ]]);
				}
			}
			for(let i = 0; z.CFB && !(i >= z.vipersVII.length); i++) {
				if(Number.isInteger(z.vipersVII[i ]) && z.vipersVII[i ] > 0) {
					unmannedVipers.push(["Viper Mk VII", i, z.vipersVII[i ]]);
				}
			}
			for(let i = 0; z.daybreak && !(i >= z.assaultRaptors.length); i++) {
				if(Number.isInteger(z.assaultRaptors[i ]) && z.assaultRaptors[i ] > 0) {
					unmannedVipers.push(["Assault Raptor", i, z.assaultRaptors[i ]]);
				}
			}
			let promptText = "Which viper would you like to recall? (1-" + unmannedVipers.length + ")\n";
			for(let i = 0; !(i >= unmannedVipers.length); i++) {
				promptText += (i + 1) + ": " + unmannedVipers[i ][0] + " in Sector " + unmannedVipers[i ][2] + ".\n";
			}
			promptNum(promptText, (a) => 1 > a || a > unmannedVipers.length, mainMenu, (prompted) => {
				if(unmannedVipers[prompted - 1][0] === "Viper Mk II") {
					z.vipersII[unmannedVipers[prompted - 1][1]] = 0;
				} else if(unmannedVipers[prompted - 1][0] === "Viper Mk VII") {
					z.vipersVII[unmannedVipers[prompted - 1][1]] = 0;
				} else if(unmannedVipers[prompted - 1][0] === "Assault Raptor") {
					z.assaultRaptors[unmannedVipers[prompted - 1][1]] = 0;
				}
				addAlert("Recalling the " + unmannedVipers[prompted - 1][0] + " in Sector " + unmannedVipers[prompted - 1][2]);
				t.value += bold(myPlayer + " recalls the " + unmannedVipers[prompted - 1][0] + " in Sector " + unmannedVipers[prompted - 1][2] +
					".\r\n");
				if(!isUnmannedInSpace() || getContext(me, ch) === "Launch") {
					if(getContext(me, ch) === "Launch") {
						if(unmannedVipers[prompted - 1][0] === "Viper Mk II") {
							addOption(me, "Launch in a Viper Mk II in Sector 5", undefined, true);
							addOption(me, "Launch in a Viper Mk II in Sector 6", undefined, true);
						} else if(unmannedVipers[prompted - 1][0] === "Viper Mk VII") {
							addOption(me, "Launch in a Viper Mk VII in Sector 5", undefined, true);
							addOption(me, "Launch in a Viper Mk VII in Sector 6", undefined, true);
						} else if(unmannedVipers[prompted - 1][0] === "Assault Raptor") {
							addOption(me, "Launch in an Assault Raptor in Sector 5", undefined, true);
							addOption(me, "Launch in an Assault Raptor in Sector 6", undefined, true);
						}
					}
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Launch in a Viper Mk II in Sector 5") {
			confirmify("Confirming you want to launch in a Viper Mk II in Sector 5.", mainMenu, () => {
				for(let i = 0; !(i >= z.vipersII.length); i++) {
					if(z.vipersII[i ] === 0) {
						z.vipersII[i ] = myPlayer;
						addAlert("Launching in a Viper Mk II in Sector 5.");
						t.value += bold(myPlayer + " launches in a Viper Mk II in Sector 5.\r\n");
						movePlayer(me, "Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch in a Viper Mk II in Sector 6") {
			confirmify("Confirming you want to launch in a Viper Mk II in Sector 6.", mainMenu, () => {
				for(let i = 0; !(i >= z.vipersII.length); i++) {
					if(z.vipersII[i ] === 0) {
						z.vipersII[i ] = myPlayer;
						addAlert("Launching in a Viper Mk II in Sector 6.");
						t.value += bold(myPlayer + " launches in a Viper Mk II in Sector 6.\r\n");
						movePlayer(me, "Sector 6");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch in a Viper Mk VII in Sector 5") {
			confirmify("Confirming you want to launch in a Viper Mk VII in Sector 5.", mainMenu, () => {
				for(let i = 0; !(i >= z.vipersVII.length); i++) {
					if(z.vipersVII[i ] === 0) {
						z.vipersVII[i ] = z.players[me];
						addAlert("Launching in a Viper Mk VII in Sector 5.");
						t.value += bold(myPlayer + " launches in a Viper Mk VII in Sector 5.\r\n");
						movePlayer(me, "Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch in a Viper Mk VII in Sector 6") {
			confirmify("Confirming you want to launch in a Viper Mk VII in Sector 6.", mainMenu, () => {
				for(let i = 0; !(i >= z.vipersVII.length); i++) {
					if(z.vipersVII[i ] === 0) {
						z.vipersVII[i ] = z.players[me];
						addAlert("Launching in a Viper Mk VII in Sector 6.");
						t.value += bold(myPlayer + " launches in a Viper Mk VII in Sector 6.\r\n");
						movePlayer(me, "Sector 6");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch in an Assault Raptor in Sector 5") {
			confirmify("Confirming you want to launch in an Assault Raptor in Sector 5.", mainMenu, () => {
				for(let i = 0; !(i >= z.assaultRaptors.length); i++) {
					if(z.assaultRaptors[i ] === 0) {
						z.assaultRaptors[i ] = z.players[me];
						addAlert("Launching in an Assault Raptor in Sector 5.");
						t.value += bold(myPlayer + " launches in an Assault Raptor in Sector 5.\r\n");
						movePlayer(me, "Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Launch in an Assault Raptor in Sector 6") {
			confirmify("Confirming you want to launch in an Assault Raptor in Sector 6.", mainMenu, () => {
				for(let i = 0; !(i >= z.assaultRaptors.length); i++) {
					if(z.assaultRaptors[i ] === 0) {
						z.assaultRaptors[i ] = myPlayer;
						addAlert("Launching in an Assault Raptor in Sector 6.");
						t.value += bold(myPlayer + " launches in an Assault Raptor in Sector 6.\r\n");
						movePlayer(me, "Sector 6");
						removeOption(me, "Launch in a Viper Mk II in Sector 5");
						removeOption(me, "Launch in a Viper Mk II in Sector 6");
						removeOption(me, "Launch in a Viper Mk VII in Sector 5");
						removeOption(me, "Launch in a Viper Mk VII in Sector 6");
						removeOption(me, "Launch in an Assault Raptor in Sector 5");
						removeOption(me, "Launch in an Assault Raptor in Sector 6");
						break;
					}
				}
				mainMenu();
			});
		} else if(ch === "Recon (OPT)" || ch === "Scout the Crisis Deck") {
			confirmify("Confirming you want to scout the Crisis Deck.", mainMenu, () => {
				z.scout = me;
				z.scoutingCrisis = true;
				if(myPlayer === "Karl" && z.revealedCylons[me] === 0 && !z.raptorPilot) {
					if(z.vBrutality) {
						z.raptorPilot = true;
					}
					t.value += bold("Karl scouts the Crisis Deck; due to his Raptor Pilot ability, he scouts 2 cards.") + "\r\n";
					let crisis1 = z.crisisDeck.pop();
					if(z.crisisDeck.length === 0) {
						plainAlert("Crisis deck reshuffles.");
						z.crisisDeck = shuffle(z.crisisDiscards);
						z.crisisDiscards = [];
					}
					let crisis2 = z.crisisDeck.pop();
					if(z.crisisDeck.length === 0) {
						plainAlert("Crisis deck reshuffles.");
						z.crisisDeck = shuffle(z.crisisDiscards);
						z.crisisDiscards = [];
					}
					z.scouted.push(crisis1);
					z.scouted.push(crisis2);
					addAlert("Top 2 cards of the Crisis deck:\n\n1: " + d.crisisNames[crisis1] + "\n2: " + d.crisisNames[crisis2] +
						"\n\nNow, top or bottom these scouted crises, in any order.");
				} else {
					t.value += bold(myPlayer + " scouts the Crisis Deck.") + "\r\n";
					let crisis = z.crisisDeck.pop();
					if(z.crisisDeck.length === 0) {
						plainAlert("Crisis deck reshuffles.");
						z.crisisDeck = shuffle(z.crisisDiscards);
						z.crisisDiscards = [];
					}
					z.scouted.push(crisis);
					addAlert("Top card of the Crisis deck is:\n\n" + d.crisisNames[crisis] + "\n\nNow, top or bottom this scouted Crisis.");
					if(ch === "Recon (OPT)") {
						z.recon = true;
					}
				}
				removeOption(me, ch);
				removeOption(me, "Scout the Destination Deck");
				removeOption(me, "Scout the Mission Deck");
				mainMenu();
			});
		} else if(ch === "Scout the Destination Deck") {
			confirmify("Confirming you want to scout the Destination Deck.", mainMenu, () => {
				z.scout = me;
				z.scoutingDestination = true;
				if(myPlayer === "Karl" && z.revealedCylons[me] === 0 && !z.raptorPilot && z.destinationDeck.length >= 2) {
					if(z.vBrutality) {
						z.raptorPilot = true;
					}
					t.value += bold("Karl scouts the Destination Deck; due to his Raptor Pilot ability, he scouts 2 cards.") + "\r\n";
					let destination1 = z.destinationDeck.pop();
					let destination2 = z.destinationDeck.pop();
					z.scouted.push(destination1);
					z.scouted.push(destination2);
					addAlert("Top 2 cards of the Destination deck:\n\n1: " + d.destinationNames[destination1] + "\n2: " + d.destinationNames[
						destination2] + "\n\nNow, top or bottom these scouted Destinations, in any order.");
				} else {
					t.value += bold(myPlayer + " scouts the Destination Deck.") + "\r\n";
					let destination = z.destinationDeck.pop();
					z.scouted.push(destination);
					addAlert("Top card of the destination deck is:\n\n" + d.destinationNames[destination] +
						"\n\nNow, top or bottom this scouted Destination.");
				}
				removeOption(me, ch);
				removeOption(me, "Scout the Crisis Deck");
				removeOption(me, "Scout the Mission Deck");
				mainMenu();
			});
		} else if(ch === "Scout the Mission Deck") {
			if(z.missionDeck.length === 0) {
				addAlert("The Mission deck is completely empty; try something else.");
				removeOption(me, ch);
				mainMenu();
			} else {
				z.scout = me;
				z.scoutingMission = true;
				t.value += bold(myPlayer + " looks at the top card of the Mission deck.") + "\r\n";
				let mission = z.missionDeck.pop();
				if(z.missionDeck.length === 0) {
					plainAlert("Mission deck reshuffled.");
					z.missionDeck = shuffle(z.missionDiscards);
					z.missionDiscards = [];
				}
				z.scouted.push(mission);
				addAlert("Top card of the Mission deck is:\n\n" + d.crisisNames[mission] + "\n\nNow, top or bottom this scouted Mission.");
				removeOption(me, ch);
				removeOption(me, "Scout the Crisis Deck");
				removeOption(me, "Scout the Destination Deck");
				mainMenu();
			}
		} else if(ch === "Critical Discovery (OPG)") {
			confirmify(
				"Confirming you want to use your OPG, Critical Discovery, to look at the top 3 cards of the Destination deck, then them on the top or bottom of the deck in any order.",
				mainMenu, () => {
					if(z.assist === "Racetrack") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					boldAlert("Racetrack uses her OPG, Critical Discovery, to look at the top 3 cards of the Destination deck.");
					let d1 = z.destinationDeck.pop();
					let d2 = z.destinationDeck.pop();
					let d3 = z.destinationDeck.pop();
					z.scout = me;
					z.scoutingDestination = true;
					z.scouted.push(d1);
					z.scouted.push(d2);
					z.scouted.push(d3);
					addAlert("Top 3 cards of the Destination deck:\n\n1: " + d.destinationNames[d1] + "\n2: " + d.destinationNames[d2] + "\n3: " + d
						.destinationNames[d3] + "\n\nNow, top or bottom these scouted Destinations, in any order.");
					didAction();
					mainMenu();
				});
		} else if(ch === "Top scouted Mission") {
			confirmify("Confirming you want to return " + d.crisisNames[z.scouted[0]] + " to the top of the Mission deck.", mainMenu, () => {
				addAlert("Returned " + d.crisisNames[z.scouted[0]] + " to the top of the Mission deck.");
				t.value += bold(myPlayer + " returns a scouted Mission to the top of the Mission deck.") + "\r\n";
				z.missionDeck.push(z.scouted.pop());
				z.scout = -1;
				z.scoutingMission = false;
				mainMenu();
			});
		} else if(ch === "Bottom scouted Mission") {
			confirmify("Confirming you want to place " + d.crisisNames[z.scouted[0]] + " on the bottom of the Mission deck.", mainMenu, () => {
				addAlert("Placed " + d.crisisNames[z.scouted[0]] + " on the bottom of the Mission deck.");
				t.value += bold(myPlayer + " places a scouted Mission on the bottom of the Mission deck.") + "\r\n";
				z.missionDeck.unshift(z.scouted.pop());
				z.scout = -1;
				z.scoutingMission = false;
				mainMenu();
			});
		} else if(ch === "Top scouted Crisis") {
			if(z.scouted.length === 1) {
				confirmify("Confirming you want to return " + d.crisisNames[z.scouted[0]] + " to the top of the Crisis deck.", mainMenu, () => {
					addAlert("Returned " + d.crisisNames[z.scouted[0]] + " to the top of the Crisis deck.");
					t.value += bold(myPlayer + " returns a scouted Crisis to the top of the Crisis deck.") + "\r\n";
					z.crisisDeck.push(z.scouted.pop());
					z.scout = -1;
					z.scoutingCrisis = false;
					mainMenu();
				});
			} else {
				let promptText = "Which Crisis would you like to return to the top of the Crisis Deck? (1-" + z.scouted.length + ")";
				for(let j = 0; !(j >= z.scouted.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.crisisNames[z.scouted[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.scouted.length, mainMenu, (prompted) => {
					let crisis = z.scouted.splice(prompted - 1, 1)[0];
					addAlert("Returned " + d.crisisNames[crisis] + " to the top of the Crisis deck.");
					z.crisisDeck.push(crisis);
					t.value += bold(myPlayer + " returns a scouted Crisis to the top of the Crisis deck.") + "\r\n";
					if(hasContext(me, ch, "Hybrid Tank") && z.scouted.length === 1) {
						let crisis = z.scouted[0];
						z.scouted = [];
						addAlert("Returned " + d.crisisNames[crisis] + " to the top of the Crisis deck.");
						z.crisisDeck.push(crisis);
						t.value += bold(myPlayer + " returns a scouted Crisis to the top of the Crisis deck.") + "\r\n";
						removeOption(me, ch);
						z.scout = -1;
					}
					mainMenu();
				});
			}
		} else if(ch === "Bottom scouted Crisis") {
			if(z.scouted.length === 1) {
				confirmify("Confirming you want to place " + d.crisisNames[z.scouted[0]] + " on the bottom of the Crisis deck.", mainMenu, () => {
					addAlert("Placed " + d.crisisNames[z.scouted[0]] + " on the bottom of the Crisis deck.");
					t.value += bold(myPlayer + " places a scouted Crisis on the bottom of the Crisis deck.") + "\r\n";
					z.crisisDeck.unshift(z.scouted.pop());
					z.scout = -1;
					z.scoutingCrisis = false;
					mainMenu();
				});
			} else {
				let promptText = "Which Crisis would you like to place on the bottom of the Crisis Deck? (1-" + z.scouted.length + ")";
				for(let j = 0; !(j >= z.scouted.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.crisisNames[z.scouted[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.scouted.length, mainMenu, (prompted) => {
					let crisis = z.scouted.splice(prompted - 1, 1)[0];
					addAlert("Placed " + d.crisisNames[crisis] + " on the bottom of the Crisis deck.");
					z.crisisDeck.unshift(crisis);
					t.value += bold(myPlayer + " places a scouted Crisis on the bottom of the Crisis deck.") + "\r\n";
					mainMenu();
				});
			}
		} else if(ch === "Top scouted Destination") {
			if(z.scouted.length === 1) {
				confirmify("Confirming you want to return " + d.destinationNames[z.scouted[0]] + " to the top of the Destination deck.", mainMenu,
			() => {
					addAlert("Returned " + d.destinationNames[z.scouted[0]] + " to the top of the Destination deck.");
					t.value += bold(myPlayer + " returns a scouted Destination to the top of the Destination deck.") + "\r\n";
					z.destinationDeck.push(z.scouted.pop());
					z.scout = -1;
					z.scoutingDestination = false;
					mainMenu();
				});
			} else {
				let promptText = "Which Destination would you like to return to the top of the Destination Deck? (1-" + z.scouted.length + ")";
				for(let j = 0; !(j >= z.scouted.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.destinationNames[z.scouted[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.scouted.length, mainMenu, (prompted) => {
					let destination = z.scouted.splice(prompted - 1, 1)[0];
					addAlert("Returned " + d.destinationNames[destination] + " to the top of the Destination deck.");
					z.destinationDeck.push(destination);
					t.value += bold(myPlayer + " returns a scouted Destination to the top of the Destination deck.") + "\r\n";
					mainMenu();
				});
			}
		} else if(ch === "Bottom scouted Destination") {
			if(z.scouted.length === 1) {
				confirmify("Confirming you want to place " + d.destinationNames[z.scouted[0]] + " on the bottom of the Destination deck.", mainMenu,
				() => {
						addAlert("Placed " + d.destinationNames[z.scouted[0]] + " on the bottom of the Destination deck.");
						t.value += bold(myPlayer + " places a scouted Destination on the bottom of the Destination deck.") + "\r\n";
						z.destinationDeck.unshift(z.scouted.pop());
						z.scout = -1;
						z.scoutingDestination = false;
						mainMenu();
					});
			} else {
				let promptText = "Which Destination would you like to place on the bottom of the Destination Deck? (1-" + z.scouted.length + ")";
				for(let j = 0; !(j >= z.scouted.length); j++) {
					promptText += "\n" + (j + 1) + ": " + d.destinationNames[z.scouted[j]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.scouted.length, mainMenu, (prompted) => {
					let destination = z.scouted.splice(prompted - 1, 1)[0];
					addAlert("Placed " + d.destinationNames[destination] + " on the bottom of the Destination deck.");
					z.destinationDeck.unshift(destination);
					t.value += bold(myPlayer + " places a scouted Destination on the bottom of the Destination deck.") + "\r\n";
					mainMenu();
				});
			}
		} else if(ch === "Process Install Upgrades") {
			confirmify("Confirming you want to process Install Upgrades.", mainMenu, () => {
				let outcome = skillCheckTally(true)[1];
				if(outcome === "FAIL" || outcome === "PREVENTED FAIL") {
					t.value += z.players[z.turn] + " gets 1 " + colorText("blue", "Engineering") + " from " + colorText("blue",
						"Install Upgrades") + ":\r\n";
					let card = dealSkillCard(z.turn, 4);
					if(z.turn === me) {
						addAlert("You received " + cardText(card) + " from Install Upgrades");
					} else {
						addAlert(z.players[z.turn] + " gets 1 Engineering from Install Upgrades.");
					}
				} else if(outcome === "PASS") {
					t.value += z.players[z.turn] + " gets 2 " + colorText("blue", "Engineering") + " from " + colorText("blue",
						"Install Upgrades") + ":\r\n";
					let card = dealSkillCard(z.turn, 4);
					let card2 = dealSkillCard(z.turn, 4);
					if(z.turn === me) {
						addAlert("You received " + cardText(card) + " and " + cardText(card2) + " from Install Upgrades");
					} else {
						addAlert(z.players[z.turn] + " gets 2 Engineering from Install Upgrades.");
					}
				} else {
					t.value += colorText("blue", "Install Upgrades") + " has no effect on a Partial.\r\n";
					addAlert("Install Upgrades has no effect on a Partial.");
				}
				z.installUpgrades = false;
				mainMenu();
			});
		} else if(ch === "Command Authority (OPG)") {
			confirmify("Confirming you want to use your OPG.", mainMenu, () => {
				if(z.assist === "Adama") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				if(z.vBrutality) {
					/* TODO: fix this */
					t.value += bold("Adama uses his OPG, Command Authority") +
						", and may draw any or all cards from the skill check into his hand.\r\n";
					addAlert("Now, you may take any or all skill cards from the skill check into your hand.");
					for(let j = 0; !(j >= z.revealedCards.length); j++) {
						if(cardText(z.revealedCards[j]) === "Install Upgrades") {
							z.possibleColors[me][4] = 1;
							z.skillCardHands[me].push(z.revealedCards.splice(j, 1)[0]);
							j--;
							plainAlert(
								"Adama takes the Install Upgrades automatically, due to technical reasons; he may discard it using the deep menus if he so chooses."
								);
						}
					}
					addOption(me, "[Command Authority] Take a card from the skill check", undefined, false);
				} else {
					addAlert("Using Command Authority to draw all skill check cards into hand.");
					t.value += bold("Adama uses his OPG, Command Authority") + ", to take all cards from the skill check into his hand.\r\n";
					for(let j = 0; !(j >= z.revealedCards.length); j++) {
						z.possibleColors[me][cardColorID(z.revealedCards[j])] = 1;
					}
					z.skillCardHands[me] = z.skillCardHands[me].concat(z.revealedCards);
					z.revealedCards = [];
					clearSkillCheck();
				}
				mainMenu();
			});
		} else if(ch === "[Command Authority] Take a card from the skill check") {
			let promptText = "Which card would you like to take from the skill check? (1-" + z.revealedCards.length + ")";
			for(let j = 0; !(j >= z.revealedCards.length); j++) {
				promptText += "\n" + (j + 1) + ": " + cardText(z.revealedCards[j]);
			}
			promptNum(promptText, (a) => 1 > a || a > z.revealedCards.length, mainMenu, (prompted) => {
				plainAlert("Adama takes " + cardText(z.revealedCards[prompted - 1]) + " into his hand.");
				let card = z.revealedCards.splice(prompted - 1, 1)[0];
				z.skillCardHands[me].push(card);
				z.possibleColors[me][cardColorID(card)] = 1;
				if(z.revealedCards.length === 0) {
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "Discard a Miracle Token" || ch === "Mark your OPG ability as having been used") {
			confirmify(
				"Confirming you want to discard your miracle token / mark your OPG as having been used.  Use this only if you have already used your OPG ability, but for some reason this is not showing up.",
				mainMenu, () => {
					z.miracles[me] = 0;
					mainMenu();
				});
		} else if(ch === "CAG (OPG)") {
			confirmify("Confirming you want to use your OPG.", mainMenu, () => {
				if(z.assist === "Apollo") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				addAlert("Using your CAG (OPG) ability.  You may now activate up to 6 unmanned vipers.");
				t.value += bold("Apollo uses his CAG (OPG) ability.") + "\r\n";
				addOption(me, "Activate an unmanned Viper", 6, false);
				menuPage = "[Manual Viper Activation]";
				didAction();
				mainMenu();
			});
		} else if(ch === "Inspect a random Loyalty card of another player") {
			let inspectLoyalty = function(prompted) {
				let assist = z.numPlayers + z.boxedPlayers.length === 1 && z.assist !== undefined;
				let targetName = "";
				if(assist) {
					targetName = z.assist;
				} else {
					targetName = z.players[prompted - 1];
				}
				let confirmText = "Confirming you want to inspect a random loyalty card belonging to " + targetName + ".";
				confirmify(confirmText, mainMenu, () => {
					let loy = -1;
					if(assist) {
						let rando = Math.floor((z.seed * z.assistLoyalty.length)/mLCG);
						updateSeed();
						loy = z.assistLoyalty[rando];
					} else if(prompted - 1 !== z.theSympatheticCylon) {
						let rando = Math.floor((z.seed * z.loyaltyHands[prompted - 1].length)/mLCG);
						updateSeed();
						loy = z.loyaltyHands[prompted - 1][rando];
					} else {
						let rando = Math.floor((z.seed * (z.loyaltyHands[prompted - 1].length - 1))/mLCG) + 1;
						updateSeed();
						loy = z.loyaltyHands[prompted - 1][rando];
					}
					if(isFinalFive(loy)) {
						addAlert("The Loyalty card is " + d.loyaltyNames[loy] + "!  It is revealed to the table.");
						if(z.vBrutality && characterPresent("D'Anna")) {
							boldAlert(
								"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card."
								);
							addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", 1], true);
						}
						t.value += bold(myPlayer + " reveals that " + targetName + " is a Final Five with " + d.loyaltyNames[loy]) +
						".\r\n";
						switch (loy) {
							case 32:
								if(z.revealedCylons[me] === 0) {
									executePlayer(me, false);
								} else {
									addAlert("As a Cylon, you are not executed.");
									t.value += "As a Cylon, " + myPlayer + " is not executed.\r\n";
								}
								break;
							case 33:
								if(!z.negotiation && !z.galacticaAway) {
									if(activateRaiders()) {
										if(activateBasestars()) {
											activateHeavies();
										} else {
											plainAlert("After Basestars finish activating, activate Heavy Raiders.");
											optionForAll("Activate Heavy Raiders");
										}
									} else {
										plainAlert("After Raiders are done activating, activate Basestars, then activate Heavy Raiders.");
										optionForAll("Activate Basestars");
										optionForAll("Activate Heavy Raiders");
									}
								} else if(z.galacticaAway) {
									addAlert("Cylon ships do not activate as Galactica is away.");
								} else {
									addAlert("Cylon ships do not activate due to Negotiation.");
									t.value += "Cylon ships do not activate due to " + colorText("orange", "Negotiation") + ".\r\n";
								}
								break;
							case 34:
								if(!z.galacticaAway) {
									if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
										addAlert(
											"Now, the current player must choose whether to damage Pegasus or Galactica for each damage, in turn."
											);
										t.value += "Now, " + z.players[z.turn] +
											", as current player, must choose whether to damage Pegasus or Galactica for each damage, in turn.\r\n";
										addOption(z.turn, "Damage Pegasus", 2, true);
										addOption(z.turn, "Damage Galactica", 2, true);
									} else {
										if(damageGalactica()) {
											damageGalactica();
										} else {
											plainAlert("After resolving Ally placement, damage Galactica again.");
											for(let j = 0; !(j >= z.numPlayers); j++) {
												if(z.revealedCylons[j] === 1) {
													addOption(j, "Damage Galactica", undefined, false);
												}
											}
										}
									}
								} else {
									plainAlert("Galactica cannot be damaged while she is away.");
								}
								break;
							case 35:
								if(!assist) {
									executePlayer(prompted - 1, false, true);
									if(z.vBrutality) {
										plainAlert("After the execution resolves, all players must discard 2 random skill cards.");
									} else {
										plainAlert("After the execution resolves, all Human players must discard 2 random skill cards.");
									}
									for(let j = 0; !(j >= z.numPlayers); j++) {
										if(z.revealedCylons[j] === 0 || z.vBrutality) {
											if(z.forLove && z.players[j] !== "Athena") {
												addOption(j, "Discard a random Skill Card", 1, true);
												z.randomLove[j] = true;
											} else {
												addOption(j, "Discard a random Skill Card", 2, true);
											}
										}
									}
									if(!z.forLove) {
										optionForAll("Trigger the random discards from the Final Five");
									}
								} else {
									plainAlert("The assist character cannot be executed, but you still discard 2 random skill cards.");
									discardRandomSkillCard(me);
									discardRandomSkillCard(me);
								}
								break;
							case 36:
								if(myLocation === "Stranded on Caprica") {
									addAlert("Since you are Stranded, you are not sent to the Brig.");
									t.value += "Helo is Stranded, and cannot be sent to the Brig.\r\n";
								} else if(z.revealedCylons[me] === 1) {
									addAlert("As a Cylon, you are not sent to the Brig.");
									t.value += "As a Cylon, " + myPlayer + " is not sent to the Brig.\r\n";
								} else if(myLocation === "Brig") {
									addAlert("You are already in the Brig.");
									t.value += myPlayer + " is already in the Brig.\r\n";
								} else if(myLocation === "Detention") {
									addAlert("You are already in Detention.");
									t.value += myPlayer + " is already in Detention.\r\n";
								} else if(isOnNewCaprica(me)) {
									addAlert("You are sent to Detention.");
									movePlayer(me, "Detention");
								} else {
									addAlert("You are sent to the Brig.");
									movePlayer(me, "Brig");
								}
								break;
						}
					} else {
						let secretText = targetName + "'s random Loyalty:\r\n";
						let secretText2 = d.loyaltyNames[loy];
						z.secretMessages[me] += "\n" + secretText + secretText2;
						if(!assist) {
							z.secretMessages[prompted - 1] += "\n" + myPlayer + " inspected a random Loyalty of yours and saw:\n" +
								secretText2;
						}
						addAlert(secretText + secretText2 + "\n\nThis can also be viewed in your hand report, for your later perusal.");
						t.value += bold(myPlayer + " inspected a random Loyalty card belonging to " + targetName) + ".\r\n";
					}
					if(hasContext(me, ch, "Visions") && z.revealedCylons[me] === 0) {
						addOption(me, "Exfiltrate", undefined, true);
					}
					removeOption(me, ch);
					mainMenu();
				});
			};
			let context = getContext(me, ch);
			if(context === "Mandatory Testing") {
				inspectLoyalty(z.turn + 1);
			} else if(context === "Cylon Screenings") {
				if(z.admiral === z.president || me === z.president) {
					inspectLoyalty(z.admiral + 1);
				} else if(me === z.admiral){
					inspectLoyalty(z.president + 1);
				} else {
					confirmify("Whose Loyalty would you like to inspect?", () => {
						inspectLoyalty(z.president + 1);
					}, () => {
						inspectLoyalty(z.admiral + 1);
					}, "Admiral", "President");
				}
			} else if(z.numPlayers + z.boxedPlayers.length === 1 && z.assist !== undefined){
				inspectLoyalty(1);
			} else if(Number.isInteger(context)){
				inspectLoyalty(context+1);
			} else {
				let promptText = "Whose Loyalty would you like to inspect? (1-" + z.numPlayers + ")\n";
				for(let i = 0; !(i >= z.numPlayers); i++) {
					promptText += (i + 1) + ": ";
					if(isCylonLeader(z.players[i ])) {
						promptText += "(Cylon Leaders have no Loyalty Cards)\n";
					} else if(z.revealedCylons[i ] === 1) {
						promptText += "(CYLON)\n";
					} else if(i === z.theSympatheticCylon && z.loyaltyHands[i ].length === 1) {
						/* RULES: can you examine a sympathetic cylon's loyalty cards? */
						promptText += "(The Sympathetic Cylon has no Loyalty Cards)\n";
					} else if(z.loyaltyHands[i ].length === 0) {
						promptText += "(no Loyalty cards)\n";
					} else if(i === me) {
						promptText += "(cannot inspect yourself)\n";
					} else {
						promptText += z.players[i ] + " (" + z.loyaltyHands[i ].length + ")\n";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || isTheCylonLeader(a - 1) || z.revealedCylons[a - 1] === 1 || (a -
					1 === me) || (z.players[a - 1] === z.theSympatheticCylon && z.loyaltyHands[a - 1].length === 1) || (z.loyaltyHands[a - 1]
					.length === 0), mainMenu, (prompted) => {
					inspectLoyalty(prompted);
				});
			}
		} else if(ch === "Cylon Detector (OPG)" || ch === "[Strange Music] Nothing But Static" || ch === "[Attorney] Inspect all Loyalty Cards") {
			let assist = z.numPlayers + z.boxedPlayers.length === 1 && z.assist !== undefined;
			let inspector = (prompted2)=>{
				
				let targetName = "";
				if(assist) {
					targetName = z.assist;
				} else {
					targetName = z.players[prompted2 - 1];
				}
				let secretText = targetName + "'s Loyalty Cards:";
				let finalFives = [];
				if(assist) {
					for(let i = 0; !(i >= z.assistLoyalty.length); i++) {
						let loy = z.assistLoyalty[i ];
						if(isFinalFive(loy)) {
							finalFives.push(loy);
						}
						secretText += "\r\n" + d.loyaltyNames[z.assistLoyalty[i ]];
					}
				} else {
					if(prompted2 - 1 !== z.theSympatheticCylon){
						shuffle(z.loyaltyHands[prompted2-1]);
					} else {
						let loy = z.loyaltyHands[prompted2-1].shift();
						shuffle(z.loyaltyHands[prompted2-1]);
						z.loyaltyHands[prompted2-1].unshift(loy);
					}
					for(let i = 0; !(i >= z.loyaltyHands[prompted2 - 1].length); i++) {
						if(prompted2 - 1 === z.theSympatheticCylon && i === 0) {
							continue;
						}
						let loy = z.loyaltyHands[prompted2 - 1][i ];
						if(isFinalFive(loy)) {
							finalFives.push(loy);
						}
						secretText += "\r\n" + d.loyaltyNames[z.loyaltyHands[prompted2 - 1][i ]];
					}
				}
				z.secretMessages[me] += "\n" + secretText;
				addAlert(secretText + "\n\nThis can also be viewed in your hand report, for your later perusal.");
				if(ch === "Cylon Detector (OPG)") {
					t.value += bold("Baltar uses his Cylon Detector OPG to inspect " + targetName + "'s Loyalty Cards.") + "\r\n";
					if(z.assist === "Baltar") {
						z.assistMiracle = 0;
					} else {
						z.miracles[me] = 0;
					}
					didAction();
				} else if (ch === "[Attorney] Inspect all Loyalty Cards"){
					t.value += bold(myPlayer + " uses Attorney to inspect " + targetName + "'s Loyalty Cards.") + "\r\n";
				} else {
					t.value += bold(myPlayer + " uses Strange Music to inspect " + targetName + "'s Loyalty Cards.") + "\r\n";
				}
				if(assist) {
					shuffle(z.assistLoyalty);
				}
				if(finalFives.length === 1) {
					let loy = finalFives[0];
					if(isFinalFive(loy)) {
						addAlert(d.loyaltyNames[loy] + " is revealed to the table.");
						t.value += bold(myPlayer + " reveals that " + z.players[prompted2 - 1] + " is a Final Five with " + d.loyaltyNames[
							loy]) + ".\r\n";
						if(z.vBrutality && characterPresent("D'Anna")) {
							boldAlert(
								"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card."
								);
							addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", 1], true);
						}
						switch (loy) {
							case 32:
								if(z.revealedCylons[me] === 0) {
									executePlayer(me, false);
								} else {
									addAlert("As a Cylon, you are not executed.");
									t.value += "As a Cylon, " + myPlayer + " is not executed.\r\n";
								}
								break;
							case 33:
								if(!z.negotiation && !z.galacticaAway) {
									if(activateRaiders()) {
										if(activateBasestars()) {
											activateHeavies();
										} else {
											plainAlert("After Basestars finish activating, activate Heavy Raiders.");
											optionForAll("Activate Heavy Raiders");
										}
									} else {
										plainAlert("After Raiders are done activating, activate Basestars, then activate Heavy Raiders.");
										optionForAll("Activate Basestars");
										optionForAll("Activate Heavy Raiders");
									}
								} else if(z.galacticaAway) {
									addAlert("Cylon ships do not activate as Galactica is away.");
								} else {
									addAlert("Cylon ships do not activate due to Negotiation.");
									t.value += "Cylon ships do not activate due to " + colorText("orange", "Negotiation") + ".\r\n";
								}
								break;
							case 34:
								if(!z.galacticaAway) {
									if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
										addAlert(
											"Now, the current player must choose whether to damage Pegasus or Galactica for each damage, in turn."
											);
										t.value += "Now, " + z.players[z.turn] +
											", as current player, must choose whether to damage Pegasus or Galactica for each damage, in turn.\r\n";
										addOption(z.turn, "Damage Pegasus", 2, true);
										addOption(z.turn, "Damage Galactica", 2, true);
									} else {
										if(damageGalactica()) {
											damageGalactica();
										} else {
											plainAlert("After resolving Ally placement, damage Galactica again.");
											for(let j = 0; !(j >= z.numPlayers); j++) {
												if(z.revealedCylons[j] === 1) {
													addOption(j, "Damage Galactica", undefined, false);
												}
											}
										}
									}
								} else {
									plainAlert("Galactica cannot be damaged while she is away.");
								}
								break;
							case 35:
								if(!assist) {
									executePlayer(prompted2 - 1, false, true);
									if(z.vBrutality) {
										plainAlert("After the execution resolves, all players must discard 2 random skill cards.");
									} else {
										plainAlert("After the execution resolves, all Human players must discard 2 random skill cards.");
									}
									for(let j = 0; !(j >= z.numPlayers); j++) {
										if(z.revealedCylons[j] === 0 || z.vBrutality) {
											if(z.forLove && z.players[j] !== "Athena") {
												addOption(j, "Discard a random Skill Card", 1, true);
												z.randomLove[j] = true;
											} else {
												addOption(j, "Discard a random Skill Card", 2, true);
											}
										}
									}
									if(!z.forLove) {
										optionForAll("Trigger the random discards from the Final Five");
									}
								} else {
									plainAlert("The assist character cannot be executed, but you still discard 2 random skill cards.");
									discardRandomSkillCard(me);
									discardRandomSkillCard(me);
								}
								break;
							case 36:
								if(myLocation === "Stranded on Caprica") {
									addAlert("Since you are Stranded, you are not sent to the Brig.");
									t.value += "Helo is Stranded, and cannot be sent to the Brig.\r\n";
								} else if(z.revealedCylons[me] === 1) {
									addAlert("As a Cylon, you are not sent to the Brig.");
									t.value += "As a Cylon, " + myPlayer + " is not sent to the Brig.\r\n";
								} else if(myLocation === "Brig") {
									addAlert("You are already in the Brig.");
									t.value += myPlayer + " is already in the Brig.\r\n";
								} else if(myLocation === "Detention") {
									addAlert("You are already in Detention.");
									t.value += myPlayer + " is already in Detention.\r\n";
								} else if(isOnNewCaprica(me)) {
									addAlert("You are sent to Detention.");
									movePlayer(me, "Detention");
								} else {
									addAlert("You are sent to the Brig.");
									movePlayer(me, "Brig");
								}
								break;
						}
					}
				} else if(finalFives.length > 1) {
					addAlert("The Final Five cards are revealed to the table.");
					t.value += bold(myPlayer + " reveals that " + z.players[prompted2 - 1] + " is a Final Five with:\r\n");
					let count = 0;
					for(let j = 0; !(j >= finalFives.length); j++) {
						t.value += bold(d.loyaltyNames[finalFives[j]])+"\r\n";
						if(finalFives[j] === 32 && z.revealedCylons[me] === 0){
							count++;
							addOption(z.turn,"Execute a player", z.players[me],true);
							plainAlert(z.players[me]+ " will be executed.");
						} else if(finalFives[j] === 33 && !z.negotiation && !z.galacticaAway){
							addOption(me,"Activate Raiders",undefined,true);
							addOption(me,"Activate Basestars",undefined,true);
							addOption(me,"Activate Heavy Raiders",undefined,true);
							plainAlert("Raiders, Basestars, and Heavy Raiders will activate, in that order.");
						} else if(finalFives[j] === 34){
							if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
								plainAlert("Two damage will be applied; "+z.players[z.turn]+" will have to choose whether Pegasus or Galactica will be damaged each time.");
								addOption(z.turn, "Damage Pegasus", 2, true);
								addOption(z.turn, "Damage Galactica", 2, true);
							} else {
								plainAlert("Galactica will be damaged twice.");
								addOption(z.turn, "Damage Galactica", 2, true);
							}
						} else if(finalFives[j] === 35) {
							count++;
							addOption(z.turn,"Execute a player", ["Final Fives", z.players[prompted2 - 1]], true);
							plainAlert(z.players[prompted2-1]+" will be executed; all other Humans will have to discard 2 random skill cards.");
							for(let j = 0; !(j>=z.numPlayers); j++){
								if((z.vBrutality || z.revealedCylons[j] === 0) && j !== prompted2 - 1){
									if(z.players[j] === "Apollo" && !noDrawback(j)){
										addOption(j,"Discard a random Skill Card",2 * finalFives.length,true);
									} else {
										promptAllyDiscards(j,2 * (finalFives.length - 1),true);
										addOption(j,"Discard a random Skill Card",2,true);
									}
								}
							}
						} else if(finalFives[j] === 36 && z.revealedCylons[me] === 0){
							if(myLocation === "Stranded on Caprica" || myLocation === "Brig" || myLocation === "Detention"){
								addAlert("If you are going to be executed by this and choose to be executed first before sending yourself to the Brig, your new character will be sent to the Brig.  You likely don't want to do that, but in case you do, you'll have to use the deep menus.");	
							} else if(isOnNewCaprica(me)){
								plainAlert(z.players[me]+" will be moved to Detention.");
								addOption(me,"Move a player to Detention",undefined,true);
							} else {
								plainAlert(z.players[me]+" will be moved to the Brig.");
								addOption(me,"Move a player to Detention",undefined,true);
							}
						}
					}
					t.value += "\r\n";
					if(z.vBrutality && characterPresent("D'Anna")) {
						boldAlert(
							"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card for each Final Five card revealed."
							);
						addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", finalFives.length],
							true);
					}
					boldAlert(z.players[z.turn] + ", as current player, must now choose the order in which the Final Five cards are applied.");
					if(count === 2){
						addOption(z.turn,"Execute a player",["Final Fives",me,prompted2-1],true);
					}
				}
				if(ch === "[Strange Music] Nothing But Static") {
					if(z.antagonistic[z.crossroadsPlayer] + z.benevolent[z.crossroadsPlayer] > 0) {
						addOption(z.crossroadsPlayer, "Discard a Trauma Token", undefined, true);
					}
					removeOption(me, ch);
				}
				if(ch === "[Attorney] Inspect all Loyalty Cards"){
					/* TODO: handle final five corner cases */
					if(isOnNewCaprica(me)){
						plainAlert(z.players[me] +" must now move "+z.players[prompted2-1]+" out of Detention or steal all their skill cards.");
						addOption(me,"Move a player out of Detention",prompted2-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted2-1,false);
					} else {
						plainAlert(z.players[me] +" must now move "+z.players[prompted2-1]+" out of the Brig or steal all their skill cards.");
						addOption(me,"Move a player out of the Brig",prompted2-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted2-1,false);
					}
					removeOption(me,ch);
				}
				mainMenu();
			};
			
			if(ch === "[Attorney] Inspect all Loyalty Cards"){
				inspector(getContext(me,ch)+1);
			} else {
				let promptText = "Whose Loyalty Cards would you like to inspect? (1-" + z.numPlayers + ")\n";
				if(assist) {
					promptText += "1: " + z.assist;
				} else {
					for(let i = 0; !(i >= z.numPlayers); i++) {
						promptText += (i + 1) + ": ";
						if(isCylonLeader(z.players[i ])) {
							promptText += "(Cylon Leaders have no Loyalty Cards)\n";
						} else if(z.revealedCylons[i ] === 1) {
							promptText += "(CYLON)\n";
						} else if(i === z.theSympatheticCylon && z.loyaltyHands[z.theSympatheticCylon].length === 1) {
							promptText += "(The Sympathetic Cylon has no Loyalty Cards)\n";
						} else if(z.loyaltyHands[i ].length === 0) {
							/* RULES: Can Baltar examine a revealed cylon's loyalty cards? */
							promptText += "(no Loyalty cards)\n";
						} else if(i === me) {
							promptText += "(cannot inspect yourself)\n";
						} else {
							promptText += z.players[i ] + " (" + z.loyaltyHands[i ].length + ")\n";
						}
					}
				}
				promptNum(promptText, (a) => {
					if(assist) {
						return a !== 1;
					} else {
						return 1 > a || a > z.numPlayers || isTheCylonLeader(a - 1) || z.revealedCylons[a - 1] === 1 || (a - 1 ===
							me) || (z.players[a - 1] === z.theSympatheticCylon && z.loyaltyHands[a - 1].length === 1) || (z.loyaltyHands[a - 1]
								.length === 0);
					}
				}, mainMenu, inspector);
			}
		} else if(ch === "Skilled Politician (OPG)") {
			if(z.quorumPeeker !== -1) {
				addAlert("Please wait for other players to finish messing with the Quorum before using your OPG.");
				mainMenu();
			} else {
				confirmify("Confirming you want to use your OPG, Skilled Politician.", mainMenu, () => {
					t.value += bold("Roslin uses her OPG, Skilled Politician.") + "\r\n";
					if(!(z.quorumDeck.length >= 4)) {
						z.quorumDeck = shuffle(z.quorumDiscards).concat(z.quorumDeck);
						z.quorumDiscards = [];
						addAlert("Fewer than 4 cards in the Quorum deck; reshuffling.");
						t.value += "Quorum deck reshuffles";
					}
					z.quorumPeeker = me;
					let message = "You draw the following Quorum cards:";
					for(let j = 0; !(j >= 4) && z.quorumDeck.length > 0; j++) {
						let quo = z.quorumDeck.pop();
						z.quorumPeek.push(quo);
						message += "\n" + d.quorumNames[quo];
					}
					message += "\n\nNow, play one of these Quorums, then return the rest to the bottom of the Quorum deck.";
					addAlert(message);
					addOption(me, "[Skilled Politician] Play a Quorum card", undefined, true);
					addOption(me, "[Skilled Politician] Bottom a Quorum card", undefined, true);
					if(z.assist === "Roslin") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					didAction();
					mainMenu();
				});
			}
		} else if(ch === "Influential (OPG)") {
			if(z.quorumPeeker !== -1) {
				addAlert("Please wait for other players to finish messing with the Quorum before using your OPG.");
				mainMenu();
			} else {
				confirmify("Confirming you want to use your OPG, Influential.", mainMenu, () => {
					t.value += bold("Tory uses her OPG, Influential.") + "\r\n";
					if(z.vBrutality) {
						t.value +=
							"Tory may place up to three Quorums on the bottom of the deck, then return the rest to the top in an order of her choosing." +
							"\r\n";
					}
					if(!(z.quorumDeck.length >= 5)) {
						z.quorumDeck = shuffle(z.quorumDiscards).concat(z.quorumDeck);
						z.quorumDiscards = [];
						addAlert("Fewer than 5 cards in the Quorum deck; reshuffling.");
						t.value += "Quorum deck reshuffles";
					}
					z.quorumPeeker = me;
					let message = "You draw the following Quorum cards:";
					for(let j = 0; !(j >= 5) && z.quorumDeck.length > 0; j++) {
						let quo = z.quorumDeck.pop();
						z.quorumPeek.push(quo);
						message += "\n" + d.quorumNames[quo];
					}
					if(z.vBrutality) {
						message +=
							"\n\nNow, you may place up to three Quorums on the bottom of the deck, then return the rest to the top in an order of your choosing.";
					} else {
						message +=
							"\n\nNow, return these Quorums to the top of the Quorum deck in an order of your choosing.  The last card you put on top will be the first the President draws.";
					}
					addAlert(message);
					if(z.vBrutality) {
						addOption(me, "[Influential] Bottom a Quorum Card", undefined, true);
					}
					addOption(me, "[Influential] Top a Quorum Card", undefined, true);
					if(z.assist === "Tory") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					didAction();
					mainMenu();
				});
			}
		} else if(ch === "Coup (OPG)") {
			confirmify("Confirming you want to use your OPG, Coup.", mainMenu, () => {
				t.value += bold("Gaeta uses his OPG, Coup.") + "\r\n";
				if(myLocation === "Brig" || (myLocation === "Detention" && z.galacticaReturned)) {
					addAlert("You move to Command.");
					movePlayer(me, "Command");
				} else if(myLocation === "Detention") {
					addAlert("You move to Resistance HQ");
					movePlayer(me, "Resistance HQ");
				}
				let oldAdmiral = z.admiral;
				z.admiral = me;
				addAlert("You are now the Admiral.");
				t.value += bold("Gaeta is now the " + colorText("green", "Admiral")) + ".\r\n";
				if(z.assist === "Gaeta") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !==
					getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
						oldAdmiral !== getPlayerNum("Zarek"))) {
					if(versionAtLeast([2,2,25])){
						z.friendsAdmiral = true;
						plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
					} else {
						plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
						if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
							addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
						} else {
							addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
						}
					}
				}
				if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" && (!
						versionAtLeast([2, 0, 1]) || oldAdmiral !== getPlayerNum("Gaius"))) {
					if(versionAtLeast([2,2,25])){
						z.cultAdmiral = true;
						plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
					} else {
						plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
						if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
							addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
						} else {
							addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
						}
					}
				}
				didAction();
				mainMenu();
			});
		} else if(ch === "Discharge of a Firearm (OPG)") {
			let targets = [];
			for(let j = 0; !(j >= z.numPlayers); j++) {
				if(j !== me && z.playerLocations[j] === myLocation) {
					targets.push(j);
				}
			}
			if(targets.length === 1) {
				confirmify("Confirming that you want to execute " + z.players[targets[0]] + " with your OPG, Discharge of a Firearm.", mainMenu, () => {
					addAlert("You use your OPG on " + z.players[targets[0]]+".");
					t.value += bold("Cally uses her OPG, Discharge of a Firearm, on " + z.players[targets[0]]) + ".\r\n";
					if(z.assist === "Cally") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					executePlayer(targets[0], false);
					if(me === z.turn && z.vBrutality && z.phase === 1) {
						z.phase = 2;
					} else {
						didAction();
					}
					mainMenu();
				});
			} else if(targets.length > 1) {
				let promptText = "Which player would you like to execute with your OPG, Discharge of a Firearm? (1-" + targets.length + ")";
				for(let j = 0; !(j >= targets.length); j++) {
					promptText += "\n" + (j + 1) + ": " + z.players[targets[j]];
				} /* TODO: add confirmify here */
				promptNum(promptText, (a) => 1 > a || a > targets.length, mainMenu, (prompted) => {
					addAlert("You use your OPG on " + z.players[targets[prompted - 1]]);
					t.value += bold("Cally uses her OPG, Discharge of a Firearm, on " + z.players[targets[prompted - 1]]) + ".\r\n";
					if(z.assist === "Cally") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					executePlayer(targets[prompted - 1], false);
					if(me === z.turn && z.vBrutality && z.phase === 1) {
						z.phase = 2;
					} else {
						didAction();
					}
					mainMenu();
				});
			}
		} else if(ch === "Longshot (OPG)") {
			let promptText = "What result would you like to make this die roll have using your OPG, Longshot? (1-8)";
			if(z.dieRollModifier !== 0) {
				promptText +=
					"\n\nNote that Strategic Planning and Calculations do not affect the result of Longshot; if someone played a Strategic Planning on this " +
					"die roll, you should rewind to before they played the Strategic Planning.";
			}
			promptNum(promptText, (a) => 1 > a || a > 8, mainMenu, (prompted) => {
				if(z.assist === "Anders") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				addAlert("You use your OPG to make the result of the die roll " + prompted + ".");
				z.lastDieRoll = z.dieRollQueue.shift();
				z.lastDieRollValue = prompted;
				z.lastDieRollModifier = 0;
				t.value += bold("Anders uses his OPG, Longshot, to make the result of the die roll: ") + dieRollImage() + "\r\n";
				processDieRoll();
				mainMenu();
			});
		} else if(ch === "Declare Martial Law (OPG)") {
			confirmify("Confirming that you want to Declare Martial Law.", mainMenu, () => {
				t.value += bold("Tigh uses his OPG, Declare Martial Law.") + "\r\n";
				if(z.assist === "Tigh") {
					z.assistMiracle = 0;
				} else {
					z.miracles[me] = 0;
				}
				movePresident(z.admiral);
				didAction();
				mainMenu();
			});
		} else if(ch === "Unconventional Tactics") {
			if(hasContext(me, ch, "Food")) {
				confirmify("Confiming you want to switch this Food loss for a Population loss.", mainMenu, () => {
					z.unconventionalTactics = true;
					removeOption(me, ch);
					increaseFood();
					decreasePopulation();
					mainMenu();
				});
			} else if(hasContext(me, ch, "Morale")) {
				confirmify("Confiming you want to switch this Morale loss for a Population loss.", mainMenu, () => {
					z.unconventionalTactics = true;
					removeOption(me, ch);
					increaseMorale();
					if(hasContext(me, "Execute a player", "Dee")) {
						removeFromAll("Execute a player");
						plainAlert("Dee is pulled back from the brink.");
					}
					decreasePopulation();
					mainMenu();
				});
			} else {
				let promptText = "Which resource loss is being traded for a loss of Population? (1-2)\n1:Food\n2:Morale";
				promptNum(promptText, (a) => 1 > a || a > 2, mainMenu, (prompted) => {
					z.unconventionalTactics = true;
					if(prompted === 1) {
						increaseFood();
					} else {
						increaseMorale();
						if(hasContext(me, "Execute a player", "Dee")) {
							removeFromAll("Execute a player");
							plainAlert("Dee is pulled back from the brink.");
						}
					}
					decreasePopulation();
					removeOption(me, ch);
					mainMenu();
				});
			}
		} else if(ch === "Unconventional Tactics (OPG)") {
			/* RULES: Can you use Zarek's OPG at 0 Population? */
			let promptText = "Which resource would you like to gain? (1-3)\n\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")\n3: Morale (" + z
				.morale + ")";
			promptNum(promptText, (a) => 1 > a || a > 3, mainMenu, (prompted) => {
				if(z.assist === "Zarek") {
					z.assistMiracle = 0;
				} else {
					z.miracles[me] = 0;
				}
				t.value += bold("Zarek uses his OPG, Unconventional Tactics.") + "\r\n";
				decreasePopulation();
				switch (prompted) {
					case 1:
						addAlert("Trading Population for Fuel.");
						increaseFuel();
						break;
					case 2:
						addAlert("Trading Population for Food.");
						increaseFood();
						break;
					case 3:
						addAlert("Trading Population for Morale.");
						increaseMorale();
						break;
				}
				didAction();
				mainMenu();
			});
		} else if(ch === "Ask for a Strategic Planning") {
			let confirmText = "This will create the Strategic Planning token for the current die roll, " + z.dieRollQueue[0] +
				".  Note that one may already have been automatically generated for you, depending on the event.";
			if(characterPresent("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")) && z.dieRoller === getPlayerNum("Billy") && (z
					.currentCrisis === null || z.capricaCrisis)) {
				confirmText +=
					"\nBilly's No Combat Experience drawback means any die rolls he takes during Action steps may not be modified.\n\nAre you sure you want to proceed?";
			}
			confirmify(confirmText, mainMenu, () => {
				let eventName = z.dieRollQueue[0];
				addAlert("Asking for Strategic Planning for " + eventName + ".");
				if(z.eco) {
					addAlert("Remember that Helo can use his ECO Officer ability to reroll the die.");
				}
				SPToken(z.dieRollQueue[0]);
				z.spToken = true;
				mainMenu();
			});
		} else if(ch === "Decrease a resource") {
			let dropResource = function(prompted) {
				switch (prompted) {
					case 1:
						decreaseFuel();
						break;
					case 2:
						decreaseFood();
						break;
					case 3:
						decreaseMorale();
						break;
					case 4:
						decreasePopulation();
						break;
				}
				removeOption(me, ch);
				mainMenu();
			};
			if(hasContext(me, ch, "Crash Landing")) {
				promptNum("Which option would you like to choose? (1-2)\n1: Decrease Fuel (currently at " + z.fuel +
					")\n2: Decrease Morale (currently at " + z.morale + ") and send " + z.players[z.turn] + " to Sickbay.", (a) => 1 > a || a > 2,
					mainMenu, (prompted) => {
						if(prompted === 1) {
							decreaseFuel();
						} else {
							let done = decreaseMorale();
							if(done) {
								if(z.playerLocations[z.turn] !== "Brig" && z.playerLocations[z.turn] !== "Sickbay" && z.revealedCylons[z.turn] ===
									0 && z.playerLocations[z.turn] !== "Stranded on Caprica") {
									movePlayer(z.turn, "Sickbay");
								}
							} else {
								plainAlert("After Dee's execution fully resolves, send the current player to Sickbay.");
								optionForAll("Move a player to Sickbay");
							}
						}
						removeOption(me, ch);
						mainMenu();
					});
			} else if(hasContext(me, ch, "Forced Water Mining")) {
				confirmify("Confirming you want to lose 1 Morale.  This will kill Dee.", mainMenu, () => {
					decreaseMorale();
					removeFromAll(ch);
					mainMenu();
				});
			} else if(hasContext(me, ch, "The Olympic Carrier")) {
				confirmify(
					"Confirming you want to lose 1 Population from the fail effect of this crisis.  Make sure Dee's execution has been fully resolved, including the picking of a new character.",
					mainMenu, () => {
						decreasePopulation();
						removeFromAll(ch);
						mainMenu();
					});
			} else if(hasContext(me, ch, "tie")) {
				let population = true;
				let morale = false;
				let food = false;
				let fuel = false;
				let maxResource = z.population;
				if(z.morale > maxResource) {
					population = false;
					maxResource = z.morale;
				} else if(z.morale === maxResource) {
					morale = true;
				}
				if(z.food > maxResource) {
					maxResource = z.food;
					morale = false;
					population = false;
				} else if(z.food === maxResource) {
					food = true;
				}
				if(z.fuel === maxResource) {
					fuel = true;
				}
				let promptText = "Which resource would you like to decrease? (1-4)";
				if(fuel) {
					promptText += "\n1: Fuel (" + z.fuel + ")";
				} else {
					promptText += "\n1: (not tied for highest resource)";
				}
				if(food) {
					promptText += "\n2: Food (" + z.food + ")";
				} else {
					promptText += "\n2: (not tied for highest resource)";
				}
				if(morale) {
					promptText += "\n3: Morale (" + z.morale + ")";
				} else {
					promptText += "\n3: (not tied for highest resource)";
				}
				if(population) {
					promptText += "\n4: Population (" + z.population + ")";
				} else {
					promptText += "\n4: (not tied for highest resource)";
				}
				promptNum(promptText, (a) => 1 > a || a > 4 || (a === 1 && !fuel) || (a === 2 && !food) || (a === 3 && !morale) || (a === 4 && !
					population), mainMenu, dropResource);
			} else if(hasContext(me, ch, "Iron Will")) {
				confirmify(
					"Confirming you want to decrease Morale by 1 from Iron Will.  Do not do this if this effect has already triggered and caused Dee's execution.",
					mainMenu, () => {
						decreaseMorale();
						removeFromAll(ch);
						mainMenu();
					});
			} else if(hasContext(me, ch, "Zarek")) {
				confirmify("Confirming you want to decrease Population to gain 1 of another resource.", mainMenu, () => {
					decreasePopulation();
					removeOption(me, ch);
					addOption(me, "Increase a resource", "Zarek", true);
					mainMenu();
				});
			} else if(hasContext(me, ch, "Shaw")) {
				confirmify("Confirming you want to decrease Morale to gain 1 Fuel or Food.", mainMenu, () => {
					decreaseMorale();
					removeOption(me, ch);
					addOption(me, "Increase a resource", "Shaw", true);
					mainMenu();
				});
			} else {
				promptNum("Which resource would you like to decrease? (1-4)\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")\n3: Morale (" + z
					.morale + ")\n4: Population (" + z.population + ")", (a) => 1 > a || a > 4, mainMenu, dropResource);
			}
		} else if(ch === "Increase a resource") {
			let bumpResource = function(prompted) {
				switch (prompted) {
					case 1:
						increaseFuel();
						break;
					case 2:
						increaseFood();
						break;
					case 3:
						increaseMorale();
						break;
					case 4:
						increasePopulation();
						break;
				}
				removeOption(me, ch);
				mainMenu();
			};
			if(hasContext(me, ch, "Zarek")) {
				promptNum("Which resource would you like to increase? (1-3)\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")\n3: Morale (" + z
					.morale + ")", (a) => 1 > a || a > 3, mainMenu, bumpResource);
			} else if(hasContext(me, ch, "Shaw") || hasContext(me, ch, "Unsavory Connections")) {
				promptNum("Which resource would you like to increase? (1-2)\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")", (a) => 1 > a || a > 2,
					mainMenu, bumpResource);
			} else {
				promptNum("Which resource would you like to increase? (1-4)\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")\n3: Morale (" + z
					.morale + ")\n4: Population (" + z.population + ")", (a) => 1 > a || a > 4, mainMenu, bumpResource);
			}
		} else if(ch === "Broadcast (OPG)") {
			promptNum("Which resource would you like to increase by 2? (1-4)\n1: Fuel (" + z.fuel + ")\n2: Food (" + z.food + ")\n3: Morale (" + z
				.morale + ")\n4: Population (" + z.population + ")", (a) => 1 > a || a > 4, mainMenu, (prompted) => {
					t.value += bold("Gaius uses his OPG, Broadcast.") + "\r\n";
					if(z.assist === "Gaius") {
						z.assistMiracle = 0;
					} else {
						z.miracles[me] = 0;
					}
					switch (prompted) {
						case 1:
							increaseFuel();
							increaseFuel();
							break;
						case 2:
							increaseFood();
							increaseFood();
							break;
						case 3:
							increaseMorale();
							increaseMorale();
							break;
						case 4:
							increasePopulation();
							increasePopulation();
							break;
					}
					didAction();
					mainMenu();
				});
		} else if(ch === "Damage Pegasus") {
			let confirmText = "Confirming you want to damage Pegasus.";
			if(z.pegasusDamage.length === 1) {
				confirmText += "\nNOTE: This will destroy Pegasus!";
			}
			confirmify(confirmText, mainMenu, () => {
				damagePegasus(getContext(me,ch)==="Sabotage");
				if(hasContext(me, ch, 2)) {
					removeFromAll(ch);
					removeFromAll("Damage Galactica");
					addOption(me, "Damage Galactica", undefined, true);
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
						addOption(z.turn, ch, undefined, true);
					}
				} else {
					removeFromAll(ch);
					removeFromAll("Damage Galactica");
				}
				mainMenu();
			});
		} else if(ch === "Damage Galactica") {
			confirmify("Confirming you want to damage Galactica.", mainMenu, () => {
				let context = getContext(me,ch);
				damageGalactica(context === "Sabotage");
				if(hasContext(me, ch, 2)) {
					removeFromAll(ch);
					if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
						removeFromAll("Damage Pegasus");
						addOption(z.turn, ch, undefined, true);
						addOption(z.turn, "Damage Pegasus", undefined, true);
					} else {
						addOption(me, ch, undefined, true);
					}
				} else {
					removeFromAll(ch);
					removeFromAll("Damage Pegasus");
				}
				mainMenu();
			});
		} else if(ch === "Move the President title") {
			if(hasContext(me, ch, "Impeachment")) {
				confirmify("Confirming you want to take the Presidency.", mainMenu, () => {
					movePresident(me);
					removeOption(me, ch);
					mainMenu();
				});
			} else if(hasContext(me, ch, "Requested Resignation")) {
				confirmify("Confirming you want to give the President title to the Admiral.", mainMenu, () => {
					movePresident(z.admiral);
					removeOption(me, ch);
					removeOption(me, "Move a player to the Brig");
					mainMenu();
				});
			} else if(hasContext(me, ch, "Manipulative")) {
				let confirmText = "Confirming you want to give the President title to ";
				let standard = 100 > z.manipulativeVictim && z.manipulativeVictim >= 0 && z.revealedCylons[z.manipulativeVictim] === 0;
				if(standard) {
					confirmText += z.players[z.manipulativeVictim] + " now.";
				} else {
					confirmText += " the player highest on the succession list now.";
				}
				confirmify(confirmText, mainMenu, () => {
					if(standard) {
						movePresident(z.manipulativeVictim);
					} else {
						passPresident(99);
					}
					z.manipulativeVictim = -1;
					removeOption(me, ch);
					mainMenu();
				});
			} else {
				let min = 0;
				if(hasContext(me, ch, "Resignation")) {
					min = 1;
				}
				let promptText = "Who receives the President title? (" + min + "-" + z.numPlayers + ")\n";
				if(!hasContext(me, ch, "Resignation")) {
					promptText += "0: Highest on the line of succession (apart from the current President)\n";
				}
				for(let i = 0; !(i >= z.numPlayers); i++) {
					promptText += (i + 1) + ": ";
					if(z.revealedCylons[i ] === 1) {
						promptText += "(Cylon)\n";
					} else if(isCylonLeader(z.players[i ])) {
						promptText += "(Cylon Leader)\n";
					} else if(i === z.theSympatheticCylon) {
						promptText += "(Sympathetic Cylon)\n";
					} else if(hasContext(me, ch, "Resignation") && i === me) {
						promptText += "(cannot pick yourself)\n";
					} else {
						promptText += z.players[i ] + " (rank " + d.presidentSuccession[getCharacter(z.players[i ])] + ")\n";
					}
				}
				if(hasContext(me, ch, "Resignation") && hasOption(me, "Discard a Quorum Card")) {
					promptText += "Make sure you have discarded the Quorums you wanted to (and drawn replacements) before choosing a new President.";
				}
				promptNum(promptText, (a) => min > a || a > z.numPlayers || (a > 0 && z.revealedCylons[a - 1] === 1) || (a > 0 && a - 1 === z
						.theCylonLeader) || (a > 0 && a - 1 === z.theSympatheticCylon) || (a - 1 === me && hasContext(me, ch, "Resignation")),
					mainMenu, (prompted) => {
						if(prompted > 0) {
							movePresident(prompted - 1);
						} else {
							passPresident(d.presidentSuccession[getCharacter(z.players[z.president])]);
						}
						if(hasContext(me, ch, "Resignation")) {
							removeOption(me, "Discard a Quorum Card");
						}
						if(hasContext(me, ch, "The Circle")) {
							removeOption(me, "Execute a player");
						}
						if(hasContext(me, ch, "Ellen")) {
							removeOption(me, "Move the Admiral title");
						}
						removeOption(me, ch);
						mainMenu();
					});
			}
		} else if(ch === "Move the CAG title") {
			let promptText = "Who receives the CAG title? (0-" + z.numPlayers + ")\n";
			promptText += "0: Highest on the line of succession (apart from the current CAG)\n";
			for(let i = 0; !(i >= z.numPlayers); i++) {
				promptText += (i + 1) + ": ";
				if(z.revealedCylons[i ] === 1) {
					promptText += "(Cylon)\n";
				} else if(isCylonLeader(z.players[i ])) {
					promptText += "(Cylon Leader)\n";
				} else if(i === z.theSympatheticCylon) {
					promptText += "(Sympathetic Cylon)\n";
				} else if(z.playerLocations[i ] === "Brig") {
					promptText += "(in the Brig)\n";
				} else if(z.cag === i && hasContext(me,ch,"CAG card")){
					promptText += "(cannot choose yourself)\n";
				} else {
					promptText += z.players[i ] + " (rank " + d.cagSuccession[getCharacter(z.players[i ])] + ")\n";
				}
			}
			promptNum(promptText, (a) => 0 > a || a > z.numPlayers || (a > 0 && z.revealedCylons[a - 1] === 1) || (a > 0 && a - 1 === z
				.theCylonLeader) || (a > 0 && a - 1 === z.theSympatheticCylon) || (a > 0 && z.playerLocations[a - 1] === "Brig") || (a-1 === me && hasContext(me,ch,"CAG card")), mainMenu, (
					prompted) => {
					if(prompted > 0) {
						let oldCAG = z.cag;
						z.cag = prompted - 1;
						t.value += bold(z.players[z.cag] + " is now the " + colorText("red", "CAG") + ".") + "\r\n";
						addAlert(z.players[z.cag] + " is now the CAG.");
						if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !==
							getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
								oldCAG !== getPlayerNum("Zarek"))) {
							if(versionAtLeast([2,2,25])){
								z.friendsCAG = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the CAG title instead.");
								if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "CAG", false);
								}
							}
						}
						if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" && (!
								versionAtLeast([2, 0, 1]) || oldCAG !== getPlayerNum("Gaius"))) {
							if(versionAtLeast([2,2,25])){
								z.cultCAG = true;
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the CAG title instead.");
								if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "CAG", false);
								}
							}
						}
					} else {
						passCAG(d.cagSuccession[getCharacter(z.players[z.cag])]);
					}
					removeOption(me, ch);
					removeOption(me, "Move the Admiral title");
					mainMenu();
				});
		} else if(ch === "Move the Admiral title") {
			if(hasContext(me, ch, "Assume Command")) {
				if(isTheCylonLeader(me) || me === z.theSympatheticCylon) {
					/* TODO: Rules */
					addAlert("You cannot be the Admiral.  No effect.  If you have a different interpretation of the rules, try this option again.");
					removeOption(me, ch);
					mainMenu();
				} else {
					confirmify("Confirming you want to take the Admiral title.", mainMenu, () => {
						let oldAdmiral = z.admiral;
						z.admiral = me;
						boldAlert(z.players[z.admiral] + " is now the Admiral.");
						if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !==
							getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
								oldAdmiral !== getPlayerNum("Zarek"))) {
							if(versionAtLeast([2,2,25])){
								z.friendsAdmiral = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
						if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" &&
							(!versionAtLeast([2, 0, 1]) || oldAdmiral !== getPlayerNum("Gaius"))) {
							if(versionAtLeast([2,2,25])){
								z.cultAdmiral = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
						removeOption(me, ch);
						mainMenu();
					});
				}
			} else if(hasContext(me, ch, "Manipulative")) {
				let confirmText = "Confirming you want to give the Admiral title to ";
				let standard = 100 > z.manipulativeVictim && z.manipulativeVictim >= 0 && z.revealedCylons[z.manipulativeVictim] === 0 && z
					.playerLocations[z.manipulativeVictim] !== "Brig";
				if(standard) {
					confirmText += z.players[z.manipulativeVictim] + " now.";
				} else {
					confirmText += " the player highest on the succession list now.";
				}
				confirmify(confirmText, mainMenu, () => {
					if(standard) {
						z.admiral = z.manipulativeVictim;
						boldAlert(z.players[z.admiral] + " is now the Admiral.");
						if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !==
							getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig") {
							if(versionAtLeast([2,2,25])){
								z.friendsAdmiral = true;
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
						if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" &&
							(z.players[z.turn] !== "Gaius" || !versionAtLeast([2, 0, 1]))) {
							if(versionAtLeast([2,2,25])){
								z.cultAdmiral = true;
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
							} else {
								plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
								if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
								} else {
									addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
								}
							}
						}
					} else {
						passAdmiral(99);
					}
					z.manipulativeVictim = -1;
					removeOption(me, ch);
					mainMenu();
				});
			} else {
				let promptText = "Who receives the Admiral title? (0-" + z.numPlayers + ")\n";
				promptText += "0: Highest on the line of succession (apart from the current Admiral)\n";
				for(let i = 0; !(i >= z.numPlayers); i++) {
					promptText += (i + 1) + ": ";
					if(z.revealedCylons[i ] === 1) {
						promptText += "(Cylon)\n";
					} else if(isCylonLeader(z.players[i ])) {
						promptText += "(Cylon Leader)\n";
					} else if(i === z.theSympatheticCylon) {
						promptText += "(Sympathetic Cylon)\n";
					} else if(z.playerLocations[i ] === "Brig") {
						promptText += "(in the Brig)\n";
					} else {
						promptText += z.players[i ] + " (rank " + d.admiralSuccession[getCharacter(z.players[i ])] + ")\n";
					}
				}
				promptNum(promptText, (a) => 0 > a || a > z.numPlayers || (a > 0 && z.revealedCylons[a - 1] === 1) || (a > 0 && a - 1 === z
						.theCylonLeader) || (a > 0 && a - 1 === z.theSympatheticCylon) || (a > 0 && z.playerLocations[a - 1] === "Brig"), mainMenu,
					(prompted) => {
						if(prompted > 0) {
							let oldAdmiral = z.admiral;
							z.admiral = prompted - 1;
							t.value += bold(z.players[z.admiral] + " is now the " + colorText("green", "Admiral") + ".") + "\r\n";
							addAlert(z.players[z.admiral] + " is now the Admiral.");
							if(z.vBrutality && characterPresent("Zarek") && z.miracles[getPlayerNum("Zarek")] === 1 && !z.theFarm && z.admiral !==
								getPlayerNum("Zarek") && z.playerLocations[getPlayerNum("Zarek")] !== "Brig" && (!versionAtLeast([2, 0, 1]) ||
									oldAdmiral !== getPlayerNum("Zarek"))) {
								if(versionAtLeast([2,2,25])){
									z.friendsAdmiral = true;
									plainAlert("Zarek could use his OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
								} else {
									plainAlert("Zarek could use his OPG, Friends in Low Places, to take the Admiral title instead.");
									if(hasOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)")) {
										addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "All", false);
									} else {
										addOption(getPlayerNum("Zarek"), "Friends in Low Places (OPG)", "Admiral", false);
									}
								}
							}
							if(actsOfFaith("Zarek") && z.admiral !== getPlayerNum("Gaius") && z.playerLocations[getPlayerNum("Gaius")] !== "Brig" &&
								(!versionAtLeast([2, 0, 1]) || oldAdmiral !== getPlayerNum("Gaius"))) {
								if(versionAtLeast([2,2,25])){
									z.cultAdmiral = true;
									plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the title at the end of this turn; you should probably wait for him before ending the turn.");
								} else {
									plainAlert("Gaius could use Zarek's OPG, Friends in Low Places, to take the Admiral title instead.");
									if(hasOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)")) {
										addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "All", false);
									} else {
										addOption(getPlayerNum("Gaius"), "Friends in Low Places (OPG)", "Admiral", false);
									}
								}
							}
						} else {
							passAdmiral(d.admiralSuccession[getCharacter(z.players[z.admiral])]);
						}
						removeOption(me, ch);
						removeOption(me, "Move the President title");
						removeOption(me, "Move the CAG title");
						if(hasContext(me, ch, "Ellen")) {
							removeOption(me, "Move the President title");
						}
						mainMenu();
					});
			}
		} else if(ch === "Escort (OPG)") {
			confirmify("Confirming that you want to use your OPG, Escort.", mainMenu, () => {
				t.value += bold("Hot Dog uses his OPG, Escort.") + "\r\n";
				if(z.assist === "Hot Dog") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				let context = getContext(z.turn,"Destroy a Civilian in space");
				removeFromAll("Destroy a Civilian in space");				
				addAlert("Now, you must destroy an undamaged Viper, then reshuffle the Civilian that would have been destroyed.");
				addOption(me, "Destroy a Viper", context, true);
				removeOption(me,ch);
				mainMenu();
			});
		} else if(ch === "Choose a player to gain a Miracle Token from An Ambitious Operation") {
			if((z.assist !== undefined && z.assistMiracle === 0) || (z.assist === "Gaius" && z.assistMiracle !== 3)) {
				confirmify("Confirming you want to give " + z.assist + " a Miracle Token.", mainMenu, () => {
					plainAlert(z.assist + " gains a Miracle token.");
					z.assistMiracle++;
					mainMenu();
				});
			} else {
				let promptText = "Who should gain a Miracle Token from An Ambitious Operation? (1-" + z.numPlayers + ")";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.miracles[j] === 3) {
						promptText += "(already has three)";
					} else if(z.miracles[j] === 1 && z.players[j] !== "Gaius") {
						promptText += "(already has one)";
					} else if(z.vBrutality && z.players[j] === "D'Anna") {
						promptText += "(D'Anna cannot hold Miracle Tokens)";
					} else if(z.revealedCylons[j] === 1 && !isCylonLeader(z.players[j])) {
						promptText += "(CYLON)";
					} else if(me === j) {
						promptText += "(cannot pick yourself)";
					} else {
						promptText += z.players[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.miracles[a - 1] === 3 || (z.miracles[a - 1] === 1 && z.players[a - 1] !==
						"Gaius") || (z.vBrutality && z.players[a - 1] === "D'Anna") || (z.revealedCylons[a - 1] === 1 && a - 1 !== z
					.theCylonLeader) || a - 1 === me, mainMenu, (prompted) => {
						z.miracles[prompted - 1]++;
						boldAlert(z.players[prompted - 1] + " gains a Miracle Token from An Ambitious Operation.");
						removeOption(me, ch);
						mainMenu();
					});
			}
		} else if(ch === "Aggressive Tactics (OPG)") {
			if(z.vBrutality) {
				confirmify("Confirming that you want to use your OPG, Aggressive Tactics.", mainMenu, () => {
					if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					if(z.superCrisisDeck.length === 0) {
						plainAlert("Cavil used his Aggressive Tactics OPG, but there are no Super Crises available; no effect.");
					} else {
						z.aggressiveTactics = [z.superCrisisDeck.pop()];
						if(z.superCrisisDeck.length === 0) {
							z.superCrisisDeck = z.superCrisisDiscards;
							shuffle(z.superCrisisDeck);
							z.superCrisisDiscards = [];
							plainAlert("Super Crisis deck reshuffles.");
						}
						if(z.superCrisisDeck.length === 0) {
							addAlert("You drew " + d.crisisNames[z.aggressiveTactics[0]] +
								", which completely exhausted the Super Crisis deck.  You must play it now.");
							t.value += bold(
									"Cavil used his Aggressive Tactics OPG, but there was only 1 Super Crisis available; he must play it now."
									) + "\r\n";
						} else {
							z.aggressiveTactics.push(z.superCrisisDeck.pop());
							addAlert("You drew " + d.crisisNames[z.aggressiveTactics[0]] + " and " + d.crisisNames[z.aggressiveTactics[1]] +
								"; you must play one of them now, and place the other in your hand.");
							t.value += bold(
								"Cavil uses his Aggressive Tactics OPG to draw 2 Super Crisis cards; he must play one and add the other to his hand."
								) + "\r\n";
						}
						addOption(me, "[Aggressive Tactics] Play a Super Crisis", undefined, true);
						didAction();
						mainMenu();
					}
				});
			} else {
				confirmify("Confirming that you want to use your OPG, Aggressive Tactics.  This is a Movement ability.", mainMenu, () => {
					z.miracles[me] = 0;
					t.value += bold("Cavil uses his OPG, Aggressive Tactics.") + "\r\n";
					addAlert("You may now take two Actions (in addition to your Action step).");
					z.aggressiveTactics = 2;
					z.phase = -1;
					mainMenu();
				});
			}
		} else if(ch === "[Aggressive Tactics] Play a Super Crisis") {
			let promptText = "Which Super Crisis would you like to play?  The other will be returned to your hand. (1-" + z.aggressiveTactics.length +
				")";
			for(let j = 0; !(j >= z.aggressiveTactics.length); j++) {
				promptText += "\n" + (j + 1) + ": " + d.crisisNames[z.aggressiveTactics[j]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.aggressiveTactics.length, mainMenu, (prompted) => {
				let sc = z.aggressiveTactics.splice(prompted - 1, 1)[0];
				if(z.aggressiveTactics.length === 1) {
					addAlert("You take " + d.crisisNames[z.aggressiveTactics[0]] + " to your hand.");
					z.superCrisisHands[me].push(z.aggressiveTactics.pop());
				}
				if(z.currentCrisis !== null) {
					if(!isSuperCrisis(z.currentCrisis) && !isMission(z.currentCrisis)) {
						discardCrisis();
					}
				}
				z.currentCrisis = sc;
				z.crisisPlayer = me;
				z.mutualAnnihilation = true;
				z.aggressiveTacticsSkip = true;
				addAlert("Playing " + d.crisisNames[sc] + ".");
				plainAlert("This super crisis will be treated as if it had a Prepare for Jump icon; this turn's Crisis Step is skipped.");
				initializeCrisis(true);
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Primacy") {
			confirmify("Confirming that you want to use Primacy.", mainMenu, () => {
				t.value += bold("Cavil uses Primacy.") + "\r\n";
				let primacyPlacement = function() {
					confirmify("Would you like to place 3 Raiders in Sector 1 and 1 Civilian in Sector 4?", ()=>{
						didAction();
						mainMenu();
					},() => {
						placeRaiders(1, 3);
						placeCivilian(4);
						didAction();
						mainMenu();
					}, "YES", "NO");
				};
				if(basestarsAway() === 0 && z.basestars.length > 0) {
					if(z.basestars.length === 1 || (z.basestars.length > 0 && z.basestars[0].length === 1 && z.basestars[1].length === 1 && z
							.basestars[0][0] === z.basestars[1][0])) {
						confirmify("Would you like to remove a Basestar from the board?", () => {
							t.value += bold("Cavil chooses not to remove a Basestar.");
							primacyPlacement();
						}, () => {
							destroyBasestar(0, true);
							primacyPlacement();
						}, "YES", "NO");
					} else {
						confirmify("Would you like to remove a Basestar from the board?", () => {
							t.value += bold("Cavil chooses not to remove a Basestar.");
							primacyPlacement();
						}, () => {
							let bs1 = basestarName(0);
							let bs2 = basestarName(1);
							confirmify("Which basestar would you like to remove from the board?\n\n1: " + bs1 + "\n\n2: " + bs2, () => {
								destroyBasestar(0, true);
								primacyPlacement();
							}, () => {
								destroyBasestar(1, true);
								primacyPlacement();
							}, "Basestar 2", "Basestar 1");
						}, "YES", "NO");
					}
				} else if(z.basestars.length > 0) {
					/* RULES: Is this optional? */
					placeBasestar(1);
					primacyPlacement();
				}
			});
		} else if(ch === "ECO Officer") {
			let confirmText = "Confirming that you want to use your ECO Officer ability to reroll a die.";
			if(characterPresent("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")) && z.dieRoller === getPlayerNum("Billy") && (z
					.currentCrisis === null || z.capricaCrisis)) {
				confirmText +=
					"\nBilly's No Combat Experience drawback means any die rolls he takes during Action steps may not be rerolled.\n\nAre you sure you want to proceed?";
			}
			confirmify(confirmText, mainMenu, () => {
				t.value += bold("Helo uses his ECO Officer ability.") + "\r\n";
				z.dieRollQueue.unshift(z.lastDieRoll);
				z.dieRollModifier = z.lastDieRollModifier;
				z.eco = false;
				z.lastDieRoll = null;
				z.lastDieRollValue = null;
				z.lastDieRollModifier = null;
				addAlert("Now, reroll the die.");
				mainMenu();
			});
		} else if(ch === "Expert Raptor Pilot") {
			let confirmText = "Confirming that you want to use your Expert Raptor Pilot ability to reroll the die.";
			confirmify(confirmText, mainMenu, () => {
				t.value += bold("Racetrack uses her Expert Raptor Pilot ability.");
				z.dieRollQueue.unshift(z.lastDieRoll);
				z.dieRollModifier = z.lastDieRollModifier;
				z.expertRaptorPilot = true;
				z.lastDieRoll = null;
				z.lastDieRollValue = null;
				z.lastDieRollModifier = null;
				addAlert("Now, reroll the die.");
				mainMenu();
			});
		} else if(ch === "FTL Operator") {
			if(z.vBrutality) {
				confirmify("The second Destination card from the top is " + d.destinationNames[z.destinationDeck[z.destinationDeck.length - 2]] + ". " +
					"Would you like to place it on the bottom of the Destination deck?", () => {
						confirmify("Confirming that you want to leave " + d.destinationNames[z.destinationDeck[z.destinationDeck.length - 2]] +
							" where it is; it will be one of the choices for this jump.", mainMenu, () => {
								removeOption(me, ch);
								boldAlert("Gaeta uses his FTL Operator and chooses not to bottom the Destination card second from the top.");
								mainMenu();
							});
					}, () => {
						confirmify("Confirming that you want to bottom " + d.destinationNames[z.destinationDeck[z.destinationDeck.length - 2]] +
							" where it is; it will not be one of the choices for this jump.", mainMenu, () => {
								removeOption(me, ch);
								let d1 = z.destinationDeck.pop();
								let d2 = z.destinationDeck.pop();
								z.destinationDeck.unshift(d2);
								z.destinationDeck.push(d1);
								boldAlert("Gaeta uses his FTL Operator bottoms the Destination card second from the top.");
								mainMenu();
							});
					}, "Yes, bottom it", "No, leave it");
			} else {
				let confirmText = "Confirming that you want to use your FTL Operator ability to reroll the die.";
				if(characterPresent("Billy") && z.phase === 3 && !noDrawback(getPlayerNum("Billy")) && z.dieRoller === getPlayerNum("Billy") && (z
						.currentCrisis === null || z.capricaCrisis)) {
					confirmText +=
						"\nBilly's No Combat Experience drawback means any die rolls he takes during Action steps may not be rerolled.\n\nAre you sure you want to proceed?";
				}
				confirmify(confirmText, mainMenu, () => {
					t.value += bold("Gaeta uses his FTL Operator ability.");
					z.dieRollQueue.unshift(z.lastDieRoll);
					z.dieRollModifier = z.lastDieRollModifier;
					z.FTLOperator = false;
					z.lastDieRoll = null;
					z.lastDieRollValue = null;
					z.lastDieRollModifier = null;
					addAlert("Now, reroll the die.");
					mainMenu();
				});
			}
		} else if(ch === "Hotshot") {
			let promptText = "What card would you like to discard for Hotshot? (1-" + z.skillCardHands[me].length + ")";
			for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
				promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
			}
			promptText += "\n\nImportant: Note that you can only use Hotshot for a die roll that " + bold("you") + " would roll during your " + bold(
				"Action") + " step.";
			promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][prompted - 1];
				let confirmText = "Confirming you want to discard " + cardText(card) + "; this will make the result of the die roll " + (
					cardValue(card) + 2) + ".";
				if(z.dieRollModifier !== 0) {
					confirmText +=
						"\n\nNote that Strategic Planning and Calculations do not affect the result of Hotshot; if someone played a Strategic Planning on this " +
						"die roll, you should rewind to before they played the Strategic Planning.";
				}
				confirmify(confirmText, mainMenu, () => {
					discardSkillCard(me, prompted - 1);
					z.lastDieRoll = z.dieRollQueue.shift();
					z.lastDieRollValue = cardValue(card) + 2;
					z.lastDieRollModifier = 0;
					t.value += bold("Kat uses her Hotshot ability to make the result of the die roll a ") + dieRollImage() + "\r\n";
					processDieRoll();
					mainMenu();
				});
			});
		} else if(ch === "Politically Adroit") {
			confirmify("Confirming that you want to use your Politically Adroit ability.  It must be the end of your Movement step.", mainMenu, () => {
				t.value += bold("Ellen uses her Politically Adroit ability.") + "\r\n";
				if(z.vBrutality) {
					addAlert(
						"Now, give a skill card to another player on your location, then draw two skill cards (they may be from outside your skill set)."
						);
				} else {
					addAlert("Now, give a skill card to another player on your location, then draw two skill cards.");
				}
				addOption(me, "Give a Skill Card to another player", "Ellen", true);
				if(z.vBrutality) {
					addOption(me, "Draw 2 Skill Cards (any color)", undefined, true);
				} else {
					addOption(me, "Draw 2 Skill Cards", undefined, true);
				}
				z.politicallyAdroit = true;
				mainMenu();
			});
		} else if(ch === "Treatment") {
			let promptText = "Who would you like to treat? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.revealedCylons[j] === 1) {
					promptText += "(CYLON)";
				} else if(j === me) {
					promptText += "(Thou canst not heal thyself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || a - 1 === me, mainMenu, (prompted) => {
				confirmify("Confirming you want to treat " + z.players[prompted - 1], mainMenu, () => {
					let chr = getCharacter(z.players[prompted - 1]);
					let allowed = [];
					for(let j = 0; !(j >= 6); j++) {
						allowed.push(d.skillSets[j][chr]);
					}
					let drew = [];
					let treatment = function(k) {
						if(k === 2) {
							let confirmText = "Confirming you want to draw ";
							if(drew[0] === drew[1]) {
								confirmText += colorIDAlert(drew[0]) + ".";
							} else {
								confirmText += colorIDAlert(drew[0]) + " and 1 " + colorIDAlert(drew[1]) + ".";
							}
							confirmify(confirmText, mainMenu, () => {
								t.value += bold("Cottle uses his Treatment ability on " + z.players[prompted - 1]) +
								".\r\n";
								let card1 = dealSkillCard(me, drew[0]);
								let card2 = dealSkillCard(me, drew[1]);
								addAlert("You draw " + cardText(card1) + " and " + cardText(card2) + ".\r\n" +
									"Now, give 2 skill cards to " + z.players[prompted - 1] + ".");
								addOption(me, "Give a Skill Card to another player", [prompted - 1, 2], true);
								didAction();
								mainMenu();
							});
							return;
						}
						let promptText = "What color would you like to draw ";
						if(k === 0) {
							promptText += "(1st card)";
						} else {
							promptText += "(2nd card)";
						}
						promptText += "? (1-6)";
						for(let j = 0; !(j >= 6); j++) {
							promptText += "\n" + (j + 1) + ": ";
							if(allowed[j] === 0) {
								promptText += "(not in " + z.players[prompted - 1] + "'s skill set)";
							} else {
								promptText += colorIDAlert(j);
							}
						}
						promptNum(promptText, (a) => 1 > a || a > 6 || allowed[a - 1] === 0, mainMenu, (prompted2) => {
							drew.push(prompted2 - 1);
							treatment(k + 1);
						});
					};
					treatment(0);
				});
			});
			let a4 = "ENDBYCE  [/size] [/c]" + 
			" [c][size=1] STARTBYCF";
		} else if(ch === "Star Player" || ch === "[Movement] Star Player") {
			confirmify("Confirming that you want to use your Star Player ability.", mainMenu, () => {
				if(z.vBrutality) {
					addAlert("To use Star Player, discard up to 3 skill cards of any one color from your hand.  " +
						"Then, you may draw the same number of skill cards of any one color in your skill set.");
				} else {
					addAlert("To use Star Player, discard some number of cards from your hand.  " +
						"Then, you may draw the same number of skill cards of any one color in your skill set.");
				}
				t.value += bold("Anders uses Star Player.") + "\r\n";
				addOption(me, "[Star Player] Discard a Skill Card", 0, false);
				if(ch === "[Movement] Star Player") {
					z.phase = -1;
				} else {
					didAction();
				}
				mainMenu();
			});
		} else if(ch === "Give a Skill Card to another player") {
			let giveSkillCard = function(target) {
				let promptText = "Which skill card would you like to give to " + z.players[target] + "? (1-" + z.skillCardHands[me].length + ")";
				for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
					promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
				}
				promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, mainMenu, (prompted) => {
					let card = z.skillCardHands[me].splice(prompted - 1, 1)[0];
					addAlert("Gave " + cardText(card) + " to " + z.players[target] + ".");
					t.value += bold(myPlayer + " gives a Skill Card to " + z.players[target] + ".") + "\r\n";
					z.skillCardHands[target].push(card);
					for(let j = 0; !(j >= z.possibleColors[me].length); j++) {
						if(z.possibleColors[me][j] === 1) {
							z.possibleColors[target][j] = 1;
						}
					}
					if(z.skillCardHands[me].length === 0) {
						z.possibleColors[me] = [0, 0, 0, 0, 0, 0];
					}
					if(getContext(me, ch) !== "Ellen" && getContext(me, ch) !== undefined && getContext(me, ch)[1] > 1) {
						let num = getContext(me, ch)[1];
						let man = isMandatory(me, ch);
						addOption(me, ch, [target, num - 1], man);
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			};
			if(getContext(me, ch) === "Ellen" || getContext(me, ch) === undefined) {
				let promptText = "Who would you like to give a Skill Card to? (1-" + z.numPlayers + ")";
				let players = 0;
				let target = -1;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.revealedCylons[j] === 1) {
						promptText += "CYLON";
					} else if(myPlayer === "Ellen" && z.playerLocations[j] !== myLocation) {
						promptText += "(not on your location)";
					} else if(j === me) {
						promptText += "(cannot give a card to yourself)";
					} else {
						target = j;
						players++;
						promptText += z.players[j];
					}
				}
				if(players === 1) {
					giveSkillCard(target);
				} else if(players > 1) {
					promptNum(promptText, (a) => 1 > a || a > z.numPlayers || (myPlayer === "Ellen" && z.playerLocations[a - 1] !== myLocation) || a -
						1 === me || z.revealedCylons[a - 1] === 1, mainMenu, (prompted) => {
							giveSkillCard(prompted - 1);
						});
				}
			} else {
				giveSkillCard(getContext(me, ch)[0]);
			}
		} else if(ch === "[Quarantine] Take a card to hand") {
			let tar = getContext(me, ch);
			let promptText = "Which card would you like to take to your hand? (1-" + (z.skillCheckCards[tar].length + 1) + ")";
			for(let j = 0; !(j >= z.skillCheckCards[tar].length); j++) {
				promptText += "\n" + (j + 1) + ": " + cardText(z.skillCheckCards[tar][j]);
			}
			promptText += "\n" + (z.skillCheckCards[tar].length + 1) + ": Decline to take a card";
			promptNum(promptText, (a) => 1 > a || a > z.skillCheckCards[tar].length + 1, mainMenu, (prompted) => {
				if(prompted === z.skillCheckCards[tar].length + 1) {
					plainAlert("Cottle declines to take a card with Quarantine.");
					removeOption(me, ch);
					mainMenu();
				} else {
					let card = z.skillCheckCards[tar].splice(prompted - 1, 1)[0];
					addAlert("You take " + cardText(card) + " to your hand.");
					z.skillCardHands[me].push(card);
					t.value += "Cottle takes a card to his hand with Quarantine.\r\n";
					let any = false;
					for(let j = 0; !(j >= z.possibleColors[tar].length); j++) {
						if(z.possibleColors[tar][j] === 1) {
							any = true;
							z.possibleColors[me][j] = 1;
						}
					}
					if(!any) {
						for(let j = 0; !(j >= z.possibleColors[me].length); j++) {
							z.possibleColors[me][j] = 1;
						}
					}
					removeOption(me, ch);
					mainMenu();
				}
			});
		} else if(ch === "Quarantine (OPG)") {
			if(z.vBrutality) {
				let promptText = "Which player would you like to target with Quarantine? (1-" + z.numPlayers +
					").  Note that technically you should only target the person who just played in.";
				for(let j = 0; !(j >= z.numPlayers); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(j === me) {
						promptText += "(cannot target yourself)";
					} else if(z.skillCheckCards[j].length === 0) {
						promptText += "(played no cards)";
					} else if(z.skillCheckCards[j].length === 1) {
						promptText += z.players[j] + " (1 card)";
					} else {
						promptText += z.players[j] + " (" + z.skillCheckCards[j].length + " cards)";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me || z.skillCheckCards[a - 1].length === 0, mainMenu, (
				prompted) => {
					if(z.assist === "Cottle") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					t.value += bold("Cottle uses his OPG, Quarantine, targeting " + z.players[prompted - 1] + ".") + "\r\n";
					t.value += "He may now take one of those skill cards to hand.\r\n";
					shuffle(z.skillCheckCards[prompted - 1]);
					let alertText = z.players[prompted - 1] + " played in the following cards: ";
					for(let j = 0; !(j >= z.skillCheckCards[prompted - 1].length); j++) {
						alertText += "\n" + cardText(z.skillCheckCards[prompted - 1][j]);
					}
					alertText += "\nYou may now take one of them to your hand.";
					addAlert(alertText);
					addOption(me, "[Quarantine] Take a card to hand", prompted - 1, false);
					mainMenu();
				});
			} else {
				confirmify("Confirming that you want to use your OPG, Quarantine.", mainMenu, () => {
					t.value += bold("Cottle uses his OPG, Quarantine.") + "\r\n";
					if(spaceCiviliansList().length > 0) {
						/* TODO: better context */
						addAlert(
							"Now, you should inspect all civilian ships in space, then choose a civilian, then (if possible) place a civilian ship in the same space area, then reshuffle the chosen civilian."
							);
						addOption(me, "Inspect all Civilians in space", undefined, false);
						if(z.civilianPile.length > 0) {
							addOption(me, "Place a Civilian on the board", "Quarantine", true);
						}
						addOption(me, "Reshuffle a Civilian", "Quarantine", true);
					} else {
						plainAlert("No Civilian ships on the game board; no effect apart from spending his Miracle token.");
					}
					if(z.assist === "Cottle") {
						z.assistMiracle = 0;
					} else {
						z.miracles[me] = 0;
					}
					didAction();
					mainMenu();
				});
			}
		} else if (ch === "Attorney (OPG)" && z.vBrutality && versionAtLeast([2,2,25])){
			let brigged = [];
			for(let i = 0; !(i >= z.numPlayers); i++) {
				if((isOnNewCaprica(me) && z.playerLocations[i ] === "Detention" && i !== me) || (!isOnNewCaprica(me) && z.playerLocations[i ] === "Brig" && i !== me)) {
					brigged.push(i);
				}
			}
			let promptText = "Who would you like to target with your OPG, Attorney? (1-" + brigged.length + ")\n";
			for(let i = 0; !(i >= brigged.length); i++) {
				promptText += (i + 1) + ": " + z.players[brigged[i ]] + "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > brigged.length, mainMenu, (prompted) => {
				if(z.players[me] === "Gaius"){
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				prompted = brigged[prompted-1] + 1;
				if(prompted - 1 === z.theCylonLeader || z.loyaltyHands[prompted-1].length === 0 || (prompted - 1 === z.theSympatheticCylon && z.loyaltyHands[prompted-1].length === 1)){
					if(isOnNewCaprica(me)){
						plainAlert(z.players[me] +" uses his OPG, Attorney, on "+z.players[prompted-1]+".  No loyalty cards are inspected, but "+z.players[me]+" may move "+z.players[prompted-1]+
									" out of Detention or take all their skill cards.");
						addOption(me,"Move a player out of Detention",prompted-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted-1,false);
					} else {
						plainAlert(z.players[me] +" uses his OPG, Attorney, on "+z.players[prompted-1]+".  No loyalty cards are inspected, but "+z.players[me]+" may move "+z.players[prompted-1]+
									" out of Detention or take all their skill cards.");
						addOption(me,"Move a player out of the Brig",prompted-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted-1,false);
					}
					
				} else if((prompted - 1 === z.theSympatheticCylon && 3 >= z.loyaltyHands[prompted-1].length) || 2 >= z.loyaltyHands[prompted-1].length){
					plainAlert(z.players[me]+" uses his OPG, Attorney, on "+z.players[prompted-1]+", and must now inspect all their Loyalty cards.");
					addOption(me,"[Attorney] Inspect all Loyalty Cards",prompted-1,true);
				} else {
					let prompted2 = prompted;
					let secretText = "Two of " + z.players[prompted2 - 1] + "'s Loyalty Cards:";
					let finalFives = [];

					if(prompted2 - 1 !== z.theSympatheticCylon){
						shuffle(z.loyaltyHands[prompted2-1]);
					} else {
						let loy = z.loyaltyHands[prompted2-1].shift();
						shuffle(z.loyaltyHands[prompted2-1]);
						z.loyaltyHands[prompted2-1].unshift(loy);
					}
					for(let i = 1; !(i >= 3); i++) {
						let loy = z.loyaltyHands[prompted2 - 1][i ];
						if(isFinalFive(loy)) {
							finalFives.push(loy);
						}
						secretText += "\r\n" + d.loyaltyNames[z.loyaltyHands[prompted2 - 1][i ]];
					}
					z.secretMessages[me] += "\n" + secretText;
					addAlert(secretText + "\n\nThis can also be viewed in your hand report, for your later perusal.");
					t.value += bold(z.players[me]+" uses his OPG, Attorney, on "+z.players[prompted-1]+", and inspects two of their Loyalty cards at random.");
					if(finalFives.length === 1) {
						let loy = finalFives[0];
						if(isFinalFive(loy)) {
							addAlert(d.loyaltyNames[loy] + " is revealed to the table.");
							t.value += bold(myPlayer + " reveals that " + z.players[prompted2 - 1] + " is a Final Five with " + d.loyaltyNames[
								loy]) + ".\r\n";
							if(z.vBrutality && characterPresent("D'Anna")) {
								boldAlert(
									"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card."
									);
								addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", 1], true);
							}
							switch (loy) {
								case 32:
									if(z.revealedCylons[me] === 0) {
										executePlayer(me, false);
									} else {
										addAlert("As a Cylon, you are not executed.");
										t.value += "As a Cylon, " + myPlayer + " is not executed.\r\n";
									}
									break;
								case 33:
									if(!z.negotiation && !z.galacticaAway) {
										if(activateRaiders()) {
											if(activateBasestars()) {
												activateHeavies();
											} else {
												plainAlert("After Basestars finish activating, activate Heavy Raiders.");
												optionForAll("Activate Heavy Raiders");
											}
										} else {
											plainAlert("After Raiders are done activating, activate Basestars, then activate Heavy Raiders.");
											optionForAll("Activate Basestars");
											optionForAll("Activate Heavy Raiders");
										}
									} else if(z.galacticaAway) {
										addAlert("Cylon ships do not activate as Galactica is away.");
									} else {
										addAlert("Cylon ships do not activate due to Negotiation.");
										t.value += "Cylon ships do not activate due to " + colorText("orange", "Negotiation") + ".\r\n";
									}
									break;
								case 34:
									if(!z.galacticaAway) {
										if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
											addAlert(
												"Now, the current player must choose whether to damage Pegasus or Galactica for each damage, in turn."
												);
											t.value += "Now, " + z.players[z.turn] +
												", as current player, must choose whether to damage Pegasus or Galactica for each damage, in turn.\r\n";
											addOption(z.turn, "Damage Pegasus", 2, true);
											addOption(z.turn, "Damage Galactica", 2, true);
										} else {
											if(damageGalactica()) {
												damageGalactica();
											} else {
												plainAlert("After resolving Ally placement, damage Galactica again.");
												for(let j = 0; !(j >= z.numPlayers); j++) {
													if(z.revealedCylons[j] === 1) {
														addOption(j, "Damage Galactica", undefined, false);
													}
												}
											}
										}
									} else {
										plainAlert("Galactica cannot be damaged while she is away.");
									}
									break;
								case 35: {
									let assist = z.numPlayers === 1 && z.players.length === 1;
									if(!assist) {
										executePlayer(prompted2 - 1, false, true);
										if(z.vBrutality) {
											plainAlert("After the execution resolves, all players must discard 2 random skill cards.");
										} else {
											plainAlert("After the execution resolves, all Human players must discard 2 random skill cards.");
										}
										for(let j = 0; !(j >= z.numPlayers); j++) {
											if(z.revealedCylons[j] === 0 || z.vBrutality) {
												if(z.forLove && z.players[j] !== "Athena") {
													addOption(j, "Discard a random Skill Card", 1, true);
													z.randomLove[j] = true;
												} else {
													addOption(j, "Discard a random Skill Card", 2, true);
												}
											}
										}
										if(!z.forLove) {
											optionForAll("Trigger the random discards from the Final Five");
										}
									} else {
										plainAlert("The assist character cannot be executed, but you still discard 2 random skill cards.");
										discardRandomSkillCard(me);
										discardRandomSkillCard(me);
									}
									break;
								}
								case 36:
									if(myLocation === "Stranded on Caprica") {
										addAlert("Since you are Stranded, you are not sent to the Brig.");
										t.value += "Helo is Stranded, and cannot be sent to the Brig.\r\n";
									} else if(z.revealedCylons[me] === 1) {
										addAlert("As a Cylon, you are not sent to the Brig.");
										t.value += "As a Cylon, " + myPlayer + " is not sent to the Brig.\r\n";
									} else if(myLocation === "Brig") {
										addAlert("You are already in the Brig.");
										t.value += myPlayer + " is already in the Brig.\r\n";
									} else if(myLocation === "Detention") {
										addAlert("You are already in Detention.");
										t.value += myPlayer + " is already in Detention.\r\n";
									} else if(isOnNewCaprica(me)) {
										addAlert("You are sent to Detention.");
										movePlayer(me, "Detention");
									} else {
										addAlert("You are sent to the Brig.");
										movePlayer(me, "Brig");
									}
									break;
							}
						}
					} else if(finalFives.length > 1) {
						addAlert("The Final Five cards are revealed to the table.");
						t.value += bold(myPlayer + " reveals that " + z.players[prompted2 - 1] + " is a Final Five with:");
						let count = 0;
						for(let j = 0; !(j >= finalFives.length); j++) {
							t.value += "\r\n" + bold(d.loyaltyNames[finalFives[j]]);
							if(finalFives[j] === 32 && z.revealedCylons[me] === 0){
								count++;
								addOption(me,"Execute a player", z.players[me],true);
								plainAlert(z.players[me]+ " will be executed.");
							} else if(finalFives[j] === 33 && !z.negotiation && !z.galacticaAway){
								addOption(me,"Activate Raiders",undefined,true);
								addOption(me,"Activate Basestars",undefined,true);
								addOption(me,"Activate Heavy Raiders",undefined,true);
								plainAlert("Raiders, Basestars, and Heavy Raiders will activate, in that order.");
							} else if(finalFives[j] === 34){
								if(z.pegasus && !z.pegasusDestroyed && !z.vAltDamage) {
									plainAlert("Two damage will be applied; "+z.players[z.turn]+" will have to choose whether Pegasus or Galactica will be damaged each time.");
									addOption(z.turn, "Damage Pegasus", 2, true);
									addOption(z.turn, "Damage Galactica", 2, true);
								} else {
									plainAlert("Galactica will be damaged twice.");
									addOption(z.turn, "Damage Galactica", 2, true);
								}
							} else if(finalFives[j] === 35) {
								count++;
								addOption(me,"Execute a player", z.players[prompted2 - 1], true);
								plainAlert(z.players[prompted2-1]+" will be executed; all other Humans will have to discard 2 random skill cards and " + (2 *
									(finalFives.length - 1)) + " skill cards of their choice.");
								for(let j = 0; !(j>=z.numPlayers); j++){
									if((z.vBrutality || z.revealedCylons[j] === 0) && j !== prompted2 - 1){
										if(z.players[j] === "Apollo" && !noDrawback(j)){
											addOption(j,"Discard a random skill card",2 * finalFives.length,true);
										} else {
											promptAllyDiscards(j,2 * (finalFives.length - 1),true);
											addOption(j,"Discard a random skill card",2,true);
										}
									}
								}
							} else if(finalFives[j] === 36 && z.revealedCylons[me] === 0){
								if(myLocation === "Stranded on Caprica" || myLocation === "Brig" || myLocation === "Detention"){
									addAlert("If you are going to be executed by this and choose to be executed first before sending yourself to the Brig, your new character will be sent to the Brig.  You likely don't want to do that, but in case you do, you'll have to use the deep menus.");	
								} else if(isOnNewCaprica(me)){
									plainAlert(z.players[me]+" will be moved to Detention.");
									addOption(me,"Move a player to Detention",undefined,true);
								} else {
									plainAlert(z.players[me]+" will be moved to the Brig.");
									addOption(me,"Move a player to Detention",undefined,true);
								}
							}
						}
						t.value += "\r\n";
						if(z.vBrutality && characterPresent("D'Anna")) {
							boldAlert(
								"D'Anna's The Opera House Discovery ability is triggered; she now draws 2 skill cards (any color) and 1 Super Crisis card for each Final Five card revealed."
								);
							addOption(getPlayerNum("D'Anna"), "Draw 2 Skill Cards (any color)", ["The Opera House Discovery", finalFives.length],
								true);
						}
						boldAlert(z.players[z.turn] + ", as current player, must now choose the order in which the Final Five cards are applied.");
						if(count === 2){
							addOption(me,"Execute a player",["Final Fives",me,prompted2-1],true);
						}
					}
					
					if(isOnNewCaprica(me)){
						plainAlert(z.players[me] +" must now move "+z.players[prompted2-1]+" out of Detention or steal all their skill cards.");
						addOption(me,"Move a player out of Detention",prompted-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted-1,false);
					} else {
						plainAlert(z.players[me] +" must now move "+z.players[prompted2-1]+" out of the Brig or steal all their skill cards.");
						addOption(me,"Move a player out of the Brig",prompted-1,false);
						addOption(me,"[Attorney] Steal Skill Cards",prompted-1,false);
					}

				}
				mainMenu();
			});
			
		} else if (ch === "[Attorney] Steal Skill Cards"){
			let target = getContext(me,ch);
			t.value += z.players[me] + " steals all of "+z.players[target]+" skill cards.\r\n";
			let stolenCards = "You steal the following skill cards:";
			z.skillCardHands[target].sort(cardCompare);
			for(let j = 0; !(j >= z.skillCardHands[target].length); j++) {
				stolenCards += "\n" + cardText(z.skillCardHands[target][j]);
			}
			addAlert(stolenCards);
			z.skillCardHands[me] = z.skillCardHands[me].concat(z.skillCardHands[target]);
			z.skillCardHands[target] = [];
			for(let j = 0; !(j >= z.possibleColors[target].length); j++) {
				if(z.possibleColors[target][j] === 1) {
					z.possibleColors[me][j] = 1;
				}
				z.possibleColors[target][j] = 0;
			}
			removeOption(me,ch);
			removeOption(me,"Move a player out of the Brig");
			removeOption(me,"Move a player out of Detention");
			mainMenu();
		} else if(ch === "Move a player out of Detention" || (onNewCaprica(myLocation) && ch === "Attorney (OPG)" && (!z.vBrutality || !versionAtLeast([2,2,25])))) {
			let attorney = ch === "Attorney (OPG)";
			let context = getContext(me,ch);
			let jailbreak = function(target) {
				let locations = ["Resistance HQ", "Occupation Authority", "Breeder's Canyon", "Shipyard"];
				if(ch === "Move a player out of Detention" && (context === "Presidential Pardon" || context === "Make a Deal") && z.galacticaReturned){
					locations = ["FTL Control", "Weapons Control", "Command", "Communications", "Admiral's Quarters",
							"Research Lab", "Hangar Deck", "Armory"
						];
				}
				let promptText = "Where would you like to move " + z.players[target] + "? (1-"+locations.length+")";
				for(let j = 0; !(j >= locations.length); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(z.players[me] === "Leoben" && target === me && otherPlayerInLocation(me, locations[j]) && !solo) {
						promptText += "(Clouded)";
					} else {
						promptText += locations[j];
					}
				}
				promptNum(promptText, (a) => 1 > a || a > locations.length || (myPlayer === "Leoben" && target === me && !solo &&
					otherPlayerInLocation(me, locations[a - 1])), mainMenu, (loc) => {
					let prompted = locations[loc - 1];
					if(attorney) {
						if(z.assist === "Romo") {
							z.assistMiracle = 0;
						} else if(z.players[me] === "Gaius") {
							z.miracles[me] -= 2;
						} else {
							z.miracles[me] = 0;
						}
						t.value += bold("Romo uses his OPG, Attorney.") + "\r\n";
						if(target !== me) {
							let stolenCards = "You steal the following skill cards:";
							z.skillCardHands[target].sort(cardCompare);
							for(let j = 0; !(j >= z.skillCardHands[target].length); j++) {
								stolenCards += "\n" + cardText(z.skillCardHands[target][j]);
							}
							addAlert(stolenCards);
							z.skillCardHands[me] = z.skillCardHands[me].concat(z.skillCardHands[target]);
							z.skillCardHands[target] = [];
							for(let j = 0; !(j >= z.possibleColors[target].length); j++) {
								if(z.possibleColors[target][j] === 1) {
									z.possibleColors[me][j] = 1;
								}
								z.possibleColors[target][j] = 0;
							}
							t.value += "Romo steals all of " + z.players[target] + "'s skill cards.\r\n";
						}
						didAction();
					}
					addAlert("Moved " + z.players[target] + " from Detention to " + prompted + ".");
					
					if(context === "Make a Deal") {
						addOption(me, "Deal a Mutiny card", "Make a Deal", true);
					}
					if(Number.isInteger(context)){
						removeOption(me,"[Attorney] Steal Skill Cards");
					}

					
					movePlayer(target, prompted);
					removeOption(me, ch);
					mainMenu();
				});
			};
			let brigged = [];
			if(hasContext(me, ch, "Escape")) {
				brigged = [me];
			} else if (Number.isInteger(context)){
				brigged = [context];
			} else {
				for(let i = 0; !(i >= z.numPlayers); i++) {
					if(z.playerLocations[i ] === "Detention" && (i !== me || !hasContext(me, ch, "Presidential Pardon"))) {
						brigged.push(i);
					}
				}
			}
			if(brigged.length === 1) {
				jailbreak(brigged[0]);
			} else if(brigged.length > 1) {
				let promptText = "Who would you like to move out of Detention? (1-" + brigged.length + ")\n";
				for(let i = 0; !(i >= brigged.length); i++) {
					promptText += (i + 1) + ": " + z.players[brigged[i ]] + "\n";
				}
				promptNum(promptText, (a) => 1 > a || a > brigged.length, mainMenu, (prompted) => {
					jailbreak(brigged[prompted - 1]);
				});
			}

		} else if(ch === "Move a player out of the Brig" || (!onNewCaprica(myLocation) && ch === "Attorney (OPG)" && (!z.vBrutality || !versionAtLeast([2,2,25])))) {
			let attorney = ch === "Attorney (OPG)";
			let context = getContext(me,ch);
			let jailbreak = function(target, destination) {
				if(destination === undefined) {
					if(hasContext(me, ch, "Dishonest Tactics")) {
						jailbreak(target, "Command");
					} else {
						let locations = ["FTL Control", "Weapons Control", "Command", "Communications", "Admiral's Quarters",
							"Research Lab", "Hangar Deck", "Armory"
						];
						let promptText = "Where on Galactica would you like to move " + z.players[target] + "? (1-8)";
						for(let j = 0; !(j >= 8); j++) {
							promptText += "\n" + (j + 1) + ": ";
							if(z.players[me] === "Leoben" && target === me && !solo && otherPlayerInLocation(me, locations[j])) {
								promptText += "(Clouded)";
							} else {
								promptText += locations[j];
							}
						}
						promptNum(promptText, (a) => 1 > a || a > 8 || (z.players[me] === "Leoben" && target === me && !solo &&
							otherPlayerInLocation(me, locations[a - 1])), mainMenu, (prompted) => {
							jailbreak(target, locations[prompted - 1]);
						});
					}
				} else {
					if(attorney) {
						if(z.assist === "Romo") {
							z.assistMiracle = 0;
						} else if(z.players[me] === "Gaius") {
							z.miracles[me] -= 2;
						} else {
							z.miracles[me] = 0;
						}
						t.value += bold("Romo uses his OPG, Attorney.") + "\r\n";
						if(target !== me) {
							let stolenCards = "You steal the following skill cards:";
							z.skillCardHands[target].sort(cardCompare);
							for(let j = 0; !(j >= z.skillCardHands[target].length); j++) {
								stolenCards += "\n" + cardText(z.skillCardHands[target][j]);
							}
							addAlert(stolenCards);
							z.skillCardHands[me] = z.skillCardHands[me].concat(z.skillCardHands[target]);
							z.skillCardHands[target] = [];
							for(let j = 0; !(j >= z.possibleColors[target].length); j++) {
								if(z.possibleColors[target][j] === 1) {
									z.possibleColors[me][j] = 1;
								}
								z.possibleColors[target][j] = 0;
							}
							t.value += "Romo steals all of " + z.players[target] + "'s skill cards.\r\n";
						}
						didAction();
					}
					addAlert("Moved " + z.players[target] + " from the Brig to " + destination + ".");
					movePlayer(target, destination);
					if(hasContext(me, ch, "Make a Deal")) {
						addOption(me, "Deal a Mutiny card", "Make a Deal", true);
					}
					if(Number.isInteger(context)){
						removeOption(me,"[Attorney] Steal Skill Cards");
					}
					removeOption(me, ch);
					mainMenu();
				}
			};
			let brigged = [];
			if(hasContext(me, ch, "Escape")) {
				brigged = [me];
			} else if(Number.isInteger(context)){
				brigged = [context];
			} else {
				for(let i = 0; !(i >= z.numPlayers); i++) {
					if(z.playerLocations[i ] === "Brig" && (i !== me || !hasContext(me, ch, "Presidential Pardon"))) {
						brigged.push(i);
					}
				}
			}
			if(brigged.length === 1) {
				if(hasContext(me, ch, "Dishonest Tactics")){
					confirmify("Confirming you want to move "+z.players[brigged[0]]+" from the Brig to Command.",mainMenu,()=>{
						jailbreak(brigged[0]);
					});
				} else {
					jailbreak(brigged[0]);
				}
			} else if(brigged.length > 1) {
				let promptText = "Who would you like to move out of the Brig? (1-" + brigged.length + ")\n";
				for(let i = 0; !(i >= brigged.length); i++) {
					promptText += (i + 1) + ": " + z.players[brigged[i ]] + "\n";
				}
				promptNum(promptText, (a) => 1 > a || a > brigged.length, mainMenu, (prompted) => {
					jailbreak(brigged[prompted - 1]);
				});
			}
		} else if(ch === "Move a player to Detention") {
			let promptText = "Who would you like to move to Detention? (1-" + z.numPlayers + ")\n";
			for(let i = 0; !(i >= z.numPlayers); i++) {
				promptText += (i + 1) + ": ";
				if(z.revealedCylons[i ] === 1) {
					promptText += "(cannot send a Cylon to Detention)\n";
				} else if(z.playerLocations[i ] === "Detention") {
					promptText += "(already in Detention)\n";
				} else if(z.playerLocations[i ] === "Stranded on Caprica") {
					promptText += "(stranded on Caprica)\n";
				} else if(!isOnNewCaprica(i)) {
					promptText += "(not on New Caprica)\n";
				} else {
					promptText += z.players[i ] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || z.playerLocations[a - 1] === "Detention" || !
				isOnNewCaprica(a - 1), mainMenu, (prompted) => {
					addAlert("Moved " + z.players[prompted - 1] + " to Detention.");
					movePlayer(prompted - 1, "Detention");
					removeOption(me, ch);
					removeOption(me, "Move a player to the Brig");
					mainMenu();
				});
		} else if(ch === "Move a player to the Brig") {
			let context = getContext(me,ch);
			if(context === "Requested Resignation") {
				confirmify("Confirming you want to move to the Brig rather than relinquish your title.", mainMenu, () => {
					if(z.playerLocations[me] === "Brig"){
						plainAlert("The President is already in the Brig.");
					} else if(z.playerLocations[me] === "Detention"){
						plainAlert("The President is already in Detention.");
					} else {
						addAlert("Moved you to the Brig.");
						if(isOnNewCaprica(me)) {
							movePlayer(me, "Detention");
						} else {
							movePlayer(me, "Brig");
						}
					}
					removeOption(me, ch);
					removeOption(me, "Move the President title");
					mainMenu();
				});
			} else if(Array.isArray(context)){
				let confirmText = "Confirming you want to pass on Intolerant and move "+z.players[context[1]]+" to the Brig rather than executing them.";
				confirmify(confirmText,mainMenu,()=>{
					if(isOnNewCaprica(context[1])){
						boldAlert("Cain passes on Intolerant; "+z.players[context[1]]+" is sent to Detention.");
						movePlayer(context[1],"Brig");
					} else {
						boldAlert("Cain passes on Intolerant; "+z.players[context[1]]+" is sent to the Brig.");
						movePlayer(context[1],"Brig");
					}
					removeOption(me,ch);
					removeOption(me,"Execute a player");
					mainMenu();
				});
			} else {
				let promptText = "Who would you like to move to the Brig? (1-" + z.numPlayers + ")\n";
				for(let i = 0; !(i >= z.numPlayers); i++) {
					promptText += (i + 1) + ": ";
					if(z.revealedCylons[i ] === 1) {
						promptText += "(cannot brig a Cylon)\n";
					} else if(z.playerLocations[i ] === "Brig") {
						promptText += "(already in the Brig)\n";
					} else if(z.playerLocations[i ] === "Stranded on Caprica") {
						promptText += "(stranded on Caprica)\n";
					} else if(isOnNewCaprica(i)) {
						promptText += "(on New Caprica)\n";
					} else if(hasContext(me, ch, "Reveal") && !isOnGalactica(i)) {
						promptText += "(not on Galactica)\n";
					} else if(context === "Tigh" && i === me){
						promptText += "(cannot choose yourself)\n";
					} else {
						promptText += z.players[i ] + "\n";
					}
				}
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || (hasContext(me, ch, "Reveal") && !isOnGalactica(a - 1)) || z.revealedCylons[
						a - 1] === 1 || z.playerLocations[a - 1] === "Brig" || isOnNewCaprica(a - 1) || z.playerLocations[a - 1] ===
					"Stranded on Caprica" || (context === "Tigh" && a-1 === me), mainMenu, (prompted) => {
						addAlert("Moved " + z.players[prompted - 1] + " to the Brig.");
						movePlayer(prompted - 1, "Brig");
						removeOption(me, ch);
						removeOption(me, "Move a player to Detention");
						mainMenu();
					});
			}
		} else if(ch === "Move a player to the Medical Center") {
			let promptText = "Who would you like to move to the Medical Center? (1-" + z.numPlayers + ")\n";
			for(let i = 0; !(i >= z.numPlayers); i++) {
				promptText += (i + 1) + ": ";
				if(z.revealedCylons[i ] === 1) {
					/* RULES: can Cylons ignore violent outbursts on NC? */
					promptText += "(cannot send a Cylon to the Medical Center)\n";
				} else if(z.playerLocations[i ] === "Detention") {
					promptText += "(in Detention)\n";
				} else if(z.playerLocations[i ] === "Medical Center") {
					promptText += "(already in the Medical Center)\n";
				} else if(z.playerLocations[i ] === "Stranded on Caprica") {
					promptText += "(stranded on Caprica)\n";
				} else if(!isOnNewCaprica(i)) {
					promptText += "(not on New Caprica)\n";
				} else {
					promptText += z.players[i ] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || z.playerLocations[a - 1] === "Detention" || !
				isOnNewCaprica(a - 1) || z.playerLocations[a - 1] === "Medical Center", mainMenu, (prompted) => {
					addAlert("Moved " + z.players[prompted - 1] + " to the Medical Center.");
					movePlayer(prompted - 1, "Medical Center");
					removeOption(me, ch);
					mainMenu();
				});
		} else if(ch === "Move a player to Sickbay") {
			if(hasContext(me, ch, "Stim Junkie")) {
				/* this is only triggered in earth games */
				if(!characterPresent("Kat")) {
					removeFromAll(ch);
					addAlert("BYC seems to think you want to move Kat to Sickbay for her Stim Junkie, but she's no longer around.  Maybe try again.");
					mainMenu();
				} else if(z.playerLocations[getPlayerNum("Kat")] === "Brig") {
					removeFromAll(ch);
					addAlert("Kat is in the Brig, and cannot be sent to Sickbay.");
					mainMenu();
				} else if(z.playerLocations[getPlayerNum("Kat")] === "Sickbay") {
					removeFromAll(ch);
					addAlert("Kat is already in Sickbay.");
					mainMenu();
				} else {
					confirmify("Confirming you want to move " + z.players[z.turn] + " to Sickbay.", mainMenu, () => {
						movePlayer(z.turn, "Sickbay");
						removeFromAll(ch);
						mainMenu();
					});
				}
			} else {
				let promptText = "Who would you like to move to Sickbay? (1-" + z.numPlayers + ")\n";
				for(let i = 0; !(i >= z.numPlayers); i++) {
					promptText += (i + 1) + ": ";
					if(z.revealedCylons[i ] === 1) {
						promptText += "(cannot send a Cylon to Sickbay)\n";
					} else if(z.playerLocations[i ] === "Brig") {
						promptText += "(in the Brig)\n";
					} else if(z.playerLocations[i ] === "Sickbay" && !hasContext(me, ch, "Reveal")) {
						promptText += "(already in Sickbay)\n";
					} else if(z.playerLocations[i ] === "Stranded on Caprica") {
						promptText += "(stranded on Caprica)\n";
					} else if(isOnNewCaprica(i)) {
						promptText += "(on New Caprica)\n";
					} else if(hasContext(me, ch, "Reveal") && !isOnGalactica(i)) {
						promptText += "(not on Galactica)\n";
					} else if((hasContext(me, ch, "another") || hasContext(me, ch, "Interrogation")) && i === me) {
						promptText += "(cannot choose yourself)\n";
					} else {
						promptText += z.players[i ] + "\n";
					}
				} /* TODO: options by context */
				promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || (hasContext(me, ch, "another") && a - 1 ===
						me) || (hasContext(me, ch, "Reveal") && !isOnGalactica(a - 1)) || z.playerLocations[a - 1] === "Brig" || isOnNewCaprica(a -
						1) || (z.playerLocations[a - 1] === "Sickbay" && !hasContext(me, ch, "Reveal")) || z.playerLocations[a - 1] ===
					"Stranded on Caprica", mainMenu, (prompted) => {
						addAlert("Moved " + z.players[prompted - 1] + " to Sickbay.");
						movePlayer(prompted - 1, "Sickbay");
						if(hasContext(me, ch, "Reveal")) {
							promptAllyDiscards(prompted - 1, 5);
						} else if(hasContext(me, ch, "Interrogation")) {
							if(z.detectorSabotage) {
								plainAlert("Due to Detector Sabotage, Loyalty cards may not be inspected.");
							} else if(isTheCylonLeader(prompted - 1) || (prompted - 1 === z.theSympatheticCylon && z.loyaltyHands[prompted - 1]
									.length === 1) || z.loyaltyHands[prompted - 1].length === 0) {
								plainAlert(z.players[prompted - 1] + " has no Loyalty cards to inspect.");
							} else {
								plainAlert("The Admiral may now look at one of " + z.players[prompted - 1] + "'s Loyalty cards at random.");
								addOption(z.admiral, "Inspect a random Loyalty card of another player", prompted - 1, false);
							}
						}
						removeFromAll(ch);
						mainMenu();
					});
			}
		} else if(ch === "Issue Executive Order") {
			let promptText = "Who would you like to target with your Executive Order? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(z.revealedCylons[j] === 1) {
					promptText += "(CYLON)"; /* RULES: can you XO turn 1 Helo just to dump a card? */
				} else if(z.playerLocations[j] === "Stranded on Caprica") {
					promptText += "(Stranded)";
				} else if(j === me) {
					promptText += "(cannot XO yourself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || z.revealedCylons[a - 1] === 1 || z.playerLocations[a - 1] ===
				"Stranded on Caprica" || a - 1 === me, mainMenu, (prompted) => {
					/* TODO: Executive Order to banner? */
					removeOption(me, ch);
					boldAlert(myPlayer + " targets " + z.players[prompted - 1] + " with the Executive Order.");
					plainAlert(z.players[prompted - 1] + " may now move and take an action, or take 2 actions.");
					if(z.vBrutality && versionAtLeast([1, 2, 4, 2]) && z.players[prompted - 1] === "Starbuck" && prompted - 1 !== z
						.theSympatheticCylon && !noDrawback(prompted - 1)) {
						plainAlert("Starbuck's Insubordinate triggers.");
						promptRandomDiscards(prompted - 1, 1);
					}
					if(z.players[prompted - 1] === "Shaw" && (me === z.president || me === z.admiral)) {
						addAlert("Shaw may use her Razor ability here.");
						addOption(prompted - 1, "Razor", undefined, false);
					}
					z.xo1 = prompted - 1;
					mainMenu();
				});
		} else if(ch === "Play a Declare Emergency") {
			/* TODO: return DEs to hand */
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Declare Emergency") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Declare Emergency would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				removeFromAll("[Human Delusion] Play a card into the skill check");
				let card = z.skillCardHands[me][mfs[prompted - 1]];
				playSkillCard(me, mfs[prompted - 1], false);
				z.thisDifficulty -= 2;
				boldAlert(z.players[me] + " plays " + cardText(card) + ".");
				z.des[me] = cardValue(card);
				DEToken();
				t.value += skillCheckTally(true)[0] + "\r\n";
				mainMenu();
			});
		} else if(ch === "Play a Strategic Planning") {
			/* TODO: return SPs to hand */
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Strategic Planning") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Strategic Planning would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][mfs[prompted - 1]];
				playSkillCard(me, mfs[prompted - 1], false);
				z.dieRollModifier += 2;
				z.sps[me] = cardValue(card);
				boldAlert(z.players[me] + " plays " + cardText(card) + ".");
				if(z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[me] === "Lee") {
					plainAlert("Lee's Forward Thinker triggers.");
					let card = dealSkillCard(me, 2);
					addAlert("You draw " + cardText(card) + ".");
				}
				SPToken(z.dieRollQueue[0]);
				z.spToken = true;
				mainMenu();
			});
		} else if(ch === "Play a Calculations") {
			/* TODO: Calculations CO */
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Calculations") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Calculations would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				playSkillCard(me, mfs[prompted - 1], true);
				confirmify("Would you like to increase the die roll or decrease it?", () => {
					z.lastDieRollModifier--;
					plainAlert(myPlayer + " decreases the last die roll by 1 to " + (z.lastDieRollValue + z.lastDieRollModifier) + ".");
					mainMenu();
				}, () => {
					z.lastDieRollModifier++;
					plainAlert(myPlayer + " increases the last die roll by 1 to " + (z.lastDieRollValue + z.lastDieRollModifier) + ".");
					mainMenu();
				}, "Increase", "Decrease");
			});
		} else if(ch === "Play a Major Victory") {
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Major Victory") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Major Victory would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][mfs[prompted - 1]];
				playSkillCard(me, mfs[prompted - 1], true);
				addAlert("Playing " + cardText(card) + ".");
				SPTokenBad("Major Victory");
				z.majorVictory = true;
				removeOption(me, ch);
				mainMenu();
			});
		} else if(ch === "Play an Evasive Maneuvers") {
			/* RULES: Can Brutality Anders longshot a Billy roll in an action step? */
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Evasive Maneuvers") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Evasive Maneuvers would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				playSkillCard(me, mfs[prompted - 1], true);
				let foundSP = false;
				for(let j = 0; !(j >= z.numPlayers); j++) {
					if(z.sps[j] !== null && z.sps[j] > 0) {
						foundSP = true;
						break;
					}
				}
				z.dieRollQueue.unshift(z.lastDieRoll);
				z.dieRoller = z.turn;
				let DRRE = /(Raider|Scar) vs\. (.*)$/.exec(z.lastDieRoll);
				let unpiloted = (DRRE[2].slice(0, 5) === "Viper" || DRRE[2].slice(0, 5) === "Assau");
				if(0 > z.lastDieRollModifier || (0 === z.lastDieRollModifier && foundSP) || unpiloted) {
					z.dieRollModifier = z.lastDieRollModifier;
				} else {
					z.dieRollModifier = z.lastDieRollModifier - 2;
				}
				z.lastDieRoll = null;
				addAlert("Now, reroll the die.");
				mainMenu();
			});
		} else if(ch === "Best of the Best") {
			let card = 0;
			let pos = 0;
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Best of the Best") {
					pos = j;
					card = z.skillCardHands[me][j];
				}
			}
			if(card === 0) {
				mainMenu();
			} else {
				confirmify("Confirming you want to play " + cardText(card) + " to roll a die and destroy that many Raiders in the Viper's space area.",
					mainMenu, () => {
						for(let j = 0; !(j >= z.numPlayers); j++) {
							let DRRE = new RegExp(z.players[j] + " vs", "g");
							if(z.dieRollQueue.length > 0 && DRRE.test(z.dieRollQueue[0])) {
								playSkillCard(me, pos, true);
								z.dieRollQueue.shift();
								SPTokenBad("Best of the Best (" + z.playerLocations[j] + ")");
								mainMenu();
								return;
							}
						}
						mainMenu();
						return;
					});
			}
		} else if(ch === "Change of Plans") {
			let card = 0;
			let pos = 0;
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Change of Plans") {
					pos = j;
					card = z.skillCardHands[me][j];
				}
			}
			if(card === 0) {
				mainMenu();
			} else {
				confirmify("Confirming you want to play " + cardText(card) +
					"; the pass effect of this skill check will be changed to: Each Human draws 2 Skill Cards.", mainMenu, () => {
						removeFromAll("[Human Delusion] Play a card into the skill check");
						let changeOfPlans = function() {
							playSkillCard(me, pos, true); /* TODO: order of draws may matter, change of plans token */
							plainAlert("The Pass effect of this skill check is replaced with: Every Human draws 2 skill cards.");
							z.changeOfPlans = true;
							menuPage = "Default";
							processSkillCheckOutcome();
							mainMenu();
						};
						if(z.currentSkillCheck === "Admiral's Quarters" && characterPresent("Cain") && skillCheckTally(true)[2] >= 10 && (!z
								.vBrutality || !versionAtLeast([2, 0, 1]))) {
							t.value += bold(myPlayer + " reveals " + colorText("green", "Change of Plans") +
								" from their hand with the intention to play it.") + "\r\n";
							addAlert("You reveal Change of Plans.");
							confirmify("Cain may also want to use her Intolerant ability on this skill check.  If she does, " + z.players[z.turn] +
								", as current player, " +
								"decides which effect (the Intolerant or the Change of Plans) goes ahead.  If they decide to go with Intolerant, you get to keep the Change of Plans.",
								mainMenu, changeOfPlans, "Proceed with Change of Plans", "Wait for Cain");
						} else {
							changeOfPlans();
						}
					});
			}
		} else if(ch === "Play a Run Interference") {
			/* TODO: RULES: timing issues here (technically at the start of Raider activation) */
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Run Interference") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Run Interference would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				playSkillCard(me, mfs[prompted - 1], true);
				addAlert("The first 4 Raider shots in your space area during this activation automatically miss.");
				let mySector = parseInt(z.playerLocations[me].slice(7));
				let numStopped = 0;
				let scarTrouble = false;
				for(let j = 0; !(j >= z.raiders.length) && numStopped !== 4; j++) {
					if(z.raiders[j] === mySector && z.raiderActivated[j] === 0) {
						if(numStopped === 3 && z.scar === mySector) {
							plainAlert(z.players[z.turn] + " must choose whether Scar or a regular Raider is stopped by Run Inteference.");
							addOption(z.turn, "[Run Interference] Interfere with Scar", undefined, true);
							addOption(z.turn, "[Run Interference] Interfere with a regular Raider", mySector, true);
							scarTrouble = true;
							break;
						} else {
							z.raiderActivated[j] = 2;
							numStopped++;
						}
					}
				}
				if(4 > numStopped && z.scar === mySector && !scarTrouble) {
					z.scarActivated = 4;
				}
				if(!scarTrouble) {
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(j !== me && z.playerLocations[j] === z.playerLocations[me] && z.possibleColors[j][3] > 0) {
							plainAlert("If " + z.players[j] + " would like to play " + colorText("red", "Run Interference") +
								" instead, you will have to rewind; " + z.players[z.turn] + " will pick whose card will be played.");
						}
					}
					removeFromAll("Attack an unmanned Viper Mk II");
					removeFromAll("Attack an unmanned Viper Mk VII");
					removeFromAll("Attack an unmanned Assault Raptor");
					removeFromAll("Attack a piloted Viper");
					removeOption(z.turn, "Choose which sector of Raiders activates next");
					resetActivatingSector();
				}
				mainMenu();
			});
		} else if(ch === "Play a Sabotage") {
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Sabotage") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Sabotage would you like to play?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				/* TODO: Sabotage improvements */
				z.sabotage = true;
				let card = z.skillCardHands[me][mfs[prompted - 1]];
				playSkillCard(me, mfs[prompted - 1], true);
				addAlert("Playing " + cardText(card) + ".");
				if(z.galacticaAway){
					plainAlert("Galactica is away; no effect.");
				} else if(z.pegasusDestroyed || z.vAltDamage) {
					damageGalactica(true);
				} else {
					plainAlert(z.players[z.turn] + ", as current player, must damage Pegasus or Galactica.");
					addOption(z.turn, "Damage Pegasus", "Sabotage", true);
					addOption(z.turn, "Damage Galactica", "Sabotage", true);
				}
				mainMenu();
			});
		} else if(ch === "Discard a Maximum Firepower to reroll the attack on the Occupation Force") {
			let mfs = [];
			let promptText = "";
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				if(cardName(z.skillCardHands[me][j]) === "Maximum Firepower") {
					mfs.push(j);
					promptText += "\n" + mfs.length + ": " + cardText(z.skillCardHands[me][j]);
				}
			}
			promptText = "Which Maximum Firepower would you like to discard to reroll the attack?" + promptText;
			promptNum(promptText, (a) => 1 > a || a > mfs.length, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][mfs[prompted - 1]];
				playSkillCard(me, mfs[prompted - 1], false);
				boldAlert(z.players[me] + " discards " + cardText(card) + " and must now reroll the attack on the Occupation Force.");
				z.dieRollQueue.unshift(z.lastDieRoll);
				z.dieRollModifier = z.lastDieRollModifier;
				z.lastDieRoll = null;
				z.lastDieRollValue = null;
				z.lastDieRollModifier = null;
				mainMenu();
			});
		} else if(ch === "Forward Thinker") {
			if(!z.vBrutality) {
				if(!canActivateLocation(me, z.playerLocations[me])) {
					addAlert("You cannot activate your current location, so you cannot use Forward Thinker.");
					plainAlert("Lee passes on Forward Thinker.");
					removeOption(me, ch);
					removeOption(me, "Pass on Forward Thinker");
					mainMenu();
				} else {
					confirmify("Confirming you want to use your Forward Thinker ability to activate " + z.playerLocations[me] + ".", mainMenu, () => {
						let loc = z.playerLocations[me];
						if(loc === "Occupation Authority" || loc === "Breeder's Canyon" || loc === "Shipyard") {
							loc += " (Human)";
						}
						boldAlert("Lee uses Forward Thinker.");
						removeOption(me, ch);
						removeOption(me, "Pass on Forward Thinker");
						if(loc === "Hangar Deck") {
							z.xo2 = me;
						}
						activateLocation(loc, false);
					});
				}
			} else {
				if(canPlayActionCard()) {
					plainAlert("Lee uses Forward Thinker, and may now play an Action skill card from his hand.");
					addOption(me, "Play an Action Skill Card", "Forward Thinker", false);
					removeOption(me, ch);
					removeOption(me, "Pass on Forward Thinker");
					mainMenu();
				} else {
					addAlert("You have no action cards to play!");
					plainAlert("Lee passes on Forward Thinker.");
					removeOption(me, ch);
					removeOption(me, "Pass on Forward Thinker");
					mainMenu();
				}
			}
		} else if(ch === "Pass on Forward Thinker") {
			confirmify("Confirming you want to pass on Forward Thinker.", mainMenu, () => {
				plainAlert("Lee passes on Forward Thinker.");
				removeOption(me, ch);
				removeOption(me, "Forward Thinker");
				mainMenu();
			});
		} else if(ch === "Adaptable") {
			let cards = [];
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				let card = z.skillCardHands[me][j];
				if(cardName(card) === "Consolidate Power") {
					cards.push([card, j]);
				}
			}
			if(cards.length === 0) {
				addAlert("You have no Consolidate Power cards in hand, and cannot use your Adaptable ability.");
				removeOption(me, ch);
				mainMenu();
			} else {
				let promptText = "What card would you like to play? (1-" + cards.length + ")";
				for(let j = 0; !(j >= cards.length); j++) {
					promptText += "\n" + (j + 1) + ": " + cardText(cards[j][0]);
				}
				promptNum(promptText, (a) => 1 > a || a > cards.length, mainMenu, (prompted) => {
					let card = cards[prompted - 1][0];
					let pos = cards[prompted - 1][1];
					confirmify("Confirming you want to play " + cardText(card) + ".", mainMenu, () => {
						addAlert("Now, draw 2 skill cards (they may be from outside of your skill set).");
						addOption(me, "Draw 2 Skill Cards (any color)", 1, true);
						playSkillCard(me, pos, true);
						removeOption(me, ch);
						mainMenu();
					});
				});
			}
		} else if(ch === "Play an Action Skill Card") {
			let didAction2 = function() {
				if(characterPresent("Seelix") && z.players[me] === "Seelix" && z.avionicsExpert){
					z.avionicsExpertAvailable = true;
				}
				if(hasContext(me, ch, "Forward Thinker")) {
					z.xo2 = me;
					removeOption(me, ch);
				}
				didAction();
			};
			let cards = [];
			for(let j = 0; !(j >= z.skillCardHands[me].length); j++) {
				let card = z.skillCardHands[me][j];
				let name = cardName(card);
				if(z.revealedCylons[me] === 1) {
					if(name === "Human Weakness" && (otherPlayerInLocation(me, "Brig") || otherPlayerInLocation(me, "Detention"))) {
						cards.push([card, j]);
					}
					continue;
				} else {
					switch (name) {
						case "Consolidate Power":
						case "Negotiation":
						case "Popular Influence":
							cards.push([card, j]);
							break;
						case "Unorthodox Plan":
							if(!z.galacticaAway) {
								cards.push([card, j]);
							}
							break;
						case "Executive Order":
							if(!z.xo) {
								cards.push([card, j]);
							}
							break;
						case "Launch Scout":
							if(z.raptors > 0) {
								cards.push([card, j]);
							}
							break;
						case "Maximum Firepower":
							if(isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z.gravityWell)) {
								cards.push([card, j]);
							}
							break;
						case "Repair":
							if(z.players[me] === "Cottle" && !solo) {
								break;
							}
							if(z.playerLocations[me] === "Hangar Deck" && (damagedVipersII() > 0 || damagedVipersVII() > 0)) {
								cards.push([card, j]);
								break;
							}
							for(let i = 0; !(i >= z.damagedLocations.length); i++) {
								if(z.playerLocations[me] === z.damagedLocations[i ]) {
									cards.push([card, j]);
									break;
								}
							}
							break;
						case "Full Throttle":
							if(isInSpace(me) && !z.hornetsNest && (!z.eventHorizon || z.gravityWell)) {
								cards.push([card, j]);
							}
							break;
						case "State of Emergency":
							cards.push([card, j]);
							break;
						case "Scout for Fuel":
							if(z.raptors > 0) {
								cards.push([card, j]);
							}
							break;
						case "Build Nuke":
							if(z.players[me] === "Cottle" && !solo) {
								break;
							}
							if(3 > z.nukes) {
								cards.push([card, j]);
							}
							break;
						case "Combat Veteran":
							if(!z.hornetsNest && !z.galacticaAway) {
								cards.push([card, j]);
							}
							break;
						case "Launch Reserves": {
							if(z.hornetsNest && !z.galacticaAway) {
								break;
							}
							let anyone = false;
							for(let j = 0; !(j >= z.numPlayers) && !anyone; j++) {
								anyone = isInSpace(j);
							}
							if(!anyone) {
								break;
							}
							if(vipersIIReserves() === 0 && vipersVIIReserves() === 0 && assaultRaptorsReserves() === 0) {
								break;
							}
							cards.push([card, j]);
							break;
						}
						case "Raptor Specialist":
							if((z.players[me] === "Cottle" && !solo)) {
								break;
							}
							if(unbuiltARs() === 0 && z.raptors === 4) {
								break;
							}
							cards.push([card, j]);
							break;
						case "Test the Limits":
							if(3 > z.jumpTrack && !z.galacticaReturned && (z.players[me] !== "Cottle" || solo)) {
								cards.push([card, j]);
							}
							break;
					}
				}
			}
			let promptText = "What card would you like to play? (1-" + cards.length + ")";
			for(let j = 0; !(j >= cards.length); j++) {
				promptText += "\n" + (j + 1) + ": " + cardText(cards[j][0]);
			}
			promptNum(promptText, (a) => 1 > a || a > cards.length, mainMenu, (prompted) => {
				let card = cards[prompted - 1][0];
				let pos = cards[prompted - 1][1];
				confirmify("Confirming you want to play " + cardText(card) + ".", mainMenu, () => {
					let name = cardName(card);
					let did = false;
					let done = function() {
						if(z.players[me] === "Hoshi" && !solo) {
							z.reluctant = false;
						}
						if(!did) {
							didAction2();
						}
						mainMenu();
					};
					let playTheCard = function() {
						addAlert("Playing " + cardText(card) + ".");
						if(name === "Consolidate Power") {
							addAlert("Now, draw 2 skill cards (they may be from outside of your skill set).");
							addOption(me, "Draw 2 Skill Cards (any color)", 1, true);
						} else if(name === "Executive Order") {
							z.xo = true;
							addOption(me, "Issue Executive Order", undefined, true);
							addAlert(
								"Now, designate the target of the Executive Order.\nThey may then move and take an action, or take 2 actions."
								);
							if(myPlayer === "Lee") {
								if(z.vBrutality) {
									if(!versionAtLeast([2, 0, 1])) {
										addAlert(
											"Remember that once the Executive Order resolves, you may play a skill card action using your Forward Thinker ability."
											);
										t.value += "Remember Lee's Forward Thinker after the XO resolves.\r\n";
										z.forwardThinker = true;
									}
								} else {
									if(!inSpace(myLocation) && myLocation !== "Sickbay" && myLocation !== "Medical Center" && !z
										.damagedLocations.includes(myLocation)) {
										/* TODO: what if the XO repairs the current location, or Lee moves during the XO (from SoE, being sent to the Brig/Detention, or New Caprica starting) */
										addAlert(
											"Remember that once the Executive Order resolves, you may activate your location using your Forward Thinker ability."
											);
										t.value += "Remember Lee's Forward Thinker after the XO resolves.\r\n";
									}
									z.forwardThinker = true;
								}
							}
						} else if(name === "Maximum Firepower") {
							if(z.eventHorizon) {
								z.gravityWell = false;
							}
							addAlert("Attack up to 4 times in your space sector.");
							if(canAttackRaider(true)) {
								addOption(me, "Attack a Raider", 4, false);
							}
							if(canAttackScar(true)) {
								addOption(me, "Attack Scar", 4, false);
							}
							if(canAttackHeavy(true)) {
								addOption(me, "Attack a Heavy Raider", 4, false);
							}
							if(canAttackBasestar(true)) {
								addOption(me, "Attack a Basestar", 4, false);
							}
							if(z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[me] === "Lee") {
								plainAlert("Lee's Forward Thinker triggers.");
								let card = dealSkillCard(me, 3);
								addAlert("You draw " + cardText(card) + ".");
							}
						} else if(name === "Unorthodox Plan" && !z.galacticaAway) {
							addOption(me, "Activate another location", "Unorthodox Plan", true);
							if(z.players[me] === "Roslin" && !solo) {
								if(z.skillCardHands[me].length > 2) {
									addOption(me, "[Terminal Illness] Discard a Skill Card", undefined, true);
								} else {
									addAlert(
									"You do not have enough cards to activate a location; you may want to walk this back.");
									removeOption(me, "Activate another location");
								}
							}
							addAlert(
								"Now, activate Command, Armory, Weapons Control, or Communications; the location may be damaged."
								);
						} else if(name === "Combat Veteran") {
							menuPage = "[Manual Viper Activation]";
							addOption(me, "Activate an unmanned Viper", 3, false);
							addAlert(
							"Now, choose an Unmanned Viper in the Reserves or a Space Area and Activate it up to 3 times.");
							if(z.eventHorizon) {
								addAlert(
									"Remember that you must discard 1 skill card for each activation, due to Gravity Well (Event Horizon CAC)."
									);
							}
						} else if(name === "Launch Reserves") {
							if(vipersIIReserves() > 0) {
								addOption(me, "Place a Viper Mk II in space", "Launch Reserves", false);
							}
							if(vipersVIIReserves() > 0) {
								addOption(me, "Place a Viper Mk VII in space", "Launch Reserves", false);
							}
							if(assaultRaptorsReserves() > 0) {
								addOption(me, "Place an Assault Raptor in space", "Launch Reserves", false);
							}
							addAlert(
								"Now, place up to 2 Unmanned Vipers from the Reserves into a Space Area containing a piloted Viper. Then, Activate those Unmanned Vipers."
								);
							if(z.eventHorizon) {
								addAlert(
									"Remember that you must discard 1 skill card for each activation, due to Gravity Well (Event Horizon CAC)."
									);
							} /* RULES: rules interaction of this with Gravity Well; are the activations optional? */
						} else if(name === "Full Throttle") {
							if(z.eventHorizon) {
								z.gravityWell = false;
							}
							addAlert("Now, you may move to any space sector, then attack a Cylon ship in your sector.");
							addOption(me, "[Full Throttle] Move to a space sector", undefined, true);
							addOption(me, "[Full Throttle] Do not move", undefined, true);
						}
						playSkillCard(me, pos, true);
						done();
					};
					if(name === "Launch Scout") {
						didAction2();
						did = true;
						if(z.raptors === 1) {
							addAlert("Playing " + cardText(card) + ".");
							playSkillCard(me, pos, true);
							SPTokenBad("Launch Scout");
							if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3])) {
								plainAlert("Remember that Racetrack may use her Expert Raptor Pilot ability to reroll the die.");
							}
							done();
							return;
						} else if(z.raptors > 1) {
							addAlert("Playing " + cardText(card) + ".  Roll a die to risk the Raptor.");
							z.dieRollQueue.push("Launch Scout");
							z.dieRoller = me;
							playSkillCard(me, pos, true);
							if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3])) {
								plainAlert("Remember that Racetrack may use her Expert Raptor Pilot ability to reroll the die.");
							}
							done();
							return;
						}
					} else if(name === "Repair") {
						if(myLocation !== "Hangar Deck" || (damagedVipersII() === 0 && damagedVipersVII() === 0)) {
							playSkillCard(me, pos, true);
							addAlert("Playing " + cardText(card) + " and repairing " + myLocation + ".");
							repairLocation(myLocation);
							t.value += bold(myPlayer + " repairs " + myLocation) + ".\r\n";
							if(myPlayer === "Chief" && z.turn === me && !z.maintenanceEngineer) {
								addAlert("You may now take another action, thanks to your Maintenance Engineer ability.");
								z.maintenanceEngineer = true;
								mainMenu();
								return;
							}
						} else {
							let damaged = false;
							for(let j = 0; !(j >= z.damagedLocations.length); j++) {
								if(z.damagedLocations[j] === "Hangar Deck") {
									damaged = true;
									break;
								}
							}
							if(damaged) {
								addOption(me, "Repair a location", "Repair", false);
								addAlert("Playing " + cardText(card) +
									"; you may now repair the Hangar Deck or up to 2 damaged Vipers.");
							} else {
								addAlert("Playing " + cardText(card) + "; you may now repair up to 2 damaged Vipers.");
							}
							if(damagedVipersII() > 0) {
								addOption(me, "Repair a damaged Viper Mk II", ["Repair", 2], false);
							}
							if(damagedVipersVII() > 0) {
								addOption(me, "Repair a damaged Viper Mk VII", ["Repair", 2], false);
							}
							playSkillCard(me, pos, true);
							if(myPlayer === "Chief" && z.turn === me && !z.maintenanceEngineer) {
								addAlert("Once you do so, you may take another action, thanks to your Maintenance Engineer ability.");
								z.maintenanceEngineer = true;
								mainMenu();
								return;
							}
						}
						done();
						return;
					} else if(name === "State of Emergency") {
						addAlert("Played " + cardText(card) + ". Everyone, starting with you, may now move or take an action.");
						decreaseFood();
						playSkillCard(me, pos, true); /* TODO: check if this is right */
						didAction2();
						did = true;
						z.SoEPlayer = me;
						z.SoEActor = me;
						SoEToken(); /* TODO: improve this? */
						optionForAll("I'm done with my part of State of Emergency");
						if(characterPresent("Helo") && z.playerLocations[getPlayerNum("Helo")] === "Stranded on Caprica") {
							plainAlert("Remember that Helo may not participate, as he is Stranded on Caprica.");
						}
						done();
						return;
					} else if(name === "Scout for Fuel") {
						addAlert("Played " + cardText(card) + ".");
						playSkillCard(me, pos, true);
						didAction2();
						did = true;
						SPTokenBad("Scout for Fuel");
						if(characterPresent("Racetrack") && z.players[z.dieRoller] === "Racetrack" && !versionAtLeast([2, 1, 3])) {
							plainAlert("Remember that Racetrack may use her Expert Raptor Pilot ability to reroll the die.");
						}
						done();
						return;
					} else if(name === "Build Nuke") {
						addAlert("Played " + cardText(card) + ".  The Admiral gains a nuke token.");
						playSkillCard(me, pos, true);
						t.value += colorText("green", "Admiral") + " " + z.players[z.admiral] + " gains a Nuke Token.\r\n";
						z.nukes++;
						done();
						return;
					} else if(name === "Popular Influence") {
						z.quorumPeeker = me;
						let alertText = "You draw the Quorums:";
						for(let j = 0; !(j >= 2); j++) {
							if(z.quorumDeck.length === 0) {
								t.value +=
									"You have completely exhausted the Quorum deck and its discards and cannot draw more Quorums.\r\n";
								break;
							}
							let quo = z.quorumDeck.pop();
							alertText += "\n" + d.quorumNames[quo];
							if(z.quorumDeck.length === 0) {
								z.quorumDeck = z.quorumDiscards;
								shuffle(z.quorumDeck);
								t.value += "Quorum deck empty; reshuffling.\r\n";
								z.quorumDiscards = [];
							}
							z.quorumPeek.push(quo);
						}
						addAlert(alertText + "\n\nNow, give one to the President, then play or discard the other one.");
						playSkillCard(me, pos, true);
						t.value += myPlayer +
							" draws 2 Quorums. They should now give one to the President, then play or discard the other one.\r\n";
						addOption(me, "[Popular Influence] Pass a Quorum card to the President", true);
						done();
						return;
					} else if(name === "Negotiation") {
						playSkillCard(me, pos, true);
						if(!z.galacticaAway) {
							placeBasestar(1);
						}
						let card = dealSkillCard(me, 0);
						addAlert("You draw " + cardText(card));
						z.negotiation = true;
						addAlert("No Cylon Ship activations or launches for the remainder of the turn.");
						done();
						return;
					} else if(name === "Raptor Specialist") {
						if(z.raptors === 0) {
							/* RULES: gained 3 ARs issues.  */
							playSkillCard(me, pos, true);
							addAlert("Playing " + cardText(card) + ".");
							repairRaptor();
							done();
							return;
						}
						if(z.raptors === 4) {
							playSkillCard(me, pos, true);
							addAlert("Playing " + cardText(card) + ".");
							destroyRaptor();
							gainAR();
							done();
							return;
						} else {
							playSkillCard(me, pos, true); /* TODO: ability to pause in here? */
							addAlert("Playing " + cardText(card) + ".");
							confirmify("Would you like to destroy a Raptor and gain an Assault Raptor or repair a Raptor", () => {
								repairRaptor();
								done();
							}, () => {
								destroyRaptor();
								gainAR();
								done();
							}, "Gain an Assault Raptor", "Repair a Raptor");
							return;
						}
					} else if(name === "Test the Limits") {
						/* RULES: New Caprica after Galactica returned? */
						didAction2();
						did = true;
						addAlert("Played " + cardText(card) + ".");
						playSkillCard(me, pos, true);
						z.jumpTrack++;
						boldAlert("Jump Prep advances to " + jumpTrackName() + ".");
						if(!z.galacticaAway) {
							SPTokenBad("Test the Limits");
						} else {
							plainAlert("Galactica is away and cannot be damaged.");
						}
						done();
						return;
					} else if(name === "Human Weakness") {
						playSkillCard(me, pos, true);
						let candidateResource = "Population";
						let maxResource = z.population;
						let tie = false;
						if(z.morale > maxResource) {
							candidateResource = "Morale";
							maxResource = z.morale;
							tie = false;
						} else if(z.morale === maxResource) {
							tie = true;
						}
						if(z.food > maxResource) {
							candidateResource = "Food";
							maxResource = z.food;
							tie = false;
						} else if(z.food === maxResource) {
							tie = true;
						}
						if(z.fuel > maxResource) {
							candidateResource = "Fuel";
							maxResource = z.fuel;
							tie = false;
						} else if(z.fuel === maxResource) {
							tie = true;
						}
						if(tie) {
							plainAlert("There is a tie for highest resource; " + z.players[z.turn] +
								" must choose one of these tied resources to decrease.");
							addOption(z.turn, "Decrease a resource", "tie", true);
						} else {
							switch (candidateResource) {
								case "Population":
									decreasePopulation();
									break;
								case "Morale":
									decreaseMorale();
									break;
								case "Food":
									decreaseFood();
									break;
								case "Fuel":
									decreaseFuel();
									break;
							}
						}
						done();
						return;
					}
					playTheCard();
				});
			});
		} else if(ch === "Play a Quorum Card" || ch === "Play a Quorum Card as an Action") {
			if(z.players[me] === "Billy" && me !== z.president) {
				let promptText = "What Quorum Card would you like to play? (1-" + z.billyHand.length + ")";
				for(let i = 0; !(i >= z.billyHand.length); i++) {
					promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.billyHand[i ]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.billyHand.length, mainMenu, (prompted) => {
					if(ch === "Play a Quorum Card as an Action") {
						didAction();
					}
					addAlert("Playing " + d.quorumNames[z.billyHand[prompted - 1]] + ".");
					playQuorumCard(prompted - 1, "Billy");
					mainMenu();
				});
			} else {
				let promptText = "What Quorum Card would you like to play? (1-" + z.quorumHand.length + ")";
				for(let i = 0; !(i >= z.quorumHand.length); i++) {
					promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumHand[i ]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.quorumHand.length, mainMenu, (prompted) => {
					addAlert("Playing " + d.quorumNames[z.quorumHand[prompted - 1]] + ".");
					if(ch === "Play a Quorum Card as an Action") {
						didAction();
					}
					removeOption(me, ch);
					removeOption(me, "Draw a Quorum Card");
					playQuorumCard(prompted - 1, false);
					if(isOnNewCaprica(z.president)) {
						t.value += colorText("orange", "President ") + z.players[z.president] +
							" must now roll a die; on a 3 or less they are sent to Detention.\r\n";
						if(z.dieRollQueue.length === 0) {
							SPTokenBad("Presidential Detention");
						} else {
							z.dieRollQueue.push("Presidential Detention");
							/* TODO: this and hotshot issues */
						} /* RULES: ordering of this roll.  Also, what if President executes themselves from Execute Prisoner? */
					}
					mainMenu();
				});
			}
		} else if(ch === "Draw a Quorum Card" || ch === "Draw a Quorum Card using the President Title") {
			confirmify("Confirming you want to draw a Quorum card.", mainMenu, () => {
				if(z.drawSkills && z.players[me] === "Billy" && me === z.turn && !versionAtLeast([2,1,9])) {
					dealQuorumCard(true);
					z.drawSkills = false;
					z.phase = 1;
				} else if(Number.isInteger(getContext(me, ch))) {
					let n = getContext(me, ch);
					for(let j = 0; !(j >= n); j++) {
						if(z.players[me] === "Billy" && me !== z.president) {
							dealQuorumCard(true);
						} else {
							dealQuorumCard();
						}
					}
					removeOption(me, ch);
					removeOption(me, "Discard a Quorum Card");
					addOption(me, "Move the President title", "Resignation", true);
				} else {
					if(z.players[me] === "Billy" && me !== z.president) {
						dealQuorumCard(true);
					} else {
						dealQuorumCard();
					}
					removeOption(me, ch);
					removeOption(me, "Play a Quorum Card");
				}
				if(ch === "Draw a Quorum Card using the President Title") {
					didAction();
				}
				mainMenu();
			});
		} else if(ch === "Discard a Quorum Card") {
			if(z.players[me] === "Billy" && me !== z.president) {
				let promptText = "What Quorum Card would you like to discard? (1-" + z.billyHand.length + ")";
				for(let i = 0; !(i >= z.billyHand.length); i++) {
					promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.billyHand[i ]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.billyHand.length, mainMenu, (prompted) => {
					addAlert("Discarding " + d.quorumNames[z.billyHand[prompted - 1]] + ".");
					discardQuorumCard(prompted - 1, "Billy");
					if(hasContext(me, ch, "Resignation")) {
						let context = getContext(me, "Draw a Quorum Card");
						if(context === undefined) {
							context = 0;
						}
						removeOption(me, "Draw a Quorum Card");
						removeOption(me, "Move the President title");
						addOption(me, "Draw a Quorum Card", context + 1, true);
					}
					if(z.billyHand.length === 0) {
						removeOption(me, ch);
					} else if(2 >= z.billyHand.length && !hasContext(me, ch, "Resignation")) {
						removeOption(me, ch);
					}
					mainMenu();
				});
			} else {
				let promptText = "What Quorum Card would you like to discard? (1-" + z.quorumHand.length + ")";
				for(let i = 0; !(i >= z.quorumHand.length); i++) {
					promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumHand[i ]];
				}
				promptNum(promptText, (a) => 1 > a || a > z.quorumHand.length, mainMenu, (prompted) => {
					addAlert("Discarding " + d.quorumNames[z.quorumHand[prompted - 1]] + ".");
					discardQuorumCard(prompted - 1, false);
					if(hasContext(me, ch, "Resignation")) {
						let context = getContext(me, "Draw a Quorum Card");
						if(context === undefined) {
							context = 0;
						}
						removeOption(me, "Draw a Quorum Card");
						addOption(me, "Draw a Quorum Card", context + 1, true);
					}
					if(z.quorumHand.length === 0) {
						removeOption(me, ch);
					} else if(!hasContext(me, ch, "Resignation") && z.quorumHandLimit >= z.quorumHand.length) {
						removeOption(me, ch);
					}
					mainMenu();
				});
			}
		} else if(ch === "[Popular Influence] Discard a Quorum Card") {
			let promptText = "What Quorum Card would you like to discard? (1-" + z.quorumPeek.length + ")";
			for(let i = 0; !(i >= z.quorumPeek.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumPeek[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.quorumPeek.length, mainMenu, (prompted) => {
				addAlert("Discarding " + d.quorumNames[z.quorumPeek[prompted - 1]] + ".");
				discardQuorumCard(prompted - 1, "Peek");
				if(z.quorumPeek.length === 1) {
					plainAlert(z.players[me] + " gives the other Quorum to the President.");
					z.quorumHand.push(z.quorumPeek.pop());
				}
				z.quorumPeeker = -1;
				removeOption(me, "[Popular Influence] Pass a Quorum card to the President");
				removeOption(me, ch);
				removeOption(me, "[Popular Influence] Play a Quorum Card");
				mainMenu();
			});
		} else if(ch === "[Skilled Politician] Bottom a Quorum card" || ch === "[Influential] Bottom a Quorum Card" || ch ===
			"[Doral] Bottom a Quorum card" || ch === "[Set the Agenda] Bottom a Quorum card") {
			let promptText = "What Quorum Card would you like to bottom? (1-" + z.quorumPeek.length + ")";
			for(let i = 0; !(i >= z.quorumPeek.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumPeek[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.quorumPeek.length, mainMenu, (prompted) => {
				addAlert("Bottoming " + d.quorumNames[z.quorumPeek[prompted - 1]] + ".");
				z.quorumDeck.unshift(z.quorumPeek.splice(prompted - 1, 1)[0]);
				t.value += myPlayer + " bottoms a Quorum card.\r\n";
				if(z.quorumPeek.length === 0) {
					z.quorumPeeker = -1;
					removeOption(me, ch);
					removeOption(me, "[Skilled Politician] Play a Quorum card");
					removeOption(me, "[Influential] Top a Quorum Card");
					removeOption(me, "[Doral] Play a Quorum card");
				} else if(ch === "[Set the Agenda] Bottom a Quorum card") {
					let context = getContext(me, ch);
					
					if(context === 2) {
						addOption(me, ch, 1, true);
						if(z.quorumPeek.length === 1) {
							removeOption(me, ch);
							let quorum = z.quorumPeek.pop();
							addAlert("You bottom " + d.quorumNames[quorum] + " as well.");
							t.value += z.players[me] + " bottoms another Quorum card.\r\n";
							z.quorumPeeker = -1;
							z.quorumDeck.unshift(quorum);
						}
					} else if(z.quorumPeek.length > 0) {
						removeOption(me, ch);
						while(z.quorumPeek.length > 0) {
							z.quorumHand.push(z.quorumPeek.shift());
						}
						plainAlert(z.players[me] + " returns the Quorum hand to the President.");
						z.quorumPeeker = -1;
					} else {
						removeOption(me, ch);
					}
				} else if(z.quorumPeek.length === 1) {
					if(hasOption(me, "[Skilled Politician] Play a Quorum card") || hasOption(me, "[Doral] Play a Quorum card")) {
						removeOption(me, ch);
					}
				}
				mainMenu();
			});
		} else if(ch === "[Influential] Top a Quorum Card") {
			let promptText = "What Quorum Card would you like to top? (1-" + z.quorumPeek.length + ")";
			for(let i = 0; !(i >= z.quorumPeek.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumPeek[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.quorumPeek.length, mainMenu, (prompted) => {
				addAlert("Placing " + d.quorumNames[z.quorumPeek[prompted - 1]] + " on top.");
				z.quorumDeck.push(z.quorumPeek.splice(prompted - 1, 1)[0]);
				t.value += myPlayer + " tops a Quorum card.\r\n";
				if(z.quorumPeek.length === 0) {
					z.quorumPeeker = -1;
					removeOption(me, "[Influential] Top a Quorum Card");
					removeOption(me, "[Influential] Bottom a Quorum Card");
					removeOption(me, ch);
				}
				mainMenu();
			});
		} else if(ch === "[Popular Influence] Pass a Quorum card to the President") {
			let promptText = "What Quorum Card would you like to pass to " + colorText("orange", "President ") + z.players[z.president] + "? (1-" + z
				.quorumPeek.length + ")";
			for(let i = 0; !(i >= z.quorumPeek.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.quorumPeek[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.quorumPeek.length, mainMenu, (prompted) => {
				let passed = d.quorumNames[z.quorumPeek[prompted - 1]];
				addAlert("Passed to the President: " + passed + ".");
				z.quorumHand.push(z.quorumPeek.splice(prompted - 1, 1)[0]);
				t.value += myPlayer + " passes a Quorum card to " + colorText("orange", "President ") + z.players[z.president] + ".\r\n";
				removeOption(me, ch);
				let other = d.quorumNames[z.quorumPeek[0]];
				if(other === "Resignation" || (other === "Execute Prisoner" && (z.playerLocations[z.president] === "Brig" || z.playerLocations[z.president] === "Detention"))){
					z.secretMessages[z.president] += "\n"+z.players[me]+" passed you "+passed+" with "+colorText("orange","Popular Influence")+".";
				} else if (z.players[z.president] === "Dee" && z.morale === 3){
					let moraleCivDead = false;
					for(let j = 0; !(j >= z.destroyedCivilians.length); j++) {
						if(z.destroyedCivilians[j] === "Pop/Morale") {
							moraleCivDead = true;
							break;
						}
					}
					if(other === "Encourage Mutiny" || other === "Release Cylon Mugshots" || other === "Enact Production Quotas" || other === "Establish Dogsville" || (!moraleCivDead && other === "Civilian Self Defense")){
						z.secretMessages[z.president] += "\n"+z.players[me]+" passed you "+passed+" with "+colorText("orange","Popular Influence")+".";
					}
				}
				addOption(me, "[Popular Influence] Play a Quorum Card", true);
				addOption(me, "[Popular Influence] Discard a Quorum Card", true);
				mainMenu();
			});
		} else if(ch === "Presidential Aide (OPT)") {
			let promptText = "What Quorum Card would you like to pass to " + colorText("orange", "President ") + z.players[z.president] + "? (1-" + z
				.billyHand.length + ")";
			for(let i = 0; !(i >= z.billyHand.length); i++) {
				promptText += "\n" + (i + 1) + ": " + d.quorumNames[z.billyHand[i ]];
			}
			promptNum(promptText, (a) => 1 > a || a > z.billyHand.length, mainMenu, (prompted) => {
				addAlert("Passed to the President: " + d.quorumNames[z.billyHand[prompted - 1]] + ".");
				z.quorumHand.push(z.billyHand.splice(prompted - 1, 1)[0]);
				t.value += myPlayer + " passes a Quorum card to " + colorText("orange", "President ") + z.players[z.president] + ".\r\n";
				z.presidentialAide = false;
				if(2 >= z.billyHand.length) {
					removeOption(me, "Discard a Quorum Card");
				}
				mainMenu();
			});
		} else if(ch === "Choose the top option on this crisis") {
			/* TODO: remove this option (and "choose the bottom...") once chosen */
			if((z.currentCrisis === 7 || z.currentCrisis === 131) && z.nukes === 0) {
				addAlert("You have no nuke tokens, and cannot pick this option.  You must pick the bottom option or use your OPG.");
				mainMenu();
			} else if(z.currentCrisis === 173 && !isOnNewCaprica(z.turn)) {
				addAlert("The current player is not on New Caprica, so you cannot pick this option.  You must pick the bottom option or use your OPG.");
				mainMenu();
			} else {
			confirmify("Confirming you want to choose the top option on " + d.crisisNames[z.currentCrisis] + ".", mainMenu, () => {
				if(d.admiralChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("green", "Admiral "));
				} else if(d.presidentChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("orange", "President "));
				} else if(d.cagChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("red", "CAG "));
				}
				t.value += bold(z.players[me] + " chooses the top option on " + d.crisisNames[z.currentCrisis] + ".") + "\r\n";
				if(canMoralCompass()) {
					let helo = getHelo();
					if(helo !== me && z.moralCompassPause) {
						let unrevealed = false;
						for(let j = 0; !(j >= z.numPlayers) && !unrevealed; j++) {
							unrevealed = cylonCards(j) > 0;
						}
						for(let j = 0; !unrevealed && !(j >= z.boxedPlayers.length); j++) {
							for(let k = 0; !unrevealed && !(k >= z.boxedPlayers[2].length); k++) {
								unrevealed = isCylonCard(z.boxedPlayers[2][k]);
							}
						}
						for(let j = 0; !(j>=z.loyaltyDeck.length) && !unrevealed; j++){
							unrevealed = isCylonCard(z.loyaltyDeck[j]);
						}
						if(unrevealed) {
							plainAlert("Remember that Helo may want to use his Moral Compass ability here before you process the top opition.");
						} else {
							addAlert('Select "Process the Top option on this crisis" to proceed.');
						}
					} else {
						addAlert('Select "Process the Top option on this crisis" to proceed.');
					}
					optionForAll("Process the Top option on this crisis");
					addOption(helo, "Use Moral Compass [OPG] to choose the Bottom option on this crisis", undefined, false);
				} else {
					processTop();
					primeCylonActivation();
					z.finishedCrisis = true;
				}
				mainMenu();
			});
			}
		} else if(ch === "Choose the bottom option on this crisis") {
			confirmify("Confirming you want to choose the bottom option on " + d.crisisNames[z.currentCrisis] + ".", mainMenu, () => {
				if(d.admiralChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("green", "Admiral "));
				} else if(d.presidentChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("orange", "President "));
				} else if(d.cagChooses[z.currentCrisis] === 1) {
					t.value += bold(colorText("red", "CAG "));
				}
				t.value += bold(z.players[me] + " chooses the bottom option on " + d.crisisNames[z.currentCrisis] + ".") + "\r\n";
				if(canMoralCompass() && !((z.currentCrisis === 7 || z.currentCrisis === 131) && z.nukes === 0) && !(z.currentCrisis === 173 && !isOnNewCaprica(z.turn))) {
					let helo = getHelo();
					if(helo !== me && z.moralCompassPause) {
						let unrevealed = false;
						for(let j = 0; !(j >= z.numPlayers) && !unrevealed; j++) {
							unrevealed = cylonCards(j) > 0;
						}
						for(let j = 0; !unrevealed && !(j >= z.boxedPlayers.length); j++) {
							for(let k = 0; !unrevealed && !(k >= z.boxedPlayers[2].length); k++) {
								unrevealed = isCylonCard(z.boxedPlayers[2][k]);
							}
						}
						for(let j = 0; !(j>=z.loyaltyDeck.length) && !unrevealed; j++){
							unrevealed = isCylonCard(z.loyaltyDeck[j]);
						}
						if(unrevealed) {
							plainAlert(
								"Remember that Helo may want to use his Moral Compass ability here before you process the bottom option.");
						} else {
							addAlert('Select "Process the Bottom option on this crisis" to proceed.');
						}
					} else {
						addAlert('Select "Process the Bottom option on this crisis" to proceed.');
					}
					optionForAll("Process the Bottom option on this crisis");
					addOption(helo, "Use Moral Compass [OPG] to choose the Top option on this crisis", undefined, false);
				} else {
					processBottom();
					primeCylonActivation();
					z.finishedCrisis = true;
				}
				mainMenu();
			});
		} else if(ch === "Choose a Different Path (OPG)") {
			confirmify("Confirming that you want to use your OPG, Choose a Different Path, to have the result of this crisis be:\n" + z.players[z
				.turn] + " discards 5 skill cards.", mainMenu, () => {
					if(z.assist === "Lee") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					t.value += bold("Lee uses his OPG, Choose a Different Path.") + "\r\n";
					t.value += "The crisis result is now: " + bold(z.players[z.turn] + " discards 5 skill cards.") + "\r\n";
					if(z.revealedCylons[z.turn] === 1) {
						plainAlert(z.players[z.turn] + " is a Cylon, and ignores the discards.");
					}
					if(canMoralCompass()) {
						let helo = getHelo();
						if(me !== helo && z.moralCompassPause) {
							let unrevealed = false;
							for(let j = 0; !(j >= z.numPlayers) && !unrevealed; j++) {
								unrevealed = cylonCards(j) > 0;
							}
							for(let j = 0; !unrevealed && !(j >= z.boxedPlayers.length); j++) {
								for(let k = 0; !unrevealed && !(k >= z.boxedPlayers[2].length); k++) {
									unrevealed = isCylonCard(z.boxedPlayers[2][k]);
								}
							}
							for(let j = 0; !(j>=z.loyaltyDeck.length) && !unrevealed; j++){
								unrevealed = isCylonCard(z.loyaltyDeck[j]);
							}
							if(unrevealed) {
								plainAlert(
									"Remember that Helo may want to use his Moral Compass ability here before you process Choose a Different Path."
									);
							} else {
								addAlert('Select "Process Choose a Different Path" to proceed.');
							}
						} else {
							addAlert('Select "Process Choose a Different Path" to proceed.');
						}
						optionForAll("Process Choose a Different Path");
						if(d.currentPlayerChooses[z.currentCrisis] === 1) {
							addOption(helo, "Use Moral Compass [OPG] to choose the skill check on this crisis", undefined, false);
							addOption(helo, "Use Moral Compass [OPG] to choose the OR on this crisis", undefined, false);
						} else {
							if(!((z.currentCrisis === 7 || z.currentCrisis === 131) && z.nukes === 0) && !(z.currentCrisis === 173 && !isOnNewCaprica(z.turn))) {
								addOption(helo, "Use Moral Compass [OPG] to choose the Top option on this crisis", undefined, false);
							}
							addOption(helo, "Use Moral Compass [OPG] to choose the Bottom option on this crisis", undefined, false);
						}
					} else {
						if(z.revealedCylons[z.turn] === 0) {
							promptDiscards(z.turn, 5);
						}
						primeCylonActivation();
						z.finishedCrisis = true;
					}
					mainMenu();
				});
		} else if(ch === "Process Choose a Different Path") {
			confirmify("Confirming you want to process the effect from Choose a Different Path", mainMenu, () => {
				if(z.revealedCylons[z.turn] === 0) {
					promptDiscards(z.turn, 5);
				}
				primeCylonActivation();
				z.finishedCrisis = true;
				removeFromAll("Process Choose a Different Path");
				let helo = getHelo();
				removeOption(helo, "Use Moral Compass [OPG] to choose the skill check on this crisis");
				removeOption(helo, "Use Moral Compass [OPG] to choose the OR on this crisis");
				removeOption(helo, "Use Moral Compass [OPG] to choose the Top option on this crisis");
				removeOption(helo, "Use Moral Compass [OPG] to choose the Bottom option on this crisis");
				mainMenu();
			});
		} else if(ch === "Choose the OR on this crisis") {
			confirmify("Confirming you want to choose the OR on " + d.crisisNames[z.currentCrisis] + "; there will be no skill check.", mainMenu,
		() => {
				t.value += bold(z.players[me] + " chooses the OR on " + d.crisisNames[z.currentCrisis] + ".") + "\r\n";
				if(canMoralCompass()) {
					let helo = getHelo();
					if(z.revealedCylons[me] === 1 || isTheCylonLeader(me)) {
						plainAlert("Remember that Helo may want to use his Moral Compass ability here.");
					} else if(me !== helo && z.moralCompassPause) {
						let unrevealed = false;
						for(let j = 0; !(j >= z.numPlayers) && !unrevealed; j++) {
							unrevealed = cylonCards(j) > 0;
						}
						for(let j = 0; !unrevealed && !(j >= z.boxedPlayers.length); j++) {
							for(let k = 0; !unrevealed && !(k >= z.boxedPlayers[2].length); k++) {
								unrevealed = isCylonCard(z.boxedPlayers[2][k]);
							}
						}
						for(let j = 0; !(j>=z.loyaltyDeck.length) && !unrevealed; j++){
							unrevealed = isCylonCard(z.loyaltyDeck[j]);
						}
						if(unrevealed) {
							plainAlert("Remember that Helo may want to use his Moral Compass ability here before you process the OR.");
						} else {
							addAlert('Select "Process the OR on this crisis" to proceed.');
						}
					} else {
						addAlert('Select "Process the OR on this crisis" to proceed.');
					}
					optionForAll("Process the OR on this crisis");
					addOption(helo, "Use Moral Compass [OPG] to choose the skill check on this crisis", undefined, false);
				} else {
					let fulfiller = d.crisisNames[z.currentCrisis] === "Fulfiller of Prophecy" && !z.capricaCrisis;
					processOR();
					if(!fulfiller) {
						primeCylonActivation();
						z.finishedCrisis = true;
					}
				}
				mainMenu();
			}); /* TODO: display relative title ranks */
		} else if(ch === "Process the OR on this crisis") {
			confirmify("Confirming you want to process the OR on this skill check.", mainMenu, () => {
				let fulfiller = d.crisisNames[z.currentCrisis] === "Fulfiller of Prophecy";
				processOR();
				if(z.vBrutalityPlus){
					z.engineRoom = false;
				}
				if(!fulfiller) {
					primeCylonActivation();
					z.finishedCrisis = true;
				}
				removeFromAll(ch);
				removeFromAll("Use Moral Compass [OPG] to choose the skill check on this crisis");
				mainMenu();
			});
		} else if(ch === "Process the Bottom option on this crisis") {
			confirmify("Confirming you want to process the bottom option on this crisis.", mainMenu, () => {
				processBottom();
				if(z.vBrutalityPlus){
					z.engineRoom = false;
				}
				primeCylonActivation();
				z.finishedCrisis = true;
				removeFromAll(ch);
				removeFromAll("Use Moral Compass [OPG] to choose the Top option on this crisis");
				mainMenu();
			});
		} else if(ch === "Process the Top option on this crisis") {
			confirmify("Confirming you want to process the Top option on this crisis.", mainMenu, () => {
				processTop();
				if(z.vBrutalityPlus){
					z.engineRoom = false;
				}
				primeCylonActivation();
				z.finishedCrisis = true;
				removeFromAll(ch);
				removeFromAll("Use Moral Compass [OPG] to choose the Bottom option on this crisis");
				mainMenu();
			});
		} else if(ch === "Process this Quorum Card") {
			confirmify("Confirming you want to process the effect of this Quorum card.", mainMenu, () => {
				playQuorumCard(getContext(me, ch), "Bypass Billy");
				removeOption(me, ch);
				removeFromAll("Reveal Secrets (OPG)");
				mainMenu();
			});
		} else if(ch === "Use Moral Compass [OPG] to choose the Top option on this crisis") {
			confirmify("Confirming you want to use your OPG, Moral Compass, to choose the Top option on " + d.crisisNames[z.currentCrisis] + ".",
				mainMenu, () => {
					t.value += bold("Helo uses his OPG, Moral Compass, to choose the Top option instead.\r\n");
					if(z.assist === "Helo") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					processTop();
					primeCylonActivation();
					z.finishedCrisis = true;
					removeOption(me, ch);
					removeOption(me, "Use Moral Compass [OPG] to choose the Bottom option on this crisis");
					removeFromAll("Process the Bottom option on this crisis");
					removeFromAll("Process Choose a Different Path");
					mainMenu();
				});
		} else if(ch === "Use Moral Compass [OPG] to choose the Bottom option on this crisis") {
			confirmify("Confirming you want to use your OPG, Moral Compass, to choose the Bottom option on " + d.crisisNames[z.currentCrisis] + ".",
				mainMenu, () => {
					t.value += bold("Helo uses his OPG, Moral Compass, to choose the Bottom option instead.\r\n");
					if(z.assist === "Helo") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					processBottom();
					primeCylonActivation();
					z.finishedCrisis = true;
					removeOption(me, ch);
					removeOption(me, "Use Moral Compass [OPG] to choose the Top option on this crisis");
					removeFromAll("Process the Bottom option on this crisis");
					removeFromAll("Process Choose a Different Path");
					mainMenu();
				});
		} else if(ch === "Use Moral Compass [OPG] to choose the OR on this crisis") {
			confirmify("Confirming you want to use your OPG, Moral Compass, to choose the OR on " + d.crisisNames[z.currentCrisis] + ".", mainMenu,
			() => {
					t.value += bold("Helo uses his OPG, Moral Compass, to choose the OR instead.\r\n");
					if(z.assist === "Helo") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					processOR();
					primeCylonActivation();
					z.finishedCrisis = true;
					removeOption(me, ch);
					removeOption(me, "Use Moral Compass [OPG] to choose the skill check on this crisis");
					removeFromAll("Process Choose a Different Path");
					mainMenu();
				});
		} else if(ch === "Use Moral Compass [OPG] to choose the skill check on this crisis") {
			confirmify("Confirming you want to use your OPG, Moral Compass, to choose the skill check on " + d.crisisNames[z.currentCrisis] + ".",
				mainMenu, () => {
					t.value += bold("Helo uses his OPG, Moral Compass, to choose the skill check on this crisis instead.\r\n");
					if(z.assist === "Helo") {
						z.assistMiracle = 0;
					} else if(z.players[me] === "Gaius") {
						z.miracles[me] -= 2;
					} else {
						z.miracles[me] = 0;
					}
					startCrisisSkillCheck();
					removeOption(me, ch);
					removeOption(me, "Use Moral Compass [OPG] to choose the OR on this crisis");
					removeFromAll("Process the OR on this crisis");
					removeFromAll("Process Choose a Different Path");
					mainMenu();
				});
		} else if(ch === "Religious Visions" || ch === "[Secret Destiny] Pick a new Crisis") {
			let mandatories = anyMandatory();
			if(ch === "Religious Visions" && mandatories.length > 0) {
				plainAlert(
					"It looks like some things still need to be done before Roslin can perform Religious Visions.  The following players must do one or more of the following things:"
					);
				for(let j = 0; !(j >= mandatories.length); j++) {
					plainAlert(z.players[mandatories[j][0]] + ": " + mandatories[j][1]);
				}
				plainAlert('If you are sure this is in error, you may use the deep menus to "Make all options non-mandatory", then try again.');
				mainMenu();
			} else {
				let promptText = "Which crisis would you like to play? (1-2)\n The other will be returned to the bottom of the Crisis deck.\n\n";
				let crisis1 = z.crisisDeck.pop();
				if(z.crisisDeck.length === 0) {
					plainAlert("Crisis deck reshuffles.");
					z.crisisDeck = shuffle(z.crisisDiscards);
					z.crisisDiscards = [];
				}
				let crisis2 = z.crisisDeck.pop();
				if(z.crisisDeck.length === 0) {
					plainAlert("Crisis deck reshuffles.");
					z.crisisDeck = shuffle(z.crisisDiscards);
					z.crisisDiscards = [];
				}
				promptText += "1: " + d.crisisNames[crisis1] + "\n";
				promptText += "2: " + d.crisisNames[crisis2];
				promptNum(promptText, (a) => 1 > a || a > 2, () => {
					z.crisisDeck.push(crisis2);
					z.crisisDeck.push(crisis1);
					mainMenu();
				}, (prompted) => {
					if(prompted === 2) {
						z.crisisDeck.unshift(crisis1);
						z.crisisDeck.push(crisis2);
					} else {
						z.crisisDeck.unshift(crisis2);
						z.crisisDeck.push(crisis1);
					}
					if(ch === "Religious Visions") {
						z.crisisOptions = blankArrays(z.numPlayers);
						z.context = blankArrays(z.numPlayers);
						z.mandatory = blankArrays(z.numPlayers);
						t.value += "Roslin uses her Religious Visions.\r\n";
					} else {
						t.value += "Starbuck picks a new crisis.\r\n";
						removeOption(me, ch);
					}
					if(ch === "Religious Visions"){
						z.phase = 4;
					}
					playCrisis(me);
					let alertText = "Played Crisis: " + d.crisisNames[z.currentCrisis] + ".";
					if((z.turn === me && d.currentPlayerChooses[z.currentCrisis] === 1) || (me === z.admiral && d.admiralChooses[z
							.currentCrisis] === 1) || (me === z.president && d.presidentChooses[z.currentCrisis] === 1) || (me === z.cag && d
							.cagChooses[z.currentCrisis] === 1)) {
						alertText += "\nIt's your choice on this crisis.";
					}
					if((d.CAC[z.currentCrisis] === 1 || z.secretDestinyPause) && ((characterPresent("Starbuck") && z.miracles[getPlayerNum(
							"Starbuck")] === 1) || actsOfFaith("Starbuck")) && !z.theFarm) {
						plainAlert(
							"Remember that Starbuck can use her OPG, Secret Destiny, here; you may want to wait for her input before proceeding."
							);
					}
					addAlert(alertText);
					mainMenu();
				});
			}
		} else if(ch === "Return a duplicate interrupt to hand") {
			let duplicates = duplicateInterrupts();
			let promptText = "Which interrupt would you like to return to hand? (1-" + duplicates.length + ")\n";
			for(let i = 0; !(i >= duplicates.length); i++) {
				promptText += (i + 1) + ": " + z.players[duplicates[i ][0]] + "'s " + z.interrupts[duplicates[i ][0]][duplicates[i ][1]] + "\n";
			}
			promptNum(promptText, (a) => 1 > a || a > duplicates.length, mainMenu, (prompted) => {
				let card = z.interrupts[duplicates[prompted - 1][0]].splice(duplicates[prompted - 1][1], 1)[0];
				let foundit = false;
				for(let i = 0; !(i >= z.skillCardDiscards.length) && !foundit; i++) {
					for(let j = z.skillCardDiscards[i ].length - 1; j >= 0 && !foundit; j--) {
						foundit = card === cardText(z.skillCardDiscards[i ][j]);
						if(foundit) {
							z.skillCardHands[duplicates[prompted - 1][0]].push(z.skillCardDiscards[i ].splice(j, 1)[0]);
							z.possibleColors[duplicates[prompted - 1][0]][cardColorID(card)] = 1;
							let alertText = "Returned " + z.players[duplicates[prompted - 1][0]] + "'s " + card + " to their hand.";
							boldAlert(alertText);
							interruptsToken();
						}
					}
				}
				if(!foundit) {
					plainAlert(
						"Could not return interrupt to hand, as it has already been reshuffled into the appropriate skill card deck thanks to a Support the People or Delusional Intuition draw."
						);
				} else if(/Restore Order/.test(card) || /Support the People/.test(card) || /At Any Cost/.test(card) || /Guts and Initiative/
					.test(card) || /Jury Rigged/.test(card)) {
					z.restoreOrder = false;
					z.reckless = false;
					if(z.criticalMission && versionAtLeast([2,1,13])){
						z.reckless = 0;
					}
					z.guts = false;
					if(z.juryRigged) {
						z.thisDifficulty += 4;
					}
					z.juryRigged = false;
					z.supportThePeople = false;
					if(z.currentSkillCheck !== "Airlock" && z.currentSkillCheck !== "Resistance HQ") {
						z.thisTreachery = 0;
					}
					for(let j = 0; !(j >= z.numPlayers); j++) {
						for(let k = 0; !(k >= z.interrupts[j].length); k++) {
							let interrupt = z.interrupts[j][k];
							if(/Restore Order/.test(interrupt)) {
								z.restoreOrder = true;
							} else if(/Support the People/.test(interrupt)) {
								if(z.criticalMission && versionAtLeast([2,1,13])){
									z.reckless++;
								} else {
									z.reckless = true;
								}
								z.supportThePeople = true;
							} else if(/At Any Cost/.test(interrupt)) {
								z.thisTreachery = 1;
								if(z.criticalMission && versionAtLeast([2,1,13])){
									z.reckless++;
								} else {
									z.reckless = true;
								}
							} else if(/Guts and Initiative/.test(interrupt)) {
								z.guts = true;
								if(z.criticalMission && versionAtLeast([2,1,13])){
									z.reckless++;
								} else {
									z.reckless = true;
								}
							} else if(/Jury Rigged/.test(interrupt) && !z.juryRigged) {
								if(z.criticalMission && versionAtLeast([2,1,13])){
									z.reckless++;
								} else {
									z.reckless = true;
								}
							}
						}
					}
					for(let j = 0; !(j >= z.numPlayers); j++) {
						if(!z.supportThePeople || (z.revealedCylons[j] === 0 && z.skillCardHands[j].length > 4)) {
							removeOption(j, "Draw 2 Skill Cards");
						}
					}
					
					if(z.players[z.turn] === "Cain" && !noDrawback(z.turn) && z.revealedCylons[z.turn] === 0 && z.turn !== z
						.theSympatheticCylon && z.vBrutality && versionAtLeast([2, 0, 1]) && !versionAtLeast([2,1,9]) && anyUndamagedBasestars()) {
						z.reckless = true;
					}
				}
				mainMenu();
			});
		} else if(ch === "Play an interrupt for this skill check") {
			let interrupts = interruptChoices();
			let promptText = "Which interrupt would you like to use? (1-" + interrupts.length + ")\n";
			for(let i = 0; !(i >= interrupts.length); i++) {
				promptText += (i + 1) + ": ";
				if(Number.isInteger(interrupts[i ])) {
					promptText += cardText(interrupts[i ]) + "\n";
				} else {
					promptText += interrupts[i ] + "\n";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > interrupts.length, mainMenu, (prompted) => {
				let confirmText = "Confirming you want to use ";
				if(Number.isInteger(interrupts[prompted - 1])) {
					confirmText += cardText(interrupts[prompted - 1]) + ".\n";
				} else {
					confirmText += interrupts[prompted - 1] + ".\n";
				}
				confirmify(confirmText, mainMenu, () => {
					if(z.interrupts[me].length === 1 && z.interrupts[me][0] === "Pass") {
						z.interrupts[me] = [];
					}
					if(Number.isInteger(interrupts[prompted - 1])) {
						for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
							if(z.skillCardHands[me][i ] === interrupts[prompted - 1]) {
								playSkillCard(me, i, false);
								switch (cardName(interrupts[prompted - 1])) {
									case "Scientific Research":
										z.thisEngineering = 1;
										if(z.supportThePeople && 4 === z.skillCardHands[me].length){
											addAlert("You may now benefit from Support the People, if you have not already done so.");
											addOption(me,"Draw 2 Skill Cards","Support the People",false);
										}
										break;
									case "Investigative Committee":
										z.investigativeCommittee = true;
										if(z.vBrutality && versionAtLeast([2, 0, 1]) && z.players[me] === "Lee") {
											plainAlert(
												"Lee's Forward Thinker triggers.  If someone else wants to play an Investigative Committee instead, you will have to rewind to undo this draw."
												);
											let card = dealSkillCard(me, 0);
											addAlert("You draw " + cardText(card) + ".");
										} else if(z.supportThePeople && 4 === z.skillCardHands[me].length){
											addAlert("You may now benefit from Support the People, if you have not already done so.");
											addOption(me,"Draw 2 Skill Cards","Support the People",false);
										}
										break;
									case "Restore Order":
										z.restoreOrder = true;
										break;
									case "A Second Chance":
										z.secondChance = true;
										if(z.supportThePeople && 4 === z.skillCardHands[me].length){
											addAlert("You may now benefit from Support the People, if you have not already done so.");
											addOption(me,"Draw 2 Skill Cards","Support the People",false);
										}
										break;
									case "Political Prowess": {
										let alertText = myPlayer +
										" makes the skill check "; /* TODO: auto-clear skill check when using this (shouldn't have the option to play in destiny) */
										let politicalProwess = function(pass) {
											addAlert(
												"IMPORTANT: If other interrupts have been played for this skill check, make sure you are quoting a post before those interrupts were played, to ensure they are properly returned to hand.  If you are not doing so, cancel this post and do so now."
												);
											alertText += " automatically with " + cardText(29) + ".";
											t.value += bold(alertText);
											t.value +=
												"\r\nIf you played an interrupt on this skill check, please check now to ensure it was returned to hand; if not, you may have to rewind.\r\n";
											if(pass && z.daybreak) {
												z.autoPass = true;
											} else {
												processSkillCheckOutcome(pass);
											}
											mainMenu();
										};
										confirmify("Do you want to have this skill check pass or fail?", () => {
											alertText += "fail";
											politicalProwess(false);
										}, () => {
											alertText += "pass";
											politicalProwess(true);
										}, "PASS", "FAIL");
										return;
									}
									case "Guts and Initiative":
										z.guts = true;
										if(z.criticalMission && versionAtLeast([2,1,13])){
											if(z.reckless === false){
												z.reckless = 0;
											}
											z.reckless++;
										} else {
											z.reckless = true;
										}
										break;
									case "At Any Cost":
										z.thisTreachery = 1;
										if(z.criticalMission && versionAtLeast([2,1,13])){
											if(z.reckless === false){
												z.reckless = 0;
											}
											z.reckless++;
										} else {
											z.reckless = true;
										}
										break;
									case "Jury Rigged":
										if(!z.juryRigged){
											z.thisDifficulty -= 4;
										}
										z.juryRigged = true;
										if(z.criticalMission && versionAtLeast([2,1,13])){
											if(z.reckless === false){
												z.reckless = 0;
											}
											z.reckless++;
										} else {
											z.reckless = true;
										}
										break;
									case "Support the People":
										z.supportThePeople = true;
										plainAlert(
											"Assuming nobody else wants to or has played a Reckless interrupt, all Human players with 4 or fewer skill cards may draw 2 skill cards now."
											);
										if(z.criticalMission && versionAtLeast([2,1,13])){
											if(z.reckless === false){
												z.reckless = 0;
											}
											z.reckless++;
										} else {
											z.reckless = true;
										}
										for(let j = 0; !(j >= z.numPlayers); j++) {
											if(z.revealedCylons[j] === 0 && 4 >= z.skillCardHands[j].length) {
												addOption(j, "Draw 2 Skill Cards", "Support the People", false);
											}
										}
										break;
								}
								z.interrupts[me].push(cardText(interrupts[prompted - 1]));
								interruptsToken();
								mainMenu();
								break;
							}
						}
					} else if(interrupts[prompted - 1] === "Critical Mission") {
						if(characterPresent("Boomer") && z.miracles[getPlayerNum("Boomer")] === 1) {
							addAlert("You may want to wait on Boomer to pass on Mysterious Intuition before using your OPG.");
						}
						let confirmText = "";
						if(versionAtLeast([2,1,13])){
							confirmText = "Confirming you want to use Critical Mission, allowing any number of Reckless interrupts to be played on this skill check, though a Reckless effect will be applied for each one.";
						} else {
							confirmText = "Confirming you want to use Critical Mission, increasing the difficulty of its skill check by 5 and changing its PASS result with \"Increase the Jump Preparation Track by 1?\"";
						}
						confirmify(confirmText,
							mainMenu, () => {
								if(z.assist === "Starbuck") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								if(versionAtLeast([2,1,13])){
									boldAlert("Shaw uses her OPG, Critical Mission.  Any number of Reckless interrupts may be played before this skill check, though each will incur a Reckless effect.");
								} else {
									boldAlert(
										"Shaw uses her OPG, Critical Mission, to increase the difficulty of the skill check by 5, and replace the PASS effect with \"Increase the Jump Preparation Track by 1.\""
										);
								}
								if(characterPresent("Boomer") && z.miracles[getPlayerNum("Boomer")] === 1) {
									plainAlert("If Boomer wants to use her OPG instead, you will have to rewind.");
								}
								if(!versionAtLeast([2,1,13])){
									z.thisDifficulty += 5;
								}
								z.interrupts[me].push("Critical Mission");
								interruptsToken();
								mainMenu();
							});
					} else if(interrupts[prompted - 1] === "Secret Destiny") {
						confirmify(
							"Confirming you want to use Secret Destiny to discard this crisis and draw a new one.\nIMPORTANT: If interrupts have been played into this crisis, make sure to quote a post before those interrupts were played, to ensure they are properly returned to hand.",
							mainMenu, () => {
								t.value += bold(
										"Starbuck uses her Secret Destiny ability to discard this crisis and draw a new one.") +
									"\r\n";
								t.value +=
									"If you played an interrupt on the first crisis, please check now to ensure it was returned to hand; if not, you may have to rewind.\r\n";
								if(z.players[z.turn] === "Baltar") {
									t.value +=
										"Note that Baltar does not get to use his Delusional Intuition on EITHER crisis when Starbuck uses her OPG.\r\n";
									removeOption(z.turn, "Draw a skill card for Delusional Intuition");
								}
								if(z.engineRoom) {
									plainAlert("Note that the Engine Room does not benefit this crisis or the next.");
									z.engineRoom = false;
								}
								if(z.assist === "Starbuck") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								clearSkillCheck(true);
								z.crisisDiscards.push(z.currentCrisis);
								z.currentCrisis = null;
								if(z.vBrutality && versionAtLeast([1, 2, 4, 2])) {
									addOption(me, "[Secret Destiny] Pick a new Crisis", undefined, true);
								} else {
									playCrisis(me);
									addAlert("New crisis is: " + d.crisisNames[z.currentCrisis] + ".");
									if((z.turn === me && d.currentPlayerChooses[z.currentCrisis] === 1) || (z.admiral === me && d
											.admiralChooses[z.currentCrisis] === 1) || (z.president === me && d.presidentChooses[z
											.currentCrisis] === 1) || (z.cag === me && d.cagChooses[z.currentCrisis] === 1)) {
										addAlert("It's your choice on this crisis.");
									}
								}
								mainMenu();
							});
					} else if(interrupts[prompted - 1] === "Moral Compass") {
						confirmify(
							"Confirming you want to use Moral Compass to change the choice on this crisis.\nIMPORTANT: If interrupts have been played into this crisis, make sure to quote a post before those interrupts were played, to ensure they are properly returned to hand.",
							mainMenu, () => {
								t.value += bold("Helo uses his Moral Compass ability to change the chosen option on this crisis.") +
									"\r\n";
								t.value +=
									"If you played an interrupt on this skill check, please check now to ensure it was returned to hand; if not, you may have to rewind.\r\n";
								clearSkillCheck(true);
								if(z.assist === "Helo") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								processOR();
								primeCylonActivation();
								z.finishedCrisis = true;
								mainMenu();
							});
					} else if(interrupts[prompted - 1] === "Mysterious Intuition (Pass)") {
						confirmify(
							"Confirming you want to use Mysterious Intuition to automatically make this skill check pass.\nIMPORTANT: If interrupts have been played into this crisis, make sure to quote a post before those interrupts were played, to ensure they are properly returned to hand.",
							mainMenu, () => {
								t.value += bold(
										"Boomer uses her Mysterious Intuition ability to automatically make this skill check pass."
										) + "\r\n";
								t.value +=
									"If you played an interrupt on this skill check, please check now to ensure it was returned to hand; if not, you may have to rewind.\r\n";
								if(z.assist === "Boomer") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								if(!z.daybreak) {
									processSkillCheckOutcome(true);
								} else {
									z.autoPass = true;
								}
								mainMenu();
							});
					} else if(interrupts[prompted - 1] === "Mysterious Intuition (Fail)") {
						confirmify(
							"Confirming you want to use Mysterious Intuition to automatically make this skill check fail.\nIMPORTANT: If interrupts have been played into this crisis, make sure to quote a post before those interrupts were played, to ensure they are properly returned to hand.",
							mainMenu, () => {
								t.value += bold(
										"Boomer uses her Mysterious Intuition ability to automatically make this skill check fail."
										) + "\r\n";
								t.value +=
									"If you played an interrupt on this skill check, please check now to ensure it was returned to hand; if not, you may have to rewind.\r\n";
								if(z.assist === "Boomer") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								processSkillCheckOutcome(false);
								mainMenu();
							});
					} else if(interrupts[prompted - 1] === "Fast Learner") {
						promptNum(
							"Which color skill cards would you like to draw for your OPG, Fast Learner? (1-6)\n1: Politics\n2: Leadership\n3: Tactics" +
							"\n4: Piloting\n5: Engineering\n6: Treachery", (a) => 1 > a || a > 6, mainMenu, (prompted2) => {
								if(z.skillCardDecks[prompted2 - 1].length === 0) {
									addAlert("That deck is completely depleted; try again.");
									mainMenu();
									return;
								}
								z.interrupts[me].push("Fast Learner");
								t.value += bold("Dee uses her OPG, Fast Learner.") + "\r\n";
								if(z.assist === "Dee") {
									z.assistMiracle = 0;
								} else if(z.players[me] === "Gaius") {
									z.miracles[me] -= 2;
								} else {
									z.miracles[me] = 0;
								}
								z.fastLearner.push(dealSkillCard(me, prompted2 - 1));
								if(z.skillCardDecks[prompted2 - 1].length > 0) {
									z.fastLearner.push(dealSkillCard(me, prompted2 - 1));
								}
								if(z.skillCardDecks[prompted2 - 1].length > 0) {
									z.fastLearner.push(dealSkillCard(me, prompted2 - 1));
								}
								let confirmText = "You draw:";
								for(let j = 0; !(j >= z.fastLearner.length); j++) {
									confirmText += "\n" + (j + 1) + ": " + cardText(z.fastLearner[j]);
								}
								/* TODO: Dee can wait until after the interrupts phase to make this decision */
								confirmText += "\n\nWould you like to keep these cards or play them all into the skill check?";
								confirmify(confirmText, () => {
									for(let j = 0; !(j >= z.fastLearner.length); j++) {
										z.skillCardHands[me].pop();
									}
									checkEmptyColors(me);
									addAlert("You play the skill cards into the check.");
									t.value += bold("Dee plays the skill cards into the check.") + "\r\n";
									mainMenu();
								}, () => {
									z.fastLearner = [];
									addAlert("You keep the skill cards.");
									t.value += bold("Dee keeps the skill cards in hand.") + "\r\n";
									mainMenu();
								}, "Keep Them", "Play Them In");
							});
					} else if(interrupts[prompted - 1] === "Friends in Low Places (increase difficulty by 2)") {
						z.interrupts[me].push("Friends in Low Places (difficulty +2)");
						z.thisDifficulty += 2;
						interruptsToken();
						mainMenu();
					} else if(interrupts[prompted - 1] === "Friends in Low Places (decrease difficulty by 2)") {
						z.interrupts[me].push("Friends in Low Places (difficulty -2)");
						z.thisDifficulty -= 2;
						interruptsToken();
						mainMenu();
					} else if(interrupts[prompted - 1] === "Cylon Hatred") {
						z.interrupts[me].push("Cylon Hatred");
						z.thisDifficulty -= 3;
						z.cylonHatred = true;
						interruptsToken();
						mainMenu();
					} else if(interrupts[prompted - 1] === "Chief of Staff") {
						z.interrupts[me].push("Chief of Staff");
						for(let i = 0; !(i >= z.quorumTitles[me].length); i++) {
							if(z.quorumTitles[me][i ] === 17) {
								z.quorumDiscards.push(z.quorumTitles[me].splice(i, 1)[0]);
							}
						}
						z.thisPolitics = 1;
						interruptsToken();
						mainMenu();
					} else if(interrupts[prompted - 1] === "Arbitrator (increase difficulty by 3)") {
						for(let i = 0; !(i >= z.quorumTitles[me].length); i++) {
							if(z.quorumTitles[me][i ] === 3) {
								z.quorumDiscards.push(z.quorumTitles[me].splice(i, 1)[0]);
							}
						}
						z.interrupts[me].push("Arbitrator (difficulty +3)");
						z.thisDifficulty += 3;
						interruptsToken();
						mainMenu();
					} else if(interrupts[prompted - 1] === "Arbitrator (decrease difficulty by 3)") {
						for(let i = 0; !(i >= z.quorumTitles[me].length); i++) {
							if(z.quorumTitles[me][i ] === 3) {
								z.quorumDiscards.push(z.quorumTitles[me].splice(i, 1)[0]);
							}
						}
						z.interrupts[me].push("Arbitrator (difficulty -3)");
						z.thisDifficulty -= 3;
						interruptsToken();
						mainMenu();
					}
				});
			});
		} else if(ch === "Pass on interrupts for this skill check") {
			confirmify("Confirming you'd like to pass on interrupts for this skill check.", mainMenu, () => {
				z.interrupts[me] = ["Pass"];
				interruptsToken();
				mainMenu();
			});
		} else if(ch === "Specify strength of your contribution to the skill check") {
			let promptText = "How would you like to specify the strength of your contribution to this skill check?\n1: Low\n";
			let mediumOK = false;
			if(z.skillCheckCards[me].length >= 3 || (z.skillCheckCards[me].length === 2 && (myPlayer !== "Simon" || z.currentSkillCheck >= 203 ||
				solo))) {
				promptText += "2: Medium\n3: High";
				mediumOK = true;
			} else {
				promptText += "2: High";
			}
			promptNum(promptText, (a) => 1 > a || a > 3 || (a === 3 && !mediumOK), mainMenu, (prompted) => {
				let confirmText = "Confirming you want to specify your contribution as ";
				if(prompted === 1) {
					confirmText += "(low)";
				} else if((prompted === 2 && !mediumOK) || prompted === 3) {
					confirmText += "(high)";
				} else {
					confirmText += "(medium)";
				}
				confirmText += ".\r\nOnce this is set, it cannot be changed.";
				confirmify(confirmText, mainMenu, () => {
					if(prompted === 1) {
						z.contributionLabels[me] = "(low)";
					} else if((prompted === 2 && !mediumOK) || prompted === 3) {
						z.contributionLabels[me] = "(high)";
					} else {
						z.contributionLabels[me] = "(medium)";
					}
					skillCheckToken();
					mainMenu();
				});
			});
		} else if(ch === "Clear skill check") {
			confirmify("Confirming that you want to discard all cards from the skill check.", mainMenu, () => {
				if((z.commandAuthorityPause && characterPresent("Adama") && z.miracles[getPlayerNum("Adama")] === 1 && !isMission(z
						.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck) && !z.theFarm) || (z.commandAuthorityPause && z.assist ===
						"Adama" && z.assistMiracle === 1 && !isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck) && !z.theFarm
						) || (z.commandAuthorityPause && actsOfFaith("Adama") && !isMission(z.currentSkillCheck) && !isSuperCrisis(z
						.currentSkillCheck))) {
					plainAlert(
						"Someone has requested a pause for Adama to consider using his Command Authority ability.  Please wait for Adama to use or pass on the ability " +
						"before proceeding.  Disregard this if he has already passed on the ability.");
					confirmify("Has Adama passed on his Command Authority ability?", mainMenu, () => {
						addAlert("Discarding all cards from the skill check");
						clearSkillCheck();
						mainMenu();
					}, "Adama has passed", "Wait for Adama");
				} else {
					addAlert("Discarding all cards from the skill check");
					clearSkillCheck();
					mainMenu();
				}
			});
		} else if(ch === "Reveal cards from skill check") {
			confirmify("Confirming that you want to shuffle and reveal all skill check cards.", mainMenu, () => {
				let revealCards = function() {
					addAlert("Shuffling and revealing skill check cards.");
					let sorted = sortedSkillCheck(true);
					revealSkillCheck();
					let text = "";
					for(let i = 0; !(i >= sorted.length); i++) {
						text += cardText(sorted[i ]) + "\n";
					}
					text += "\n";
					text += skillCheckTally(true)[0] + "\n";
					addAlert("The following cards are revealed:\n" + text);
					if(isMission(z.currentSkillCheck)) {
						processSkillCheckOutcome();
					} else {
						if(z.humanDelusionPause && ((z.miracles[getPlayerNum("Six")] === 1 && (!z.theFarm || z.revealedCylons[getPlayerNum(
								"Six")] === 1)) || actsOfFaith("Gaius")) && !isMission(z.currentSkillCheck) && !isSuperCrisis(z
								.currentSkillCheck)) {
							plainAlert(
								"Someone has requested a pause for Six to consider using her Human Delusion ability.  Please wait for Six to use or pass on the ability " +
								"before proceeding.");
						}
						if(skillCheckEffects().length === 0 && (!z.reckless || !z.daybreak) && (z.thisConsequence === 0 || !
								consequenceTriggered())) {
							if(shouldDE()) {
								addAlert("The check is within Declare Emergency range.");
								DEToken();
							}
						}
					}
					mainMenu();
				};
				if(z.vBrutality && versionAtLeast([2,1,13]) && characterPresent("Lee") && z.skillCardHands[getPlayerNum("Lee")].length > 0
				   && !Number.isInteger(z.currentSkillCheck)){
					  
					let j = Math.floor((z.seed * z.skillCardHands[getPlayerNum("Lee")].length)/mLCG);
					updateSeed();
					let card = z.skillCardHands[getPlayerNum("Lee")].splice(j,1)[0];
					z.skillCheckCards[z.numPlayers].push(card);
					checkEmptyColors(getPlayerNum("Lee"));
					boldAlert("Lee plays a random card into the skill check due to his Moral Dilemma drawback.");
					if(z.players[me] === "Lee"){
						addAlert("You played "+cardText(card)+" into the skill check randomly.");
					} else {
						z.secretMessages[getPlayerNum("Lee")] += "\nMoral Dilemma, "+z.currentSkillCheck+" check, Turn "+z.round+"."+z.turn+": "+cardText(card);
					}
				}
				if(!z.vBrutality && z.blindDevotionPause && z.blindDevotion === -1 && ((characterPresent("Chief") && z.miracles[getPlayerNum(
						"Chief")] === 1) || (z.assist === "Chief" && z.assistMiracle === 1)) && !z.theFarm && !isMission(z.currentSkillCheck) &&
					!isSuperCrisis(z.currentSkillCheck)) {
					addAlert(
						"Someone has requested a pause for Chief to consider using his Blind Devotion ability.  Please wait for Chief to use or pass on the ability.  Do NOT add more cards to the skill check."
						);
					t.value += "Someone has requested a pause for Chief's Blind Devotion ability. (Disregard if he has already passed.)\r\n";
					confirmify("Has Chief passed on his Blind Devotion ability?", mainMenu, revealCards, "Chief has passed", "Wait for Chief");
				} else if(z.vBrutality && z.blindDevotionPause && z.blindDevotion === -1 && ((characterPresent("Tigh") && z.miracles[
						getPlayerNum("Tigh")] === 1) || (z.assist === "Tigh" && z.assistMiracle === 1) || actsOfFaith("Tigh")) && !z.theFarm &&
					!isMission(z.currentSkillCheck) && !isSuperCrisis(z.currentSkillCheck)) {
					addAlert(
						"Someone has requested a pause for Tigh to consider using his Blind Devotion ability.  Please wait for Tigh to use or pass on the ability.  Do NOT add more cards to the skill check."
						);
					t.value += "Someone has requested a pause for Tigh's Blind Devotion ability. (Disregard if he has already passed.)\r\n";
					confirmify("Has Tigh passed on his Blind Devotion ability?", mainMenu, revealCards, "Tigh has passed", "Wait for Tigh");
				} else {
					revealCards();
				}
			});
		} else if(ch === "Play Destiny into skill check") {
			confirmify("Confirming that you'd like to play 2 cards from Destiny into the skill check.", mainMenu, () => {
				playDestinyToSkillCheck();
				if(!z.pegasusIC && z.investigativeCommittee) {
					addAlert("Played " + cardText(z.skillCheckCards[z.numPlayers][0]) + " and " + cardText(z.skillCheckCards[z.numPlayers][1]) +
						" into the skill check from Destiny.");
				} else {
					addAlert("Played 2 cards from Destiny into the skill check.");
				}
				mainMenu();
			});
		} else if(ch === "Display the skill check token") {
			confirmify("Confirming that you want to display the skill check token to prompt " + z.players[(z.turn + z.contributingPlayer + 1) % z
				.numPlayers] + " to play into the skill check.", mainMenu, () => {
				plainAlert("Displaying the skill check token; note that interrupts can still be played until " + z.players[(z.turn + z
					.contributingPlayer + 1) % z.numPlayers] + " plays or passes on the skill check itself.");
				skillCheckToken();
				mainMenu();
			});
		} else if(ch === "Pass on the skill check") {
			/* TODO: CO contributions, etc. */
			confirmify("Confirming that you want to pass on the skill check.", mainMenu, () => {
				advanceContributor();
				skillCheckToken();
				mainMenu();
			});
		} else if(ch === "Play a card into the skill check" || ch === "Play a card into the skill check (MANDATORY)") {
			let playIn = function() {
				if(!canIContribute()) {
					let promptText = "You played ";
					for(let k = 0; !(k >= z.skillCheckCards[me].length); k++) {
						promptText += cardText(z.skillCheckCards[me][k]) + ", ";
					}
					promptText = promptText.slice(0, -2);
					promptText += " into the skill check.\n\nYou cannot contribute any more cards.";
					addAlert(promptText);
					advanceContributor();
					for(let k = 0; z.probationPause && !(k >= z.quorumTitles[me].length); k++) {
						if(d.quorumNames[z.quorumTitles[me][k]] === "Probation" && z.skillCheckCards[me].length > 0 && !isMission(z
							.currentCrisis)) {
							plainAlert("Someone has requested a pause for President " + z.players[z.president] +
								" to consider using Probation here to examine the " +
								" skill cards you contributed to the skill check.  Please wait for the President to play or pass on Probation before proceeding."
								);
						}
					}
					mainMenu();
					return;
				}
				let promptText = "";
				if(z.skillCheckCards[me].length > 0) {
					promptText += "So far, you have played ";
					for(let k = 0; !(k >= z.skillCheckCards[me].length); k++) {
						promptText += cardText(z.skillCheckCards[me][k]) + ", ";
					}
					promptText = promptText.slice(0, -2);
					promptText += " into the skill check.\n\n";
				}
				promptText += "What card would you like to play into the skill check? (1-" + z.skillCardHands[me].length + ")";
				if(myPlayer === "Simon" && z.skillCheckCards[me].length === 0 && !solo && (z.currentCrisis === null || !isMission(z
					.currentCrisis))) {
					promptText += "\n\nIMPORTANT NOTE: This card will be played face-up, due to your Logic-Bound drawback.\n";
				}
				for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
					promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
				}
				promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, () => {
					if(z.skillCheckCards[me].length > 1 || (z.skillCheckCards[me].length === 1 && (ch ===
						"Play a card into the skill check" || z.players[me] !== "Cally"))) {
						advanceContributor();
						for(let k = 0; z.probationPause && !(k >= z.quorumTitles[me].length); k++) {
							if(d.quorumNames[z.quorumTitles[me][k]] === "Probation" && z.skillCheckCards[me].length > 0 && !isMission(z
									.currentCrisis)) {
								plainAlert("Someone has requested a pause for President " + z.players[z.president] +
									" to consider using Probation here to examine the " +
									" skill cards you contributed to the skill check.  Please wait for the President to play or pass on Probation before proceeding."
									);
							}
						}
					}
					mainMenu();
				}, (prompted) => {
					confirmify("Confirming you want to play " + cardText(z.skillCardHands[me][prompted - 1]) + " into the check.", playIn,
					() => {
						addAlert("Played " + cardText(z.skillCardHands[me][prompted - 1]) + " into the skill check.");
						for(let j = 0; !(j >= z.numPlayers); j++) {
							z.tank[j] = false;
						}
						playCardToSkillCheck(me, prompted - 1);
						if(myPlayer === "Cally" && z.skillCheckCards[me].length === 1 && z.revealedCylons[me] === 0 &&
							myLocation !== "Brig" && myLocation !== "Detention" && me !== z.theSympatheticCylon && !solo) {
							addAlert("Due to your Impulsive drawback, you must play at least 1 more card into this skill check.");
						}
						if(z.skillCardHands[me].length === 0) {
							advanceContributor();
							for(let k = 0; z.probationPause && !(k >= z.quorumTitles[me].length); k++) {
								if(d.quorumNames[z.quorumTitles[me][k]] === "Probation" && z.skillCheckCards[me].length > 0) {
									plainAlert("Someone has requested a pause for President " + z.players[z.president] +
										" to consider using Probation here to examine the " +
										" skill cards you contributed to the skill check.  Please wait for the President to play or pass on Probation before proceeding."
										);
								}
							}
							mainMenu();
						} else {
							/* TODO: any way to cancel later? */
							playIn();
						}
					});
				});
			};
			playIn();
		} else if(ch === "Activate Scar") {
			confirmify("Confirming you want to activate Scar.", mainMenu, () => {
				removeOption(me, ch);
				removeOption(me, "Activate a regular Raider");
				activateSector(true);
				mainMenu();
			});
		} else if(ch === "Activate a regular Raider") {
			confirmify("Confirming you want to activate a regular raider.", mainMenu, () => {
				removeOption(me, ch);
				removeOption(me, "Activate Scar");
				activateSector(false);
				mainMenu();
			});
		} else if(ch.slice(0, 8) === "Activate" && ch.slice(9) !== "Raiders" && ch.slice(9) !== "Heavy Raiders" && ch.slice(9) !==
			"an unmanned Viper" && ch.slice(9) !== "Heavy Raiders from By Your Command" && ch.slice(9) !== "Basestars" && ch.slice(9) !==
			"another location" && ch.slice(9) !== "Occupation Forces" && ch.slice(9) !== "Skill Check Effects" && ch.slice(9) !== "Scar" && ch.slice(
			9) != "a regular Raider") {
			let location = ch.slice(9);
			if(location === "Occupation Authority" || location === "Breeder's Canyon" || location === "Shipyard") {
				if(z.revealedCylons[me] === 0) {
					location += " (Human)";
				} else {
					location += " (Cylon)";
				}
			}
			confirmify("Confirming you want to activate " + location + ".", mainMenu, () => {
				if(myPlayer === "Hoshi" && me === z.turn && (location === "Command" || location === "Communications" || location ===
						"Weapons Control")) {
					addAlert(
						"Remember that you may activate this location again (once per turn) by discarding a skill card, due to your Dutiful ability."
						);
					addOption(me, "Discard a Skill Card", location, false);
				}
				if(hasContext(me, ch, "Dutiful")) {
					activateLocation(location, false);
				} else {
					activateLocation(location, true);
				}
			});
		} else if(ch === "Resolute (OPG)") {
			confirmify("Confirming that you want to use your OPG, Resolute, to activate an undamaged location.", mainMenu, () => {
				if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				t.value += bold("Athena uses her OPG, Resolute.") + "\r\n";
				addAlert('Now, use "Activate another location" to activate a location of your choice.');
				addOption(me, "Activate another location", "Resolute", true);
				didAction();
				mainMenu();
			});
		} else if(ch === "Organized (OPG)") {
			let confirmText = "Confirming that you want to use your OPG, Organized, to activate three different undamaged Human locations.";
			if(z.vBrutality) {
				confirmText = "Confirming that you want to use your OPG, Organized, to activate any two Galactica or Pegasus locations.";
			}
			confirmify(confirmText, mainMenu, () => {
				if(z.assist === "Hoshi") {
					z.assistMiracle = 0;
				} else if(z.players[me] === "Gaius") {
					z.miracles[me] -= 2;
				} else {
					z.miracles[me] = 0;
				}
				t.value += bold("Hoshi uses his OPG, Organized.") + "\r\n";
				if(z.vBrutality) {
					t.value += "He will now activate two Galactica or Pegasus locations.\r\n";
				} else {
					t.value += "He will now activate three different undamaged Human locations.\r\n";
				}
				addAlert('Now, use "Activate another location" to activate the first location.');
				addOption(me, "Activate another location", "Organized", true);
				didAction();
				mainMenu();
			});
		} else if(ch === "[Inspirational Leader] Activate another location" || ch === "[Feared Leader] Activate another location") {
			let promptText = "Which location would you like to activate? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j === me) {
					promptText += "(cannot pick yourself)";
				} else if(z.revealedCylons[j] === 1) {
					promptText += "(CYLON)";
				} else if(!canActivateLocation(me, z.playerLocations[j])) {
					promptText += "(cannot activate " + z.playerLocations[j] + ")";
				} else if(z.playerLocations[j] === "Occupation Authority" || z.playerLocations[j] === "Breeder's Canyon" || z.playerLocations[j] ===
					"Shipyard") {
					promptText += z.playerLocations[j] + " (Human)";
				} else {
					promptText += z.playerLocations[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me || z.revealedCylons[a - 1] === 1 || !canActivateLocation(me, z
				.playerLocations[a - 1]), mainMenu, (prompted) => {
				let pr = z.playerLocations[prompted - 1];
				removeOption(me, ch);
				z.phase = 2;
				activateLocation(pr, false);
			});
		} else if(ch === "Activate another location") {
			if(hasContext(me, ch, "Unorthodox Plan")) {
				let promptText = "Which location would you like to activate? (1-4)\n1: Command\n2: Armory\n3: Weapons Control\n4: Communications";
				if(myPlayer === "Roslin" && !solo) {
					promptText += "\nMake sure you have already discarded 2 cards for Terminal Illness.";
				}
				promptNum(promptText, (a) => 1 > a || a > 4, mainMenu, (prompted) => {
					let pr = "";
					switch (prompted) {
						case 1:
							pr = "Command";
							break;
						case 2:
							pr = "Armory";
							break;
						case 3:
							pr = "Weapons Control";
							break;
						case 4:
							pr = "Communications";
							break;
					}
					if(z.galacticaAway) {
						addAlert("You cannot activate locations on Galactica while she is away.");
						mainMenu();
					} else if(pr === "Armory" && (z.lockdown || z.centurions.length === centurionReserves())) {
						if(z.lockdown) {
							addAlert("Concerted Attack (from the Lockdown CAC) means you cannot activate Armory at this time.");
						} else {
							addAlert("There are no Centurions on board to attack.");
						}
						mainMenu();
					} else if(pr === "Communications" && z.jammedAssault) {
						addAlert("Communications Jamming (from the Jammed Assault CAC) means you cannot activate Communications at this time.");
						mainMenu();
					} else if(pr === "Communications" && spaceCiviliansList().length === 0) {
						addAlert("There are no civilians in space to inspect, so you may want to pick a different location to activate.");
						mainMenu();
					} else if(myPlayer === "Zarek" && otherPlayerInLocation(me, pr) && !solo) {
						addAlert("Your Convicted Criminal drawback means you cannot activte " + pr + " at this time.");
						mainMenu();
					} else {
						if(myPlayer === "Hoshi" && pr !== "Armory" && hasContext(me, ch, "Unorthodox Plan") && ((pr === "Command" &&
								characterPresent("Apollo")) || !z.damagedLocations.includes(pr)) && z.turn === me) {
							removeOption(me, ch); /* TODO: enforce Dutiful once per turn for Hoshi */
							addAlert(
								"Remember that you may activate this location again (once per turn) by discarding a skill card, due to your Dutiful ability."
								);
							if(z.damagedLocations.includes(pr)) {
								addAlert(
									"Note that you may not used Dutiful to activate Command again unless it somehow gets repaired in the meantime."
									);
							}
							addOption(me, "Discard a Skill Card", pr, false);
						} else {
							removeOption(me, ch);
						}
						activateLocation(pr, false);
					}
				});
			} else {
				let validShips = [];
				let pickLocation = function(ship) {
					let validLocations = [];
					switch (ship) {
						case "Galactica":
							validLocations = ["FTL Control", "Weapons Control", "Command", "Communications", "Admiral's Quarters", "Research Lab",
								"Hangar Deck", "Armory", "Brig"
							];
							break;
						case "Colonial One":
							validLocations = ["Press Room", "President's Office", "Administration"];
							if(z.daybreak) {
								validLocations.push("Quorum Chamber");
							}
							break;
						case "Pegasus":
							validLocations = ["Airlock", "Pegasus CIC", "Main Batteries", "Engine Room"];
							break;
						case "Rebel Basestar":
							validLocations = ["Raider Bay", "Datastream", "Hybrid Tank"];
							break;
						case "Demetrius":
							validLocations = ["Bridge", "Captain's Cabin", "Tactical Plot"];
							break;
						case "New Caprica (Human)":
							validLocations = ["Resistance HQ", "Occupation Authority (Human)", "Breeder's Canyon (Human)", "Shipyard (Human)",
								"Detention"
							];
							break;
						case "New Caprica (Cylon)":
							validLocations = ["Occupation Authority (Cylon)", "Breeder's Canyon (Cylon)", "Shipyard (Cylon)"];
							break;
						case "Cylon Locations":
							validLocations = ["Caprica", "Cylon Fleet", "Human Fleet"];
							if(z.hubDestroyed) {
								validLocations.push("Hub Destroyed");
							} else {
								validLocations.push("Resurrection Ship");
							}
							if(z.CFB) {
								validLocations.push("Basestar Bridge");
							}
							break;
					}
					let promptText = "Which location would you like to activate? (1-" + validLocations.length + ")";
					for(let j = 0; !(j >= validLocations.length); j++) {
						promptText += "\n" + (j + 1) + ": " + validLocations[j];
					}
					promptNum(promptText, (a) => 1 > a || a > validLocations.length, mainMenu, (prompted) => {
						let pr = validLocations[prompted - 1];
						if(!canActivateLocation(me, pr)) {
							addAlert("You cannot activate " + pr + " at this time.");
							mainMenu();
							return;
						}
						if(myPlayer === "Hoshi" && (pr === "Command" || pr === "Communications" || pr === "Weapons Control") && z.turn ===
							me) {
							addAlert(
								"Remember that you may activate this location again (once per turn) by discarding a skill card, due to your Dutiful ability, if you have not already used that ability this turn."
								);
							addOption(me, "Discard a Skill Card", pr, false);
						}
						if(hasContext(me, ch, "Organized")) {
							addOption(me, ch, "Organized2", true);
						} else if(hasContext(me, ch, "Organized2")) {
							
							if(!z.vBrutality) {
								addOption(me, ch, "Organized3", true);
							} else {
								removeOption(me, ch);
							}
						} else {
							removeOption(me, ch);
						} /* TODO: backing out of these will cause issues */
						if(pr === "Hangar Deck") {
							z.athenaProblem = true;
						}
						activateLocation(pr, false);
					});
				};
				if(!z.galacticaAway) {
					validShips = ["Galactica"];
				}
				if(!z.galacticaAway && !z.galacticaReturned && !z.colonialOneDestroyed && (!z.vBrutality || hasContext(me, ch, "Resolute"))) {
					validShips.push("Colonial One");
				}
				if(z.pegasus && !z.galacticaAway && !z.pegasusDestroyed) {
					validShips.push("Pegasus");
				}
				if(z.rebelBasestar !== 0 && !z.galacticaAway && (z.miracles[me] !== 0 || z.superCrisisHands[me].length > 0) && (myPlayer !== "Hoshi" ||
						z.rebelBasestar === 1) && (!z.vBrutality || hasContext(me, ch, "Resolute"))) {
					validShips.push("Rebel Basestar");
				}
				if((z.destination === "Earth" || z.destination === "Ionian Earth") && (!z.vBrutality || hasContext(me, ch, "Resolute")) && (!z
						.vBrutality || !versionAtLeast([1, 2, 4, 6]))) {
					validShips.push("Demetrius");
				}
				if((z.galacticaAway || z.galacticaReturned) && !hasContext(me, ch, "Resolute") && !z.vBrutality) {
					validShips.push("New Caprica (Human)");
				}
				if((z.galacticaAway || z.galacticaReturned) && hasContext(me, ch, "Resolute")) {
					validShips.push("New Caprica (Human)");
					validShips.push("New Caprica (Cylon)");
				}
				if(hasContext(me, ch, "Resolute")) {
					validShips.push("Cylon Locations");
				}
				if(validShips.length === 1) {
					pickLocation(validShips[0]);
				} else {
					let promptText = "Which ship would you like to activate a location on? (1-" + validShips.length + ")";
					for(let j = 0; !(j >= validShips.length); j++) {
						promptText += "\n" + (j + 1) + ": " + validShips[j];
					}
					promptNum(promptText, (a) => 1 > a || a > validShips.length, mainMenu, (prompted) => {
						pickLocation(validShips[prompted - 1]);
					});
				}
			}
		} else if(ch.slice(0, 7) === "Stay on") {
			confirmify("Confirming you want to waive your movement step and stay on " + z.playerLocations[me] + " this turn.", mainMenu, () => {
				plainAlert(z.players[me] + " chooses to waive their Movement step.");
				endMovement();
				mainMenu();
			});
		} else if(ch === "Do Nothing") {
			confirmify("Confirming you want to waive the action you are presently entitled to, thereby doing nothing.", mainMenu, () => {
				plainAlert(z.players[me] + " chooses to do nothing as an action.");
				didAction();
				mainMenu();
			});
		} else if(ch === "Move" || ch === "Move to Galactica from the Shipyard" || ch === "Infiltrate Galactica" || ch === "Move in Space") {
			/* you don't get this option if you're in the Brig, in Detention, or Stranded */ /* TODO: don't let you move between ships if you have no cards! (except from Human Fleet) */ /* TODO: check infiltration */ /* TODO: don't prompt discard if returning to Hangar Deck on jump in AR. */
			let myLocation = z.playerLocations[me];
			let validShips = [];
			let pickLocation = function(shipChosen) {
				let validLocations = [];
				switch (shipChosen) {
					case "Galactica":
						validLocations = ["FTL Control", "Weapons Control", "Command", "Communications", "Admiral's Quarters", "Research Lab",
							"Hangar Deck", "Armory"
						];
						break;
					case "Colonial One":
						validLocations = ["Press Room", "President's Office", "Administration"];
						if(z.daybreak) {
							validLocations.push("Quorum Chamber");
						}
						break;
					case "Pegasus":
						validLocations = ["Airlock", "Pegasus CIC", "Main Batteries", "Engine Room"];
						break;
					case "Rebel Basestar":
						validLocations = ["Raider Bay", "Datastream", "Hybrid Tank"];
						break;
					case "Demetrius":
						validLocations = ["Bridge", "Captain's Cabin", "Tactical Plot"];
						break;
					case "New Caprica":
						validLocations = ["Resistance HQ", "Occupation Authority", "Breeder's Canyon", "Shipyard"];
						break;
					case "Cylon Locations":
						validLocations = ["Caprica", "Cylon Fleet", "Human Fleet"];
						if(!z.pegasus && !z.daybreak) {
							validLocations.push("Resurrection Ship");
						}
						if(z.CFB) {
							validLocations.push("Basestar Bridge");
						}
						break;
					case "Space":
						if(whatViper(me) === "Viper Mk VII" && (!characterPresent("Racetrack") || z.playerLocations[me] !== z.playerLocations[
								getPlayerNum("Racetrack")] || !versionAtLeast([2, 1, 3]))) {
							switch (myLocation) {
								case "Sector 1":
								case "Sector 4":
									validLocations = ["Sector 2", "Sector 3", "Sector 5", "Sector 6"];
									break;
								case "Sector 2":
								case "Sector 5":
									validLocations = ["Sector 1", "Sector 3", "Sector 4", "Sector 6"];
									break;
								case "Sector 3":
								case "Sector 6":
									validLocations = ["Sector 1", "Sector 2", "Sector 4", "Sector 5"];
									break;
							}
						} else {
							switch (myLocation) {
								case "Sector 1":
									validLocations = ["Sector 2", "Sector 6"];
									break;
								case "Sector 4":
									validLocations = ["Sector 3", "Sector 5"];
									break;
								case "Sector 2":
									validLocations = ["Sector 1", "Sector 3"];
									break;
								case "Sector 5":
									validLocations = ["Sector 4", "Sector 6"];
									break;
								case "Sector 3":
									validLocations = ["Sector 2", "Sector 4"];
									break;
								case "Sector 6":
									validLocations = ["Sector 1", "Sector 5"];
									break;
							}
						}
						break;
				}
				let promptText = "Which location would you like to move to?";
				for(let j = 0; !(j >= validLocations.length); j++) {
					promptText += "\n" + (j + 1) + ": ";
					if(myLocation === validLocations[j]) {
						promptText += "(already here)";
					} else if(myPlayer === "Leoben" && !solo && otherPlayerInLocation(me, validLocations[j])) {
						promptText += "(Clouded)";
					} else {
						promptText += validLocations[j];
						if(z.daybreak) {
							if(validLocations[j] === "Quorum Chamber") {
								promptText += " (Draw/Play Quorums)";
							} else if(validLocations[j] === "Press Room") {
								promptText += " (Deal/Discard Mutinies)";
							} else if(validLocations[j] === "President's Office") {
								promptText += " (Draw Two Politics)";
							} else if(validLocations[j] === "Administration") {
								promptText += " (Draw Mutiny / Move President Title)";
							}
						} else {
							if(validLocations[j] === "Press Room") {
								promptText += " (Draw Two Politics)";
							} else if(validLocations[j] === "President's Office") {
								promptText += " (Draw/Play Quorums)";
							} else if(validLocations[j] === "Administration") {
								promptText += " (Skill Check: Move President Title)";
							}
						}
					}
				}
				promptNum(promptText, (a) => 1 > a || a > validLocations.length || validLocations[a - 1] === myLocation || (myPlayer === "Leoben" &&
					!solo && otherPlayerInLocation(me, validLocations[a - 1])), mainMenu, (choice) => {
					let prompted = validLocations[choice - 1];
					addAlert("You moved to " + prompted + ".");
					if(ship(z.playerLocations[me]) !== ship(prompted) && ch !== "Infiltrate Galactica" && ch !==
						"Move to Galactica from the Shipyard" && !hasContext(me, ch, "Meticulous")) {
						let alertText = "You must discard a card for moving between ships.";
						if(z.forLove && !z.vBrutality && z.players[me] !== "Athena") {
							alertText += "\nAthena may be able to Love you.";
						}
						/*if(z.pegasus && !z.daybreak) {
							let numDamaged = 0;
							for(let j = 0; !(j >= z.damagedLocations.length); j++) {
								if(onPegasus(z.damagedLocations[j])) {
									numDamaged++;
								}
							}
							let sabotagePossible = false;
							for(let j = 0; !(j >= z.numPlayers); j++) {
								if(z.possibleColors[j][5] > 0 && z.revealedCylons[j] === 1) {
									sabotagePossible = true;
									break;
								}
							}
							if(z.possibleColors[me][5] === 0) {
								sabotagePossible = false;
							}
							if(sabotagePossible) {
								if(ship(prompted) === "Pegasus" && numDamaged === 3) {
									let alertText = "If the discard results in " + colorText("brown", "Sabotage") +
										" destroying Pegasus, you will be incorrectly moved to Sickbay; move back to " + z.playerLocations[
											me] + " instead.";
									if(ship(z.playerLocations[me]) === "Space") {
										alertText +=
											"  This will require you to move to the Hangar Deck, launch yourself in your viper, then move back to " +
											z.playerLocations[me] + ".";
									} else if(ship(z.playerLocations[me]) !== "Galactica") {
										alertText += "  Do not discard another skill card to do so.";
									}
									plainAlert(alertText);
								} else if(z.damage.includes(prompted) || (!z.vAltDamage && z.pegasusDamage.includes(prompted))) {
									let alertText = "If the discard results in " + colorText("brown", "Sabotage") + " damaging " +
										prompted + ", you will be incorrectly moved to Sickbay; move back to " + prompted + ".";
									if(ship(prompted) === "Pegasus") {
										alertText += "  Do not discard another skill card to do so.";
									}
									plainAlert(alertText);
								}
								if(ship(z.playerLocations[me]) === "Pegasus" && numDamaged === 3) {
									plainAlert("If the discard results in " + colorText("brown", "Sabotage") +
										" destroying Pegasus, you should be moved to Sickbay; BYC will not do this automatically for you."
										);
								} else if(z.damage.includes(z.playerLocations[me]) || (!z.vAltDamage && z.pegasusDamage.includes(z
										.playerLocations[me]))) {
									plainAlert("If the discard results in " + colorText("brown", "Sabotage") + " damaging " + z
										.playerLocations[me] +
										", you should be moved to Sickbay; BYC will not do this automatically for you.");
								}
							}
						}*/
						addAlert(alertText);
						if(z.forLove && z.players[me] !== "Athena" && !z.vBrutality && z.forLoveCOs[me] === null) {
							addOption(me, "Choose a Skill Card to discard if Athena does not Love you", undefined, true);
						} else {
							addOption(me, "Discard a Skill Card", "Move", true);
						}
					}
					if(ch === "Move in Space" && z.eventHorizon) {
						z.gravityWell = false;
					}
					movePlayer(me, prompted);
					if(z.phase === 1) {
						endMovement();
					} else if((me === z.xo1 && !z.razor) || me === z.SoEActor || ch === "Move in Space") {
						didAction();
					}
					removeOption(me, ch);
					removeOption(me, "Move to Galactica from the Shipyard");
					removeOption(me, "Infiltrate Galactica");
					removeOption(me, "Razor");
					mainMenu();
				});
			};
			if(ch === "Infiltrate Galactica" || ch === "Move to Galactica from the Shipyard") {
				validShips = ["Galactica"];
			} else if(ch === "Move in Space") {
				validShips = ["Space"];
			} else if(z.revealedCylons[me] === 0) {
				if(!z.galacticaAway) {
					validShips = ["Galactica"];
				}
				if(!z.galacticaAway && !z.galacticaReturned && !z.colonialOneDestroyed) {
					validShips.push("Colonial One");
				}
				if(z.pegasus && !z.galacticaAway && !z.pegasusDestroyed) {
					validShips.push("Pegasus");
				}
				if(z.rebelBasestar === 1 && !z.galacticaAway) {
					validShips.push("Rebel Basestar");
				}
				if((z.destination === "Earth" || z.destination === "Ionian Earth") && (!z.vBrutality || !versionAtLeast([1, 2, 4, 6]))) {
					validShips.push("Demetrius");
				}
				if(z.galacticaAway || z.galacticaReturned) {
					validShips.push("New Caprica");
				}
				if(inSpace(z.playerLocations[me])) {
					validShips.push("Space");
				}
			} else {
				if(!z.galacticaAway) {
					validShips = ["Cylon Locations"];
				}
				if(z.rebelBasestar === -1 && !z.galacticaAway) {
					validShips.push("Rebel Basestar");
				}
				if(z.galacticaAway || z.galacticaReturned) {
					validShips.push("New Caprica");
				}
			}
			if(validShips.length === 1) {
				pickLocation(validShips[0]);
			} else if(z.skillCardHands[me].length === 0) {
				/* TODO: what if you're fixing sabotage issues */
				pickLocation(ship(z.playerLocations[me]));
			} else {
				let promptText = "Which ship would you like to move to? (1-" + validShips.length + ")";
				for(let j = 0; !(j >= validShips.length); j++) {
					promptText += "\n" + (j + 1) + ": " + validShips[j];
				}
				promptNum(promptText, (a) => 1 > a || a > validShips.length, mainMenu, (prompted) => {
					pickLocation(validShips[prompted - 1]);
				});
			} /*TODO: start skill check when guts around */
		} else if(ch === "Pass on For Love") {
			confirmify(
				"Confirming you want to pass on For Love; any random discards being waited on will happen now, as will any normal discards players chose to discard in this eventuality.",
				mainMenu, () => {
					boldAlert("Athena passes on For Love.");
					cleanLove();
					mainMenu();
				});
		} else if(ch === "For Love") {
			let promptText = "Who are you Loving? (1-" + z.numPlayers + ")";
			for(let j = 0; !(j >= z.numPlayers); j++) {
				promptText += "\n" + (j + 1) + ": ";
				if(j === me) {
					promptText += "(cannot Love yourself)";
				} else {
					promptText += z.players[j];
				}
			}
			promptNum(promptText, (a) => 1 > a || a > z.numPlayers || a - 1 === me , mainMenu, (prompted) => {
				let love = function() {
					let card = dealSkillCard(me, 5);
					addAlert("You draw " + cardName(card) + ".");
					z.forLove = false;
					cleanLove();
					mainMenu();
				};
				if(z.randomLove[prompted - 1]) {
					boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
					z.randomLove[prompted - 1] = false;
					love();
				} else if(z.forLoveCOs[prompted - 1] !== null) {
					boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
					z.forLoveCOs[prompted - 1] = null;
					love();
				} else if (z.allForLove[prompted-1]){
					boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
					z.allForLove[prompted - 1] = false;
					love();
					if(z.skillCardHands[prompted-1].length > 1){
						z.allForLove[prompted - 1] = true;
					}
				} else if(hasOption(prompted - 1, "Choose a Skill Card to discard if Athena does not Love you") || hasOption(prompted - 1,
						"[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you") || hasOption(prompted - 1,
						"[Kleptomania] Choose a Skill Card to discard if Athena does not Love you")) {
					removeOption(prompted - 1, "Choose a Skill Card to discard if Athena does not Love you");
					removeOption(prompted - 1, "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you");
					removeOption(prompted - 1, "[Kleptomania] Choose a Skill Card to discard if Athena does not Love you");
					boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
					love();
				} else if(z.players[prompted - 1] === "Hoshi" && z.eventHorizon && !z.vBrutality) {
					confirmify(
						"BYC assumes you are using For Love on Hoshi to prevent a discard from his Dutiful drawback or the Gravity Well effect of Event Horizon.  If neither of these is the case, you may want to check that you can actually use For Love here before proceeding.\n\nAre you sure you want to use For Love on Hoshi?",
						mainMenu, () => {
							boldAlert("Athena uses For Love on Hoshi.");
							love();
						}, "YES", "NO");
				} else if(z.players[prompted - 1] === "Hoshi" && !z.vBrutality) {
					confirmify(
						"BYC assumes you are using For Love on Hoshi to prevent a discard from his Dutiful drawback.  If this is not the case, you may want to check that you can actually use For Love here before proceeding.\n\nAre you sure you want to use For Love on Hoshi?",
						mainMenu, () => {
							boldAlert("Athena uses For Love on Hoshi.");
							love();
						}, "YES", "NO");
				} else if(z.eventHorizon) {
					confirmify(
						"BYC assumes you are using For Love to prevent a discard from the Gravity Well effect of the Event Horizon CAC.  If this is not the case, you may want to check that you can actually use For Love here before proceeding.\n\nAre you sure you want to use For Love on " +
						z.players[prompted - 1] + "?", mainMenu, () => {
							boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
							love();
						}, "YES", "NO");
				} else if (z.selfishLove){
					confirmify("BYC assumes you are using For Love on a player who was instructed to discard more cards than they had in hand.  If this is not the case, you may want to check that you can actually use For Love here before proceeding.\n\nAre you sure you want to use For Love on "+
						z.players[prompted - 1] + "?",mainMenu, () => {
							boldAlert("Athena uses For Love on "+ z.players[prompted-1] + "; the only effect is Athena's Treachery draw.");
							delete z.selfishLove;
							love();
						}, "YES", "NO");
				} else {
					confirmify("BYC doesn't think " + z.players[prompted - 1] +
						" needs to discard right now, but BYC has been known to make mistakes.\nAre you sure you still want to use For Love here?",
						mainMenu, () => {
							boldAlert("Athena uses For Love on " + z.players[prompted - 1] + ".");
							love();
						}, "YES", "NO");
				}
			});
		} else if(ch === "Choose a Skill Card to discard if Athena does not Love you" || ch ===
			"[Kleptomania] Choose a Skill Card to discard if Athena does not Love you" || ch ===
			"[Reluctant] Choose a Skill Card to discard if Athena does not Love you" || ch ===
			"[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you" || ch ===
			"[Gravity Well] Choose a Skill Card to discard if Athena does not Love you") {
			let promptText = "Which card would you like to discard if Athena does not use For Love on you? (1-" + z.skillCardHands[me].length + ")";
			for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
				promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
			}
			if(ch === "[Reluctant] Choose a Skill Card to discard if Athena does not Love you") {
				promptText += "\nMake sure you don't pick the card you're about to play.";
			} else if(ch === "[Gravity Well] Choose a Skill Card to discard if Athena does not Love you") {
				promptText += "\nIf you're about to play a Piloting card, make sure you don't pick the card you're about to play.";
			}
			promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length, mainMenu, (prompted) => {
				confirmify("Confirming you want to discard " + cardText(z.skillCardHands[me][prompted - 1]) + " if Athena does not Love you.",
					mainMenu, () => {
						z.forLoveCOs[me] = z.skillCardHands[me][prompted - 1];
						addAlert("You will discard " + cardText(z.skillCardHands[me][prompted - 1]) + " if Athena does not Love you.");
						t.value += z.players[me] +
						" privately chose a skill card they would discard if Athena does not Love them here.\r\n";
						removeOption(me, ch);
						if(ch === "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you" && !hasOption(me,
								"Activate another location")) {
							addOption(me, "Activate " + z.playerLocations[me], undefined, true);
						} else if(ch === "[Reluctant] Choose a Skill Card to discard if Athena does not Love you") {
							z.reluctant = true;
						} else if(ch === "[Gravity Well] Choose a Skill Card to discard if Athena does not Love you") {
							z.gravityWell = true;
						}
						mainMenu();
					});
			});
		} else if(ch === "Discard a Skill Card" || ch === "[Kleptomania] Discard a Skill Card" || ch === "[Star Player] Discard a Skill Card" || ch ===
			"[Reluctant] Discard a Skill Card" || ch === "[Conflicted Loyalties] Discard a Skill Card" || ch ===
			"[Terminal Illness] Discard a Skill Card" || ch === "[Terminal Illness] Discard another Skill Card" || ch ===
			"[Gravity Well] Discard a Skill Card") {
			let promptText = "";
			promptText += "What card would you like to discard? (1-" + z.skillCardHands[me].length + ")";
			if(myPlayer === "Apollo" && !solo) {
				promptText +=
				"\n Apollo discards randomly if he is being forced to discard; if you need to discard randomly instead, press Cancel.";
			}
			for(let i = 0; !(i >= z.skillCardHands[me].length); i++) {
				promptText += "\n" + (i + 1) + ": " + cardText(z.skillCardHands[me][i ]);
			}
			if(ch === "[Reluctant] Discard a Skill Card") {
				promptText += "\nMake sure you do not discard the skill card you want to play.";
			}
			if(ch === "[Star Player] Discard a Skill Card" && z.vBrutality) {
				promptText += "\nMake sure the skill cards you discard are all of the same color.";
			}
			promptNum(promptText, (a) => 1 > a || a > z.skillCardHands[me].length + 1, mainMenu, (prompted) => {
				let card = z.skillCardHands[me][prompted - 1];
				let confirmText = "Confirming you want to discard " + cardText(card) + ".";
				if(z.dradisBait[me] && (cardName(card) === "Bait" || cardName(card) === "Dradis Contact")) {
					confirmText +=
						"\n\nWarning: Discarding this card will cause you to draw a Mutiny.  (If you have been instructed to discard your entire hand, or discard randomly, discard this card randomly instead to avoid the Mutiny draw.";
				}
				confirmify(confirmText, mainMenu, () => {
					addAlert("Discarding " + cardText(card) + ".");
					discardSkillCard(me, prompted - 1);
					let context = getContext(me, ch);
					let man = isMandatory(me, ch);
					
					if(ch === "[Kleptomania] Discard a Skill Card") {
						
						if(context > 1) {
							addOption(me, ch, context - 1, man);
						} else {
							removeOption(me, ch);
						}
					} else if(ch === "[Star Player] Discard a Skill Card") {
						context++;
						if(z.skillCardHands[me].length > 0 && (!z.vBrutality || 4 > context)) {
							addOption(me, ch, context, false);
						} else {
							removeOption(me, ch);
						}
						addOption(me, "[Star Player] Draw Skill Cards", context, true);
					} else if(Number.isInteger(context)) {
						removeOption(me, "[D'Anna] Draw Trauma Tokens");
						removeOption(me, "[Gaeta] Draw Trauma Tokens");
						
						if(z.skillCardHands[me].length > 0 && context > 1) {
							addOption(me, ch, context - 1, man);
						} else {
							removeOption(me, ch);
						}
					} else if(context === "Communications" || context === "Command" || context === "Weapons Control") {
						removeOption(me, ch);
						addOption(me, "Activate " + context, "Dutiful", true);
					} else if(ch === "[Conflicted Loyalties] Discard a Skill Card") {
						addOption(me, "Activate Cylon Fleet", undefined, true);
					} else if(ch === "[Terminal Illness] Discard a Skill Card") {
						removeOption(me, ch);
						if(z.forLove && !z.vBrutality && z.forLoveCOs[me] === null) {
							addOption(me, "[Terminal Illness] Choose a Skill Card to discard if Athena does not Love you", undefined,
								true);
						} else {
							addOption(me, "[Terminal Illness] Discard another Skill Card", undefined, true);
						}
					} else if(ch === "[Terminal Illness] Discard another Skill Card") {
						removeOption(me, ch);
						if(!hasOption(me, "Activate another location")) {
							addOption(me, "Activate " + z.playerLocations[me], undefined, true);
						}
					} else if(ch === "[Reluctant] Discard a Skill Card") {
						z.reluctant = true;
					} else if(ch === "[Gravity Well] Discard a Skill Card") {
						z.gravityWell = true;
					} else if(!z.forLove && Array.isArray(z.allForLove) && z.allForLove[me] && z.skillCardHands[me].length === 1){
						z.allForLove[me] = false;
					} else if(context === "Move"){
						removeOption(me,ch);
						if(z.pegasus && !z.daybreak && cardColorID(card) === 5){
							z.sabotageMove = [me,z.playerLocations[me]];
							for(let j = 0; !(j>=z.vipersII.length); j++){
								if(z.vipersII[j] === z.players[me]){
									z.sabotageMove.push("II");
									break;
								}
							}
							for(let j = 0; z.CFB && !(j>=z.vipersVII.length); j++){
								if(z.vipersVII[j] === z.players[me]){
									z.sabotageMove.push("VII");
									break;
								}
							}
						}
					}
					mainMenu();
				});
			});
		} else if(ch === "Discard a random Skill Card") {
			if(z.skillCardHands[me].length === 0) {
				addAlert("You have no skill cards to discard, randomly or otherwise.");
				removeOption(me, ch);
				mainMenu();
			} else {
				let confirmText = "Are you sure you would like to discard a random skill card?";
				if(z.forLove && myPlayer !== "Athena") {
					confirmText += "\nWait for Athena to play or pass on For Love before discarding.";
				} /* TODO: is this notification still necessary? */
				if(z.currentCrisis !== null && myPlayer === "Romo" && z.revealedCylons[me] === 0 && me !== z.theSympatheticCylon) {
					promptText += "\nRemember that your Deceitful ability means you discard 1 fewer skill card from Crisis Card effects.";
				}
				confirmify(confirmText, mainMenu, () => {
					let discard = discardRandomSkillCard(me);
					addAlert("Discarded " + cardText(discard) + " randomly.");
					let context = getContext(me, ch);
					let man = isMandatory(me, ch);
					
					if(Number.isInteger(context) && context > 1) {
						addOption(me, ch, context - 1, man);
					} else if(z.players[me] === "Apollo") {
						removeOption(me, ch);
						removeFromAll("Make Apollo discard randomly");
					} else {
						removeOption(me, ch);
					}
					mainMenu();
				});
			}
		} else if(ch === "Play the top Crisis") {
			let mandatories = anyMandatory();
			if(mandatories.length > 0) {
				plainAlert(
					"It looks like some things still need to be done before we can proceed to the Crisis step.  The following players must do one or more of the following things:"
					);
				for(let j = 0; !(j >= mandatories.length); j++) {
					plainAlert(z.players[mandatories[j][0]] + ": " + mandatories[j][1]);
				}
				plainAlert('If you are sure this is in error, you may use the deep menus to "Make all options non-mandatory", then try again.');
				mainMenu();
			} else {
				confirmify("Confirming you want to play the top crisis.", mainMenu, () => {
					z.crisisOptions = blankArrays(z.numPlayers);
					z.context = blankArrays(z.numPlayers);
					z.mandatory = blankArrays(z.numPlayers);
					if(z.stim !== null && z.revealedCylons[z.turn] === 0 && z.turn !== z.theSympatheticCylon && z.playerLocations[z.turn] === z
						.stim) {
						if(isOnNewCaprica(z.turn) && z.playerLocations[z.turn] !== "Detention" && z.playerLocations[z.turn] !==
							"Medical Center" && z.numPlayers + z.boxedPlayers.length > 1) {
							boldAlert("Kat is a Stim Junkie.");
							movePlayer(z.turn, "Medical Center");
						} else if(!isOnNewCaprica(z.turn) && z.playerLocations[z.turn] !== "Brig" && z.playerLocations[z.turn] !== "Sickbay" &&
							z.numPlayers + z.boxedPlayers.length > 1) {
							boldAlert("Kat is a Stim Junkie.");
							movePlayer(z.turn, "Sickbay");
						}
					}
					if(characterPresent("Cain") && z.vBrutality && versionAtLeast([2,1,9]) && z.players[z.turn] === "Cain" && anyUndamagedBasestars()){
						boldAlert("Cain is Bent on Revenge.");
						dealMutiny(z.turn);
						if(z.playerLocations[z.turn] === "Brig"){
							plainAlert("As Cain is now in the Brig, she does not get a Crisis card after all.");
							mainMenu();
							return;
						}
					}
					z.stim = null;
					addAlert("Crisis is: " + d.crisisNames[z.crisisDeck[z.crisisDeck.length - 1]] + ".");
					z.phase = 4;
					playCrisis();
					if(z.players[z.turn] === "Baltar") {
						plainAlert("Remember that Baltar must draw a skill card from Delusional Intuition.");
						addOption(z.turn, "Draw a skill card for Delusional Intuition", undefined, true);
					}
					if((z.turn === me && d.currentPlayerChooses[z.currentCrisis] === 1) || (me === z.admiral && d.admiralChooses[z
							.currentCrisis] === 1) || (me === z.president && d.presidentChooses[z.currentCrisis] === 1) || (me === z.cag && d
							.cagChooses[z.currentCrisis] === 1)) {
						addAlert("It's your choice on this crisis.");
					}
					if((d.CAC[z.currentCrisis] === 1 || z.secretDestinyPause) && characterPresent("Starbuck") && (z.miracles[getPlayerNum(
							"Starbuck")] === 1 || actsOfFaith("Starbuck")) && !z.theFarm) {
						plainAlert(
							"Remember that Starbuck can use her OPG, Secret Destiny, here; you may want to wait for her input before proceeding."
							);
					}
					mainMenu();
				});
			}
		} else if(ch === "Choose the Skill Check on this crisis") {
			confirmify("Confirming you want to choose the Skill Check on this crisis", mainMenu, () => {
				t.value += bold(myPlayer + " chooses to take the skill check for " + d.crisisNames[z.currentCrisis] + ".\r\n");
				if(canMoralCompass()) {
					if(z.revealedCylons[me] === 1 || isTheCylonLeader(me)) {
						plainAlert("Remember that Helo may want to use his Moral Compass ability here.");
					} else if(me !== getHelo() && z.moralCompassPause) {
						let unrevealed = false;
						for(let j = 0; !(j >= z.numPlayers) && !unrevealed; j++) {
							unrevealed = cylonCards(j) > 0;
						}
						for(let j = 0; !unrevealed && !(j >= z.boxedPlayers.length); j++) {
							for(let k = 0; !unrevealed && !(k >= z.boxedPlayers[2].length); k++) {
								unrevealed = isCylonCard(z.boxedPlayers[2][k]);
							}
						}
						for(let j = 0; !(j>=z.loyaltyDeck.length) && !unrevealed; j++){
							unrevealed = isCylonCard(z.loyaltyDeck[j]);
						}
						if(unrevealed) {
							plainAlert("Remember that Helo may want to use his Moral Compass ability here.");
						}
					}
				}
				addAlert("Initializing skill check: " + d.crisisNames[z.currentCrisis] + ".");
				startCrisisSkillCheck();
				mainMenu();
			});
		} else if(ch === "Add text after your post (and quit)") {
			promptString("Type your note below.", mainMenu, (prompted) => {
				t.value += prompted + "\r\n";
				saveAndQuit();
			});
		} else if(ch === "Show Hand Report") {
			let report = handReport();
			addAlert(report);
			mainMenu();
		} else if(ch === "Display Game State") {
			confirmify(
				"Confirming you want to display the game state in the post.\nNote that game states are automatically displayed at the start of turns, and when ships are set up from a CAC.",
				mainMenu, () => {
					textGameState(true);
					mainMenu();
				});
		} else if(ch === "Change my username") {
			confirmify(
				"Are you sure you want to change your username? You should only do this if:\n1) The person who set up the game misspelled your username.\n2) You are stepping down from the game and are handing control of your character to someone else",
				mainMenu, () => {
					promptString("What is the new BoardGameGeek username associated with this character?", mainMenu, (prompted) => {
						z.usernames[me] = prompted;
						addAlert("Handing over control to " + prompted);
						t.value += "Handing over control of " + z.players[me] + " to " + prompted + ".\r\n";
						saveAndQuit();
					});
				});
		} else if(ch === "Change dialog display style") {
			let promptText = "Which style of dialog boxes would you like to use?";
			let styles = ["Classic", "Modern", "Modern (Mobile)", "Modern (Desktop)"];
			for(let j = 0; !(j >= styles.length); j++) {
				promptText += "\n" + (j + 1) + ": " + styles[j];
				if(z.promptStyle[me] === j) {
					promptText += " (you're using this now)";
				}
			}
			promptNum(promptText, (a) => 1 > a || a > styles.length, mainMenu, (choice) => {
				if(choice - 1 !== z.promptStyle[me]) {
					addAlert("Styles switched; reload BYC to see the new style!");
					z.promptStyle[me] = choice - 1;
					saveAndQuit();
				} else {
					addAlert("You chose not to switch styles.");
					mainMenu();
				}
			});
		}
	}, cancelLabel);
}
/*
var quickQuoteThread = new RegExp("thread/\\d+", "g");
var quickQuoteArticle = new RegExp("article/\\d+", "g");
var quotedRE = new RegExp("\\[size=(1|0)\\]\\[color=#(F4F4FF|FFFFFF)\\]Quoted Article: (\\d+)\\[/color\\]\\[/size\\]", "g");

function checkForNewer() {
	let parser = new DOMParser();
	let doc = parser.parseFromString(this.responseText, "text/html");
	let quotedRE = new RegExp("\\[size=(1|0)\\]\\[color=#(F4F4FF|FFFFFF)\\]Quoted Article: (\\d+)\\[/color\\]\\[/size\\]", "g");
	let quotedArticle = parseInt(quotedRE.exec(t.value)[3]);
	let articles = doc.querySelectorAll('div[id^="objcontainer_article"]');
	for(let j = 0; !(j >= articles.length); j++) {
		let articleRE = new RegExp("objcontainer_article(\\d+)$", "g");
		let article = parseInt(articleRE.exec(articles[j].id)[1]);
		if(article > quotedArticle) {
			if(articles[j].innerHTML.search(/New seed: /g) !== -1) {
				alert(
					"You do not appear to be quoting the most recent BYC-using post in the thread.\nYou probably want to cancel this post and check if there is a post further down the thread (perhaps on a subsequent page) you should be quoting instead.");
				t.value += colorText("red", bold(
						"WARNING: This post did not quote the most recent BYC-using post in the thread, and thus probably cancelled another person's play."
						)) + "\r\n";
				return;
			}
		}
	}
	let nextPage = doc.querySelector('a[title="next page"]');
	if(nextPage !== null) {
		let href = nextPage.getAttribute("href");
		let oReq = new XMLHttpRequest();
		oReq.addEventListener("load", checkForNewer);
		oReq.open("GET", href);
		oReq.send();
	}
}
if(t !== undefined && (quickQuoteThread.test(location.pathname) || quickQuoteArticle.test(location.pathname))) {
	let articles = document.querySelectorAll('div[id^="objcontainer_article"]');
	let textArea = document.querySelector("textarea");
	let foundQQ = false;
	let badMan = false;
	for(let j = 0; !(j >= articles.length); j++) {
		if(!foundQQ) {
			let articleRE = new RegExp("objcontainer_article(\\d+)$", "g");
			let article = articleRE.exec(articles[j].id)[1];
			t.value = size(invisible("Quoted Article: " + article), 0) + clear() + t.value.replace(quotedRE, "");
			foundQQ = articles[j].contains(textArea);
		} else {
			if(articles[j].innerHTML.search(/New seed: /g) !== -1) {
				alert(
					"You do not appear to be quoting the most recent BYC-using post in the thread.\nYou probably want to cancel this post and quote a post further down the page instead.");
				t.value += colorText("red", bold(
						"WARNING: This post did not quote the most recent BYC-using post in the thread, and thus probably cancelled another person's play."
						));
				badMan = true;
				break;
			}
		}
	}
	if(!badMan && foundQQ) {
		let nextPage = document.querySelector('a[title="next page"]');
		if(nextPage !== null) {
			let href = nextPage.getAttribute("href");
			let oReq = new XMLHttpRequest();
			oReq.addEventListener("load", checkForNewer);
			oReq.open("GET", href);
			oReq.send();
		}
	}
} else if(t !== undefined) {
	let quoteRE = new RegExp("quote/(\\d+)$", "g");
	let quoteEX = quoteRE.exec(location.pathname);
	let article = 0;
	if(quoteEX === null) {
		let quotedEX = quotedRE.exec(t.value);
		if(quotedEX !== null) {
			article = parseInt(quotedEX[1]);
		}
	} else {
		article = parseInt(quoteEX[1]);
		t.value = size(invisible("Quoted Article: " + article), 0) + clear() + t.value.replace(quotedRE, "");
	}
	if(article !== 0) {
		let oReq = new XMLHttpRequest();
		oReq.addEventListener("load", checkForNewer);
		oReq.open("GET", "/article/" + article);
		oReq.send();
	}
}*/ // ENDBYCF [/size][/c]